<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Camera Visualizer</title>
	<style>
		:root {
			--bg: #0f1117;
			--panel: #161a22;
			--text: #e6e6e6;
			--muted: #8b93a7;
			--accent: #4da3ff;
			--danger: #ff5d5d;
			--good: #00d27a;
			--warn: #ffb020;
			--ring: rgba(255, 255, 255, .08)
		}

		* {
			box-sizing: border-box
		}

		html,
		body {
			height: 100%
		}

		body {
			margin: 0;
			min-height: 100svh;
			padding-bottom: env(safe-area-inset-bottom);
			background: #0f1117;
			color: var(--text);
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
			display: flex;
			flex-direction: column
		}

		/* Topbar */
		.topbar {
			background: #2a2f3b;
			color: #fff;
			border-bottom: 1px solid #000
		}

		.topbar .bar {
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px 14px
		}

		.topbar .brand {
			position: absolute;
			left: 10px;
			display: inline-flex;
			align-items: center;
			gap: .35rem;
			text-decoration: none;
			color: #fff
		}

		.topbar .brand img {
			height: 22px;
			width: auto;
			display: block
		}

		.topbar .title {
			font-size: 17px;
			font-weight: 700
		}

		/* Toolbar container – compact, no forced full width */
		header {
			padding: .35rem .6rem .3rem;
			background: rgba(0, 0, 0, .18);
			border-bottom: 1px solid rgba(255, 255, 255, .06)
		}

		.row {
			display: flex;
			flex-wrap: wrap;
			gap: .4rem .5rem;
			align-items: center;
			/* groups size to content, row won’t stretch them */
		}

		/* Group boxes – very compact */
		.group {
			display: flex;
			align-items: center;
			gap: .4rem;
			flex-wrap: nowrap;
			background: var(--panel);
			border: 1px solid var(--ring);
			padding: .26rem .38rem;
			border-radius: .5rem
		}

		.title-mini {
			font-size: .78rem;
			font-weight: 600;
			opacity: .9;
			margin-right: .3rem;
			white-space: nowrap
		}

		/* Controls – compact */
		select,
		button {
			background: #0e121a;
			color: var(--text);
			border: 1px solid var(--ring);
			border-radius: .4rem;
			padding: .22rem .42rem;
			font-size: .9rem;
			outline: none
		}

		button {
			cursor: pointer;
			transition: transform .06s ease
		}

		button:hover {
			transform: translateY(-1px)
		}

		button:disabled {
			opacity: .55;
			cursor: not-allowed;
			transform: none
		}

		.primary {
			background: var(--accent);
			border-color: #9acbff;
			color: #061423
		}

		.danger {
			background: var(--danger);
			border-color: #ffc4c4;
			color: #2a0000
		}

		.muted {
			background: #0e121a;
			color: #adb3c4
		}

		.active {
			box-shadow: 0 0 0 2px #9acbff inset
		}

		.fixed-width-btn {
			width: 60px;
			text-align: center
		}

		.hidden {
			display: none !important
		}

		/* Label-as-color buttons */
		.labelBtn {
			font-weight: 700;
			padding: .22rem .42rem;
			border-radius: .4rem;
			border: 1px solid var(--ring);
			min-width: 84px;
			text-align: center;
			cursor: pointer;
			user-select: none;
			font-size: .9rem;
			white-space: nowrap
		}

		.srOnly {
			position: absolute !important;
			width: 1px;
			height: 1px;
			margin: -1px;
			padding: 0;
			border: 0;
			clip: rect(0 0 0 0);
			clip-path: inset(50%);
			overflow: hidden;
			white-space: nowrap;
		}

		/* Stream status */
		.status {
			display: flex;
			align-items: center;
			gap: .3rem
		}

		.light {
			width: 11px;
			height: 11px;
			border-radius: 50%;
			border: 2px solid rgba(255, 255, 255, .15)
		}

		.live {
			background: var(--good)
		}

		.paused {
			background: var(--warn)
		}

		.statusText {
			min-width: 44px;
			color: #cfd5e4;
			font-size: .82rem
		}

		.switch {
			position: relative;
			width: 46px;
			height: 24px;
			display: inline-block
		}

		.switch input {
			display: none
		}

		.slider {
			position: absolute;
			inset: 0;
			cursor: pointer;
			background: #293040;
			border-radius: 999px;
			border: 1px solid rgba(255, 255, 255, .12);
			transition: .2s
		}

		.slider:before {
			content: "";
			position: absolute;
			height: 18px;
			width: 18px;
			left: 3px;
			top: 2px;
			background: #fff;
			border-radius: 50%;
			transition: .2s
		}

		input:checked+.slider {
			background: #1f6bff
		}

		input:checked+.slider:before {
			transform: translateX(22px)
		}

		.vsep {
			width: 1px;
			height: 16px;
			background: rgba(255, 255, 255, .08)
		}

		/* Size pickers – tiny dots, single line */
		.sizePicker {
			display: flex;
			align-items: center;
			gap: .25rem
		}

		.dotBtn {
			--dot: 9px;
			--dot-color: #fff;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 28px;
			height: 22px;
			border: 1px solid var(--ring);
			border-radius: .35rem;
			background: #0e121a;
			cursor: pointer
		}

		.dotBtn .dot {
			display: block;
			width: var(--dot);
			height: var(--dot);
			aspect-ratio: 1/1;
			border-radius: 50%;
			background: var(--dot-color)
		}

		.dotBtn.active {
			outline: 2px solid #9acbff
		}

		/* Zoom – single line */
		#zoomGroup {
			white-space: nowrap
		}

		#zoomSlider {
			width: 160px;
			height: 22px;
			vertical-align: middle
		}

		#zoomVal {
			display: inline-block;
			min-width: 2.6ch;
			text-align: right;
			color: #cfd5e4;
			font-size: .9rem
		}

		/* Stage */
		#stage {
			position: relative;
			flex: 1;
			min-height: 50vh;
			margin: .4rem .6rem calc(.5rem + env(safe-area-inset-bottom));
			border: 1px solid var(--ring);
			border-radius: 12px;
			overflow: hidden;
			background: #000
		}

		video,
		canvas {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			touch-action: none
		}

		video {
			object-fit: contain;
			background: #000
		}

		#hud {
			position: absolute;
			right: .5rem;
			bottom: .5rem;
			font-size: .8rem;
			color: #cfd5e4;
			background: rgba(0, 0, 0, .4);
			padding: .2rem .4rem;
			border-radius: .35rem;
			border: 1px solid var(--ring)
		}

		#statusDot {
			display: inline-block;
			width: .5rem;
			height: .5rem;
			border-radius: 50%;
			background: var(--good);
			margin-right: .35rem
		}

		.pausedVideo #statusDot {
			background: var(--warn)
		}

		/* Text overlay */
		#textOverlay {
			position: absolute;
			display: none;
			z-index: 20;
			background: rgba(20, 22, 28, .2);
			border: 1px dashed rgba(255, 255, 255, .5);
			border-radius: .45rem;
			padding: .35rem
		}

		#textOverlay textarea {
			width: 250px;
			max-width: 60vw;
			min-height: 72px;
			background: transparent;
			color: #fff;
			border: 1px dashed rgba(255, 255, 255, .35);
			border-radius: .35rem;
			padding: .35rem;
			font-size: 15px;
			outline: none
		}

		#textActions {
			display: flex;
			gap: .35rem;
			justify-content: flex-end;
			margin-top: .35rem
		}

		/* Toast */
		#toast {
			position: fixed;
			left: 50%;
			transform: translateX(-50%);
			bottom: calc(6px + env(safe-area-inset-bottom));
			background: rgba(0, 0, 0, .75);
			color: #fff;
			padding: .4rem .6rem;
			border-radius: .45rem;
			border: 1px solid rgba(255, 255, 255, .12);
			font-size: .85rem;
			opacity: 0;
			pointer-events: none;
			transition: opacity .25s
		}

		#toast.show {
			opacity: 1
		}

		footer {
			position: static;
			font-size: 15px;
			text-align: center;
			padding: 7px;
			background: transparent;
			color: #555;
			margin: 4px 0;
			width: 100%;
		}

		footer a {
			color: #ff5f1f;
			text-decoration: none;
		}

		footer a:hover {
			text-decoration: underline;
		}
	</style>
</head>

<body>
	<!-- Topbar -->
	<div class="topbar">
		<div class="bar">
			<a class="brand" href="https://panphy.github.io" aria-label="panphy home">
				<img src="/panphy.png" alt="panphy logo" />
			</a>
			<div class="title">Camera Visualizer</div>
		</div>
	</div>

	<!-- Toolbar: compact, wraps naturally (typically 2 rows) -->
	<header>
		<div class="row">
			<div class="group">
				<span class="title-mini">Camera</span>
				<select id="cameraSelect"></select>
				<button id="refreshBtn">Refresh</button>
			</div>

			<div class="group">
				<span class="title-mini">Stream</span>
				<label class="switch">
					<input id="liveToggle" type="checkbox" checked />
					<span class="slider"></span>
				</label>
				<span class="vsep"></span>
				<div class="status">
					<span id="statusLight" class="light live"></span>
					<span id="statusLabel" class="statusText">Live</span>
				</div>
			</div>

			<div class="group">
				<span class="title-mini">Display</span>
				<button id="screenshotBtn">Snapshot</button>
				<button id="recordBtn">Record</button>
				<button id="mirrorBtn">Mirror</button>
				<button id="fitBtn" class="fixed-width-btn">Fill</button>
			</div>

			<div class="group">
				<label for="pointerColorInput" id="pointerLabelBtn" class="labelBtn">Pointer</label>
				<input id="pointerColorInput" type="color" class="srOnly" value="#ff3b3b" />
				<div id="pointerSizes" class="sizePicker" aria-label="Pointer size"></div>
			</div>

			<div class="group" id="annotGroup">
				<label for="annotColorInput" id="annotLabelBtn" class="labelBtn">Annotate</label>
				<input id="annotColorInput" type="color" class="srOnly" value="#33d17a" />
				<div id="annotSizes" class="sizePicker" aria-label="Annotation size"></div>
				<button id="annotationBtn" class="muted">Annotation</button>
				<button id="eraserBtn" class="muted">Eraser</button>
				<button id="textBtn" class="muted">Text</button>
				<button id="clearBtn" class="danger">Clear</button>
			</div>

			<div class="group" id="zoomGroup">
				<span class="title-mini">Zoom</span>
				<input id="zoomSlider" type="range" min="1" max="3" step="0.1" value="1" aria-label="Zoom level">
				<span id="zoomVal">1.0×</span>
			</div>
		</div>
	</header>

	<!-- Stage -->
	<main id="stage">
		<video id="video" playsinline autoplay muted></video>
		<canvas id="freezeCanvas" class="hidden"></canvas>
		<canvas id="drawCanvas"></canvas>
		<canvas id="laserCanvas"></canvas>
		<div id="hud"><span id="statusDot"></span><span id="hudText">Live</span></div>

		<!-- Text overlay -->
		<div id="textOverlay">
			<textarea id="textInput" placeholder="Type your note..."></textarea>
			<div id="textActions"><button id="textCancel">Cancel</button><button id="textAdd" class="primary">Add</button></div>
		</div>
	</main>

	<div id="toast" role="status" aria-live="polite"></div>

	<script>
		(() => {
			/* ===== DOM refs ===== */
			var video = document.getElementById('video');
			var freezeCanvas = document.getElementById('freezeCanvas');
			var drawCanvas = document.getElementById('drawCanvas');
			var laserCanvas = document.getElementById('laserCanvas');
			var ctxFreeze = freezeCanvas.getContext('2d');
			var ctxDraw = drawCanvas.getContext('2d');
			var ctxLaser = laserCanvas.getContext('2d');

			var cameraSelect = document.getElementById('cameraSelect');
			var refreshBtn = document.getElementById('refreshBtn');
			var liveToggle = document.getElementById('liveToggle');

			var annotationBtn = document.getElementById('annotationBtn');
			var eraserBtn = document.getElementById('eraserBtn');
			var textBtn = document.getElementById('textBtn');

			var statusLight = document.getElementById('statusLight');
			var statusLabel = document.getElementById('statusLabel');

			var clearBtn = document.getElementById('clearBtn');
			var screenshotBtn = document.getElementById('screenshotBtn');
			var recordBtn = document.getElementById('recordBtn');
			var mirrorBtn = document.getElementById('mirrorBtn');
			var fitBtn = document.getElementById('fitBtn');
			var hudText = document.getElementById('hudText');
			var stage = document.getElementById('stage');
			var toast = document.getElementById('toast');

			/* Color inputs + label buttons */
			var pointerColorInput = document.getElementById('pointerColorInput');
			var annotColorInput = document.getElementById('annotColorInput');
			var pointerLabelBtn = document.getElementById('pointerLabelBtn');
			var annotLabelBtn = document.getElementById('annotLabelBtn');

			var sizeUI = {
				pointer: document.getElementById('pointerSizes'),
				annot: document.getElementById('annotSizes')
			};

			var textOverlay = document.getElementById('textOverlay');
			var textInput = document.getElementById('textInput');
			var textAdd = document.getElementById('textAdd');
			var textCancel = document.getElementById('textCancel');

			/* Zoom controls */
			var zoomSlider = document.getElementById('zoomSlider');
			var zoomVal = document.getElementById('zoomVal');

			/* ===== Persistence ===== */
			function saveStr(k, v) { try { localStorage.setItem(k, v == null ? '' : String(v)); } catch (e) {} }

			function loadStr(k, f) { try { var v = localStorage.getItem(k); return v === null ? f : v; } catch (e) { return f; } }

			function saveNum(k, v) { try { localStorage.setItem(k, String(v)); } catch (e) {} }

			function loadNum(k, f) { try { var v = localStorage.getItem(k); var n = v !== null ? Number(v) : NaN; return isFinite(n) ? n : f; } catch (e) { return f; } }

			/* ===== State ===== */
			var pointerColor = pointerColorInput.value;
			var annotColor = annotColorInput.value;
			var SIZESET = [6, 12, 20];
			var pointerSize = loadNum('pointerSize', 12);
			var annotSize = loadNum('annotSize', 12);

			var isPaused = false;
			var isMirrored = false,
				fitMode = 'contain';

			var annotationOn = false,
				eraserOn = false,
				textModeOn = false,
				overlayVisible = false;

			var facingPref = loadStr('lastFacing', 'environment');
			var stream = null,
				switching = false;

			var tail = [];
			var laserActive = true;

			var frozen = document.createElement('canvas');
			var frozenCtx = frozen.getContext('2d');
			var hasFrozen = false;

			var objects = [];
			var currentStroke = null;

			var composite = document.createElement('canvas');
			var compositeCtx = composite.getContext('2d');
			var recording = false,
				mediaRecorder = null,
				recChunks = [];

			/* Zoom state */
			var zoomLevel = loadNum('zoomLevel', 1);

			/* ===== Utils ===== */
			function showToast(msg, ms) {
				ms = ms || 1600;
				toast.textContent = msg;
				toast.classList.add('show');
				setTimeout(function() { toast.classList.remove('show'); }, ms);
			}

			function contrastOn(hex) {
				var h = hex.replace('#', '');
				if (h.length === 3) h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
				var r = parseInt(h.slice(0, 2), 16),
					g = parseInt(h.slice(2, 4), 16),
					b = parseInt(h.slice(4, 6), 16);
				var yiq = (r * 299 + g * 587 + b * 114) / 1000;
				return yiq >= 160 ? '#111' : '#fff';
			}

			function paintLabelBtn(btn, color) {
				btn.style.background = color;
				btn.style.borderColor = 'rgba(255,255,255,.25)';
				btn.style.color = contrastOn(color);
			}

			function resizeCanvases() {
				var r = stage.getBoundingClientRect();
				[freezeCanvas, drawCanvas, laserCanvas, composite].forEach(function(c) {
					c.width = Math.floor(r.width);
					c.height = Math.floor(r.height);
				});
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				renderAnnotations();
			}

			/* UI sync */
			function syncToggleUI() { liveToggle.checked = !isPaused; }

			function updateStatusUI() {
				stage.classList.toggle('pausedVideo', isPaused);
				hudText.textContent = isPaused ? 'Paused' : 'Live';
				statusLabel.textContent = isPaused ? 'Paused' : 'Live';
				statusLight.className = 'light ' + (isPaused ? 'paused' : 'live');
				syncToggleUI();
			}

			/* Freeze handling */
			function captureFrozenFromVideo() {
				var w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (!video.videoWidth || w === 0 || h === 0) return;
				frozen.width = w;
				frozen.height = h;
				var vw = video.videoWidth,
					vh = video.videoHeight;
				var cr = w / h,
					vr = vw / vh;
				var dw, dh, dx, dy;
				if (fitMode === 'cover') {
					if (vr > cr) {
						dh = h;
						dw = h * vr;
					} else {
						dw = w;
						dh = w / vr;
					}
					dx = (w - dw) / 2;
					dy = (h - dh) / 2;
				} else {
					if (vr > cr) {
						dw = w;
						dh = w / vr;
					} else {
						dh = h;
						dw = h * vr;
					}
					dx = (w - dw) / 2;
					dy = (h - dh) / 2;
				}
				frozenCtx.save();
				if (isMirrored) {
					frozenCtx.translate(w, 0);
					frozenCtx.scale(-1, 1);
					dx = w - dx - dw;
				}
				frozenCtx.clearRect(0, 0, w, h);
				frozenCtx.drawImage(video, dx, dy, dw, dh);
				frozenCtx.restore();
				hasFrozen = true;
			}

			function drawFreezeFromFrozen() {
				if (!hasFrozen) return;
				var w = freezeCanvas.width,
					h = freezeCanvas.height;
				ctxFreeze.clearRect(0, 0, w, h);
				ctxFreeze.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				freezeCanvas.classList.remove('hidden');
			}

			function setPaused(state) {
				if (state === isPaused) return;
				isPaused = state;
				if (isPaused) {
					captureFrozenFromVideo();
					drawFreezeFromFrozen();
				} else {
					hasFrozen = false;
					freezeCanvas.classList.add('hidden');
				}
				updateStatusUI();
			}

			/* Tools ↔ pointer */
			function updateInteractionMode() {
				var toolActive = annotationOn || eraserOn || textModeOn;
				laserActive = !toolActive;
				if (!laserActive) {
					ctxLaser.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
					tail.length = 0;
				}
			}

			/* Camera */
			async function startCamera(constraint) {
				if (switching) return;
				switching = true;
				try {
					if (stream) { stream.getTracks().forEach(function(t) { t.stop(); }); }
					var constraints = { audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, constraint || {}) };
					stream = await navigator.mediaDevices.getUserMedia(constraints);
					video.srcObject = stream;
					await video.play();
				} catch (e1) {
					try {
						var fb1 = { facingMode: facingPref };
						stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, fb1) });
						video.srcObject = stream;
						await video.play();
					} catch (e2) {
						var fb2 = {};
						stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, fb2) });
						video.srcObject = stream;
						await video.play();
					}
				} finally {
					await enumerate();
					resizeCanvases();
					switching = false;
				}
			}
			async function enumerate() {
				var devs = await navigator.mediaDevices.enumerateDevices();
				var cams = devs.filter(function(d) { return d.kind === 'videoinput'; });

				function facingGuess(label) {
					var L = (label || '').toLowerCase();
					if (/(back|rear|environment)/.test(L)) return 'environment';
					if (/(front|user|face)/.test(L)) return 'user';
					return 'environment';
				}
				cameraSelect.innerHTML = '';
				cams.forEach(function(d, i) {
					var opt = document.createElement('option');
					var fg = facingGuess(d.label || '');
					opt.value = d.deviceId || ('facing:' + fg + ':' + i);
					opt.textContent = d.label || ('Camera ' + (i + 1));
					opt.dataset.facing = fg;
					cameraSelect.appendChild(opt);
				});
				cameraSelect.disabled = cameraSelect.options.length <= 1;
			}

			function debounced(fn, ms) {
				var t;
				ms = ms || 250;
				return function() {
					var a = arguments;
					clearTimeout(t);
					t = setTimeout(function() { fn.apply(null, a); }, ms);
				};
			}
			var onCameraChange = debounced(async function() {
				var val = cameraSelect.value || '';
				if (val.indexOf('facing:') === 0) {
					var facing = val.split(':')[1] || facingPref;
					facingPref = facing;
					saveStr('lastFacing', facing);
					await startCamera({ facingMode: facing });
				} else {
					await startCamera({ deviceId: { exact: val } });
					var opt = [].slice.call(cameraSelect.options).find(function(o) { return o.value === val; });
					if (opt && opt.dataset && opt.dataset.facing) {
						facingPref = opt.dataset.facing;
						saveStr('lastFacing', facingPref);
					}
				}
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
			}, 250);
			cameraSelect.addEventListener('change', onCameraChange);
			cameraSelect.addEventListener('input', onCameraChange);
			refreshBtn.addEventListener('click', function() { enumerate(); });

			/* Annotations */
			function renderAnnotations() {
				var w = drawCanvas.width,
					h = drawCanvas.height;
				ctxDraw.clearRect(0, 0, w, h);
				for (var i = 0; i < objects.length; i++) {
					var obj = objects[i];
					if (obj.type === 'stroke') {
						var pts = obj.points;
						if (pts.length < 2) continue;
						ctxDraw.save();
						ctxDraw.strokeStyle = obj.color;
						ctxDraw.lineWidth = obj.size;
						ctxDraw.lineCap = 'round';
						ctxDraw.lineJoin = 'round';
						ctxDraw.beginPath();
						ctxDraw.moveTo(pts[0].x, pts[0].y);
						for (var j = 1; j < pts.length; j++) ctxDraw.lineTo(pts[j].x, pts[j].y);
						ctxDraw.stroke();
						ctxDraw.restore();
					} else if (obj.type === 'text') {
						ctxDraw.save();
						ctxDraw.font = 'bold ' + obj.fontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
						ctxDraw.textBaseline = 'top';
						ctxDraw.fillStyle = obj.color;
						ctxDraw.lineWidth = Math.max(2, obj.fontPx * 0.12);
						ctxDraw.strokeStyle = 'rgba(0,0,0,0.55)';
						var lines = obj.text.split(/\r?\n/);
						lines.forEach(function(ln, li) {
							var yy = obj.y + li * obj.lh;
							ctxDraw.strokeText(ln, obj.x, yy);
							ctxDraw.fillText(ln, obj.x, yy);
						});
						ctxDraw.restore();
					}
				}
			}

			function measureTextBlock(text, fontPx) {
				var lines = String(text).split(/\r?\n/);
				ctxDraw.save();
				ctxDraw.font = 'bold ' + fontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
				var widths = lines.map(function(ln) { return ctxDraw.measureText(ln).width; });
				ctxDraw.restore();
				var lh = Math.round(fontPx * 1.25);
				var maxW = 1;
				for (var i = 0; i < widths.length; i++) { if (widths[i] > maxW) maxW = widths[i]; }
				return { width: maxW, height: lines.length * lh, lh: lh };
			}

			function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
				var A = px - x1,
					B = py - y1,
					C = x2 - x1,
					D = y2 - y1;
				var dot = A * C + B * D;
				var lenSq = C * C + D * D || 1e-6;
				var t = dot / lenSq;
				t = Math.max(0, Math.min(1, t));
				var xx = x1 + t * C,
					yy = y1 + t * D;
				return Math.hypot(px - xx, py - yy);
			}

			function hitTestObject(px, py, tol) {
				for (var i = objects.length - 1; i >= 0; i--) {
					var obj = objects[i];
					if (obj.type === 'text') {
						if (px >= obj.x && px <= obj.x + obj.width && py >= obj.y && py <= obj.y + obj.height) return i;
					} else if (obj.type === 'stroke') {
						var pts = obj.points;
						for (var j = 1; j < pts.length; j++) {
							if (pointToSegmentDistance(px, py, pts[j - 1].x, pts[j - 1].y, pts[j].x, pts[j].y) <= tol) return i;
						}
					}
				}
				return -1;
			}

			/* Pointer / drawing – zoom-aware */
			function canvasToCtxXY(clientX, clientY, canvas) {
				var rect = canvas.getBoundingClientRect();
				var baseW = canvas.width,
					baseH = canvas.height;
				var s = zoomLevel || 1;
				var x = (clientX - rect.left - rect.width / 2) / s + baseW / 2;
				var y = (clientY - rect.top - rect.height / 2) / s + baseH / 2;
				if (!isFinite(x) || !isFinite(y)) return { x: 0, y: 0 };
				return { x: x, y: y };
			}

			function normPressure(p) { var v = isFinite(p) ? p : 1; return Math.max(0.2, Math.min(1, v)); }

			function getPrimaryPoint(e) {
				if (window.PointerEvent && e instanceof PointerEvent) return { x: e.clientX, y: e.clientY, id: e.pointerId, pressure: e.pressure };
				if (e.touches && e.touches[0]) { var t = e.touches[0]; return { x: t.clientX, y: t.clientY, id: 1, pressure: 1 }; }
				if (e.changedTouches && e.changedTouches[0]) { var t2 = e.changedTouches[0]; return { x: t2.clientX, y: t2.clientY, id: 1, pressure: 1 }; }
				if (e.clientX !== undefined) return { x: e.clientX, y: e.clientY, id: 1, pressure: 1 };
				return null;
			}
			var pointerIdActive = null;

			function startDraw(e) {
				if (overlayVisible) return;
				var p = getPrimaryPoint(e);
				if (!p) return;
				var pt = canvasToCtxXY(p.x, p.y, drawCanvas);
				var x = pt.x,
					y = pt.y;
				pointerIdActive = p.id;

				if (eraserOn) {
					var tol = Math.max(8, annotSize * 1.1);
					var idx = hitTestObject(x, y, tol);
					if (idx >= 0) {
						objects.splice(idx, 1);
						renderAnnotations();
					}
					return;
				}
				if (annotationOn && !textModeOn) {
					currentStroke = { type: 'stroke', color: annotColor, size: annotSize * normPressure(p.pressure), points: [{ x: x, y: y }] };
					objects.push(currentStroke);
					renderAnnotations();
				}
			}

			function moveDraw(e) {
				if (overlayVisible) return;
				var p = getPrimaryPoint(e);
				if (!p) return;

				if (laserActive) {
					var ptL = canvasToCtxXY(p.x, p.y, laserCanvas);
					addTailPoint(ptL.x, ptL.y);
				}
				if (eraserOn && p.id === pointerIdActive) {
					var ptE = canvasToCtxXY(p.x, p.y, drawCanvas);
					var tol = Math.max(8, annotSize * 1.1);
					var idx = hitTestObject(ptE.x, ptE.y, tol);
					if (idx >= 0) {
						objects.splice(idx, 1);
						renderAnnotations();
					}
					return;
				}
				if (annotationOn && !textModeOn && p.id === pointerIdActive && currentStroke) {
					var ptA = canvasToCtxXY(p.x, p.y, drawCanvas);
					currentStroke.points.push({ x: ptA.x, y: ptA.y });
					currentStroke.size = Math.max(1, annotSize * normPressure(p.pressure));
					renderAnnotations();
				}
			}

			function endDraw() {
				pointerIdActive = null;
				currentStroke = null;
			}

			/* Laser trail */
			function addTailPoint(x, y) { tail.push({ x: x, y: y, life: 1 }); if (tail.length > 220) tail.shift(); }

			function renderLaser() {
				var w = laserCanvas.width,
					h = laserCanvas.height;
				ctxLaser.clearRect(0, 0, w, h);
				if (laserActive) {
					var rgb = hexToRgb(pointerColor);
					var r = rgb.r,
						g = rgb.g,
						b = rgb.b;
					for (var i = 0; i < tail.length; i++) {
						var t = tail[i];
						t.life *= 0.96;
						if (t.life < 0.02) continue;
						var a = t.life,
							radius = pointerSize * (0.9 + 1.2 * a),
							glow = radius * 2.2;
						var grad = ctxLaser.createRadialGradient(t.x, t.y, 0, t.x, t.y, glow);
						grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (0.25 * a) + ')');
						grad.addColorStop(1, 'rgba(0,0,0,0)');
						ctxLaser.fillStyle = grad;
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, glow, 0, Math.PI * 2);
						ctxLaser.fill();
						ctxLaser.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + (0.85 * a) + ')';
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, radius, 0, Math.PI * 2);
						ctxLaser.fill();
					}
				}
				for (var j = tail.length - 1; j >= 0; j--) { if (tail[j].life < 0.02) tail.splice(j, 1); }
				requestAnimationFrame(renderLaser);
			}

			function hexToRgb(hex) { var h = hex.replace('#', ''); var b = parseInt(h.length === 3 ? h.split('').map(function(c) { return c + c; }).join('') : h, 16); return { r: (b >> 16) & 255, g: (b >> 8) & 255, b: b & 255 }; }

			/* Text overlay */
			var pendingTextXY = null;

			function showTextOverlayAt(clientX, clientY) {
				var rect = stage.getBoundingClientRect();
				var x = Math.min(Math.max(clientX - rect.left, 8), rect.width - 260);
				var y = Math.min(Math.max(clientY - rect.top, 8), rect.height - 126);
				textOverlay.style.left = x + 'px';
				textOverlay.style.top = y + 'px';
				textOverlay.style.display = 'block';
				overlayVisible = true;
				textInput.value = '';
				textInput.focus();
			}

			function hideTextOverlay(keepMode) {
				keepMode = !!keepMode;
				textOverlay.style.display = 'none';
				overlayVisible = false;
				pendingTextXY = null;
				if (!keepMode) {
					textModeOn = false;
					textBtn.classList.toggle('active', false);
					textBtn.classList.toggle('primary', false);
					textBtn.classList.toggle('muted', true);
					updateInteractionMode();
				}
			}

			function placeTextObject(text, x, y) {
				if (!text) return;
				var fontPx = Math.round(10 + annotSize * 2);
				var m = measureTextBlock(text, fontPx);
				var obj = { type: 'text', x: x, y: y, text: String(text), color: annotColor, fontPx: fontPx, lh: m.lh, width: m.width, height: m.height };
				objects.push(obj);
				renderAnnotations();
			}

			/* Wiring */
			liveToggle.addEventListener('change', function() { setPaused(!liveToggle.checked); });

			annotationBtn.addEventListener('click', function() {
				annotationOn = !annotationOn;
				eraserOn = false;
				textModeOn = false;
				hideTextOverlay();
				annotationBtn.classList.toggle('active', annotationOn);
				annotationBtn.classList.toggle('primary', annotationOn);
				annotationBtn.classList.toggle('muted', !annotationOn);
				eraserBtn.classList.remove('active', 'primary');
				eraserBtn.classList.add('muted');
				textBtn.classList.remove('active', 'primary');
				textBtn.classList.add('muted');
				updateInteractionMode();
			});
			eraserBtn.addEventListener('click', function() {
				eraserOn = !eraserOn;
				annotationOn = eraserOn ? true : annotationOn;
				textModeOn = false;
				hideTextOverlay();
				eraserBtn.classList.toggle('active', eraserOn);
				eraserBtn.classList.toggle('primary', eraserOn);
				eraserBtn.classList.toggle('muted', !eraserOn);
				annotationBtn.classList.toggle('active', annotationOn);
				annotationBtn.classList.toggle('primary', annotationOn);
				annotationBtn.classList.toggle('muted', !annotationOn);
				textBtn.classList.remove('active', 'primary');
				textBtn.classList.add('muted');
				updateInteractionMode();
			});
			textBtn.addEventListener('click', function() {
				annotationOn = true;
				eraserOn = false;
				textModeOn = !textModeOn;
				hideTextOverlay(textModeOn);
				annotationBtn.classList.add('active', 'primary');
				annotationBtn.classList.remove('muted');
				eraserBtn.classList.remove('active', 'primary');
				eraserBtn.classList.add('muted');
				textBtn.classList.toggle('active', textModeOn);
				textBtn.classList.toggle('primary', textModeOn);
				textBtn.classList.toggle('muted', !textModeOn);
				if (textModeOn) showToast('Tap where you want the text.');
				updateInteractionMode();
			});
			clearBtn.addEventListener('click', function() {
				objects.length = 0;
				renderAnnotations();
			});

			function refreshPickerColors() {
				[].slice.call(sizeUI.pointer.children).forEach(function(btn) { btn.style.setProperty('--dot-color', pointerColor); });
				[].slice.call(sizeUI.annot.children).forEach(function(btn) { btn.style.setProperty('--dot-color', annotColor); });
			}
			pointerColorInput.addEventListener('input', function(e) {
				pointerColor = e.target.value;
				paintLabelBtn(pointerLabelBtn, pointerColor);
				refreshPickerColors();
			});
			annotColorInput.addEventListener('input', function(e) {
				annotColor = e.target.value;
				paintLabelBtn(annotLabelBtn, annotColor);
				refreshPickerColors();
			});

			function buildSizePicker(container, sizes, getColor, currentSize, onPick) {
				container.innerHTML = '';
				sizes.forEach(function(sz) {
					var btn = document.createElement('button');
					btn.type = 'button';
					btn.className = 'dotBtn';
					btn.style.setProperty('--dot', sz + 'px');
					btn.style.setProperty('--dot-color', getColor());
					if (currentSize === sz) btn.classList.add('active');
					var dot = document.createElement('span');
					dot.className = 'dot';
					btn.appendChild(dot);
					btn.addEventListener('click', function() {
						[].slice.call(container.children).forEach(function(c) { c.classList.remove('active'); });
						btn.classList.add('active');
						onPick(sz);
					});
					container.appendChild(btn);
				});
			}

			/* Zoom + mirror + fit */
			function applyTransforms() {
				var s = zoomLevel || 1;
				[drawCanvas, laserCanvas, freezeCanvas].forEach(function(el) {
					el.style.transformOrigin = 'center center';
					el.style.transform = 'scale(' + s + ')';
				});
				video.style.transformOrigin = 'center center';
				video.style.transform = (isMirrored ? 'scaleX(-1) ' : '') + 'scale(' + s + ')';
			}
			document.getElementById('mirrorBtn').addEventListener('click', function() {
				isMirrored = !isMirrored;
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				showToast(isMirrored ? 'Mirrored' : 'Unmirrored');
			});
			document.getElementById('fitBtn').addEventListener('click', function() {
				fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
				fitBtn.textContent = (fitMode === 'cover') ? 'Fill' : 'Fit';
				resizeCanvases();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				showToast(fitMode === 'cover' ? 'Fill mode' : 'Fit mode');
			});

			function setZoom(v) {
				zoomLevel = Math.max(1, Math.min(3, v || 1));
				saveNum('zoomLevel', zoomLevel);
				zoomSlider.value = String(zoomLevel);
				zoomVal.textContent = zoomLevel.toFixed(1) + '×';
				applyTransforms();
			}
			zoomSlider.addEventListener('input', function(e) { setZoom(parseFloat(e.target.value)); });

			/* Stage events */
			var target = stage;

			function touchGuard(e) {
				if (overlayVisible && e.target.closest('#textOverlay')) return;
				e.preventDefault();
			}
			['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(function(ev) { target.addEventListener(ev, touchGuard, { passive: false }); });
			target.addEventListener('pointerdown', function(e) {
				if (annotationOn && textModeOn && !overlayVisible) {
					var pt = canvasToCtxXY(e.clientX, e.clientY, drawCanvas);
					pendingTextXY = { x: pt.x, y: pt.y };
					showTextOverlayAt(e.clientX, e.clientY);
					return;
				}
				startDraw(e);
			});
			target.addEventListener('pointermove', moveDraw);
			target.addEventListener('pointerup', endDraw);
			target.addEventListener('pointercancel', endDraw);
			target.addEventListener('pointerout', endDraw);
			target.addEventListener('pointerleave', endDraw);

			/* Text overlay actions */
			textAdd.addEventListener('click', function() {
				if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
				hideTextOverlay();
			});
			textCancel.addEventListener('click', function() { hideTextOverlay(); });
			textInput.addEventListener('keydown', function(e) {
				if (e.key === 'Escape') {
					e.preventDefault();
					hideTextOverlay();
				}
				if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
					e.preventDefault();
					if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
					hideTextOverlay();
				}
			});

			/* Snapshot */
			screenshotBtn.addEventListener('click', function() {
				var w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (w === 0 || h === 0) { showToast('Snapshot failed: canvas not ready'); return; }
				var out = document.createElement('canvas');
				out.width = w;
				out.height = h;
				var octx = out.getContext('2d');

				if (isPaused && hasFrozen) {
					octx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					var vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						var cr = w / h,
							vr = vw / vh;
						var dw, dh, dx, dy;
						if (fitMode === 'cover') {
							if (vr > cr) {
								dh = h;
								dw = h * vr;
							} else {
								dw = w;
								dh = w / vr;
							}
							dx = (w - dw) / 2;
							dy = (h - dh) / 2;
						} else {
							if (vr > cr) {
								dw = w;
								dh = w / vr;
							} else {
								dh = h;
								dw = h * vr;
							}
							dx = (w - dw) / 2;
							dy = (h - dh) / 2;
						}
						octx.save();
						if (isMirrored) {
							octx.translate(w, 0);
							octx.scale(-1, 1);
							dx = w - dx - dw;
						}
						octx.drawImage(video, dx, dy, dw, dh);
						octx.restore();
					}
				}
				octx.drawImage(drawCanvas, 0, 0);
				octx.drawImage(laserCanvas, 0, 0);
				out.toBlob(function(blob) {
					if (!blob) { showToast('Snapshot failed'); return; }
					var url = URL.createObjectURL(blob);
					var a = document.createElement('a');
					a.href = url;
					a.download = 'snapshot_' + new Date().toISOString().replace(/[:.]/g, '-') + '.png';
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(url);
					showToast('Snapshot saved');
				});
			});

			/* Recording */
			function drawCompositeFrame() {
				var w = composite.width,
					h = composite.height;
				compositeCtx.clearRect(0, 0, w, h);
				if (isPaused && hasFrozen) {
					compositeCtx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					var vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						var cr = w / h,
							vr = vw / vh;
						var dw, dh, dx, dy;
						if (fitMode === 'cover') {
							if (vr > cr) {
								dh = h;
								dw = h * vr;
							} else {
								dw = w;
								dh = w / vr;
							}
							dx = (w - dw) / 2;
							dy = (h - dh) / 2;
						} else {
							if (vr > cr) {
								dw = w;
								dh = w / vr;
							} else {
								dh = h;
								dw = h * vr;
							}
							dx = (w - dw) / 2;
							dy = (h - dh) / 2;
						}
						compositeCtx.save();
						if (isMirrored) {
							compositeCtx.translate(w, 0);
							compositeCtx.scale(-1, 1);
							dx = w - dx - dw;
						}
						compositeCtx.drawImage(video, dx, dy, dw, dh);
						compositeCtx.restore();
					}
				}
				compositeCtx.drawImage(drawCanvas, 0, 0);
				compositeCtx.drawImage(laserCanvas, 0, 0);
				if (recording) requestAnimationFrame(drawCompositeFrame);
			}

			function getSupportedMime() {
				var prefs = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4;codecs=avc1.42E01E,mp4a.40.2'];
				for (var i = 0; i < prefs.length; i++) { if (MediaRecorder.isTypeSupported(prefs[i])) return prefs[i]; }
				return '';
			}
			recordBtn.addEventListener('click', function() {
				if (!recording) {
					composite.width = freezeCanvas.width;
					composite.height = freezeCanvas.height;
					var mime = getSupportedMime();
					var s = composite.captureStream(30);
					try { mediaRecorder = new MediaRecorder(s, mime ? { mimeType: mime } : {}) } catch (e) { showToast('Recording not supported'); return; }
					recChunks = [];
					mediaRecorder.ondataavailable = function(e) { if (e.data && e.data.size > 0) recChunks.push(e.data); };
					mediaRecorder.onstop = function() {
						var blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'video/webm' });
						var url = URL.createObjectURL(blob);
						var a = document.createElement('a');
						a.href = url;
						a.download = 'recording_' + new Date().toISOString().replace(/[:.]/g, '-') + '.webm';
						document.body.appendChild(a);
						a.click();
						a.remove();
						URL.revokeObjectURL(url);
						showToast('Recording saved');
					};
					mediaRecorder.start(120);
					recording = true;
					recordBtn.textContent = 'Stop';
					recordBtn.classList.add('danger');
					drawCompositeFrame();
					showToast('Recording started');
				} else {
					recording = false;
					try { mediaRecorder.stop(); } catch (e) {}
					recordBtn.textContent = 'Record';
					recordBtn.classList.remove('danger');
				}
			});

			/* Init */
			var ro = new ResizeObserver(function() { resizeCanvases(); });
			ro.observe(stage);
			window.addEventListener('orientationchange', function() { setTimeout(resizeCanvases, 200); });
			requestAnimationFrame(renderLaser);

			(async function init() {
				if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { showToast('getUserMedia not supported'); return; }
				await startCamera({ facingMode: facingPref });
				await enumerate();

				isPaused = false;
				updateStatusUI();

				buildSizePicker(sizeUI.pointer, SIZESET, function() { return pointerColor; }, pointerSize, function(sz) {
					pointerSize = sz;
					saveNum('pointerSize', sz);
				});
				buildSizePicker(sizeUI.annot, SIZESET, function() { return annotColor; }, annotSize, function(sz) {
					annotSize = sz;
					saveNum('annotSize', sz);
				});
				refreshPickerColors();
				paintLabelBtn(pointerLabelBtn, pointerColor);
				paintLabelBtn(annotLabelBtn, annotColor);

				setZoom(zoomLevel);
				resizeCanvases();
			})();
		})();
	</script>

	<footer>
		&copy; 2025 <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

</html>