<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Camera Visualizer</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<script>
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('/sw.js')
					.catch((err) => console.log('Service Worker registration failed', err));
			});
		}
	</script>
	<style>
		:root {
			--font-sans: 'Inter', 'Poppins', 'Segoe UI', system-ui, -apple-system, sans-serif;
			--bg-color: #0f1014;
			--bg-pattern: #181a20;
			--text-main: #dfe6e9;
			--text-secondary: #b2bec3;
			--brand-primary: #a29bfe;
			--brand-secondary: #6c5ce7;
			--brand-accent: #81ecec;
			--nav-bg: rgba(22, 24, 29, 0.85);
			--nav-border: rgba(255, 255, 255, 0.05);
			--panel: #1e2129;
			--panel-border: #2d3436;
			--panel-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
			--text: var(--text-main);
			--muted: #8b93a7;
			--accent: var(--brand-primary);
			--danger: #ff5d5d;
			--good: #00d27a;
			--warn: #ffb020;
			--ring: rgba(255, 255, 255, .08);
			--tool-active-bg: linear-gradient(135deg, var(--brand-primary), var(--brand-secondary));
			--tool-hover-bg: rgba(162, 155, 254, 0.15)
		}

		* {
			box-sizing: border-box;
			transition: background-color .2s ease, color .2s ease, border-color .2s ease, transform .15s ease, box-shadow .2s ease
		}

		html,
		body {
			height: 100%
		}

		body {
			margin: 0;
			min-height: 100svh;
			padding-bottom: env(safe-area-inset-bottom);
			background-color: var(--bg-color);
			background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
			background-size: 30px 30px;
			color: var(--text);
			font-family: var(--font-sans);
			display: flex;
			flex-direction: column
		}

		.offline-font {
			--font-sans: 'Segoe UI', system-ui, -apple-system, 'Helvetica Neue', Arial, sans-serif;
		}

		/* Top bar */
		.topbar {
			background: var(--nav-bg);
			color: var(--text);
			border-bottom: 1px solid var(--nav-border);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px)
		}

		.topbar .bar {
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px 14px
		}

		.topbar .brand {
			position: absolute;
			left: 10px;
			display: inline-flex;
			align-items: center;
			gap: .35rem;
			text-decoration: none;
			color: var(--text-main)
		}

		.topbar .brand img {
			height: 22px;
			width: auto;
			display: block
		}

		.topbar .title {
			font-family: 'Poppins', 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
			font-size: 17px;
			font-weight: 700;
			background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text
		}

		.controls {
			position: absolute;
			top: .55rem;
			left: .55rem;
			z-index: 6;
			background: transparent;
			display: inline-flex;
			flex-direction: column;
			align-items: flex-start;
			max-width: calc(100% - 3.1rem)
		}

		.controls summary {
			list-style: none;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: .5rem;
			padding: .5rem .85rem;
			background: var(--panel);
			border: 1px solid var(--panel-border);
			border-radius: .65rem;
			color: var(--text-main);
			font-weight: 600;
			box-shadow: var(--panel-shadow)
		}

		.controls summary::-webkit-details-marker {
			display: none
		}

		.controls summary::after {
			content: '+';
			font-size: 1.1rem;
			color: var(--text-secondary)
		}

		.controls[open] summary::after {
			content: '–'
		}

		.controls .row {
			margin-top: .5rem
		}

		.row {
			display: flex;
			flex-wrap: wrap;
			gap: .4rem .5rem;
			align-items: center
		}

		.group {
			display: flex;
			align-items: center;
			gap: .4rem;
			flex-wrap: nowrap;
			background: var(--panel);
			border: 1px solid var(--panel-border);
			padding: .32rem .45rem;
			border-radius: .6rem;
			box-shadow: var(--panel-shadow)
		}

		.group-label {
			font-size: .72rem;
			font-weight: 600;
			text-transform: uppercase;
			letter-spacing: .04em;
			color: var(--text-secondary);
			padding: 0 .25rem;
			white-space: nowrap
		}

		.vsep {
			width: 1px;
			height: 20px;
			background: rgba(255, 255, 255, .1);
			margin: 0 .15rem
		}

		select,
		button {
			background: #151820;
			color: var(--text);
			border: 1px solid var(--panel-border);
			border-radius: .45rem;
			padding: .28rem .48rem;
			font-size: .85rem;
			outline: none;
			font-weight: 500
		}

		button {
			cursor: pointer;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: .35rem;
			min-height: 32px
		}

		button:hover:not(:disabled) {
			transform: translateY(-1px);
			background: var(--tool-hover-bg)
		}

		button:active:not(:disabled) {
			transform: translateY(0)
		}

		button:disabled {
			opacity: .45;
			cursor: not-allowed;
			transform: none
		}

		.btn-icon {
			font-size: 1rem;
			line-height: 1
		}

		.btn-text {
			font-size: .8rem
		}

		.kbd {
			font-size: .65rem;
			padding: .1rem .3rem;
			background: rgba(255, 255, 255, .08);
			border-radius: .25rem;
			color: var(--text-secondary);
			font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
			margin-left: .2rem
		}

		.primary {
			background: var(--tool-active-bg);
			border-color: rgba(255, 255, 255, .2);
			color: #fff;
			box-shadow: 0 2px 8px rgba(108, 92, 231, .35)
		}

		.primary:hover:not(:disabled) {
			background: var(--tool-active-bg);
			box-shadow: 0 4px 12px rgba(108, 92, 231, .5)
		}

		.danger {
			background: var(--danger);
			border-color: rgba(255, 255, 255, .2);
			color: #fff
		}

		.muted {
			background: #151820;
			color: #adb3c4
		}

		.tool-btn {
			min-width: 38px;
			position: relative
		}

		.tool-btn.active::after {
			content: '';
			position: absolute;
			bottom: -2px;
			left: 50%;
			transform: translateX(-50%);
			width: 60%;
			height: 2px;
			background: var(--brand-accent);
			border-radius: 1px
		}

		.hidden {
			display: none !important
		}

		/* Color picker button */
		.color-btn {
			width: 32px;
			height: 32px;
			border-radius: .45rem;
			border: 2px solid rgba(255, 255, 255, .2);
			cursor: pointer;
			position: relative;
			overflow: hidden;
			padding: 0
		}

		.color-btn:hover {
			border-color: rgba(255, 255, 255, .4);
			transform: scale(1.05)
		}

		.color-btn input[type="color"] {
			position: absolute;
			width: 150%;
			height: 150%;
			top: -25%;
			left: -25%;
			cursor: pointer;
			border: none;
			padding: 0
		}

		.laserIndicator {
			display: inline-flex;
			align-items: center;
			gap: .3rem;
			padding: .18rem .5rem;
			border-radius: .4rem;
			border: 1px solid var(--panel-border);
			color: #8b93a7;
			font-size: .72rem;
			font-weight: 600;
			letter-spacing: .03em;
			text-transform: uppercase;
			background: #151820
		}

		.laserIndicator.active {
			background: linear-gradient(135deg, rgba(162, 155, 254, .25), rgba(129, 236, 236, .15));
			border-color: rgba(162, 155, 254, .5);
			color: #fff;
			box-shadow: 0 0 12px rgba(162, 155, 254, .3)
		}

		.laserIndicator .dot {
			width: .5rem;
			height: .5rem;
			border-radius: 50%;
			background: currentColor;
			animation: pulse 1.5s ease-in-out infinite
		}

		.laserIndicator:not(.active) .dot {
			animation: none
		}

		@keyframes pulse {
			0%, 100% { opacity: 1; transform: scale(1); }
			50% { opacity: .6; transform: scale(.85); }
		}

		.srOnly {
			position: absolute !important;
			width: 1px;
			height: 1px;
			margin: -1px;
			padding: 0;
			border: 0;
			clip: rect(0 0 0 0);
			clip-path: inset(50%);
			overflow: hidden;
			white-space: nowrap;
		}

		.status {
			display: flex;
			align-items: center;
			gap: .35rem
		}

		.light {
			width: 10px;
			height: 10px;
			border-radius: 50%;
			border: 2px solid rgba(255, 255, 255, .15)
		}

		.live {
			background: var(--good);
			box-shadow: 0 0 6px rgba(0, 210, 122, .5)
		}

		.paused {
			background: var(--warn);
			box-shadow: 0 0 6px rgba(255, 176, 32, .5)
		}

		.statusText {
			min-width: 48px;
			color: #cfd5e4;
			font-size: .8rem;
			font-weight: 500
		}

		.switch {
			position: relative;
			width: 44px;
			height: 24px;
			display: inline-block
		}

		.switch input {
			display: none
		}

		.slider {
			position: absolute;
			inset: 0;
			cursor: pointer;
			background: #262b35;
			border-radius: 999px;
			border: 1px solid rgba(255, 255, 255, .12);
			transition: .2s
		}

		.slider:before {
			content: "";
			position: absolute;
			height: 18px;
			width: 18px;
			left: 2px;
			top: 2px;
			background: #fff;
			border-radius: 50%;
			transition: .2s;
			box-shadow: 0 2px 4px rgba(0, 0, 0, .2)
		}

		input:checked+.slider {
			background: var(--brand-secondary)
		}

		input:checked+.slider:before {
			transform: translateX(20px)
		}

		.sizePicker {
			display: flex;
			align-items: center;
			gap: .25rem
		}

		.dotBtn {
			--dot: 8px;
			--dot-color: #fff;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 26px;
			height: 26px;
			border: 1px solid var(--panel-border);
			border-radius: .4rem;
			background: #151820;
			cursor: pointer;
			transition: all .15s ease
		}

		.dotBtn:hover {
			background: var(--tool-hover-bg);
			transform: scale(1.05)
		}

		.dotBtn .dot {
			display: block;
			width: var(--dot);
			height: var(--dot);
			aspect-ratio: 1/1;
			border-radius: 50%;
			background: var(--dot-color);
			transition: transform .15s ease
		}

		.dotBtn.active {
			outline: 2px solid var(--brand-accent);
			outline-offset: 1px
		}

		.dotBtn.active .dot {
			transform: scale(1.15)
		}

		#zoomGroup {
			white-space: nowrap
		}

		#zoomSlider {
			width: 120px;
			height: 22px;
			vertical-align: middle;
			accent-color: var(--brand-primary)
		}

		#zoomVal {
			display: inline-block;
			min-width: 2.8ch;
			text-align: right;
			color: #cfd5e4;
			font-size: .85rem;
			font-weight: 600
		}

		#stage {
			position: relative;
			flex: 1;
			min-height: 50vh;
			margin: .4rem .6rem calc(.5rem + env(safe-area-inset-bottom));
			border: 1px solid var(--panel-border);
			border-radius: 14px;
			overflow: hidden;
			background: #000;
			box-shadow: 0 8px 32px rgba(0, 0, 0, .4)
		}

		video,
		canvas {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			touch-action: none
		}

		video {
			object-fit: contain;
			background: #000;
			object-position: center center
		}

		#hud {
			position: absolute;
			right: .5rem;
			bottom: .5rem;
			font-size: .78rem;
			color: #cfd5e4;
			background: rgba(0, 0, 0, .55);
			padding: .25rem .5rem;
			border-radius: .4rem;
			border: 1px solid rgba(255, 255, 255, .1);
			backdrop-filter: blur(4px);
			display: flex;
			align-items: center;
			gap: .4rem
		}

		#fullscreenBtn {
			position: absolute;
			top: .55rem;
			right: .55rem;
			z-index: 5;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 38px;
			height: 34px;
			padding: 0;
			background: rgba(20, 22, 28, .7);
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .55rem;
			color: #f0f4ff;
			font-size: 1.1rem;
			box-shadow: 0 6px 16px rgba(0, 0, 0, .35);
			backdrop-filter: blur(8px);
			-webkit-backdrop-filter: blur(8px)
		}

		#fullscreenBtn:hover {
			transform: translateY(-1px);
			background: rgba(28, 30, 38, .8)
		}

		#fullscreenBtn:active {
			transform: translateY(0)
		}

		#statusDot {
			display: inline-block;
			width: .5rem;
			height: .5rem;
			border-radius: 50%;
			background: var(--good)
		}

		.pausedVideo #statusDot {
			background: var(--warn)
		}

		#recordIndicator {
			display: none;
			align-items: center;
			gap: .2rem;
			font-size: .7rem;
			letter-spacing: .04em;
			color: #ffb0b0
		}

		#hud.recording #recordIndicator {
			display: inline-flex
		}

		#recordDot {
			width: .4rem;
			height: .4rem;
			border-radius: 50%;
			background: #ff4d4d;
			box-shadow: 0 0 6px rgba(255, 77, 77, .7);
			animation: recordPulse 1s ease-in-out infinite
		}

		@keyframes recordPulse {
			0%, 100% { opacity: 1; }
			50% { opacity: .4; }
		}

		#textOverlay {
			position: absolute;
			display: none;
			z-index: 20;
			background: rgba(20, 22, 28, .9);
			border: 1px solid rgba(162, 155, 254, .4);
			border-radius: .6rem;
			padding: .5rem;
			box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
			backdrop-filter: blur(8px)
		}

		#textOverlay textarea {
			width: 260px;
			max-width: 65vw;
			min-height: 80px;
			background: rgba(0, 0, 0, .3);
			color: #fff;
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .4rem;
			padding: .4rem;
			font-size: 15px;
			outline: none;
			resize: vertical
		}

		#textOverlay textarea:focus {
			border-color: var(--brand-primary)
		}

		#textActions {
			display: flex;
			gap: .4rem;
			justify-content: flex-end;
			margin-top: .4rem
		}

		#toast {
			position: fixed;
			left: 50%;
			transform: translateX(-50%) translateY(10px);
			bottom: calc(12px + env(safe-area-inset-bottom));
			background: rgba(30, 33, 41, .95);
			color: #fff;
			padding: .5rem .8rem;
			border-radius: .5rem;
			border: 1px solid rgba(255, 255, 255, .1);
			font-size: .85rem;
			font-weight: 500;
			opacity: 0;
			pointer-events: none;
			transition: opacity .25s, transform .25s;
			box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
			backdrop-filter: blur(8px)
		}

		#toast.show {
			opacity: 1;
			transform: translateX(-50%) translateY(0)
		}

		footer {
			position: static;
			font-size: 14px;
			text-align: center;
			padding: 8px;
			background: transparent;
			color: #555;
			margin: 4px 0;
			width: 100%
		}

		footer a {
			color: #ff5f1f;
			text-decoration: none
		}

		footer a:hover {
			text-decoration: underline
		}

		.helperText {
			font-size: 11px;
			color: #b45309;
			margin-top: 4px;
			display: none
		}

		.helperText.visible {
			display: block
		}

		/* Tool active cursor states */
		.cursor-draw {
			cursor: crosshair !important
		}

		.cursor-eraser {
			cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23ff5d5d' stroke-width='2'%3E%3Cpath d='M20 20H7L3 16a1 1 0 0 1 0-1.4l10-10a1 1 0 0 1 1.4 0l7 7a1 1 0 0 1 0 1.4L16 19'/%3E%3Cpath d='M6.5 13.5L11 9'/%3E%3C/svg%3E") 12 12, crosshair !important
		}

		.cursor-text {
			cursor: text !important
		}

		/* Tooltip for shortcuts */
		[data-tooltip] {
			position: relative
		}

		[data-tooltip]:hover::after {
			content: attr(data-tooltip);
			position: absolute;
			bottom: calc(100% + 6px);
			left: 50%;
			transform: translateX(-50%);
			padding: .3rem .5rem;
			background: rgba(0, 0, 0, .9);
			color: #fff;
			font-size: .7rem;
			white-space: nowrap;
			border-radius: .3rem;
			pointer-events: none;
			z-index: 100
		}

		@media (pointer: coarse) {
			button,
			input,
			select,
			.toolbar-btn,
			.tool-button {
				min-height: 44px;
				touch-action: manipulation;
			}

			canvas {
				touch-action: none;
			}

			[data-tooltip]:hover::after {
				display: none
			}
		}

		@media (max-width: 600px) {
			.btn-text {
				display: none
			}

			.tool-btn {
				min-width: 36px
			}

			.kbd {
				display: none
			}

			#zoomSlider {
				width: 80px
			}
		}
	</style>
</head>

<body>
	<!-- Topbar -->
	<div class="topbar">
		<div class="bar">
			<a class="brand" href="https://panphy.github.io" aria-label="panphy home">
				<img src="/panphy.png" alt="panphy logo" />
			</a>
			<div class="title">Camera Visualizer</div>
		</div>
	</div>

	<!-- Stage -->
	<main id="stage">
		<details class="controls">
			<summary>Controls</summary>
			<div class="row">
				<!-- Camera & Stream -->
				<div class="group">
					<span class="group-label">Camera</span>
					<select id="cameraSelect"></select>
					<div id="cameraHelper" class="helperText" aria-live="polite"></div>
					<button id="refreshBtn" data-tooltip="Refresh camera list">
						<span class="btn-icon">&#x21bb;</span>
					</button>
				</div>

				<div class="group">
					<span class="group-label">Stream</span>
					<label class="switch">
						<input id="liveToggle" type="checkbox" checked />
						<span class="slider"></span>
					</label>
					<div class="status">
						<span id="statusLight" class="light live"></span>
						<span id="statusLabel" class="statusText">Live</span>
					</div>
				</div>

				<!-- Tools -->
				<div class="group">
					<span class="group-label">Tools</span>
					<button id="laserBtn" class="tool-btn primary" data-tooltip="Laser pointer (L)">
						<span class="btn-icon">&#x2739;</span>
						<span class="btn-text">Laser</span>
						<span class="kbd">L</span>
					</button>
					<button id="annotationBtn" class="tool-btn muted" data-tooltip="Draw annotation (A)">
						<span class="btn-icon">&#x270E;</span>
						<span class="btn-text">Draw</span>
						<span class="kbd">A</span>
					</button>
					<button id="eraserBtn" class="tool-btn muted" data-tooltip="Eraser (E)">
						<span class="btn-icon">&#x232B;</span>
						<span class="btn-text">Erase</span>
						<span class="kbd">E</span>
					</button>
					<button id="textBtn" class="tool-btn muted" data-tooltip="Add text (T)">
						<span class="btn-icon">T</span>
						<span class="btn-text">Text</span>
						<span class="kbd">T</span>
					</button>
				</div>

				<!-- Pointer settings -->
				<div class="group" id="pointerGroup">
					<span class="group-label">Pointer</span>
					<button class="color-btn" id="pointerColorBtn" title="Pointer color">
						<input id="pointerColorInput" type="color" value="#ff3b3b" />
					</button>
					<div id="pointerSizes" class="sizePicker" aria-label="Pointer size"></div>
					<span id="laserIndicator" class="laserIndicator active" aria-live="polite">
						<span class="dot" aria-hidden="true"></span>
						Active
					</span>
				</div>

				<!-- Annotation settings -->
				<div class="group" id="annotGroup">
					<span class="group-label">Annotate</span>
					<button class="color-btn" id="annotColorBtn" title="Annotation color">
						<input id="annotColorInput" type="color" value="#33d17a" />
					</button>
					<div id="annotSizes" class="sizePicker" aria-label="Annotation size"></div>
					<span class="vsep"></span>
					<button id="undoBtn" class="muted" data-tooltip="Undo last (Ctrl+Z)" disabled>
						<span class="btn-icon">&#x21B6;</span>
						<span class="btn-text">Undo</span>
					</button>
					<button id="clearBtn" class="danger" data-tooltip="Clear all">
						<span class="btn-icon">&#x2715;</span>
						<span class="btn-text">Clear</span>
					</button>
				</div>

				<!-- Display controls -->
				<div class="group">
					<span class="group-label">Display</span>
					<button id="mirrorBtn" data-tooltip="Mirror view (M)">
						<span class="btn-icon">&#x21C4;</span>
						<span class="btn-text">Mirror</span>
						<span class="kbd">M</span>
					</button>
					<button id="fitBtn" data-tooltip="Toggle fit/fill mode">
						<span class="btn-icon">&#x26F6;</span>
						<span class="btn-text">Fit</span>
					</button>
				</div>

				<!-- Zoom -->
				<div class="group" id="zoomGroup">
					<span class="group-label">Zoom</span>
					<input id="zoomSlider" type="range" min="1" max="3" step="0.1" value="1" aria-label="Zoom level">
					<span id="zoomVal">1.0×</span>
				</div>

				<!-- Capture -->
				<div class="group">
					<span class="group-label">Capture</span>
					<button id="screenshotBtn" data-tooltip="Take snapshot">
						<span class="btn-icon">&#x1F4F7;</span>
						<span class="btn-text">Snapshot</span>
					</button>
					<button id="recordBtn" data-tooltip="Start recording">
						<span class="btn-icon">&#x23FA;</span>
						<span class="btn-text">Record</span>
					</button>
				</div>
			</div>
		</details>
		<button id="fullscreenBtn" type="button" aria-label="Enter full screen" title="Enter full screen">&#x26F6;</button>
		<video id="video" playsinline autoplay muted></video>
		<canvas id="freezeCanvas" class="hidden"></canvas>
		<canvas id="drawCanvas"></canvas>
		<canvas id="laserCanvas"></canvas>
		<div id="hud">
			<span id="statusDot"></span>
			<span id="hudText">Live</span>
			<span id="recordIndicator"><span id="recordDot"></span>REC</span>
		</div>

		<!-- Text overlay -->
		<div id="textOverlay">
			<textarea id="textInput" placeholder="Type your note..." aria-label="Text annotation"></textarea>
			<div id="textActions">
				<button id="textCancel" class="muted">Cancel</button>
				<button id="textAdd" class="primary">Add Text</button>
			</div>
		</div>
	</main>

	<div id="toast" role="status" aria-live="polite"></div>

	<script>
		(() => {
			/* ===== DOM refs ===== */
			const video = document.getElementById('video');
			const freezeCanvas = document.getElementById('freezeCanvas');
			const drawCanvas = document.getElementById('drawCanvas');
			const laserCanvas = document.getElementById('laserCanvas');
			const ctxFreeze = freezeCanvas.getContext('2d');
			const ctxDraw = drawCanvas.getContext('2d');
			const ctxLaser = laserCanvas.getContext('2d');

			const cameraSelect = document.getElementById('cameraSelect');
			const cameraHelper = document.getElementById('cameraHelper');
			const refreshBtn = document.getElementById('refreshBtn');
			const liveToggle = document.getElementById('liveToggle');

			const laserBtn = document.getElementById('laserBtn');
			const annotationBtn = document.getElementById('annotationBtn');
			const eraserBtn = document.getElementById('eraserBtn');
			const textBtn = document.getElementById('textBtn');

			const statusLight = document.getElementById('statusLight');
			const statusLabel = document.getElementById('statusLabel');

			const undoBtn = document.getElementById('undoBtn');
			const clearBtn = document.getElementById('clearBtn');
			const screenshotBtn = document.getElementById('screenshotBtn');
			const recordBtn = document.getElementById('recordBtn');
			const mirrorBtn = document.getElementById('mirrorBtn');
			const fitBtn = document.getElementById('fitBtn');
			const hud = document.getElementById('hud');
			const hudText = document.getElementById('hudText');
			const stage = document.getElementById('stage');
			const fullscreenBtn = document.getElementById('fullscreenBtn');
			const toast = document.getElementById('toast');

			/* Color inputs */
			const pointerColorInput = document.getElementById('pointerColorInput');
			const annotColorInput = document.getElementById('annotColorInput');
			const pointerColorBtn = document.getElementById('pointerColorBtn');
			const annotColorBtn = document.getElementById('annotColorBtn');
			const laserIndicator = document.getElementById('laserIndicator');

			const sizeUI = {
				pointer: document.getElementById('pointerSizes'),
				annot: document.getElementById('annotSizes')
			};

			const textOverlay = document.getElementById('textOverlay');
			const textInput = document.getElementById('textInput');
			const textAdd = document.getElementById('textAdd');
			const textCancel = document.getElementById('textCancel');

			/* Zoom controls */
			const zoomSlider = document.getElementById('zoomSlider');
			const zoomVal = document.getElementById('zoomVal');

			/* ===== Persistence ===== */
			function saveStr(k, v) { try { localStorage.setItem(k, v == null ? '' : String(v)); } catch (e) {} }
			function loadStr(k, f) { try { const v = localStorage.getItem(k); return v === null ? f : v; } catch (e) { return f; } }
			function saveNum(k, v) { try { localStorage.setItem(k, String(v)); } catch (e) {} }
			function loadNum(k, f) { try { const v = localStorage.getItem(k); const n = v !== null ? Number(v) : NaN; return isFinite(n) ? n : f; } catch (e) { return f; } }

			/* ===== State ===== */
			let pointerColor = loadStr('pointerColor', '#ff3b3b');
			let annotColor = loadStr('annotColor', '#33d17a');
			const SIZESET = [6, 12, 20];
			let pointerSize = loadNum('pointerSize', 12);
			let annotSize = loadNum('annotSize', 12);

			let isPaused = false;
			let isMirrored = false,
				fitMode = 'contain';

			let annotationOn = false,
				eraserOn = false,
				textModeOn = false,
				overlayVisible = false;

			let facingPref = loadStr('lastFacing', 'environment');
			let lastDeviceId = loadStr('lastDeviceId', '');
			let stream = null,
				switching = false;

			let tail = [];
			let laserActive = true;

			const frozen = document.createElement('canvas');
			const frozenCtx = frozen.getContext('2d');
			let hasFrozen = false;

			// Drawing model with smoothing
			let objects = [];
			let currentStroke = null;
			let undoStack = [];
			const MAX_UNDO = 50;

			// Recording composite
			const composite = document.createElement('canvas');
			const compositeCtx = composite.getContext('2d');
			let recording = false,
				mediaRecorder = null,
				recChunks = [];

			/* Zoom state */
			let zoomLevel = loadNum('zoomLevel', 1);
			const Z = () => (zoomLevel || 1);

			/* Initialize color inputs from saved values */
			pointerColorInput.value = pointerColor;
			annotColorInput.value = annotColor;

			/* ===== Fullscreen ===== */
			function isFullscreen() {
				return document.fullscreenElement === stage ||
					document.fullscreenElement === video ||
					document.webkitFullscreenElement === stage ||
					document.webkitFullscreenElement === video;
			}

			function updateFullscreenUI() {
				const active = isFullscreen();
				fullscreenBtn.innerHTML = active ? '&#x2716;' : '&#x26F6;';
				fullscreenBtn.setAttribute('aria-label', active ? 'Exit full screen' : 'Enter full screen');
				fullscreenBtn.setAttribute('title', active ? 'Exit full screen' : 'Enter full screen');
			}

			fullscreenBtn.addEventListener('click', () => {
				const requestFullscreen = stage.requestFullscreen || stage.webkitRequestFullscreen || stage.webkitRequestFullScreen;
				const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.webkitCancelFullScreen;

				if (isFullscreen()) {
					if (exitFullscreen) { exitFullscreen.call(document); }
					return;
				}
				if (requestFullscreen) {
					requestFullscreen.call(stage);
					return;
				}
				if (video.webkitEnterFullscreen) {
					video.webkitEnterFullscreen();
					return;
				}
				showToast('Fullscreen not supported');
			});

			document.addEventListener('fullscreenchange', updateFullscreenUI);
			document.addEventListener('webkitfullscreenchange', updateFullscreenUI);
			updateFullscreenUI();

			/* ===== Utils ===== */
			function showToast(msg, ms = 1800) {
				toast.textContent = msg;
				toast.classList.add('show');
				setTimeout(() => toast.classList.remove('show'), ms);
			}

			let permissionBlocked = false;
			function setCameraHelper(message) {
				cameraHelper.textContent = message || '';
				cameraHelper.classList.toggle('visible', !!message);
			}

			function updateColorBtn(btn, color) {
				btn.style.background = color;
			}

			function resizeCanvases() {
				const r = stage.getBoundingClientRect();
				[freezeCanvas, drawCanvas, laserCanvas, composite].forEach(c => {
					c.width = Math.floor(r.width);
					c.height = Math.floor(r.height);
				});
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				renderAnnotations();
			}

			/* UI sync */
			function syncToggleUI() { liveToggle.checked = !isPaused; }

			function updateStatusUI() {
				stage.classList.toggle('pausedVideo', isPaused);
				hudText.textContent = isPaused ? 'Paused' : 'Live';
				statusLabel.textContent = isPaused ? 'Paused' : 'Live';
				statusLight.className = 'light ' + (isPaused ? 'paused' : 'live');
				syncToggleUI();
			}

			function updateUndoState() {
				undoBtn.disabled = objects.length === 0;
			}

			/* Update cursor based on active tool */
			function updateCursor() {
				stage.classList.remove('cursor-draw', 'cursor-eraser', 'cursor-text');
				if (eraserOn) {
					stage.classList.add('cursor-eraser');
				} else if (textModeOn) {
					stage.classList.add('cursor-text');
				} else if (annotationOn) {
					stage.classList.add('cursor-draw');
				}
			}

			/* Freeze handling */
			function captureFrozenFromVideo() {
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (!video.videoWidth || w === 0 || h === 0) return;
				frozen.width = w;
				frozen.height = h;
				const vw = video.videoWidth,
					vh = video.videoHeight;
				const cr = w / h,
					vr = vw / vh;
				let dw, dh, dx, dy;
				if (fitMode === 'cover') {
					if (vr > cr) { dh = h; dw = h * vr; }
					else { dw = w; dh = w / vr; }
				} else {
					if (vr > cr) { dw = w; dh = w / vr; }
					else { dh = h; dw = h * vr; }
				}
				dx = (w - dw) / 2;
				dy = (h - dh) / 2;
				frozenCtx.save();
				if (isMirrored) {
					frozenCtx.translate(w, 0);
					frozenCtx.scale(-1, 1);
					dx = w - dx - dw;
				}
				frozenCtx.clearRect(0, 0, w, h);
				frozenCtx.drawImage(video, dx, dy, dw, dh);
				frozenCtx.restore();
				hasFrozen = true;
			}

			function drawFreezeFromFrozen() {
				if (!hasFrozen) return;
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				ctxFreeze.clearRect(0, 0, w, h);
				ctxFreeze.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				freezeCanvas.classList.remove('hidden');
			}

			async function setPaused(state) {
				if (state === isPaused) return;
				if (state) {
					isPaused = true;
					captureFrozenFromVideo();
					drawFreezeFromFrozen();
					if (stream) { stream.getTracks().forEach(t => t.stop()); }
					updateStatusUI();
					return;
				}
				const val = cameraSelect.value || '';
				if (val && val.indexOf('facing:') !== 0) {
					await startCamera({ deviceId: { exact: val } });
				} else {
					await startCamera({ facingMode: facingPref });
				}
				hasFrozen = false;
				freezeCanvas.classList.add('hidden');
				isPaused = false;
				updateStatusUI();
			}

			/* Interaction mode */
			function updateInteractionMode() {
				const toolActive = annotationOn || eraserOn || textModeOn;
				laserActive = !toolActive;
				laserIndicator.classList.toggle('active', laserActive);
				if (!laserActive) {
					ctxLaser.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
					tail.length = 0;
				}
				updateCursor();
			}

			/* Camera */
			async function startCamera(constraint) {
				if (switching) return;
				switching = true;
				try {
					if (stream) { stream.getTracks().forEach(t => t.stop()); }
					const base = { width: { ideal: 1280 }, height: { ideal: 720 } };
					const attempts = [constraint || {}, { facingMode: facingPref }, {}];
					let lastError = null;
					for (let i = 0; i < attempts.length; i++) {
						try {
							const constraints = { audio: false, video: Object.assign({}, base, attempts[i]) };
							stream = await navigator.mediaDevices.getUserMedia(constraints);
							video.srcObject = stream;
							await video.play();
							permissionBlocked = false;
							setCameraHelper('');
							lastError = null;
							break;
						} catch (err) {
							lastError = err;
							if (err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')) {
								permissionBlocked = true;
								setCameraHelper('Camera access is blocked. Allow permission to see cameras.');
								showToast('Camera permission blocked');
								break;
							}
						}
					}
					if (lastError) throw lastError;
				} finally {
					await enumerate();
					resizeCanvases();
					switching = false;
				}
			}

			async function enumerate() {
				try {
					const devs = await navigator.mediaDevices.enumerateDevices();
					const cams = devs.filter(d => d.kind === 'videoinput');

					function facingGuess(label) {
						const L = (label || '').toLowerCase();
						if (/(back|rear|environment)/.test(L)) return 'environment';
						if (/(front|user|face)/.test(L)) return 'user';
						return 'environment';
					}
					cameraSelect.innerHTML = '';
					if (cams.length === 0) {
						const opt = document.createElement('option');
						opt.textContent = 'No cameras found';
						opt.disabled = true;
						opt.selected = true;
						cameraSelect.appendChild(opt);
					}
					cams.forEach((d, i) => {
						const opt = document.createElement('option');
						const fg = facingGuess(d.label || '');
						opt.value = d.deviceId || ('facing:' + fg + ':' + i);
						opt.textContent = d.label || ('Camera ' + (i + 1));
						opt.dataset.facing = fg;
						cameraSelect.appendChild(opt);
					});
					cameraSelect.disabled = permissionBlocked || cameraSelect.options.length <= 1;
					let activeId = '';
					try {
						if (stream) {
							const tracks = stream.getVideoTracks();
							if (tracks && tracks[0]) {
								const s = tracks[0].getSettings && tracks[0].getSettings();
								if (s && s.deviceId) activeId = s.deviceId;
							}
						}
					} catch (e) {}
					const hasVal = v => [].some.call(cameraSelect.options, o => o.value === v);
					let targetValue = '';
					if (activeId && hasVal(activeId)) { targetValue = activeId; }
					else if (lastDeviceId && hasVal(lastDeviceId)) { targetValue = lastDeviceId; }
					else {
						const optByFacing = [].find.call(cameraSelect.options, o => o.dataset && o.dataset.facing === facingPref);
						if (optByFacing) targetValue = optByFacing.value;
						else if (cameraSelect.options[0]) targetValue = cameraSelect.options[0].value;
					}
					if (targetValue) cameraSelect.value = targetValue;
				} catch (err) {
					console.error(err);
					showToast('Could not list cameras');
				}
			}

			function debounced(fn, ms) {
				let t = 0;
				return function() {
					const a = arguments;
					clearTimeout(t);
					t = setTimeout(() => fn.apply(null, a), ms);
				};
			}

			const onCameraChange = debounced(async function() {
				const val = cameraSelect.value || '';
				if (val.indexOf('facing:') === 0) {
					const facing = val.split(':')[1] || facingPref;
					facingPref = facing;
					saveStr('lastFacing', facing);
					saveStr('lastDeviceId', '');
					await startCamera({ facingMode: facing });
				} else {
					saveStr('lastDeviceId', val);
					await startCamera({ deviceId: { exact: val } });
					const opt = [].slice.call(cameraSelect.options).find(o => o.value === val);
					if (opt && opt.dataset && opt.dataset.facing) {
						facingPref = opt.dataset.facing;
						saveStr('lastFacing', facingPref);
					}
				}
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
			}, 250);

			cameraSelect.addEventListener('change', onCameraChange);
			cameraSelect.addEventListener('input', onCameraChange);

			refreshBtn.addEventListener('click', async function() {
				if (switching) return;
				try {
					try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch (e) {}
					await enumerate();
					const val = cameraSelect.value || '';
					if (val && val.indexOf('facing:') !== 0) {
						saveStr('lastDeviceId', val);
						await startCamera({ deviceId: { exact: val } });
					} else {
						await startCamera({ facingMode: facingPref });
					}
				} catch (e) {
					console.error(e);
					if (!permissionBlocked) showToast('Refresh failed');
				}
			});

			/* ===== Coordinate helpers (zoom-aware positions) ===== */
			function canvasToCtxXY(clientX, clientY, canvas) {
				const rect = canvas.getBoundingClientRect();
				const baseW = canvas.width,
					baseH = canvas.height;
				const s = Z();
				let x = (clientX - rect.left - rect.width / 2) / s + baseW / 2;
				const y = (clientY - rect.top - rect.height / 2) / s + baseH / 2;
				if (isMirrored) x = baseW - x;
				if (!isFinite(x) || !isFinite(y)) return { x: 0, y: 0 };
				return { x, y };
			}

			function normPressure(p) {
				const v = isFinite(p) ? p : 1;
				return Math.max(0.3, Math.min(1, v));
			}

			function getPrimaryPoint(e) {
				if (window.PointerEvent && e instanceof PointerEvent) {
					return { x: e.clientX, y: e.clientY, id: e.pointerId, pressure: e.pressure };
				}
				if (e.touches && e.touches[0]) {
					const t = e.touches[0];
					return { x: t.clientX, y: t.clientY, id: 1, pressure: 1 };
				}
				if (e.changedTouches && e.changedTouches[0]) {
					const t2 = e.changedTouches[0];
					return { x: t2.clientX, y: t2.clientY, id: 1, pressure: 1 };
				}
				if (e.clientX !== undefined) {
					return { x: e.clientX, y: e.clientY, id: 1, pressure: 1 };
				}
				return null;
			}
			let pointerIdActive = null;

			/* ===== Smooth line drawing with quadratic curves ===== */
			function drawSmoothLine(ctx, points, color, size, scale) {
				if (points.length < 2) return;

				ctx.save();
				ctx.strokeStyle = color;
				ctx.lineWidth = Math.max(1, size / scale);
				ctx.lineCap = 'round';
				ctx.lineJoin = 'round';
				ctx.beginPath();

				ctx.moveTo(points[0].x, points[0].y);

				if (points.length === 2) {
					ctx.lineTo(points[1].x, points[1].y);
				} else {
					// Use quadratic curves for smoother lines
					for (let i = 1; i < points.length - 1; i++) {
						const xc = (points[i].x + points[i + 1].x) / 2;
						const yc = (points[i].y + points[i + 1].y) / 2;
						ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
					}
					// Connect to last point
					const last = points[points.length - 1];
					const secondLast = points[points.length - 2];
					ctx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
				}

				ctx.stroke();
				ctx.restore();
			}

			/* ===== Rendering annotations ===== */
			function renderAnnotations() {
				const w = drawCanvas.width,
					h = drawCanvas.height;
				ctxDraw.clearRect(0, 0, w, h);
				const s = Z();

				for (let i = 0; i < objects.length; i++) {
					const obj = objects[i];
					if (obj.type === 'stroke') {
						drawSmoothLine(ctxDraw, obj.points, obj.color, obj.size, s);
					} else if (obj.type === 'text') {
						const effFontPx = Math.max(8, obj.baseFontPx / s);
						const m = measureTextBlock(obj.text, effFontPx);
						ctxDraw.save();
						ctxDraw.font = 'bold ' + effFontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
						ctxDraw.textBaseline = 'top';
						ctxDraw.fillStyle = obj.color;
						ctxDraw.lineWidth = Math.max(2, effFontPx * 0.12);
						ctxDraw.strokeStyle = 'rgba(0,0,0,0.55)';
						const lines = obj.text.split(/\r?\n/);
						lines.forEach((ln, li) => {
							const yy = obj.y + li * m.lh;
							ctxDraw.strokeText(ln, obj.x, yy);
							ctxDraw.fillText(ln, obj.x, yy);
						});
						ctxDraw.restore();
						obj._lastMeasured = { w: m.width, h: m.height, lh: m.lh, effFontPx };
					}
				}
				updateUndoState();
			}

			function measureTextBlock(text, fontPx) {
				const lines = String(text).split(/\r?\n/);
				ctxDraw.save();
				ctxDraw.font = 'bold ' + fontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
				const widths = lines.map(ln => ctxDraw.measureText(ln).width);
				ctxDraw.restore();
				const lh = Math.round(fontPx * 1.25);
				let maxW = 1;
				for (let i = 0; i < widths.length; i++) {
					if (widths[i] > maxW) maxW = widths[i];
				}
				return { width: maxW, height: lines.length * lh, lh };
			}

			function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
				const A = px - x1,
					B = py - y1,
					C = x2 - x1,
					D = y2 - y1;
				const dot = A * C + B * D;
				const lenSq = C * C + D * D || 1e-6;
				let t = dot / lenSq;
				t = Math.max(0, Math.min(1, t));
				const xx = x1 + t * C,
					yy = y1 + t * D;
				return Math.hypot(px - xx, py - yy);
			}

			function hitTestObject(px, py, tolScreenPx) {
				const s = Z();
				const tol = tolScreenPx / s;
				for (let i = objects.length - 1; i >= 0; i--) {
					const obj = objects[i];
					if (obj.type === 'text') {
						const effFontPx = Math.max(8, obj.baseFontPx / s);
						const m = obj._lastMeasured && obj._lastMeasured.effFontPx === effFontPx ?
							{ width: obj._lastMeasured.w, height: obj._lastMeasured.h } :
							measureTextBlock(obj.text, effFontPx);
						if (px >= obj.x && px <= obj.x + m.width && py >= obj.y && py <= obj.y + m.height) return i;
					} else if (obj.type === 'stroke') {
						const pts = obj.points;
						const strokeTol = tol + (obj.size / s) / 2;
						for (let j = 1; j < pts.length; j++) {
							const dist = pointToSegmentDistance(px, py, pts[j - 1].x, pts[j - 1].y, pts[j].x, pts[j].y);
							if (dist <= strokeTol) return i;
						}
					}
				}
				return -1;
			}

			function startDraw(e) {
				if (overlayVisible) return;
				const p = getPrimaryPoint(e);
				if (!p) return;
				const pt = canvasToCtxXY(p.x, p.y, drawCanvas);
				const { x, y } = pt;
				pointerIdActive = p.id;

				if (eraserOn) {
					const idx = hitTestObject(x, y, Math.max(12, annotSize * 1.5));
					if (idx >= 0) {
						objects.splice(idx, 1);
						renderAnnotations();
					}
					return;
				}
				if (annotationOn && !textModeOn) {
					currentStroke = {
						type: 'stroke',
						color: annotColor,
						size: Math.max(1, annotSize * normPressure(p.pressure)),
						points: [{ x, y }]
					};
					objects.push(currentStroke);
					renderAnnotations();
				}
			}

			function moveDraw(e) {
				if (overlayVisible) return;
				const p = getPrimaryPoint(e);
				if (!p) return;

				if (laserActive) {
					const ptL = canvasToCtxXY(p.x, p.y, laserCanvas);
					addTailPoint(ptL.x, ptL.y);
				}
				if (eraserOn && p.id === pointerIdActive) {
					const ptE = canvasToCtxXY(p.x, p.y, drawCanvas);
					const idx = hitTestObject(ptE.x, ptE.y, Math.max(12, annotSize * 1.5));
					if (idx >= 0) {
						objects.splice(idx, 1);
						renderAnnotations();
					}
					return;
				}
				if (annotationOn && !textModeOn && p.id === pointerIdActive && currentStroke) {
					const ptA = canvasToCtxXY(p.x, p.y, drawCanvas);
					// Only add point if it's far enough from the last one (reduces jaggedness)
					const last = currentStroke.points[currentStroke.points.length - 1];
					const dist = Math.hypot(ptA.x - last.x, ptA.y - last.y);
					if (dist > 2) {
						currentStroke.points.push({ x: ptA.x, y: ptA.y });
						currentStroke.size = Math.max(1, annotSize * normPressure(p.pressure));
						renderAnnotations();
					}
				}
			}

			function endDraw() {
				pointerIdActive = null;
				currentStroke = null;
			}

			/* Laser trail */
			function addTailPoint(x, y) {
				tail.push({ x, y, life: 1 });
				if (tail.length > 180) tail.shift();
			}

			function renderLaser() {
				const w = laserCanvas.width,
					h = laserCanvas.height;
				ctxLaser.clearRect(0, 0, w, h);
				if (laserActive && tail.length > 0) {
					const rgb = hexToRgb(pointerColor);
					const r = rgb.r,
						g = rgb.g,
						b = rgb.b;
					const s = Z();

					for (let i = 0; i < tail.length; i++) {
						const t = tail[i];
						t.life *= 0.94;
						if (t.life < 0.02) continue;
						const a = t.life;
						const radius = (pointerSize / s) * (0.8 + 1.0 * a);
						const glow = radius * 2.5;

						// Outer glow
						const grad = ctxLaser.createRadialGradient(t.x, t.y, 0, t.x, t.y, glow);
						grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (0.3 * a) + ')');
						grad.addColorStop(0.5, 'rgba(' + r + ',' + g + ',' + b + ',' + (0.1 * a) + ')');
						grad.addColorStop(1, 'rgba(0,0,0,0)');
						ctxLaser.fillStyle = grad;
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, glow, 0, Math.PI * 2);
						ctxLaser.fill();

						// Inner bright core
						ctxLaser.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + (0.9 * a) + ')';
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, radius, 0, Math.PI * 2);
						ctxLaser.fill();

						// White center for brightness
						ctxLaser.fillStyle = 'rgba(255,255,255,' + (0.5 * a) + ')';
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, radius * 0.4, 0, Math.PI * 2);
						ctxLaser.fill();
					}
				}
				for (let j = tail.length - 1; j >= 0; j--) {
					if (tail[j].life < 0.02) tail.splice(j, 1);
				}
				requestAnimationFrame(renderLaser);
			}

			function hexToRgb(hex) {
				const h = hex.replace('#', '');
				const b = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
				return { r: (b >> 16) & 255, g: (b >> 8) & 255, b: b & 255 };
			}

			/* Text overlay */
			let pendingTextXY = null;

			function showTextOverlayAt(clientX, clientY) {
				const rect = stage.getBoundingClientRect();
				textOverlay.style.display = 'block';
				const padding = 8;
				const overlayWidth = textOverlay.offsetWidth;
				const overlayHeight = textOverlay.offsetHeight;
				const maxX = Math.max(padding, rect.width - overlayWidth - padding);
				const maxY = Math.max(padding, rect.height - overlayHeight - padding);
				const x = Math.min(Math.max(clientX - rect.left, padding), maxX);
				const y = Math.min(Math.max(clientY - rect.top, padding), maxY);
				textOverlay.style.left = x + 'px';
				textOverlay.style.top = y + 'px';
				overlayVisible = true;
				textInput.value = '';
				textInput.focus();
			}

			function hideTextOverlay(keepMode) {
				keepMode = !!keepMode;
				textOverlay.style.display = 'none';
				overlayVisible = false;
				pendingTextXY = null;
				if (!keepMode) {
					textModeOn = false;
					syncToolButtons();
					updateInteractionMode();
				}
			}

			function placeTextObject(text, x, y) {
				if (!text) return;
				const baseFontPx = Math.round(12 + annotSize * 1.8);
				const obj = { type: 'text', x, y, text: String(text), color: annotColor, baseFontPx };
				objects.push(obj);
				renderAnnotations();
			}

			function syncToolButtons() {
				// Remove active state from all tool buttons
				[laserBtn, annotationBtn, eraserBtn, textBtn].forEach(btn => {
					btn.classList.remove('active', 'primary');
					btn.classList.add('muted');
				});

				// Set active state
				if (eraserOn) {
					eraserBtn.classList.remove('muted');
					eraserBtn.classList.add('active', 'primary');
				} else if (textModeOn) {
					textBtn.classList.remove('muted');
					textBtn.classList.add('active', 'primary');
				} else if (annotationOn) {
					annotationBtn.classList.remove('muted');
					annotationBtn.classList.add('active', 'primary');
				} else {
					// Laser mode (default)
					laserBtn.classList.remove('muted');
					laserBtn.classList.add('active', 'primary');
				}
			}

			function setLaserMode(showFeedback) {
				annotationOn = false;
				eraserOn = false;
				textModeOn = false;
				hideTextOverlay();
				syncToolButtons();
				updateInteractionMode();
				if (showFeedback) showToast('Laser pointer active');
			}

			function toggleAnnotation(showFeedback) {
				annotationOn = !annotationOn;
				eraserOn = false;
				textModeOn = false;
				hideTextOverlay();
				syncToolButtons();
				updateInteractionMode();
				if (showFeedback) showToast(annotationOn ? 'Draw mode' : 'Laser pointer');
			}

			function toggleEraser(showFeedback) {
				eraserOn = !eraserOn;
				annotationOn = eraserOn;
				textModeOn = false;
				hideTextOverlay();
				syncToolButtons();
				updateInteractionMode();
				if (showFeedback) showToast(eraserOn ? 'Eraser mode' : 'Laser pointer');
			}

			function toggleTextMode(showFeedback) {
				textModeOn = !textModeOn;
				annotationOn = textModeOn;
				eraserOn = false;
				hideTextOverlay(textModeOn);
				syncToolButtons();
				updateInteractionMode();
				if (showFeedback) {
					showToast(textModeOn ? 'Text mode - tap to place' : 'Laser pointer');
				}
			}

			/* Wiring */
			liveToggle.addEventListener('change', () => setPaused(!liveToggle.checked));

			laserBtn.addEventListener('click', () => setLaserMode(true));
			annotationBtn.addEventListener('click', () => toggleAnnotation(true));
			eraserBtn.addEventListener('click', () => toggleEraser(true));
			textBtn.addEventListener('click', () => toggleTextMode(true));

			undoBtn.addEventListener('click', () => {
				if (!objects.length) return;
				objects.pop();
				renderAnnotations();
				showToast('Undone');
			});

			clearBtn.addEventListener('click', () => {
				if (!objects.length) return;
				objects.length = 0;
				renderAnnotations();
				showToast('Cleared all');
			});

			function refreshPickerColors() {
				[].slice.call(sizeUI.pointer.children).forEach(btn => btn.style.setProperty('--dot-color', pointerColor));
				[].slice.call(sizeUI.annot.children).forEach(btn => btn.style.setProperty('--dot-color', annotColor));
			}

			pointerColorInput.addEventListener('input', (e) => {
				pointerColor = e.target.value;
				saveStr('pointerColor', pointerColor);
				updateColorBtn(pointerColorBtn, pointerColor);
				refreshPickerColors();
			});

			annotColorInput.addEventListener('input', (e) => {
				annotColor = e.target.value;
				saveStr('annotColor', annotColor);
				updateColorBtn(annotColorBtn, annotColor);
				refreshPickerColors();
			});

			function buildSizePicker(container, sizes, getColor, currentSize, onPick) {
				container.innerHTML = '';
				sizes.forEach(sz => {
					const btn = document.createElement('button');
					btn.type = 'button';
					btn.className = 'dotBtn';
					btn.style.setProperty('--dot', sz + 'px');
					btn.style.setProperty('--dot-color', getColor());
					if (currentSize === sz) btn.classList.add('active');
					const dot = document.createElement('span');
					dot.className = 'dot';
					btn.appendChild(dot);
					btn.addEventListener('click', () => {
						[].slice.call(container.children).forEach(c => c.classList.remove('active'));
						btn.classList.add('active');
						onPick(sz);
					});
					container.appendChild(btn);
				});
			}

			/* Zoom + mirror + fit */
			function applyTransforms() {
				const s = Z();
				const mirror = isMirrored ? 'scaleX(-1) ' : '';
				[drawCanvas, laserCanvas, freezeCanvas].forEach(el => {
					el.style.transformOrigin = 'center center';
					el.style.transform = mirror + 'scale(' + s + ')';
				});
				video.style.transformOrigin = 'center center';
				video.style.transform = mirror + 'scale(' + s + ')';
				applyFitMode();
			}

			function applyFitMode() {
				video.style.objectFit = fitMode;
			}

			mirrorBtn.addEventListener('click', () => {
				isMirrored = !isMirrored;
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				showToast(isMirrored ? 'Mirrored' : 'Unmirrored');
			});

			function updateFitButton() {
				const isCover = fitMode === 'cover';
				fitBtn.querySelector('.btn-text').textContent = isCover ? 'Fill' : 'Fit';
				fitBtn.setAttribute('title', isCover ? 'Crop to fill (Fill)' : 'Show full view (Fit)');
			}

			fitBtn.addEventListener('click', () => {
				fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
				updateFitButton();
				applyFitMode();
				if (isPaused) {
					captureFrozenFromVideo();
					drawFreezeFromFrozen();
				}
				showToast(fitMode === 'cover' ? 'Fill mode' : 'Fit mode');
			});

			function setZoom(v) {
				zoomLevel = Math.max(1, Math.min(3, v || 1));
				saveNum('zoomLevel', zoomLevel);
				zoomSlider.value = String(zoomLevel);
				zoomVal.textContent = zoomLevel.toFixed(1) + '×';
				applyTransforms();
				renderAnnotations();
			}
			zoomSlider.addEventListener('input', e => setZoom(parseFloat(e.target.value)));

			/* Keyboard shortcuts */
			document.addEventListener('keydown', async e => {
				if (document.activeElement === textInput) return;

				// Ctrl/Cmd + Z for undo
				if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
					e.preventDefault();
					if (objects.length) {
						objects.pop();
						renderAnnotations();
						showToast('Undone');
					}
					return;
				}

				if (e.code === 'Space') {
					e.preventDefault();
					await setPaused(!isPaused);
					showToast(isPaused ? 'Paused' : 'Live');
					return;
				}
				if (e.key === undefined) return;
				const key = e.key.toLowerCase();
				if (key === 'm') {
					e.preventDefault();
					mirrorBtn.click();
				} else if (key === 'l') {
					e.preventDefault();
					setLaserMode(true);
				} else if (key === 'a') {
					e.preventDefault();
					toggleAnnotation(true);
				} else if (key === 'e') {
					e.preventDefault();
					toggleEraser(true);
				} else if (key === 't') {
					e.preventDefault();
					toggleTextMode(true);
				} else if (key === 'escape') {
					if (overlayVisible) {
						e.preventDefault();
						hideTextOverlay();
					} else if (annotationOn || eraserOn || textModeOn) {
						e.preventDefault();
						setLaserMode(true);
					}
				}
			});

			/* Stage events */
			const target = stage;

			function touchGuard(e) {
				if (overlayVisible && e.target.closest('#textOverlay')) return;
				if (e.target.closest('.controls') || e.target.closest('#fullscreenBtn')) return;
				e.preventDefault();
			}
			['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(ev => target.addEventListener(ev, touchGuard, { passive: false }));

			function isStageControlTarget(e) {
				return !!(e.target.closest('.controls') || e.target.closest('#fullscreenBtn') || e.target.closest('#textOverlay'));
			}

			target.addEventListener('pointerdown', e => {
				if (isStageControlTarget(e)) return;
				if (annotationOn && textModeOn && !overlayVisible) {
					const pt = canvasToCtxXY(e.clientX, e.clientY, drawCanvas);
					pendingTextXY = { x: pt.x, y: pt.y };
					showTextOverlayAt(e.clientX, e.clientY);
					return;
				}
				startDraw(e);
			});
			target.addEventListener('pointermove', e => {
				if (isStageControlTarget(e)) return;
				moveDraw(e);
			});
			target.addEventListener('pointerup', endDraw);
			target.addEventListener('pointercancel', endDraw);
			target.addEventListener('pointerout', endDraw);
			target.addEventListener('pointerleave', endDraw);

			/* Text overlay actions */
			textAdd.addEventListener('click', () => {
				if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
				hideTextOverlay();
			});
			textCancel.addEventListener('click', () => hideTextOverlay());
			textInput.addEventListener('keydown', e => {
				if (e.key === 'Escape') {
					e.preventDefault();
					hideTextOverlay();
				}
				if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
					e.preventDefault();
					if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
					hideTextOverlay();
				}
			});

			/* Snapshot */
			screenshotBtn.addEventListener('click', () => {
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (w === 0 || h === 0) {
					showToast('Snapshot failed: canvas not ready');
					return;
				}
				const out = document.createElement('canvas');
				out.width = w;
				out.height = h;
				const octx = out.getContext('2d');

				if (isPaused && hasFrozen) {
					octx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					const vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						const cr = w / h,
							vr = vw / vh;
						let dw, dh, dx, dy;
						if (fitMode === 'cover') {
							if (vr > cr) { dh = h; dw = h * vr; }
							else { dw = w; dh = w / vr; }
						} else {
							if (vr > cr) { dw = w; dh = w / vr; }
							else { dh = h; dw = h * vr; }
						}
						dx = (w - dw) / 2;
						dy = (h - dh) / 2;
						octx.save();
						if (isMirrored) {
							octx.translate(w, 0);
							octx.scale(-1, 1);
							dx = w - dx - dw;
						}
						octx.drawImage(video, dx, dy, dw, dh);
						octx.restore();
					}
				}
				if (isMirrored) {
					octx.save();
					octx.translate(w, 0);
					octx.scale(-1, 1);
					octx.drawImage(drawCanvas, 0, 0);
					octx.drawImage(laserCanvas, 0, 0);
					octx.restore();
				} else {
					octx.drawImage(drawCanvas, 0, 0);
					octx.drawImage(laserCanvas, 0, 0);
				}
				out.toBlob(blob => {
					if (!blob) {
						showToast('Snapshot failed');
						return;
					}
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = 'snapshot_' + new Date().toISOString().replace(/[:.]/g, '-') + '.png';
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(url);
					showToast('Snapshot saved');
				});
			});

			/* Recording */
			function drawCompositeFrame() {
				const w = composite.width,
					h = composite.height;
				compositeCtx.clearRect(0, 0, w, h);
				if (isPaused && hasFrozen) {
					compositeCtx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					const vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						const cr = w / h,
							vr = vw / vh;
						let dw, dh, dx, dy;
						if (fitMode === 'cover') {
							if (vr > cr) { dh = h; dw = h * vr; }
							else { dw = w; dh = w / vr; }
						} else {
							if (vr > cr) { dw = w; dh = w / vr; }
							else { dh = h; dw = h * vr; }
						}
						dx = (w - dw) / 2;
						dy = (h - dh) / 2;
						compositeCtx.save();
						if (isMirrored) {
							compositeCtx.translate(w, 0);
							compositeCtx.scale(-1, 1);
							dx = w - dx - dw;
						}
						compositeCtx.drawImage(video, dx, dy, dw, dh);
						compositeCtx.restore();
					}
				}
				if (isMirrored) {
					compositeCtx.save();
					compositeCtx.translate(w, 0);
					compositeCtx.scale(-1, 1);
					compositeCtx.drawImage(drawCanvas, 0, 0);
					compositeCtx.drawImage(laserCanvas, 0, 0);
					compositeCtx.restore();
				} else {
					compositeCtx.drawImage(drawCanvas, 0, 0);
					compositeCtx.drawImage(laserCanvas, 0, 0);
				}
				if (recording) requestAnimationFrame(drawCompositeFrame);
			}

			function getSupportedMime() {
				const prefs = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4;codecs=avc1.42E01E,mp4a.40.2'];
				for (let i = 0; i < prefs.length; i++) {
					if (MediaRecorder.isTypeSupported(prefs[i])) return prefs[i];
				}
				return '';
			}

			recordBtn.addEventListener('click', () => {
				if (!recording) {
					composite.width = freezeCanvas.width;
					composite.height = freezeCanvas.height;
					const mime = getSupportedMime();
					const s = composite.captureStream(30);
					try {
						mediaRecorder = new MediaRecorder(s, mime ? { mimeType: mime } : {});
					} catch (e) {
						showToast('Recording not supported');
						return;
					}
					recChunks = [];
					mediaRecorder.ondataavailable = e => {
						if (e.data && e.data.size > 0) recChunks.push(e.data);
					};
					mediaRecorder.onstop = () => {
						const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'video/webm' });
						const url = URL.createObjectURL(blob);
						const a = document.createElement('a');
						a.href = url;
						a.download = 'recording_' + new Date().toISOString().replace(/[:.]/g, '-') + '.webm';
						document.body.appendChild(a);
						a.click();
						a.remove();
						URL.revokeObjectURL(url);
						showToast('Recording saved');
					};
					mediaRecorder.start(120);
					recording = true;
					recordBtn.innerHTML = '<span class="btn-icon">&#x23F9;</span><span class="btn-text">Stop</span>';
					recordBtn.classList.add('danger');
					hud.classList.add('recording');
					drawCompositeFrame();
					showToast('Recording started');
				} else {
					recording = false;
					try { mediaRecorder.stop(); } catch (e) {}
					recordBtn.innerHTML = '<span class="btn-icon">&#x23FA;</span><span class="btn-text">Record</span>';
					recordBtn.classList.remove('danger');
					hud.classList.remove('recording');
				}
			});

			/* Init */
			const ro = new ResizeObserver(() => resizeCanvases());
			ro.observe(stage);
			window.addEventListener('orientationchange', () => setTimeout(resizeCanvases, 200));
			requestAnimationFrame(renderLaser);

			(async function init() {
				if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
					showToast('getUserMedia not supported');
					return;
				}
				await enumerate();

				let chosen = '';
				if (lastDeviceId && [].some.call(cameraSelect.options, o => o.value === lastDeviceId)) {
					chosen = lastDeviceId;
				}
				if (chosen) await startCamera({ deviceId: { exact: chosen } });
				else await startCamera({ facingMode: facingPref });

				isPaused = false;
				updateStatusUI();

				buildSizePicker(sizeUI.pointer, SIZESET, () => pointerColor, pointerSize, (sz) => {
					pointerSize = sz;
					saveNum('pointerSize', sz);
				});
				buildSizePicker(sizeUI.annot, SIZESET, () => annotColor, annotSize, (sz) => {
					annotSize = sz;
					saveNum('annotSize', sz);
				});

				updateColorBtn(pointerColorBtn, pointerColor);
				updateColorBtn(annotColorBtn, annotColor);
				refreshPickerColors();

				syncToolButtons();
				updateInteractionMode();
				setZoom(zoomLevel);
				applyFitMode();
				updateFitButton();
				resizeCanvases();
			})();
		})();
	</script>
	<script>
		function updateOfflineFontState() {
			document.documentElement.classList.toggle('offline-font', !navigator.onLine);
		}

		window.addEventListener('online', updateOfflineFontState);
		window.addEventListener('offline', updateOfflineFontState);
		updateOfflineFontState();
	</script>

	<footer>
		&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

</html>
