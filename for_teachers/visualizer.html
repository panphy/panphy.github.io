<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Camera Visualizer</title>
	<style>
		:root {
			--bg: #0f1117;
			--panel: #161a22;
			--text: #e6e6e6;
			--muted: #8b93a7;
			--accent: #4da3ff;
			--danger: #ff5d5d;
			--good: #00d27a;
			--warn: #ffb020;
			--ring: rgba(255, 255, 255, .08)
		}

		* {
			box-sizing: border-box
		}

		html,
		body {
			height: 100%
		}

		body {
			margin: 0;
			min-height: 100svh;
			padding-bottom: env(safe-area-inset-bottom);
			background: #0f1117;
			color: var(--text);
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
			display: flex;
			flex-direction: column
		}

		/* Top bar */
		.topbar {
			background: #2a2f3b;
			color: #fff;
			border-bottom: 1px solid #000
		}

		.topbar .bar {
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px 14px
		}

		.topbar .brand {
			position: absolute;
			left: 10px;
			display: inline-flex;
			align-items: center;
			gap: .35rem;
			text-decoration: none;
			color: #fff
		}

		.topbar .brand img {
			height: 22px;
			width: auto;
			display: block
		}

		.topbar .title {
			font-size: 17px;
			font-weight: 700
		}

		header {
			padding: .35rem .6rem .3rem;
			background: rgba(0, 0, 0, .18);
			border-bottom: 1px solid rgba(255, 255, 255, .06)
		}

		.row {
			display: flex;
			flex-wrap: wrap;
			gap: .4rem .5rem;
			align-items: center
		}

		.group {
			display: flex;
			align-items: center;
			gap: .4rem;
			flex-wrap: nowrap;
			background: var(--panel);
			border: 1px solid var(--ring);
			padding: .26rem .38rem;
			border-radius: .5rem
		}

		.title-mini {
			font-size: .78rem;
			font-weight: 600;
			opacity: .9;
			margin-right: .3rem;
			white-space: nowrap
		}

		select,
		button {
			background: #0e121a;
			color: var(--text);
			border: 1px solid var(--ring);
			border-radius: .4rem;
			padding: .22rem .42rem;
			font-size: .9rem;
			outline: none
		}

		button {
			cursor: pointer;
			transition: transform .06s ease
		}

		button:hover {
			transform: translateY(-1px)
		}

		button:disabled {
			opacity: .55;
			cursor: not-allowed;
			transform: none
		}

		.primary {
			background: var(--accent);
			border-color: #9acbff;
			color: #061423
		}

		.danger {
			background: var(--danger);
			border-color: #ffc4c4;
			color: #2a0000
		}

		.muted {
			background: #0e121a;
			color: #adb3c4
		}

		.active {
			box-shadow: 0 0 0 2px #9acbff inset
		}

		.fixed-width-btn {
			width: 60px;
			text-align: center
		}

		.hidden {
			display: none !important
		}

		.labelBtn {
			font-weight: 700;
			padding: .22rem .42rem;
			border-radius: .4rem;
			border: 1px solid var(--ring);
			min-width: 84px;
			text-align: center;
			cursor: pointer;
			user-select: none;
			font-size: .9rem;
			white-space: nowrap
		}

		.srOnly {
			position: absolute !important;
			width: 1px;
			height: 1px;
			margin: -1px;
			padding: 0;
			border: 0;
			clip: rect(0 0 0 0);
			clip-path: inset(50%);
			overflow: hidden;
			white-space: nowrap;
		}

		.status {
			display: flex;
			align-items: center;
			gap: .3rem
		}

		.light {
			width: 11px;
			height: 11px;
			border-radius: 50%;
			border: 2px solid rgba(255, 255, 255, .15)
		}

		.live {
			background: var(--good)
		}

		.paused {
			background: var(--warn)
		}

		.statusText {
			min-width: 44px;
			color: #cfd5e4;
			font-size: .82rem
		}

		.switch {
			position: relative;
			width: 46px;
			height: 24px;
			display: inline-block
		}

		.switch input {
			display: none
		}

		.slider {
			position: absolute;
			inset: 0;
			cursor: pointer;
			background: #293040;
			border-radius: 999px;
			border: 1px solid rgba(255, 255, 255, .12);
			transition: .2s
		}

		.slider:before {
			content: "";
			position: absolute;
			height: 18px;
			width: 18px;
			left: 3px;
			top: 2px;
			background: #fff;
			border-radius: 50%;
			transition: .2s
		}

		input:checked+.slider {
			background: #1f6bff
		}

		input:checked+.slider:before {
			transform: translateX(22px)
		}

		.vsep {
			width: 1px;
			height: 16px;
			background: rgba(255, 255, 255, .08)
		}

		.sizePicker {
			display: flex;
			align-items: center;
			gap: .25rem
		}

		.dotBtn {
			--dot: 9px;
			--dot-color: #fff;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 28px;
			height: 22px;
			border: 1px solid var(--ring);
			border-radius: .35rem;
			background: #0e121a;
			cursor: pointer
		}

		.dotBtn .dot {
			display: block;
			width: var(--dot);
			height: var(--dot);
			aspect-ratio: 1/1;
			border-radius: 50%;
			background: var(--dot-color)
		}

		.dotBtn.active {
			outline: 2px solid #9acbff
		}

		#zoomGroup {
			white-space: nowrap
		}

		#zoomSlider {
			width: 160px;
			height: 22px;
			vertical-align: middle
		}

		#zoomVal {
			display: inline-block;
			min-width: 2.6ch;
			text-align: right;
			color: #cfd5e4;
			font-size: .9rem
		}

		#stage {
			position: relative;
			flex: 1;
			min-height: 50vh;
			margin: .4rem .6rem calc(.5rem + env(safe-area-inset-bottom));
			border: 1px solid var(--ring);
			border-radius: 12px;
			overflow: hidden;
			background: #000
		}

		video,
		canvas {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			touch-action: none
		}

		video {
			object-fit: contain;
			background: #000;
			object-position: center center
		}

		#hud {
			position: absolute;
			right: .5rem;
			bottom: .5rem;
			font-size: .8rem;
			color: #cfd5e4;
			background: rgba(0, 0, 0, .4);
			padding: .2rem .4rem;
			border-radius: .35rem;
			border: 1px solid var(--ring)
		}

		#statusDot {
			display: inline-block;
			width: .5rem;
			height: .5rem;
			border-radius: 50%;
			background: var(--good);
			margin-right: .35rem
		}

		.pausedVideo #statusDot {
			background: var(--warn)
		}

		#textOverlay {
			position: absolute;
			display: none;
			z-index: 20;
			background: rgba(20, 22, 28, .2);
			border: 1px dashed rgba(255, 255, 255, .5);
			border-radius: .45rem;
			padding: .35rem
		}

		#textOverlay textarea {
			width: 250px;
			max-width: 60vw;
			min-height: 72px;
			background: transparent;
			color: #fff;
			border: 1px dashed rgba(255, 255, 255, .35);
			border-radius: .35rem;
			padding: .35rem;
			font-size: 15px;
			outline: none
		}

		#textActions {
			display: flex;
			gap: .35rem;
			justify-content: flex-end;
			margin-top: .35rem
		}

		#toast {
			position: fixed;
			left: 50%;
			transform: translateX(-50%);
			bottom: calc(6px + env(safe-area-inset-bottom));
			background: rgba(0, 0, 0, .75);
			color: #fff;
			padding: .4rem .6rem;
			border-radius: .45rem;
			border: 1px solid rgba(255, 255, 255, .12);
			font-size: .85rem;
			opacity: 0;
			pointer-events: none;
			transition: opacity .25s
		}

		#toast.show {
			opacity: 1
		}

		footer {
			position: static;
			font-size: 15px;
			text-align: center;
			padding: 7px;
			background: transparent;
			color: #555;
			margin: 4px 0;
			width: 100%
		}

		footer a {
			color: #ff5f1f;
			text-decoration: none
		}

		footer a:hover {
			text-decoration: underline
		}
	</style>
</head>

<body>
	<!-- Topbar -->
	<div class="topbar">
		<div class="bar">
			<a class="brand" href="https://panphy.github.io" aria-label="panphy home">
				<img src="/panphy.png" alt="panphy logo" />
			</a>
			<div class="title">Camera Visualizer</div>
		</div>
	</div>

	<!-- Toolbar -->
	<header>
		<div class="row">
			<div class="group">
				<span class="title-mini">Camera</span>
				<select id="cameraSelect"></select>
				<button id="refreshBtn">Refresh</button>
			</div>

			<div class="group">
				<span class="title-mini">Stream</span>
				<label class="switch">
					<input id="liveToggle" type="checkbox" checked />
					<span class="slider"></span>
				</label>
				<span class="vsep"></span>
				<div class="status">
					<span id="statusLight" class="light live"></span>
					<span id="statusLabel" class="statusText">Live</span>
				</div>
			</div>

			<div class="group">
				<span class="title-mini">Display</span>
				<button id="screenshotBtn">Snapshot</button>
				<button id="recordBtn">Record</button>
				<button id="mirrorBtn">Mirror</button>
				<button id="fitBtn" class="fixed-width-btn">Fill</button>
			</div>

			<div class="group">
				<label for="pointerColorInput" id="pointerLabelBtn" class="labelBtn">Pointer</label>
				<input id="pointerColorInput" type="color" class="srOnly" value="#ff3b3b" />
				<div id="pointerSizes" class="sizePicker" aria-label="Pointer size"></div>
			</div>

			<div class="group" id="annotGroup">
				<label for="annotColorInput" id="annotLabelBtn" class="labelBtn">Annotate</label>
				<input id="annotColorInput" type="color" class="srOnly" value="#33d17a" />
				<div id="annotSizes" class="sizePicker" aria-label="Annotation size"></div>
				<button id="annotationBtn" class="muted">Annotation</button>
				<button id="eraserBtn" class="muted">Eraser</button>
				<button id="textBtn" class="muted">Text</button>
				<button id="clearBtn" class="danger">Clear</button>
			</div>

			<div class="group" id="zoomGroup">
				<span class="title-mini">Zoom</span>
				<input id="zoomSlider" type="range" min="1" max="3" step="0.1" value="1" aria-label="Zoom level">
				<span id="zoomVal">1.0×</span>
			</div>
		</div>
	</header>

	<!-- Stage -->
	<main id="stage">
		<video id="video" playsinline autoplay muted></video>
		<canvas id="freezeCanvas" class="hidden"></canvas>
		<canvas id="drawCanvas"></canvas>
		<canvas id="laserCanvas"></canvas>
		<div id="hud"><span id="statusDot"></span><span id="hudText">Live</span></div>

		<!-- Text overlay -->
		<div id="textOverlay">
			<textarea id="textInput" placeholder="Type your note..."></textarea>
			<div id="textActions"><button id="textCancel">Cancel</button><button id="textAdd" class="primary">Add</button></div>
		</div>
	</main>

	<div id="toast" role="status" aria-live="polite"></div>

	<script>
		(() => {
			/* ===== DOM refs ===== */
			const video = document.getElementById('video');
			const freezeCanvas = document.getElementById('freezeCanvas');
			const drawCanvas = document.getElementById('drawCanvas');
			const laserCanvas = document.getElementById('laserCanvas');
			const ctxFreeze = freezeCanvas.getContext('2d');
			const ctxDraw = drawCanvas.getContext('2d');
			const ctxLaser = laserCanvas.getContext('2d');

			const cameraSelect = document.getElementById('cameraSelect');
			const refreshBtn = document.getElementById('refreshBtn');
			const liveToggle = document.getElementById('liveToggle');

			const annotationBtn = document.getElementById('annotationBtn');
			const eraserBtn = document.getElementById('eraserBtn');
			const textBtn = document.getElementById('textBtn');

			const statusLight = document.getElementById('statusLight');
			const statusLabel = document.getElementById('statusLabel');

			const clearBtn = document.getElementById('clearBtn');
			const screenshotBtn = document.getElementById('screenshotBtn');
			const recordBtn = document.getElementById('recordBtn');
			const mirrorBtn = document.getElementById('mirrorBtn');
			const fitBtn = document.getElementById('fitBtn');
			const hudText = document.getElementById('hudText');
			const stage = document.getElementById('stage');
			const toast = document.getElementById('toast');

			/* Color inputs + label buttons */
			const pointerColorInput = document.getElementById('pointerColorInput');
			const annotColorInput = document.getElementById('annotColorInput');
			const pointerLabelBtn = document.getElementById('pointerLabelBtn');
			const annotLabelBtn = document.getElementById('annotLabelBtn');

			const sizeUI = {
				pointer: document.getElementById('pointerSizes'),
				annot: document.getElementById('annotSizes')
			};

			const textOverlay = document.getElementById('textOverlay');
			const textInput = document.getElementById('textInput');
			const textAdd = document.getElementById('textAdd');
			const textCancel = document.getElementById('textCancel');

			/* Zoom controls */
			const zoomSlider = document.getElementById('zoomSlider');
			const zoomVal = document.getElementById('zoomVal');

			/* ===== Persistence ===== */
			function saveStr(k, v) { try { localStorage.setItem(k, v == null ? '' : String(v)); } catch (e) {} }

			function loadStr(k, f) { try { const v = localStorage.getItem(k); return v === null ? f : v; } catch (e) { return f; } }

			function saveNum(k, v) { try { localStorage.setItem(k, String(v)); } catch (e) {} }

			function loadNum(k, f) { try { const v = localStorage.getItem(k); const n = v !== null ? Number(v) : NaN; return isFinite(n) ? n : f; } catch (e) { return f; } }

			/* ===== State ===== */
			let pointerColor = pointerColorInput.value;
			let annotColor = annotColorInput.value;
			const SIZESET = [6, 12, 20];
			let pointerSize = loadNum('pointerSize', 12); // logical screen px
			let annotSize = loadNum('annotSize', 12); // logical screen px

			let isPaused = false;
			let isMirrored = false,
				fitMode = 'contain';

			let annotationOn = false,
				eraserOn = false,
				textModeOn = false,
				overlayVisible = false;

			let facingPref = loadStr('lastFacing', 'environment');
			let lastDeviceId = loadStr('lastDeviceId', '');
			let stream = null,
				switching = false;

			let tail = []; // laser trail
			let laserActive = true;

			const frozen = document.createElement('canvas');
			const frozenCtx = frozen.getContext('2d');
			let hasFrozen = false;

			// Drawing model
			let objects = []; // {type:'stroke'|'text', ...}
			let currentStroke = null; // active stroke

			// Recording composite
			const composite = document.createElement('canvas');
			const compositeCtx = composite.getContext('2d');
			let recording = false,
				mediaRecorder = null,
				recChunks = [];

			/* Zoom state */
			let zoomLevel = loadNum('zoomLevel', 1);
			const Z = () => (zoomLevel || 1); // helper

			/* ===== Utils ===== */
			function showToast(msg, ms) { ms = ms || 1600;
				toast.textContent = msg;
				toast.classList.add('show');
				setTimeout(() => toast.classList.remove('show'), ms); }

			function contrastOn(hex) {
				let h = hex.replace('#', '');
				if (h.length === 3) h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
				const r = parseInt(h.slice(0, 2), 16),
					g = parseInt(h.slice(2, 4), 16),
					b = parseInt(h.slice(4, 6), 16);
				const yiq = (r * 299 + g * 587 + b * 114) / 1000;
				return yiq >= 160 ? '#111' : '#fff';
			}

			function paintLabelBtn(btn, color) { btn.style.background = color;
				btn.style.borderColor = 'rgba(255,255,255,.25)';
				btn.style.color = contrastOn(color); }

			function resizeCanvases() {
				const r = stage.getBoundingClientRect();
				[freezeCanvas, drawCanvas, laserCanvas, composite].forEach(c => { c.width = Math.floor(r.width);
					c.height = Math.floor(r.height); });
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				renderAnnotations();
			}

			/* UI sync */
			function syncToggleUI() { liveToggle.checked = !isPaused; }

			function updateStatusUI() {
				stage.classList.toggle('pausedVideo', isPaused);
				hudText.textContent = isPaused ? 'Paused' : 'Live';
				statusLabel.textContent = isPaused ? 'Paused' : 'Live';
				statusLight.className = 'light ' + (isPaused ? 'paused' : 'live');
				syncToggleUI();
			}

			/* Freeze handling */
			function captureFrozenFromVideo() {
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (!video.videoWidth || w === 0 || h === 0) return;
				frozen.width = w;
				frozen.height = h;
				const vw = video.videoWidth,
					vh = video.videoHeight;
				const cr = w / h,
					vr = vw / vh;
				let dw, dh, dx, dy;
				if (fitMode === 'cover') {
					if (vr > cr) { dh = h;
						dw = h * vr; } else { dw = w;
						dh = w / vr; }
					dx = (w - dw) / 2;
					dy = (h - dh) / 2;
				} else {
					if (vr > cr) { dw = w;
						dh = w / vr; } else { dh = h;
						dw = h * vr; }
					dx = (w - dw) / 2;
					dy = (h - dh) / 2;
				}
				frozenCtx.save();
				if (isMirrored) { frozenCtx.translate(w, 0);
					frozenCtx.scale(-1, 1);
					dx = w - dx - dw; }
				frozenCtx.clearRect(0, 0, w, h);
				frozenCtx.drawImage(video, dx, dy, dw, dh);
				frozenCtx.restore();
				hasFrozen = true;
			}

			function drawFreezeFromFrozen() {
				if (!hasFrozen) return;
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				ctxFreeze.clearRect(0, 0, w, h);
				ctxFreeze.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				freezeCanvas.classList.remove('hidden');
			}

			async function setPaused(state) {
				if (state === isPaused) return;
				if (state) {
					isPaused = true;
					captureFrozenFromVideo();
					drawFreezeFromFrozen();
					if (stream) { stream.getTracks().forEach(t => t.stop()); }
					updateStatusUI();
					return;
				}
				const val = cameraSelect.value || '';
				if (val && val.indexOf('facing:') !== 0) { await startCamera({ deviceId: { exact: val } }); } else { await startCamera({ facingMode: facingPref }); }
				hasFrozen = false;
				freezeCanvas.classList.add('hidden');
				isPaused = false;
				updateStatusUI();
			}

			/* Interaction mode */
			function updateInteractionMode() {
				const toolActive = annotationOn || eraserOn || textModeOn;
				laserActive = !toolActive;
				if (!laserActive) { ctxLaser.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
					tail.length = 0; }
			}

			/* Camera */
			async function startCamera(constraint) {
				if (switching) return;
				switching = true;
				try {
					if (stream) { stream.getTracks().forEach(t => t.stop()); }
					const constraints = { audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, constraint || {}) };
					stream = await navigator.mediaDevices.getUserMedia(constraints);
					video.srcObject = stream;
					await video.play();
				} catch (e1) {
					try {
						const fb1 = { facingMode: facingPref };
						stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, fb1) });
						video.srcObject = stream;
						await video.play();
					} catch (e2) {
						const fb2 = {};
						stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: Object.assign({ width: { ideal: 1280 }, height: { ideal: 720 } }, fb2) });
						video.srcObject = stream;
						await video.play();
					}
				} finally {
					await enumerate();
					resizeCanvases();
					switching = false;
				}
			}
			async function enumerate() {
				try {
					const devs = await navigator.mediaDevices.enumerateDevices();
					const cams = devs.filter(d => d.kind === 'videoinput');

					function facingGuess(label) {
						const L = (label || '').toLowerCase();
						if (/(back|rear|environment)/.test(L)) return 'environment';
						if (/(front|user|face)/.test(L)) return 'user';
						return 'environment';
					}
					cameraSelect.innerHTML = '';
					cams.forEach((d, i) => {
						const opt = document.createElement('option');
						const fg = facingGuess(d.label || '');
						opt.value = d.deviceId || ('facing:' + fg + ':' + i);
						opt.textContent = d.label || ('Camera ' + (i + 1));
						opt.dataset.facing = fg;
						cameraSelect.appendChild(opt);
					});
					cameraSelect.disabled = cameraSelect.options.length <= 1;
					let activeId = '';
					try {
						if (stream) {
							const tracks = stream.getVideoTracks();
							if (tracks && tracks[0]) {
								const s = tracks[0].getSettings && tracks[0].getSettings();
								if (s && s.deviceId) activeId = s.deviceId;
							}
						}
					} catch (e) {}
					const hasVal = v => [].some.call(cameraSelect.options, o => o.value === v);
					let targetValue = '';
					if (activeId && hasVal(activeId)) { targetValue = activeId; } else if (lastDeviceId && hasVal(lastDeviceId)) { targetValue = lastDeviceId; } else {
						const optByFacing = [].find.call(cameraSelect.options, o => o.dataset && o.dataset.facing === facingPref);
						if (optByFacing) targetValue = optByFacing.value;
						else if (cameraSelect.options[0]) targetValue = cameraSelect.options[0].value;
					}
					if (targetValue) cameraSelect.value = targetValue;
				} catch (err) {
					console.error(err);
					showToast('Could not list cameras');
				}
			}

			function debounced(fn, ms) { let t = 0; return function() { const a = arguments;
					clearTimeout(t);
					t = setTimeout(() => fn.apply(null, a), ms); }; }
			const onCameraChange = debounced(async function() {
				const val = cameraSelect.value || '';
				if (val.indexOf('facing:') === 0) {
					const facing = val.split(':')[1] || facingPref;
					facingPref = facing;
					saveStr('lastFacing', facing);
					saveStr('lastDeviceId', '');
					await startCamera({ facingMode: facing });
				} else {
					saveStr('lastDeviceId', val);
					await startCamera({ deviceId: { exact: val } });
					const opt = [].slice.call(cameraSelect.options).find(o => o.value === val);
					if (opt && opt.dataset && opt.dataset.facing) { facingPref = opt.dataset.facing;
						saveStr('lastFacing', facingPref); }
				}
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
			}, 250);
			cameraSelect.addEventListener('change', onCameraChange);
			cameraSelect.addEventListener('input', onCameraChange);

			refreshBtn.addEventListener('click', async function() {
				if (switching) return;
				switching = true;
				try {
					try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch (e) {}
					await enumerate();
					const val = cameraSelect.value || '';
					if (val && val.indexOf('facing:') !== 0) { saveStr('lastDeviceId', val);
						await startCamera({ deviceId: { exact: val } }); } else { await startCamera({ facingMode: facingPref }); }
				} catch (e) { console.error(e);
					showToast('Refresh failed'); } finally { switching = false; }
			});

			/* ===== Coordinate helpers (zoom-aware positions) ===== */
			function canvasToCtxXY(clientX, clientY, canvas) {
				const rect = canvas.getBoundingClientRect();
				const baseW = canvas.width,
					baseH = canvas.height;
				const s = Z();
				let x = (clientX - rect.left - rect.width / 2) / s + baseW / 2;
				const y = (clientY - rect.top - rect.height / 2) / s + baseH / 2;
				if (isMirrored) x = baseW - x;
				if (!isFinite(x) || !isFinite(y)) return { x: 0, y: 0 };
				return { x, y };
			}

			function normPressure(p) { const v = isFinite(p) ? p : 1; return Math.max(0.2, Math.min(1, v)); }

			function getPrimaryPoint(e) {
				if (window.PointerEvent && e instanceof PointerEvent) return { x: e.clientX, y: e.clientY, id: e.pointerId, pressure: e.pressure };
				if (e.touches && e.touches[0]) { const t = e.touches[0]; return { x: t.clientX, y: t.clientY, id: 1, pressure: 1 }; }
				if (e.changedTouches && e.changedTouches[0]) { const t2 = e.changedTouches[0]; return { x: t2.clientX, y: t2.clientY, id: 1, pressure: 1 }; }
				if (e.clientX !== undefined) return { x: e.clientX, y: e.clientY, id: 1, pressure: 1 };
				return null;
			}
			let pointerIdActive = null;

			/* ===== Rendering annotations (sizes independent of zoom) ===== */
			function renderAnnotations() {
				const w = drawCanvas.width,
					h = drawCanvas.height;
				ctxDraw.clearRect(0, 0, w, h);
				const s = Z();

				for (let i = 0; i < objects.length; i++) {
					const obj = objects[i];
					if (obj.type === 'stroke') {
						const pts = obj.points;
						if (pts.length < 2) continue;
						ctxDraw.save();
						ctxDraw.strokeStyle = obj.color;
						ctxDraw.lineWidth = Math.max(1, obj.size / s);
						ctxDraw.lineCap = 'round';
						ctxDraw.lineJoin = 'round';
						ctxDraw.beginPath();
						ctxDraw.moveTo(pts[0].x, pts[0].y);
						for (let j = 1; j < pts.length; j++) ctxDraw.lineTo(pts[j].x, pts[j].y);
						ctxDraw.stroke();
						ctxDraw.restore();
					} else if (obj.type === 'text') {
						const effFontPx = Math.max(8, obj.baseFontPx / s);
						const m = measureTextBlock(obj.text, effFontPx);
						ctxDraw.save();
						ctxDraw.font = 'bold ' + effFontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
						ctxDraw.textBaseline = 'top';
						ctxDraw.fillStyle = obj.color;
						ctxDraw.lineWidth = Math.max(2, effFontPx * 0.12);
						ctxDraw.strokeStyle = 'rgba(0,0,0,0.55)';
						const lines = obj.text.split(/\r?\n/);
						lines.forEach((ln, li) => {
							const yy = obj.y + li * m.lh;
							ctxDraw.strokeText(ln, obj.x, yy);
							ctxDraw.fillText(ln, obj.x, yy);
						});
						ctxDraw.restore();
						obj._lastMeasured = { w: m.width, h: m.height, lh: m.lh, effFontPx };
					}
				}
			}

			function measureTextBlock(text, fontPx) {
				const lines = String(text).split(/\r?\n/);
				ctxDraw.save();
				ctxDraw.font = 'bold ' + fontPx + 'px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif';
				const widths = lines.map(ln => ctxDraw.measureText(ln).width);
				ctxDraw.restore();
				const lh = Math.round(fontPx * 1.25);
				let maxW = 1;
				for (let i = 0; i < widths.length; i++) { if (widths[i] > maxW) maxW = widths[i]; }
				return { width: maxW, height: lines.length * lh, lh };
			}

			function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
				const A = px - x1,
					B = py - y1,
					C = x2 - x1,
					D = y2 - y1;
				const dot = A * C + B * D;
				const lenSq = C * C + D * D || 1e-6;
				let t = dot / lenSq;
				t = Math.max(0, Math.min(1, t));
				const xx = x1 + t * C,
					yy = y1 + t * D;
				return Math.hypot(px - xx, py - yy);
			}

			function hitTestObject(px, py, tolScreenPx) {
				const s = Z();
				const tol = tolScreenPx / s;
				for (let i = objects.length - 1; i >= 0; i--) {
					const obj = objects[i];
					if (obj.type === 'text') {
						const effFontPx = Math.max(8, obj.baseFontPx / s);
						const m = obj._lastMeasured && obj._lastMeasured.effFontPx === effFontPx ?
							{ width: obj._lastMeasured.w, height: obj._lastMeasured.h } :
							measureTextBlock(obj.text, effFontPx);
						if (px >= obj.x && px <= obj.x + m.width && py >= obj.y && py <= obj.y + m.height) return i;
					} else if (obj.type === 'stroke') {
						const pts = obj.points;
						for (let j = 1; j < pts.length; j++) {
							if (pointToSegmentDistance(px, py, pts[j - 1].x, pts[j].x ? pts[j - 1].y : pts[j - 1].y, pts[j].x ? pts[j].y : pts[j].y) <= tol) return i;
						}
					}
				}
				return -1;
			}

			function startDraw(e) {
				if (overlayVisible) return;
				const p = getPrimaryPoint(e);
				if (!p) return;
				const pt = canvasToCtxXY(p.x, p.y, drawCanvas);
				const { x, y } = pt;
				pointerIdActive = p.id;

				if (eraserOn) {
					const idx = hitTestObject(x, y, Math.max(8, annotSize * 1.1));
					if (idx >= 0) { objects.splice(idx, 1);
						renderAnnotations(); }
					return;
				}
				if (annotationOn && !textModeOn) {
					currentStroke = { type: 'stroke', color: annotColor, size: Math.max(1, annotSize * normPressure(p.pressure)), points: [{ x, y }] };
					objects.push(currentStroke);
					renderAnnotations();
				}
			}

			function moveDraw(e) {
				if (overlayVisible) return;
				const p = getPrimaryPoint(e);
				if (!p) return;

				if (laserActive) {
					const ptL = canvasToCtxXY(p.x, p.y, laserCanvas);
					addTailPoint(ptL.x, ptL.y);
				}
				if (eraserOn && p.id === pointerIdActive) {
					const ptE = canvasToCtxXY(p.x, p.y, drawCanvas);
					const idx = hitTestObject(ptE.x, ptE.y, Math.max(8, annotSize * 1.1));
					if (idx >= 0) { objects.splice(idx, 1);
						renderAnnotations(); }
					return;
				}
				if (annotationOn && !textModeOn && p.id === pointerIdActive && currentStroke) {
					const ptA = canvasToCtxXY(p.x, p.y, drawCanvas);
					currentStroke.points.push({ x: ptA.x, y: ptA.y });
					currentStroke.size = Math.max(1, annotSize * normPressure(p.pressure));
					renderAnnotations();
				}
			}

			function endDraw() { pointerIdActive = null;
				currentStroke = null; }

			/* Laser trail */
			function addTailPoint(x, y) { tail.push({ x, y, life: 1 }); if (tail.length > 220) tail.shift(); }

			function renderLaser() {
				const w = laserCanvas.width,
					h = laserCanvas.height;
				ctxLaser.clearRect(0, 0, w, h);
				if (laserActive) {
					const rgb = hexToRgb(pointerColor);
					const r = rgb.r,
						g = rgb.g,
						b = rgb.b;
					const s = Z();
					for (let i = 0; i < tail.length; i++) {
						const t = tail[i];
						t.life *= 0.96;
						if (t.life < 0.02) continue;
						const a = t.life;
						const radius = (pointerSize / s) * (0.9 + 1.2 * a);
						const glow = radius * 2.2;
						const grad = ctxLaser.createRadialGradient(t.x, t.y, 0, t.x, t.y, glow);
						grad.addColorStop(0, 'rgba(' + r + ',' + g + ',' + b + ',' + (0.25 * a) + ')');
						grad.addColorStop(1, 'rgba(0,0,0,0)');
						ctxLaser.fillStyle = grad;
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, glow, 0, Math.PI * 2);
						ctxLaser.fill();
						ctxLaser.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + (0.85 * a) + ')';
						ctxLaser.beginPath();
						ctxLaser.arc(t.x, t.y, radius, 0, Math.PI * 2);
						ctxLaser.fill();
					}
				}
				for (let j = tail.length - 1; j >= 0; j--) { if (tail[j].life < 0.02) tail.splice(j, 1); }
				requestAnimationFrame(renderLaser);
			}

			function hexToRgb(hex) {
				const h = hex.replace('#', '');
				const b = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
				return { r: (b >> 16) & 255, g: (b >> 8) & 255, b: b & 255 };
			}

			/* Text overlay */
			let pendingTextXY = null;

			function showTextOverlayAt(clientX, clientY) {
				const rect = stage.getBoundingClientRect();
				textOverlay.style.display = 'block';
				const padding = 8;
				const overlayWidth = textOverlay.offsetWidth;
				const overlayHeight = textOverlay.offsetHeight;
				const maxX = Math.max(padding, rect.width - overlayWidth - padding);
				const maxY = Math.max(padding, rect.height - overlayHeight - padding);
				const x = Math.min(Math.max(clientX - rect.left, padding), maxX);
				const y = Math.min(Math.max(clientY - rect.top, padding), maxY);
				textOverlay.style.left = x + 'px';
				textOverlay.style.top = y + 'px';
				overlayVisible = true;
				textInput.value = '';
				textInput.focus();
			}

			function hideTextOverlay(keepMode) {
				keepMode = !!keepMode;
				textOverlay.style.display = 'none';
				overlayVisible = false;
				pendingTextXY = null;
				if (!keepMode) {
					textModeOn = false;
					textBtn.classList.toggle('active', false);
					textBtn.classList.toggle('primary', false);
					textBtn.classList.toggle('muted', true);
					updateInteractionMode();
				}
			}

			function placeTextObject(text, x, y) {
				if (!text) return;
				const baseFontPx = Math.round(10 + annotSize * 2);
				const obj = { type: 'text', x, y, text: String(text), color: annotColor, baseFontPx };
				objects.push(obj);
				renderAnnotations();
			}

			/* Wiring */
			liveToggle.addEventListener('change', () => setPaused(!liveToggle.checked));

			annotationBtn.addEventListener('click', () => {
				annotationOn = !annotationOn;
				eraserOn = false;
				textModeOn = false;
				hideTextOverlay();
				annotationBtn.classList.toggle('active', annotationOn);
				annotationBtn.classList.toggle('primary', annotationOn);
				annotationBtn.classList.toggle('muted', !annotationOn);
				eraserBtn.classList.remove('active', 'primary');
				eraserBtn.classList.add('muted');
				textBtn.classList.remove('active', 'primary');
				textBtn.classList.add('muted');
				updateInteractionMode();
			});
			eraserBtn.addEventListener('click', () => {
				eraserOn = !eraserOn;
				annotationOn = eraserOn ? true : annotationOn;
				textModeOn = false;
				hideTextOverlay();
				eraserBtn.classList.toggle('active', eraserOn);
				eraserBtn.classList.toggle('primary', eraserOn);
				eraserBtn.classList.toggle('muted', !eraserOn);
				annotationBtn.classList.toggle('active', annotationOn);
				annotationBtn.classList.toggle('primary', annotationOn);
				annotationBtn.classList.toggle('muted', !annotationOn);
				textBtn.classList.remove('active', 'primary');
				textBtn.classList.add('muted');
				updateInteractionMode();
			});
			textBtn.addEventListener('click', () => {
				annotationOn = true;
				eraserOn = false;
				textModeOn = !textModeOn;
				hideTextOverlay(textModeOn);
				annotationBtn.classList.add('active', 'primary');
				annotationBtn.classList.remove('muted');
				eraserBtn.classList.remove('active', 'primary');
				eraserBtn.classList.add('muted');
				textBtn.classList.toggle('active', textModeOn);
				textBtn.classList.toggle('primary', textModeOn);
				textBtn.classList.toggle('muted', !textModeOn);
				if (textModeOn) showToast('Tap where you want the text.');
				updateInteractionMode();
			});
			clearBtn.addEventListener('click', () => { objects.length = 0;
				renderAnnotations(); });

			function refreshPickerColors() {
				[].slice.call(sizeUI.pointer.children).forEach(btn => btn.style.setProperty('--dot-color', pointerColor));
				[].slice.call(sizeUI.annot.children).forEach(btn => btn.style.setProperty('--dot-color', annotColor));
			}
			pointerColorInput.addEventListener('input', (e) => { pointerColor = e.target.value;
				paintLabelBtn(pointerLabelBtn, pointerColor);
				refreshPickerColors(); });
			annotColorInput.addEventListener('input', (e) => { annotColor = e.target.value;
				paintLabelBtn(annotLabelBtn, annotColor);
				refreshPickerColors(); });

			function buildSizePicker(container, sizes, getColor, currentSize, onPick) {
				container.innerHTML = '';
				sizes.forEach(sz => {
					const btn = document.createElement('button');
					btn.type = 'button';
					btn.className = 'dotBtn';
					btn.style.setProperty('--dot', sz + 'px');
					btn.style.setProperty('--dot-color', getColor());
					if (currentSize === sz) btn.classList.add('active');
					const dot = document.createElement('span');
					dot.className = 'dot';
					btn.appendChild(dot);
					btn.addEventListener('click', () => {
						[].slice.call(container.children).forEach(c => c.classList.remove('active'));
						btn.classList.add('active');
						onPick(sz);
					});
					container.appendChild(btn);
				});
			}

			/* Zoom + mirror + fit */
			function applyTransforms() {
				const s = Z();
				const mirror = isMirrored ? 'scaleX(-1) ' : '';
				[drawCanvas, laserCanvas, freezeCanvas].forEach(el => {
					el.style.transformOrigin = 'center center';
					el.style.transform = mirror + 'scale(' + s + ')';
				});
				video.style.transformOrigin = 'center center';
				video.style.transform = mirror + 'scale(' + s + ')';
				applyFitMode(); // ensure objectFit is applied whenever transforms update
			}

			function applyFitMode() {
				// This is the fix: apply the chosen mode to the live video element
				video.style.objectFit = fitMode; // 'contain' or 'cover'
			}

			document.getElementById('mirrorBtn').addEventListener('click', () => {
				isMirrored = !isMirrored;
				applyTransforms();
				if (isPaused && hasFrozen) drawFreezeFromFrozen();
				showToast(isMirrored ? 'Mirrored' : 'Unmirrored');
			});
			document.getElementById('fitBtn').addEventListener('click', () => {
				fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
				fitBtn.textContent = (fitMode === 'cover') ? 'Fit' : 'Fill';
				applyFitMode();
				// Redraw paused frame to match the new mode
				if (isPaused) { captureFrozenFromVideo();
					drawFreezeFromFrozen(); }
				showToast(fitMode === 'cover' ? 'Fill mode' : 'Fit mode');
			});

			function setZoom(v) {
				zoomLevel = Math.max(1, Math.min(3, v || 1));
				saveNum('zoomLevel', zoomLevel);
				zoomSlider.value = String(zoomLevel);
				zoomVal.textContent = zoomLevel.toFixed(1) + '×';
				applyTransforms();
				renderAnnotations();
			}
			zoomSlider.addEventListener('input', e => setZoom(parseFloat(e.target.value)));

			/* Stage events */
			const target = stage;

			function touchGuard(e) { if (overlayVisible && e.target.closest('#textOverlay')) return;
				e.preventDefault(); }
			['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(ev => target.addEventListener(ev, touchGuard, { passive: false }));

			target.addEventListener('pointerdown', e => {
				if (annotationOn && textModeOn && !overlayVisible) {
					const pt = canvasToCtxXY(e.clientX, e.clientY, drawCanvas);
					pendingTextXY = { x: pt.x, y: pt.y };
					showTextOverlayAt(e.clientX, e.clientY);
					return;
				}
				startDraw(e);
			});
			target.addEventListener('pointermove', moveDraw);
			target.addEventListener('pointerup', endDraw);
			target.addEventListener('pointercancel', endDraw);
			target.addEventListener('pointerout', endDraw);
			target.addEventListener('pointerleave', endDraw);

			/* Text overlay actions */
			textAdd.addEventListener('click', () => { if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
				hideTextOverlay(); });
			textCancel.addEventListener('click', () => { hideTextOverlay(); });
			textInput.addEventListener('keydown', e => {
				if (e.key === 'Escape') { e.preventDefault();
					hideTextOverlay(); }
				if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') { e.preventDefault(); if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y);
					hideTextOverlay(); }
			});

			/* Snapshot */
			screenshotBtn.addEventListener('click', () => {
				const w = freezeCanvas.width,
					h = freezeCanvas.height;
				if (w === 0 || h === 0) { showToast('Snapshot failed: canvas not ready'); return; }
				const out = document.createElement('canvas');
				out.width = w;
				out.height = h;
				const octx = out.getContext('2d');

				if (isPaused && hasFrozen) {
					octx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					const vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						const cr = w / h,
							vr = vw / vh;
						let dw, dh, dx, dy;
						if (fitMode === 'cover') { if (vr > cr) { dh = h;
								dw = h * vr; } else { dw = w;
								dh = w / vr; } dx = (w - dw) / 2;
							dy = (h - dh) / 2; } else { if (vr > cr) { dw = w;
								dh = w / vr; } else { dh = h;
								dw = h * vr; } dx = (w - dw) / 2;
							dy = (h - dh) / 2; }
						octx.save();
						if (isMirrored) { octx.translate(w, 0);
							octx.scale(-1, 1);
							dx = w - dx - dw; }
						octx.drawImage(video, dx, dy, dw, dh);
						octx.restore();
					}
				}
				if (isMirrored) {
					octx.save();
					octx.translate(w, 0);
					octx.scale(-1, 1);
					octx.drawImage(drawCanvas, 0, 0);
					octx.drawImage(laserCanvas, 0, 0);
					octx.restore();
				} else {
					octx.drawImage(drawCanvas, 0, 0);
					octx.drawImage(laserCanvas, 0, 0);
				}
				out.toBlob(blob => {
					if (!blob) { showToast('Snapshot failed'); return; }
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = 'snapshot_' + new Date().toISOString().replace(/[:.]/g, '-') + '.png';
					document.body.appendChild(a);
					a.click();
					a.remove();
					URL.revokeObjectURL(url);
					showToast('Snapshot saved');
				});
			});

			/* Recording */
			function drawCompositeFrame() {
				const w = composite.width,
					h = composite.height;
				compositeCtx.clearRect(0, 0, w, h);
				if (isPaused && hasFrozen) {
					compositeCtx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
				} else {
					const vw = video.videoWidth,
						vh = video.videoHeight;
					if (vw && vh) {
						const cr = w / h,
							vr = vw / vh;
						let dw, dh, dx, dy;
						if (fitMode === 'cover') { if (vr > cr) { dh = h;
								dw = h * vr; } else { dw = w;
								dh = w / vr; } dx = (w - dw) / 2;
							dy = (h - dh) / 2; } else { if (vr > cr) { dw = w;
								dh = w / vr; } else { dh = h;
								dw = h * vr; } dx = (w - dw) / 2;
							dy = (h - dh) / 2; }
						compositeCtx.save();
						if (isMirrored) { compositeCtx.translate(w, 0);
							compositeCtx.scale(-1, 1);
							dx = w - dx - dw; }
						compositeCtx.drawImage(video, dx, dy, dw, dh);
						compositeCtx.restore();
					}
				}
				if (isMirrored) {
					compositeCtx.save();
					compositeCtx.translate(w, 0);
					compositeCtx.scale(-1, 1);
					compositeCtx.drawImage(drawCanvas, 0, 0);
					compositeCtx.drawImage(laserCanvas, 0, 0);
					compositeCtx.restore();
				} else {
					compositeCtx.drawImage(drawCanvas, 0, 0);
					compositeCtx.drawImage(laserCanvas, 0, 0);
				}
				if (recording) requestAnimationFrame(drawCompositeFrame);
			}

			function getSupportedMime() {
				const prefs = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4;codecs=avc1.42E01E,mp4a.40.2'];
				for (let i = 0; i < prefs.length; i++) { if (MediaRecorder.isTypeSupported(prefs[i])) return prefs[i]; }
				return '';
			}
			recordBtn.addEventListener('click', () => {
				if (!recording) {
					composite.width = freezeCanvas.width;
					composite.height = freezeCanvas.height;
					const mime = getSupportedMime();
					const s = composite.captureStream(30);
					try { mediaRecorder = new MediaRecorder(s, mime ? { mimeType: mime } : {}) } catch (e) { showToast('Recording not supported'); return; }
					recChunks = [];
					mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) recChunks.push(e.data); };
					mediaRecorder.onstop = () => {
						const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'video/webm' });
						const url = URL.createObjectURL(blob);
						const a = document.createElement('a');
						a.href = url;
						a.download = 'recording_' + new Date().toISOString().replace(/[:.]/g, '-') + '.webm';
						document.body.appendChild(a);
						a.click();
						a.remove();
						URL.revokeObjectURL(url);
						showToast('Recording saved');
					};
					mediaRecorder.start(120);
					recording = true;
					recordBtn.textContent = 'Stop';
					recordBtn.classList.add('danger');
					drawCompositeFrame();
					showToast('Recording started');
				} else {
					recording = false;
					try { mediaRecorder.stop(); } catch (e) {}
					recordBtn.textContent = 'Record';
					recordBtn.classList.remove('danger');
				}
			});

			/* Init */
			const ro = new ResizeObserver(() => { resizeCanvases(); });
			ro.observe(stage);
			window.addEventListener('orientationchange', () => { setTimeout(resizeCanvases, 200); });
			requestAnimationFrame(renderLaser);

			(async function init() {
				if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { showToast('getUserMedia not supported'); return; }
				await enumerate();

				let chosen = '';
				if (lastDeviceId && [].some.call(cameraSelect.options, o => o.value === lastDeviceId)) chosen = lastDeviceId;
				if (chosen) await startCamera({ deviceId: { exact: chosen } });
				else await startCamera({ facingMode: facingPref });

				isPaused = false;
				updateStatusUI();

				buildSizePicker(sizeUI.pointer, SIZESET, () => pointerColor, pointerSize, (sz) => { pointerSize = sz;
					saveNum('pointerSize', sz); });
				buildSizePicker(sizeUI.annot, SIZESET, () => annotColor, annotSize, (sz) => { annotSize = sz;
					saveNum('annotSize', sz); });
				[].slice.call(sizeUI.pointer.children).forEach(btn => btn.style.setProperty('--dot-color', pointerColor));
				[].slice.call(sizeUI.annot.children).forEach(btn => btn.style.setProperty('--dot-color', annotColor));

				function paintLabelBtn(btn, color) {
					let h = color.replace('#', '');
					if (h.length === 3) h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
					const r = parseInt(h.slice(0, 2), 16),
						g = parseInt(h.slice(2, 4), 16),
						b = parseInt(h.slice(4, 6), 16);
					const yiq = (r * 299 + g * 587 + b * 114) / 1000;
					btn.style.background = color;
					btn.style.borderColor = 'rgba(255,255,255,.25)';
					btn.style.color = (yiq >= 160 ? '#111' : '#fff');
				}
				paintLabelBtn(pointerLabelBtn, pointerColor);
				paintLabelBtn(annotLabelBtn, annotColor);

				setZoom(zoomLevel);
				applyFitMode(); // ensure initial live mode matches fitMode
				resizeCanvases();
			})();
		})();
	</script>

	<footer>
		&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

</html>
