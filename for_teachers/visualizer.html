<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera Visualizer</title>

  <style>
    :root {
      --bg: #0f1117;
      --panel: #161a22;
      --text: #e6e6e6;
      --accent: #4da3ff;
      --muted: #8b93a7;
      --danger: #ff5d5d;
      --good: #00d27a;
      --warn: #ffb020;
    }

    html,
    body {
      height: 100%;
      margin: 0
    }

    body {
      background: linear-gradient(180deg, #0d0f14, #0f1117 60%, #0b0d12);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
      display: flex;
      flex-direction: column;
      gap: .8rem;
    }

    /* ===== PanPhy top banner ===== */
    .topbar {
      background: #333;
      color: #fff;
      position: relative;
      text-align: center;
      padding: 10px 20px;
      border-bottom: 1px solid #000;
    }

    .topbar .logo {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 6px
    }

    .topbar .logo img {
      height: 30px
    }

    .topbar .title {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: .2px
    }

    header {
      padding: .6rem .9rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: .6rem;
      background: rgba(0, 0, 0, .25);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid rgba(255, 255, 255, .06);
    }

    .group {
      display: flex;
      align-items: center;
      gap: .5rem;
      background: var(--panel);
      padding: .45rem .55rem;
      border-radius: .6rem;
      border: 1px solid rgba(255, 255, 255, .06);
      flex-wrap: wrap
    }

    .group h4 {
      margin: 0 .35rem 0 0;
      font-size: .85rem;
      font-weight: 600;
      color: #cfd5e4
    }

    label {
      font-size: .9rem;
      color: var(--muted)
    }

    select,
    input[type=color],
    input[type=range],
    button {
      background: #0e121a;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: .45rem;
      padding: .35rem .5rem;
      font-size: .95rem;
      outline: none
    }

    select {
      max-width: 38vw
    }

    button {
      cursor: pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease
    }

    button:hover {
      transform: translateY(-1px)
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed;
      transform: none
    }

    .primary {
      background: var(--accent);
      border-color: #9acbff;
      color: #061423
    }

    .danger {
      background: var(--danger);
      border-color: #ffc4c4;
      color: #2a0000
    }

    .muted {
      background: #0e121a;
      color: var(--muted)
    }

    .active {
      box-shadow: 0 0 0 2px #9acbff inset
    }

    .spacer {
      flex: 1
    }

    #stage {
      position: relative;
      flex: 1;
      min-height: 45vh;
      margin: 0 .9rem .9rem;
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 12px;
      overflow: hidden;
      background: #000
    }

    video,
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      touch-action: none
    }

    video {
      object-fit: contain;
      background: #000
    }

    #hud {
      position: absolute;
      right: .6rem;
      bottom: .6rem;
      font-size: .85rem;
      color: #cfd5e4;
      background: rgba(0, 0, 0, .4);
      padding: .25rem .5rem;
      border-radius: .4rem;
      border: 1px solid rgba(255, 255, 255, .08)
    }

    #statusDot {
      display: inline-block;
      width: .55rem;
      height: .55rem;
      border-radius: 50%;
      background: var(--good);
      margin-right: .4rem
    }

    .paused #statusDot {
      background: var(--warn)
    }

    .hidden {
      display: none !important
    }

    #toast {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 1rem;
      background: rgba(0, 0, 0, .75);
      color: #fff;
      padding: .5rem .75rem;
      border-radius: .5rem;
      border: 1px solid rgba(255, 255, 255, .12);
      font-size: .9rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s
    }

    #toast.show {
      opacity: 1
    }

    .switch {
      position: relative;
      width: 56px;
      height: 30px;
      display: inline-block
    }

    .switch input {
      display: none
    }

    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #293040;
      border-radius: 999px;
      transition: .2s;
      border: 1px solid rgba(255, 255, 255, .12)
    }

    .slider:before {
      content: "";
      position: absolute;
      height: 24px;
      width: 24px;
      left: 3px;
      top: 2px;
      background: #fff;
      border-radius: 50%;
      transition: .2s
    }

    input:checked+.slider {
      background: #1f6bff
    }

    input:checked+.slider:before {
      transform: translateX(26px)
    }

    .statusLightWrap {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .2rem .4rem
    }

    .statusLight {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, .15);
      box-shadow: 0 0 10px rgba(0, 0, 0, .3) inset, 0 0 8px rgba(0, 0, 0, .15)
    }

    .light-live {
      background: var(--good)
    }

    .light-paused {
      background: var(--warn)
    }

    .statusText {
      font-size: .9rem;
      color: #cfd5e4;
      min-width: 52px
    }

    .vsep {
      width: 1px;
      height: 24px;
      background: rgba(255, 255, 255, .08);
      margin: 0 .25rem
    }

    /* Transparent text overlay */
    #textOverlay {
      position: absolute;
      display: none;
      z-index: 20;
      background: rgba(20, 22, 28, .2);
      border: 1px dashed rgba(255, 255, 255, .5);
      border-radius: .6rem;
      padding: .5rem;
      box-shadow: 0 6px 18px rgba(0, 0, 0, .15)
    }

    #textOverlay textarea {
      width: 280px;
      max-width: 60vw;
      min-height: 80px;
      background: transparent;
      color: #fff;
      border: 1px dashed rgba(255, 255, 255, .35);
      border-radius: .4rem;
      padding: .45rem;
      font-size: 16px;
      outline: none
    }

    #textActions {
      display: flex;
      gap: .5rem;
      justify-content: flex-end;
      margin-top: .5rem
    }

    /* Fixed width for Fit/Fill button */
    .fixed-width-btn {
      width: 72px;
      text-align: center
    }
  </style>
</head>

<body>
  <!-- PanPhy banner -->
  <div class="topbar">
    <div class="logo">
      <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer" title="PanPhy">
        <img src="/panphy.png" alt="PanPhy logo">
      </a>
    </div>
    <div class="title">Camera Visualizer</div>
  </div>

  <header>
    <div class="group">
      <h4>Camera</h4>
      <select id="cameraSelect" title="Choose camera"></select>
      <button id="refreshBtn" title="Refresh device list">Refresh</button>
    </div>

    <div class="group">
      <h4>Stream</h4>
      <label class="switch" title="Toggle Live / Paused">
        <input id="liveToggle" type="checkbox" checked />
        <span class="slider"></span>
      </label>
      <span class="vsep"></span>
      <div class="statusLightWrap" aria-live="polite" aria-atomic="true">
        <span id="statusLight" class="statusLight light-live"></span>
        <span id="statusLabel" class="statusText">Live</span>
      </div>
    </div>

    <div class="group">
      <h4>Pointer</h4>
      <input id="pointerColor" type="color" value="#ff3b3b" title="Pointer color" />
      <label for="pointerSize">Size</label>
      <input id="pointerSize" type="range" min="2" max="30" step="1" value="10" title="Pointer size" />
    </div>

    <div class="group" id="annotGroup">
      <h4>Annotate</h4>
      <input id="annotColor" type="color" value="#33d17a" title="Annotation color" />
      <label for="annotSize">Size</label>
      <input id="annotSize" type="range" min="2" max="30" step="1" value="8" title="Annotation size" />
      <button id="annotationBtn" class="muted" title="Freehand drawing">Annotation</button>
      <button id="eraserBtn" class="muted" title="Object eraser">Eraser</button>
      <button id="textBtn" class="muted" title="Typed text">Text</button>
      <button id="clearBtn" class="danger" title="Clear annotations">Clear</button>
    </div>

    <div class="spacer"></div>
    <div class="group">
      <button id="screenshotBtn" title="Save snapshot with annotations">Snapshot</button>
      <button id="recordBtn" title="Record/Stop recording the view">Record</button>
      <button id="mirrorBtn" title="Toggle mirror">Mirror</button>
      <button id="fitBtn" class="fixed-width-btn" title="Fit or Fill">Fill</button>
    </div>
  </header>

  <main id="stage">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="freezeCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
    <canvas id="laserCanvas"></canvas>
    <div id="hud"><span id="statusDot"></span><span id="hudText">Live</span></div>

    <div id="textOverlay">
      <textarea id="textInput" placeholder="Type your note..."></textarea>
      <div id="textActions">
        <button id="textCancel">Cancel</button>
        <button id="textAdd" class="primary">Add</button>
      </div>
    </div>
  </main>

  <div id="toast" role="status" aria-live="polite"></div>

  <script>
    (() => {
      const video = document.getElementById('video');
      const freezeCanvas = document.getElementById('freezeCanvas');
      const drawCanvas = document.getElementById('drawCanvas');
      const laserCanvas = document.getElementById('laserCanvas');
      const ctxFreeze = freezeCanvas.getContext('2d');
      const ctxDraw = drawCanvas.getContext('2d');
      const ctxLaser = laserCanvas.getContext('2d');

      const cameraSelect = document.getElementById('cameraSelect');
      const refreshBtn = document.getElementById('refreshBtn');

      const liveToggle = document.getElementById('liveToggle');
      const annotationBtn = document.getElementById('annotationBtn');
      const eraserBtn = document.getElementById('eraserBtn');
      const textBtn = document.getElementById('textBtn');

      const statusLight = document.getElementById('statusLight');
      const statusLabel = document.getElementById('statusLabel');

      const clearBtn = document.getElementById('clearBtn');
      const pointerColorEl = document.getElementById('pointerColor');
      const pointerSizeEl = document.getElementById('pointerSize');
      const annotColorEl = document.getElementById('annotColor');
      const annotSizeEl = document.getElementById('annotSize');
      const screenshotBtn = document.getElementById('screenshotBtn');
      const recordBtn = document.getElementById('recordBtn');
      const mirrorBtn = document.getElementById('mirrorBtn');
      const fitBtn = document.getElementById('fitBtn');
      const hudText = document.getElementById('hudText');
      const stage = document.getElementById('stage');
      const toast = document.getElementById('toast');

      const textOverlay = document.getElementById('textOverlay');
      const textInput = document.getElementById('textInput');
      const textAdd = document.getElementById('textAdd');
      const textCancel = document.getElementById('textCancel');

      /* ===== Persistent settings ===== */
      function saveStr(k, v) { try { localStorage.setItem(k, v == null ? '' : String(v)); } catch (_) { } }
      function loadStr(k, f) { try { const v = localStorage.getItem(k); return v === null ? f : v; } catch (_) { return f; } }
      function saveNum(k, v) { try { localStorage.setItem(k, String(v)); } catch (_) { } }
      function loadNum(k, f) { try { const v = localStorage.getItem(k); const n = v !== null ? Number(v) : NaN; return Number.isFinite(n) ? n : f; } catch (_) { return f; } }

      let pointerColor = pointerColorEl.value;
      let pointerSize = loadNum('pointerSize', parseInt(pointerSizeEl.value, 10)); pointerSizeEl.value = pointerSize;
      let annotColor = annotColorEl.value;
      let annotSize = loadNum('annotSize', parseInt(annotSizeEl.value, 10)); annotSizeEl.value = annotSize;

      /* ===== App state ===== */
      let isPaused = false;
      let isMirrored = false;
      let fitMode = 'contain'; // 'contain' or 'cover'
      let annotationOn = false;
      let eraserOn = false;
      let textModeOn = false;
      let overlayVisible = false;

      // Camera
      let devicesCache = [];
      let currentDeviceId = loadStr('lastDeviceId', null);
      let facingPref = loadStr('lastFacing', 'environment');
      let stream = null;
      let lastGoodConstraint = null;
      let switching = false;

      // Laser tail
      const tail = [];
      let laserActive = true;

      // Frozen frame persistence
      const frozen = document.createElement('canvas');
      const frozenCtx = frozen.getContext('2d');
      let hasFrozen = false;

      // Annotation objects
      const objects = []; // stroke/text objects
      let currentStroke = null;

      // Recording (composited canvas)
      const composite = document.createElement('canvas');
      const compositeCtx = composite.getContext('2d');
      let recording = false;
      let mediaRecorder = null;
      let recChunks = [];

      /* ===== Helpers ===== */
      function showToast(msg, ms = 1600) { toast.textContent = msg; toast.classList.add('show'); setTimeout(() => toast.classList.remove('show'), ms); }
      function humanizeError(e) { if (!e) return 'Unknown error'; if (e.name) return e.name + (e.message ? `: ${e.message}` : ''); try { return JSON.stringify(e); } catch (_) { return String(e); } }
      function logError(prefix, e) { console.warn(prefix + ': ' + humanizeError(e)); }
      function stopStream() { if (stream) { try { stream.getTracks().forEach(t => t.stop()); } catch (_) { } stream = null; } }

      function applyVideoStyle() { video.style.objectFit = (fitMode === 'cover') ? 'cover' : 'contain'; video.style.transform = isMirrored ? 'scaleX(-1)' : 'none'; }

      function resizeCanvases() {
        const r = stage.getBoundingClientRect();
        [freezeCanvas, drawCanvas, laserCanvas, composite].forEach(c => { c.width = Math.floor(r.width); c.height = Math.floor(r.height); });
        applyVideoStyle();
        if (isPaused && hasFrozen) drawFreezeFromFrozen();
        renderAnnotations();
      }

      function updateStatusUI() {
        stage.classList.toggle('paused', isPaused);
        hudText.textContent = isPaused ? 'Paused' : 'Live';
        statusLabel.textContent = isPaused ? 'Paused' : 'Live';
        statusLight.classList.toggle('light-paused', isPaused);
        statusLight.classList.toggle('light-live', !isPaused);
        // Fit/Fill only in Live mode
        fitBtn.disabled = isPaused;
      }

      function updateInteractionMode() {
        const anyAnnotation = annotationOn || eraserOn || textModeOn;
        laserActive = !anyAnnotation;
        if (!laserActive) { ctxLaser.clearRect(0, 0, laserCanvas.width, laserCanvas.height); tail.length = 0; }
      }

      function captureFrozenFromVideo() {
        const w = freezeCanvas.width, h = freezeCanvas.height;
        if (!video.videoWidth || w === 0 || h === 0) return;
        frozen.width = w; frozen.height = h;
        const vw = video.videoWidth, vh = video.videoHeight;
        const cr = w / h, vr = vw / vh;
        let dw, dh, dx, dy;
        if (fitMode === 'cover') { if (vr > cr) { dh = h; dw = h * vr; } else { dw = w; dh = w / vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
        else { if (vr > cr) { dw = w; dh = w / vr; } else { dh = h; dw = h * vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
        frozenCtx.save();
        if (isMirrored) { frozenCtx.translate(w, 0); frozenCtx.scale(-1, 1); dx = w - dx - dw; }
        frozenCtx.clearRect(0, 0, w, h);
        frozenCtx.drawImage(video, dx, dy, dw, dh);
        frozenCtx.restore();
        hasFrozen = true;
      }

      function drawFreezeFromFrozen() {
        if (!hasFrozen) return;
        const w = freezeCanvas.width, h = freezeCanvas.height;
        ctxFreeze.clearRect(0, 0, w, h);
        ctxFreeze.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
        freezeCanvas.classList.remove('hidden');
      }

      function setPaused(state) {
        const prev = isPaused;
        isPaused = state;
        if (liveToggle.checked === isPaused) liveToggle.checked = !isPaused; // checked means Live
        updateStatusUI();
        if (isPaused) {
          if (!prev) { captureFrozenFromVideo(); }
          drawFreezeFromFrozen();
        } else {
          hasFrozen = false;
          hideTextOverlay(); // fully exit text mode when resuming live
          freezeCanvas.classList.add('hidden');
        }
      }

      /* ===== Camera start with fallbacks ===== */
      async function startCamera(constraint) {
        if (switching) return;
        switching = true;
        const prevStream = stream;
        const prevConstraint = lastGoodConstraint;

        try {
          stopStream();
          const constraints = { audio: false, video: { ...constraint, width: { ideal: 1280 }, height: { ideal: 720 } } };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          await video.play();
          lastGoodConstraint = constraint;
          await enumerate();
          resizeCanvases();
          switching = false;
          return true;
        } catch (e1) {
          logError('getUserMedia failed (primary)', e1);
          try {
            const facing = (constraint && constraint.deviceId) ? (cameraSelect.selectedOptions[0]?.dataset?.facing || facingPref || 'environment') : facingPref;
            const fb1 = { facingMode: facing };
            const c2 = { audio: false, video: { ...fb1, width: { ideal: 1280 }, height: { ideal: 720 } } };
            stream = await navigator.mediaDevices.getUserMedia(c2);
            video.srcObject = stream; await video.play();
            lastGoodConstraint = fb1; await enumerate(); resizeCanvases(); switching = false; return true;
          } catch (e2) {
            logError('getUserMedia failed (fallback facingMode)', e2);
            try {
              const fb2 = {};
              const c3 = { audio: false, video: { ...fb2, width: { ideal: 1280 }, height: { ideal: 720 } } };
              stream = await navigator.mediaDevices.getUserMedia(c3);
              video.srcObject = stream; await video.play();
              lastGoodConstraint = fb2; await enumerate(); resizeCanvases(); switching = false; return true;
            } catch (e3) {
              logError('getUserMedia failed (generic)', e3);
              switching = false;
              if (prevStream) {
                try { stream = prevStream; video.srcObject = stream; await video.play(); lastGoodConstraint = prevConstraint; resizeCanvases(); showToast('Reverted to previous camera.'); return false; } catch (_) { }
              }
              showToast('Camera start failed: ' + humanizeError(e3));
              return false;
            }
          }
        }
      }

      async function enumerate() {
        const devs = await navigator.mediaDevices.enumerateDevices();
        const cams = devs.filter(d => d.kind === 'videoinput');
        const guessFacing = (label = '') => {
          const L = (label || '').toLowerCase();
          if (/(back|rear|environment)/.test(L)) return 'environment';
          if (/(front|user|face)/.test(L)) return 'user';
          return 'environment';
        };
        devicesCache = cams.map((d, i) => ({ deviceId: d.deviceId || '', label: d.label || `Camera ${i + 1}`, facingGuess: guessFacing(d.label || '') }));
        cameraSelect.innerHTML = '';
        devicesCache.forEach((cam, i) => {
          const opt = document.createElement('option');
          opt.value = cam.deviceId || `facing:${cam.facingGuess}:${i}`;
          opt.textContent = cam.label;
          opt.dataset.facing = cam.facingGuess;
          cameraSelect.appendChild(opt);
        });
        let selected = null;
        if (currentDeviceId) selected = [...cameraSelect.options].find(o => o.value === currentDeviceId);
        if (!selected) selected = [...cameraSelect.options].find(o => (o.dataset.facing || '') === facingPref) || cameraSelect.options[0];
        if (selected) cameraSelect.value = selected.value;
        cameraSelect.disabled = cameraSelect.options.length <= 1;
      }

      async function listCameras() { try { await enumerate(); } catch (e) { logError('enumerateDevices', e); showToast('Could not list cameras'); } }

      function debounced(fn, ms = 250) { let t = null; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

      const onCameraChange = debounced(async () => {
        const val = cameraSelect.value || '';
        currentDeviceId = val; saveStr('lastDeviceId', currentDeviceId);
        if (val.startsWith('facing:')) {
          const facing = val.split(':')[1] || facingPref; facingPref = facing; saveStr('lastFacing', facingPref);
          await startCamera({ facingMode: facingPref });
        } else {
          await startCamera({ deviceId: { exact: val } });
          const opt = [...cameraSelect.options].find(o => o.value === val);
          if (opt?.dataset?.facing) { facingPref = opt.dataset.facing; saveStr('lastFacing', facingPref); }
        }
        if (isPaused && hasFrozen) { drawFreezeFromFrozen(); }
      }, 250);

      cameraSelect.addEventListener('change', onCameraChange);
      cameraSelect.addEventListener('input', onCameraChange);
      refreshBtn.addEventListener('click', listCameras);

      navigator.mediaDevices?.addEventListener?.('devicechange', async () => {
        await listCameras();
        if (!stream || stream.getVideoTracks().every(t => t.readyState !== 'live')) {
          await startCamera(lastGoodConstraint || { facingMode: facingPref });
          if (isPaused && hasFrozen) drawFreezeFromFrozen();
        }
      });
      document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'visible' && (!video.srcObject || video.readyState < 2)) {
          await startCamera(lastGoodConstraint || { facingMode: facingPref });
          if (isPaused && hasFrozen) drawFreezeFromFrozen();
        }
      });

      /* ===== Annotations (objects) ===== */
      function renderAnnotations() {
        const w = drawCanvas.width, h = drawCanvas.height;
        ctxDraw.clearRect(0, 0, w, h);
        for (const obj of objects) {
          if (obj.type === 'stroke') {
            const pts = obj.points;
            if (pts.length < 2) continue;
            ctxDraw.save();
            ctxDraw.strokeStyle = obj.color;
            ctxDraw.lineWidth = obj.size;
            ctxDraw.lineCap = 'round'; ctxDraw.lineJoin = 'round';
            ctxDraw.beginPath();
            ctxDraw.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctxDraw.lineTo(pts[i].x, pts[i].y);
            ctxDraw.stroke();
            ctxDraw.restore();
          } else if (obj.type === 'text') {
            ctxDraw.save();
            ctxDraw.font = `bold ${obj.fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif`;
            ctxDraw.textBaseline = 'top';
            ctxDraw.fillStyle = obj.color;
            ctxDraw.lineWidth = Math.max(2, obj.fontPx * 0.12);
            ctxDraw.strokeStyle = 'rgba(0,0,0,0.55)';
            const lines = obj.text.split(/\r?\n/);
            lines.forEach((ln, i) => { const yy = obj.y + i * obj.lh; ctxDraw.strokeText(ln, obj.x, yy); ctxDraw.fillText(ln, obj.x, yy); });
            ctxDraw.restore();
          }
        }
      }

      function measureTextBlock(text, fontPx) {
        const lines = String(text).split(/\r?\n/);
        ctxDraw.save();
        ctxDraw.font = `bold ${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif`;
        const widths = lines.map(ln => ctxDraw.measureText(ln).width);
        ctxDraw.restore();
        const lh = Math.round(fontPx * 1.25);
        return { width: Math.max(1, ...widths, 1), height: lines.length * lh, lh };
      }

      function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D || 1e-6;
        let t = dot / lenSq; t = Math.max(0, Math.min(1, t));
        const xx = x1 + t * C, yy = y1 + t * D;
        const dx = px - xx, dy = py - yy;
        return Math.hypot(dx, dy);
      }

      function hitTestObject(px, py, tolerance) {
        for (let i = objects.length - 1; i >= 0; i--) {
          const obj = objects[i];
          if (obj.type === 'text') {
            if (px >= obj.x && px <= obj.x + obj.width && py >= obj.y && py <= obj.y + obj.height) {
              return i;
            }
          } else if (obj.type === 'stroke') {
            const pts = obj.points;
            for (let j = 1; j < pts.length; j++) {
              if (pointToSegmentDistance(px, py, pts[j - 1].x, pts[j - 1].y, pts[j].x, pts[j].y) <= tolerance) {
                return i;
              }
            }
          }
        }
        return -1;
      }

      /* ===== Interaction & drawing ===== */
      function canvasToCtxXY(clientX, clientY, canvas) { const r = canvas.getBoundingClientRect(); return { x: clientX - r.left, y: clientY - r.top }; }
      function normPressure(p) { const v = Number.isFinite(p) ? p : 1; return Math.max(0.2, Math.min(1, v)); }
      function getPrimaryPoint(e) {
        if (e instanceof PointerEvent) return { x: e.clientX, y: e.clientY, id: e.pointerId, pressure: e.pressure };
        if (e.touches && e.touches[0]) { const t = e.touches[0]; return { x: t.clientX, y: t.clientY, id: 1, pressure: 1 }; }
        if (e.changedTouches && e.changedTouches[0]) { const t = e.changedTouches[0]; return { x: t.clientX, y: t.clientY, id: 1, pressure: 1 }; }
        if (e.clientX !== undefined) return { x: e.clientX, y: e.clientY, id: 1, pressure: 1 };
        return null;
      }

      let pointerIdActive = null;

      function startDraw(e) {
        if (overlayVisible) return;
        if (!isPaused) return;
        const p = getPrimaryPoint(e); if (!p) return;
        const { x, y } = canvasToCtxXY(p.x, p.y, drawCanvas);
        pointerIdActive = p.id;

        if (eraserOn) {
          const tol = Math.max(8, annotSize * 1.1);
          const idx = hitTestObject(x, y, tol);
          if (idx >= 0) { objects.splice(idx, 1); renderAnnotations(); }
          return;
        }

        if (annotationOn && !textModeOn) {
          currentStroke = { type: 'stroke', color: annotColor, size: annotSize * normPressure(p.pressure), points: [{ x, y }] };
          objects.push(currentStroke);
          renderAnnotations();
        }
      }

      function moveDraw(e) {
        if (overlayVisible) return;
        const p = getPrimaryPoint(e); if (!p) return;

        if (laserActive) {
          const { x, y } = canvasToCtxXY(p.x, p.y, laserCanvas);
          addTailPoint(x, y);
        }

        if (!isPaused) return;

        if (eraserOn && p.id === pointerIdActive) {
          const { x, y } = canvasToCtxXY(p.x, p.y, drawCanvas);
          const tol = Math.max(8, annotSize * 1.1);
          const idx = hitTestObject(x, y, tol);
          if (idx >= 0) { objects.splice(idx, 1); renderAnnotations(); }
          return;
        }

        if (annotationOn && !textModeOn && p.id === pointerIdActive && currentStroke) {
          const { x, y } = canvasToCtxXY(p.x, p.y, drawCanvas);
          currentStroke.points.push({ x, y });
          currentStroke.size = Math.max(1, annotSize * normPressure(p.pressure));
          renderAnnotations();
        }
      }

      function endDraw() { pointerIdActive = null; currentStroke = null; }

      // Laser trail
      function addTailPoint(x, y) { tail.push({ x, y, life: 1 }); if (tail.length > 220) tail.shift(); }
      function renderLaser() {
        const w = laserCanvas.width, h = laserCanvas.height;
        ctxLaser.clearRect(0, 0, w, h);
        if (laserActive) {
          const { r, g, b } = hexToRgb(pointerColor);
          ctxLaser.globalCompositeOperation = 'source-over';
          for (let i = 0; i < tail.length; i++) {
            const t = tail[i]; t.life *= 0.96; if (t.life < 0.02) continue;
            const a = t.life, radius = pointerSize * (0.9 + 1.2 * a), glow = radius * 2.2;
            const grad = ctxLaser.createRadialGradient(t.x, t.y, 0, t.x, t.y, glow);
            grad.addColorStop(0, `rgba(${r},${g},${b},${0.25 * a})`); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctxLaser.fillStyle = grad; ctxLaser.beginPath(); ctxLaser.arc(t.x, t.y, glow, 0, Math.PI * 2); ctxLaser.fill();
            ctxLaser.fillStyle = `rgba(${r},${g},${b},${0.85 * a})`; ctxLaser.beginPath(); ctxLaser.arc(t.x, t.y, radius, 0, Math.PI * 2); ctxLaser.fill();
          }
        }
        for (let i = tail.length - 1; i >= 0; i--) { if (tail[i].life < 0.02) tail.splice(i, 1); }
        requestAnimationFrame(renderLaser);
      }
      function hexToRgb(hex) { const h = hex.replace('#', ''); const b = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16); return { r: (b >> 16) & 255, g: (b >> 8) & 255, b: b & 255 }; }

      /* ===== Text overlay & objects ===== */
      let pendingTextXY = null;
      function showTextOverlayAt(clientX, clientY) {
        const rect = stage.getBoundingClientRect();
        const x = Math.min(Math.max(clientX - rect.left, 8), rect.width - 300);
        const y = Math.min(Math.max(clientY - rect.top, 8), rect.height - 140);
        textOverlay.style.left = `${x}px`; textOverlay.style.top = `${y}px`; textOverlay.style.display = 'block';
        overlayVisible = true; textInput.value = ''; textInput.focus();
      }

      // CHANGED: allow hiding overlay without turning text mode off
      function hideTextOverlay(keepMode = false) {
        textOverlay.style.display = 'none';
        overlayVisible = false;
        pendingTextXY = null;
        if (!keepMode) {
          textModeOn = false;
          textBtn.classList.toggle('active', false);
          textBtn.classList.toggle('primary', false);
          textBtn.classList.toggle('muted', true);
          updateInteractionMode();
        }
      }

      function placeTextObject(text, x, y) {
        if (!text) return;
        const fontPx = Math.round(10 + annotSize * 2);
        const m = measureTextBlock(text, fontPx);
        const obj = { type: 'text', x, y, text: String(text), color: annotColor, fontPx, lh: m.lh, width: m.width, height: m.height };
        objects.push(obj);
        renderAnnotations();
      }

      /* ===== UI events ===== */
      liveToggle.addEventListener('change', () => setPaused(!liveToggle.checked));

      annotationBtn.addEventListener('click', () => {
        annotationOn = !annotationOn;
        eraserOn = false; textModeOn = false; hideTextOverlay();
        annotationBtn.classList.toggle('active', annotationOn);
        annotationBtn.classList.toggle('primary', annotationOn);
        annotationBtn.classList.toggle('muted', !annotationOn);
        eraserBtn.classList.toggle('active', false);
        eraserBtn.classList.toggle('primary', false);
        eraserBtn.classList.toggle('muted', true);
        textBtn.classList.toggle('active', false);
        textBtn.classList.toggle('primary', false);
        textBtn.classList.toggle('muted', true);
        updateInteractionMode();
        if (annotationOn) setPaused(true);
      });

      eraserBtn.addEventListener('click', () => {
        eraserOn = !eraserOn;
        annotationOn = eraserOn ? true : annotationOn;
        textModeOn = false; hideTextOverlay();
        eraserBtn.classList.toggle('active', eraserOn);
        eraserBtn.classList.toggle('primary', eraserOn);
        eraserBtn.classList.toggle('muted', !eraserOn);
        annotationBtn.classList.toggle('active', annotationOn);
        annotationBtn.classList.toggle('primary', annotationOn);
        annotationBtn.classList.toggle('muted', !annotationOn);
        textBtn.classList.toggle('active', false);
        textBtn.classList.toggle('primary', false);
        textBtn.classList.toggle('muted', true);
        updateInteractionMode();
        if (eraserOn) setPaused(true);
      });

      // CHANGED: keep text mode active when hiding the overlay
      textBtn.addEventListener('click', () => {
        annotationOn = true; eraserOn = false;
        textModeOn = !textModeOn;
        hideTextOverlay(textModeOn); // keep mode if we just turned it on
        annotationBtn.classList.toggle('active', true);
        annotationBtn.classList.toggle('primary', true);
        annotationBtn.classList.toggle('muted', false);
        eraserBtn.classList.toggle('active', false);
        eraserBtn.classList.toggle('primary', false);
        eraserBtn.classList.toggle('muted', true);
        textBtn.classList.toggle('active', textModeOn);
        textBtn.classList.toggle('primary', textModeOn);
        textBtn.classList.toggle('muted', !textModeOn);
        updateInteractionMode();
        if (textModeOn) { setPaused(true); showToast('Tap where you want the text.'); }
      });

      clearBtn.addEventListener('click', () => { objects.length = 0; renderAnnotations(); });

      pointerColorEl.addEventListener('input', e => { pointerColor = e.target.value; });
      pointerSizeEl.addEventListener('input', e => { pointerSize = parseInt(e.target.value, 10); saveNum('pointerSize', pointerSize); });
      annotColorEl.addEventListener('input', e => { annotColor = e.target.value; });
      annotSizeEl.addEventListener('input', e => { annotSize = parseInt(e.target.value, 10); saveNum('annotSize', annotSize); });

      mirrorBtn.addEventListener('click', () => { isMirrored = !isMirrored; applyVideoStyle(); if (isPaused && hasFrozen) drawFreezeFromFrozen(); showToast(isMirrored ? 'Mirrored' : 'Unmirrored'); });

      // Fit/Fill toggle (disabled while paused)
      fitBtn.addEventListener('click', () => {
        if (isPaused) return;
        fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
        fitBtn.textContent = (fitMode === 'cover') ? 'Fill' : 'Fit';
        resizeCanvases();
        if (isPaused && hasFrozen) drawFreezeFromFrozen();
        showToast(fitMode === 'cover' ? 'Fill mode' : 'Fit mode');
      });

      // Stage pointer wiring
      const target = stage;
      function touchGuard(e) { if (overlayVisible && e.target.closest('#textOverlay')) return; e.preventDefault(); }
      ['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(ev => target.addEventListener(ev, touchGuard, { passive: false }));
      target.addEventListener('pointerdown', (e) => {
        if (isPaused && annotationOn && textModeOn && !overlayVisible) {
          const { x, y } = canvasToCtxXY(e.clientX, e.clientY, drawCanvas);
          pendingTextXY = { x, y }; showTextOverlayAt(e.clientX, e.clientY); return;
        }
        startDraw(e);
      });
      target.addEventListener('pointermove', moveDraw);
      target.addEventListener('pointerup', endDraw);
      target.addEventListener('pointercancel', endDraw);
      target.addEventListener('pointerout', endDraw);
      target.addEventListener('pointerleave', endDraw);

      textAdd.addEventListener('click', () => { if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y); hideTextOverlay(); });
      textCancel.addEventListener('click', () => hideTextOverlay());
      textInput.addEventListener('keydown', e => {
        if (e.key === 'Escape') { e.preventDefault(); hideTextOverlay(); }
        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') { e.preventDefault(); if (pendingTextXY) placeTextObject(textInput.value, pendingTextXY.x, pendingTextXY.y); hideTextOverlay(); }
      });

      // Snapshot
      screenshotBtn.addEventListener('click', () => {
        const w = freezeCanvas.width, h = freezeCanvas.height;
        if (w === 0 || h === 0) { showToast('Snapshot failed: canvas not ready'); return; }
        const out = document.createElement('canvas');
        out.width = w; out.height = h;
        const octx = out.getContext('2d');

        if (isPaused && hasFrozen) {
          octx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
        } else {
          const vw = video.videoWidth, vh = video.videoHeight;
          if (vw && vh) {
            const cr = w / h, vr = vw / vh;
            let dw, dh, dx, dy;
            if (fitMode === 'cover') { if (vr > cr) { dh = h; dw = h * vr; } else { dw = w; dh = w / vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
            else { if (vr > cr) { dw = w; dh = w / vr; } else { dh = h; dw = h * vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
            octx.save();
            if (isMirrored) { octx.translate(w, 0); octx.scale(-1, 1); dx = w - dx - dw; }
            octx.drawImage(video, dx, dy, dw, dh);
            octx.restore();
          }
        }
        octx.drawImage(drawCanvas, 0, 0);
        octx.drawImage(laserCanvas, 0, 0);

        out.toBlob(blob => {
          if (!blob) { showToast('Snapshot failed'); return; }
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `snapshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
          document.body.appendChild(a); a.click(); a.remove();
          URL.revokeObjectURL(url);
          showToast('Snapshot saved');
        });
      });

      /* ===== Recording the composite view ===== */
      function drawCompositeFrame() {
        const w = composite.width, h = composite.height;
        compositeCtx.clearRect(0, 0, w, h);

        // Base: live video (fit/mirror) OR frozen
        if (isPaused && hasFrozen) {
          compositeCtx.drawImage(frozen, 0, 0, frozen.width, frozen.height, 0, 0, w, h);
        } else {
          const vw = video.videoWidth, vh = video.videoHeight;
          if (vw && vh) {
            const cr = w / h, vr = vw / vh;
            let dw, dh, dx, dy;
            if (fitMode === 'cover') { if (vr > cr) { dh = h; dw = h * vr; } else { dw = w; dh = w / vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
            else { if (vr > cr) { dw = w; dh = w / vr; } else { dh = h; dw = h * vr; } dx = (w - dw) / 2; dy = (h - dh) / 2; }
            compositeCtx.save();
            if (isMirrored) { compositeCtx.translate(w, 0); compositeCtx.scale(-1, 1); dx = w - dx - dw; }
            compositeCtx.drawImage(video, dx, dy, dw, dh);
            compositeCtx.restore();
          }
        }

        // Overlays
        compositeCtx.drawImage(drawCanvas, 0, 0);
        compositeCtx.drawImage(laserCanvas, 0, 0);

        if (recording) requestAnimationFrame(drawCompositeFrame);
      }

      function getSupportedMime() {
        const prefs = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
          'video/mp4;codecs=avc1.42E01E,mp4a.40.2'
        ];
        for (const m of prefs) { if (MediaRecorder.isTypeSupported(m)) return m; }
        return '';
      }

      recordBtn.addEventListener('click', () => {
        if (!recording) {
          // prepare composite size
          composite.width = freezeCanvas.width;
          composite.height = freezeCanvas.height;

          const mime = getSupportedMime();
          const stream = composite.captureStream(30);
          try {
            mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : {});
          } catch (e) {
            showToast('Recording not supported'); return;
          }
          recChunks = [];
          mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) recChunks.push(e.data); };
          mediaRecorder.onstop = () => {
            const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
            showToast('Recording saved');
          };
          mediaRecorder.start(120); // gather data every ~2s
          recording = true;
          recordBtn.textContent = 'Stop';
          recordBtn.classList.add('danger');
          drawCompositeFrame();
          showToast('Recording started');
        } else {
          recording = false;
          try { mediaRecorder.stop(); } catch (_) { }
          recordBtn.textContent = 'Record';
          recordBtn.classList.remove('danger');
        }
      });

      /* ===== Init & reactive ===== */
      const ro = new ResizeObserver(() => resizeCanvases()); ro.observe(stage);
      window.addEventListener('orientationchange', () => setTimeout(resizeCanvases, 200));
      requestAnimationFrame(renderLaser);

      (async function init() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          showToast('getUserMedia not supported in this browser'); return;
        }
        try {
          if (currentDeviceId) { await startCamera({ deviceId: { exact: currentDeviceId } }); }
          else { await startCamera({ facingMode: facingPref }); }
        } catch (e) { logError('initial start', e); await startCamera({ facingMode: facingPref }); }
        await listCameras();
        liveToggle.checked = true; setPaused(false);
        freezeCanvas.classList.add('hidden');
        annotationBtn.classList.toggle('muted', true);
        eraserBtn.classList.toggle('muted', true);
        textBtn.classList.toggle('muted', true);
        updateInteractionMode();
        updateStatusUI();
        fitBtn.textContent = (fitMode === 'cover') ? 'Fill' : 'Fit';
        resizeCanvases();
      })();

    })();
  </script>
</body>

</html>