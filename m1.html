<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Motion Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            padding: 0;
            margin: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        h1 {
            text-align: center;
            font-size: 2.5em;
            font-weight: bold;
            margin: 0;
            padding: 20px 0;
            background-color: #333; 
            color: white; 
        }
        #message {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin: 15px auto;
            color: #666;
            max-width: 800px;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px auto;
            padding: 10px 0;
            flex-wrap: wrap;
        }
        #controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #controls button:disabled {
            background-color: #a9a9a9;
            cursor: not-allowed;
        }
        #controls button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        .clear-button {
            background-color: #dc3545; 
        }
        .clear-button:hover:not(:disabled) {
            background-color: #c82333;
        }
        .export-button {
            background-color: #17a2b8; 
        }
        .export-button:hover:not(:disabled) {
            background-color: #138496;
        }
        #controls input[type="range"] {
            appearance: none;
            background: #007bff;
            height: 5px;
            border-radius: 5px;
            outline: none;
            margin: 0 10px;
            cursor: pointer;
            width: 200px;
        }
        #controls input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #007bff;
            cursor: pointer;
            margin-top: -5px;
        }
        #controls input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #007bff;
            cursor: pointer;
        }
        #controls span {
            font-size: 1.1em;
            color: #333;
        }
        #analysisContainer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px auto;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
        }
        #videoWrapper {
            position: relative;
            width: 48%; 
            max-width: 600px;
            min-width: 300px;
            min-height: 200px; 
        }
        video, canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 100%;
            background-color: #f5f5f5;
            display: block;
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            background-color: transparent;
        }
        #chartCanvasContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            width: 48%;
            min-width: 300px;
            max-width: 600px;
            height: 400px;
        }
        #chartCanvasContainer canvas {
            width: 100%;
            height: 100%;
        }
        #velocityControls {
            text-align: center;
            margin-top: 20px;
        }
        #velocityControls button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #velocityControls button:hover {
            background-color: #218838;
        }
        #clearControls {
            text-align: center;
            margin-top: 10px;
        }
        #clearControls button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 1em;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        @media (max-width: 768px) {
            #analysisContainer {
                flex-direction: column;
            }
            #videoWrapper, #chartCanvasContainer {
                width: 90%;
            }
        }
        #calibrationPrompt, #exportPrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid #333;
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 300px;
            box-sizing: border-box;
        }
        #calibrationPrompt h2, #exportPrompt h2 {
            margin-top: 0;
            text-align: center;
        }
        #calibrationPrompt p, #exportPrompt p {
            text-align: center;
        }
        #calibrationPrompt form, #exportPrompt form {
            display: flex;
            flex-direction: column;
        }
        #calibrationPrompt input, #exportPrompt input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            box-sizing: border-box;
        }
        #calibrationPrompt button, #exportPrompt button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 48%;
            font-size: 1em;
        }
        #calibrationPrompt button:hover, #exportPrompt button:hover:not(.cancel-button) {
            background-color: #0056b3;
        }
        .cancel-button {
            background-color: #dc3545;
        }
        .cancel-button:hover {
            background-color: #c82333;
        }
        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 3;
            display: none;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background-color: red;
        }
        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }
        .crosshair::after {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }
        input:-webkit-autofill,
        input:-webkit-autofill:hover, 
        input:-webkit-autofill:focus, 
        input:-webkit-autofill:active {
            transition: background-color 5000s ease-in-out 0s;
            -webkit-text-fill-color: #000 !important;
            background-color: #fff !important;
        }
    </style>
</head>
<body>
    <h1>Motion Tracker</h1>

    <!-- Calibration Prompt Modal -->
    <div id="calibrationPrompt">
        <h2>Calibration</h2>
        <p>Enter the actual length and unit of the drawn line:</p>
        <form onsubmit="return false;" autocomplete="off">
            <input type="number" id="actualLength" name="actualLength" placeholder="Actual Length" min="0.0001" step="any" autocomplete="off">
            <input type="text" id="actualUnit" name="actualUnit" placeholder="Unit (e.g., meters, cm)" autocomplete="off">
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button type="button" id="confirmCalibration">Confirm</button>
                <button type="button" id="cancelCalibration" class="cancel-button">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Export Filename Prompt Modal -->
    <div id="exportPrompt">
        <h2>Export Data</h2>
        <p>Enter the desired filename for the exported data:</p>
        <form onsubmit="return false;" autocomplete="off">
            <input type="text" id="exportFilename" name="exportFilename" placeholder="Filename" value="motion_tracker_data" autocomplete="off">
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button type="button" id="confirmExport">Export</button>
                <button type="button" id="cancelExport" class="cancel-button">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Main Controls -->
    <div id="controls">
        <button id="startRecording">Start Recording</button>
        <button id="stopRecording" disabled>Stop Recording</button>
        <button id="uploadVideo">Upload Video</button>
        <input type="file" id="videoUploadInput" accept="video/*" style="display: none;">
        <button id="playPause" style="display: none;">Play</button>
        <button id="calibrate" style="display: none;">Calibration</button>
        <button id="setOrigin" style="display: none;">Set Origin</button>
        <input type="range" id="slider" min="0" max="1" step="0.001" value="0" style="display: none;">
        <span id="timeDisplay" style="display: none;">0:00.000</span>
    </div>

    <p id="message">Click "Start Recording" to begin.</p>

    <div id="analysisContainer">
        <div id="videoWrapper">
            <video id="liveVideo" autoplay muted playsinline webkit-playsinline preload="metadata"></video>
            <canvas id="frameCanvas" style="display: none;"></canvas>
            <canvas id="overlayCanvas"></canvas>
            <div class="crosshair" id="crosshair"></div>
        </div>
        <div id="chartCanvasContainer" style="display: none;">
            <canvas id="positionChart"></canvas>
        </div>
    </div>

    <div id="velocityControls" style="display: none;">
        <button id="plotVx">Plot vₓ vs t</button>
        <button id="plotVy">Plot vᵧ vs t</button>
        <button id="backToPosition">Plot x vs t and y vs t</button>
    </div>

    <div id="clearControls" style="display: none;">
        <button id="clearDataPoints" class="clear-button">Clear Data Points</button>
        <button id="clearCalibration" class="clear-button">Clear Calibration</button>
        <button id="clearOrigin" class="clear-button">Clear Origin</button>
        <button id="exportData" class="export-button">Export Data</button>
    </div>

    <script>
        const startRecordingButton = document.getElementById('startRecording');
        const stopRecordingButton = document.getElementById('stopRecording');
        const uploadVideoButton = document.getElementById('uploadVideo');
        const videoUploadInput = document.getElementById('videoUploadInput');
        const playPauseButton = document.getElementById('playPause');
        const calibrateButton = document.getElementById('calibrate');
        const setOriginButton = document.getElementById('setOrigin');
        const slider = document.getElementById('slider');
        const timeDisplay = document.getElementById('timeDisplay');
        const liveVideo = document.getElementById('liveVideo');
        const frameCanvas = document.getElementById('frameCanvas');
        const positionChartCanvas = document.getElementById('positionChart');
        const message = document.getElementById('message');
        const chartCanvasContainer = document.getElementById('chartCanvasContainer');
        const velocityControls = document.getElementById('velocityControls');
        const plotVxButton = document.getElementById('plotVx');
        const plotVyButton = document.getElementById('plotVy');
        const backToPositionButton = document.getElementById('backToPosition');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const videoWrapper = document.getElementById('videoWrapper');
        const clearControls = document.getElementById('clearControls');
        const clearDataPointsButton = document.getElementById('clearDataPoints');
        const clearCalibrationButton = document.getElementById('clearCalibration');
        const clearOriginButton = document.getElementById('clearOrigin');
        const exportDataButton = document.getElementById('exportData');
        const calibrationPrompt = document.getElementById('calibrationPrompt');
        const actualLengthInput = document.getElementById('actualLength');
        const actualUnitInput = document.getElementById('actualUnit');
        const confirmCalibrationButton = document.getElementById('confirmCalibration');
        const cancelCalibrationButton = document.getElementById('cancelCalibration');
        const exportPrompt = document.getElementById('exportPrompt');
        const exportFilenameInput = document.getElementById('exportFilename');
        const confirmExportButton = document.getElementById('confirmExport');
        const cancelExportButton = document.getElementById('cancelExport');
        const crosshair = document.getElementById('crosshair');

        let ctx = frameCanvas.getContext('2d');
        let overlayCtx = overlayCanvas.getContext('2d');
        let mediaRecorder;
        let recordedChunks = [];
        let recordedBlob = null;
        let frameData = [];
        let isPlaying = false;
        let positionChart;
        let skippingFrame = false; 
        let videoElement = liveVideo; 
        let mode = "record"; 
        let calibrationMode = false;
        let calibrationStart = null;
        let calibrationEnd = null;
        let scaleFactor = 1; 
        let scaleUnit = "pixels";
        let isDrawingCalibration = false;
        let originMode = false;
        let originSet = false;
        let originPoint = { x: 0, y: 0 };

        function canvasYToCartesianY(y) {
            return frameCanvas.height - y;
        }
        function cartesianYToCanvasY(y) {
            return frameCanvas.height - y;
        }

        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then((stream) => {
                liveVideo.srcObject = stream;
                liveVideo.play().catch(err => console.log('Video play error:', err));

                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    recordedChunks = [];
                    switchToAnalysisMode();
                };
            })
            .catch((error) => {
                alert('Unable to access camera. Check your permissions.');
                console.error('getUserMedia error:', error);
            });

        startRecordingButton.addEventListener('click', () => {
            if (mode === "record") {
                recordedChunks = [];
                mediaRecorder.start();
                startRecordingButton.disabled = true;
                stopRecordingButton.disabled = false;
                uploadVideoButton.disabled = true;
                message.textContent = "Recording in progress...";
            }
        });

        stopRecordingButton.addEventListener('click', () => {
            if (mode === "record") {
                mediaRecorder.stop();
                startRecordingButton.disabled = false;
                stopRecordingButton.disabled = true;
                uploadVideoButton.disabled = false;
                message.textContent = "Recording stopped. Preparing for analysis...";
            }
        });

        uploadVideoButton.addEventListener('click', () => {
            videoUploadInput.click();
        });

        videoUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                recordedBlob = null; 
                recordedChunks = [];
                mode = "analyze";

                videoElement.srcObject = null; 
                videoElement.src = URL.createObjectURL(file);
                videoElement.autoplay = false;
                videoElement.load();

                videoElement.onloadedmetadata = () => {
                    finalizeVideoInitialization();
                };

                liveVideo.style.display = "none";
                frameCanvas.style.display = "block";
                chartCanvasContainer.style.display = "flex"; 
                velocityControls.style.display = "block";
                clearControls.style.display = "block"; 
                calibrateButton.style.display = "inline-block"; 
                setOriginButton.style.display = "inline-block";
                startRecordingButton.style.display = "none";
                stopRecordingButton.style.display = "none";
                uploadVideoButton.style.display = "none";
                playPauseButton.style.display = "inline-block";
                slider.style.display = "inline-block";
                timeDisplay.style.display = "inline-block";
                message.innerHTML = "Use the slide bar to select the starting frame.<br>Click on the object to track its position.";
            }
        });

        function switchToAnalysisMode() {
            mode = "analyze";

            videoElement.srcObject = null; 
            videoElement.src = URL.createObjectURL(recordedBlob);
            videoElement.autoplay = false; 
            videoElement.load();

            videoElement.onloadedmetadata = () => {
                finalizeVideoInitialization();
            };

            liveVideo.style.display = "none";
            frameCanvas.style.display = "block";
            chartCanvasContainer.style.display = "flex";
            velocityControls.style.display = "block";
            clearControls.style.display = "block";
            calibrateButton.style.display = "inline-block";
            setOriginButton.style.display = "inline-block";
            startRecordingButton.style.display = "none";
            stopRecordingButton.style.display = "none";
            uploadVideoButton.style.display = "none";
            playPauseButton.style.display = "inline-block";
            slider.style.display = "inline-block";
            timeDisplay.style.display = "inline-block";
            message.innerHTML = "Use the slide bar to select the starting frame.<br>Click on the object to track its position.";
        }

        function finalizeVideoInitialization() {
            let dur = videoElement.duration;
            if (!isFinite(dur) && videoElement.seekable.length > 0) {
                dur = videoElement.seekable.end(videoElement.seekable.length - 1);
            }
            if (!isFinite(dur)) dur = 0;
            slider.max = dur;
            slider.value = 0; 
            timeDisplay.textContent = formatTime(0); 
            videoElement.currentTime = 0;
            videoElement.pause();

            videoElement.addEventListener('seeked', () => {
                setupCanvasDimensions();
                drawOverlay();
                drawFrame();
            }, { once: true });

            videoElement.currentTime = 0; 
        }

        function setupCanvasDimensions() {
            if (!videoElement.videoWidth || !videoElement.videoHeight) return;
            frameCanvas.width = videoElement.videoWidth;
            frameCanvas.height = videoElement.videoHeight;
            overlayCanvas.width = videoElement.videoWidth;
            overlayCanvas.height = videoElement.videoHeight;
        }

        playPauseButton.addEventListener('click', () => {
            if (isPlaying) {
                videoElement.pause();
                playPauseButton.textContent = "Play";
            } else {
                videoElement.play();
                playPauseButton.textContent = "Pause";
            }
            isPlaying = !isPlaying;
        });

        videoElement.addEventListener("timeupdate", () => {
            const t = isFinite(videoElement.currentTime) ? videoElement.currentTime : 0;
            slider.value = Math.min(t, slider.max); 
            timeDisplay.textContent = formatTime(t); 
            drawFrame(); 
            drawOverlay(); 
        });

        slider.addEventListener("input", () => {
            const val = parseFloat(slider.value);
            if (val <= videoElement.duration) {
                videoElement.currentTime = val; 
            }
        });

        // Use pointer events for mobile compatibility
        overlayCanvas.addEventListener('pointerdown', startCalibrationOrOrigin);
        overlayCanvas.addEventListener('pointermove', moveCalibrationOrCrosshair);
        overlayCanvas.addEventListener('pointerup', endCalibration);

        function startCalibrationOrOrigin(event) {
            if (!calibrationMode) return;
            isDrawingCalibration = true;
            const rect = overlayCanvas.getBoundingClientRect();
            const scaleX = overlayCanvas.width / rect.width;
            const scaleY = overlayCanvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = canvasYToCartesianY((event.clientY - rect.top) * scaleY);
            calibrationStart = { x, y };
            calibrationEnd = { x, y };
            event.preventDefault();
        }

        function moveCalibrationOrCrosshair(event) {
            if ((calibrationMode || originMode) && mode === "analyze") {
                const rect = overlayCanvas.getBoundingClientRect();
                const crossX = event.clientX - rect.left;
                const crossY = event.clientY - rect.top;
                crosshair.style.left = `${crossX - 10}px`;
                crosshair.style.top = `${crossY - 10}px`;
                crosshair.style.display = "block";
            }
            if (calibrationMode && isDrawingCalibration) {
                const rect = overlayCanvas.getBoundingClientRect();
                const scaleX = overlayCanvas.width / rect.width;
                const scaleY = overlayCanvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = canvasYToCartesianY((event.clientY - rect.top) * scaleY);
                calibrationEnd = { x, y };
                drawOverlay();
                event.preventDefault();
            }
        }

        function endCalibration(event) {
            if (!calibrationMode || !isDrawingCalibration) return;
            isDrawingCalibration = false;
            calibrationMode = false;
            overlayCanvas.style.pointerEvents = "none";
            frameCanvas.style.cursor = "default";
            message.innerHTML = "Calibration line drawn. Enter actual length and unit.";
            showCalibrationPrompt();
        }

        // Set origin with frameCanvas pointerdown (for accurate coordinate mapping)
        frameCanvas.addEventListener('pointerdown', (event) => {
            if (mode === "analyze" && !calibrationMode && !originMode) {
                // Selecting data point
                const rect = frameCanvas.getBoundingClientRect();
                const scaleX = frameCanvas.width / rect.width; 
                const scaleY = frameCanvas.height / rect.height; 
                const canvasX = (event.clientX - rect.left) * scaleX;
                const canvasY = (event.clientY - rect.top) * scaleY;
                const cartesianY = canvasYToCartesianY(canvasY);

                frameData.push({ x: canvasX, y: cartesianY, time: videoElement.currentTime });
                plotPosition();
                skipToNextFrame();
            } else if (mode === "analyze" && originMode && !calibrationMode) {
                // Selecting origin
                const rect = frameCanvas.getBoundingClientRect();
                const scaleX = frameCanvas.width / rect.width; 
                const scaleY = frameCanvas.height / rect.height; 
                const canvasX = (event.clientX - rect.left) * scaleX;
                const canvasY = (event.clientY - rect.top) * scaleY;
                const cartesianY = canvasYToCartesianY(canvasY);
                originPoint = { x: canvasX, y: cartesianY };
                originSet = true;
                originMode = false;
                frameCanvas.style.cursor = "default";
                crosshair.style.display = "none";
                overlayCanvas.style.pointerEvents = "none";
                message.textContent = "Origin set. Data will now be plotted relative to the chosen origin.";
                drawOverlay();
                plotPosition();
            }
        });

        function drawFrame() {
            if (!videoElement.videoWidth || !videoElement.videoHeight) return;
            ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
            ctx.drawImage(videoElement, 0, 0, frameCanvas.width, frameCanvas.height);

            const referenceHeight = 1080; 
            const scale = (frameCanvas.height) / referenceHeight;
            const crossSize = 25 * scale; 
            const circleRadius = 25 * scale; 

            frameData.forEach((point) => {
                const x = point.x;
                const y = cartesianYToCanvasY(point.y);
                drawDataPoint(x, y, crossSize, circleRadius);
            });
        }

        function drawDataPoint(x, y, crossSize, circleRadius) {
            ctx.fillStyle = 'red'; 
            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2; 
            ctx.beginPath();
            ctx.moveTo(x - crossSize, y);
            ctx.lineTo(x + crossSize, y);
            ctx.moveTo(x, y - crossSize);
            ctx.lineTo(x, y + crossSize);
            ctx.stroke();
        }

        function skipToNextFrame() {
            if (videoElement.currentTime + (1/30) >= videoElement.duration) {
                message.textContent = "Reached end of video.";
                return;
            }
            skippingFrame = true;
            videoElement.currentTime = videoElement.currentTime + 1 / 30; 
            videoElement.addEventListener('seeked', () => {
                skippingFrame = false;
                drawFrame();
                drawOverlay(); 
            }, { once: true });
        }

        function plotPosition() {
            const xData = frameData.map((point) => parseFloat(point.time.toFixed(3))); 
            const yDataX = frameData.map((p) => parseFloat(((p.x - (originSet ? originPoint.x : 0)) * scaleFactor).toFixed(3)));
            const yDataY = frameData.map((p) => parseFloat(((p.y - (originSet ? originPoint.y : 0)) * scaleFactor).toFixed(3)));

            if (!positionChart) {
                positionChart = new Chart(positionChartCanvas.getContext("2d"), {
                    type: "scatter",
                    data: {
                        datasets: [
                            {
                                label: "x vs t",
                                data: xData.map((t, i) => ({ x: t, y: yDataX[i] })),
                                borderColor: "blue",
                                backgroundColor: "blue",
                                showLine: false,
                                pointRadius: 4,
                            },
                            {
                                label: "y vs t",
                                data: xData.map((t, i) => ({ x: t, y: yDataY[i] })),
                                borderColor: "green",
                                backgroundColor: "green",
                                showLine: false,
                                pointRadius: 4,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: "linear",
                                position: "bottom",
                                title: {
                                    display: true,
                                    text: "Time (s)",
                                },
                            },
                            y: {
                                type: "linear",
                                position: "left",
                                title: {
                                    display: true,
                                    text: `Position (${scaleUnit})`,
                                },
                            },
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                            }
                        }
                    },
                });
            } else {
                positionChart.data.datasets = [
                    {
                        label: "x vs t",
                        data: xData.map((t, i) => ({ x: t, y: yDataX[i] })),
                        borderColor: "blue",
                        backgroundColor: "blue",
                        showLine: false,
                        pointRadius: 4,
                    },
                    {
                        label: "y vs t",
                        data: xData.map((t, i) => ({ x: t, y: yDataY[i] })),
                        borderColor: "green",
                        backgroundColor: "green",
                        showLine: false,
                        pointRadius: 4,
                    },
                ];
                positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
                positionChart.update();
            }
        }

        function plotVelocity(axis) {
            const windowSize = 3; 
            if (frameData.length < windowSize) {
                alert(`Insufficient data to calculate velocity. At least ${windowSize} points are needed.`);
                return;
            }

            const velocityEstimates = [];
            const velocityTimes = [];
            for (let i = 1; i < frameData.length; i++) {
                const deltaTime = frameData[i].time - frameData[i - 1].time;
                if (deltaTime <= 0) continue;
                const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
                const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };

                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;
                const deltaPos = axis === 'x' ? deltaX : deltaY;

                const velocity = (deltaPos * scaleFactor) / deltaTime;
                velocityEstimates.push(velocity);
                velocityTimes.push(frameData[i].time);
            }

            const smoothedVelocities = [];
            const smoothedTimes = [];
            for (let i = windowSize - 1; i < velocityEstimates.length; i++) {
                const window = velocityEstimates.slice(i - windowSize + 1, i + 1);
                const averageVelocity = window.reduce((sum, val) => sum + val, 0) / windowSize;
                smoothedVelocities.push(parseFloat(averageVelocity.toFixed(3)));
                const timeWindow = velocityTimes.slice(i - windowSize + 1, i + 1);
                const midpointTime = (timeWindow[0] + timeWindow[windowSize - 1]) / 2;
                smoothedTimes.push(parseFloat(midpointTime.toFixed(3)));
            }

            positionChart.data.datasets = [
                {
                    label: axis === "x" ? "vₓ vs t" : "vᵧ vs t",
                    data: smoothedTimes.map((t, i) => ({ x: t, y: smoothedVelocities[i] })),
                    borderColor: axis === "x" ? "blue" : "green",
                    backgroundColor: axis === "x" ? "blue" : "green",
                    showLine: false,
                    pointRadius: 4,
                },
            ];
            positionChart.options.scales.y.title.text = `Velocity (${scaleUnit}/s)`;
            positionChart.update();
        }

        plotVxButton.addEventListener("click", () => plotVelocity("x"));
        plotVyButton.addEventListener("click", () => plotVelocity("y"));
        backToPositionButton.addEventListener("click", () => {
            plotPosition();
        });

        clearDataPointsButton.addEventListener("click", () => {
            frameData = []; 
            if (positionChart) {
                positionChart.data.datasets.forEach((dataset) => {
                    dataset.data = [];
                });
                positionChart.update();
            }
            drawFrame(); 
            drawOverlay(); 
            message.textContent = "Data points cleared.";
        });

        clearCalibrationButton.addEventListener("click", () => {
            scaleFactor = 1;
            scaleUnit = "pixels";
            calibrationStart = null;
            calibrationEnd = null;

            drawOverlay();
            drawFrame();
            plotPosition();
            message.textContent = "Calibration cleared. Positions are now in pixel units.";
        });

        clearOriginButton.addEventListener("click", () => {
            originSet = false;
            originPoint = { x: 0, y: 0 };
            drawOverlay();
            plotPosition();
            message.textContent = "Origin cleared. Default origin (lower-left) is used.";
        });

        exportDataButton.addEventListener("click", () => {
            if (frameData.length === 0) {
                alert("No data to export.");
                return;
            }
            showExportPrompt();
        });

        function showExportPrompt() {
            exportFilenameInput.value = "motion_tracker_data"; 
            exportPrompt.style.display = "block";
        }

        function hideExportPrompt() {
            exportPrompt.style.display = "none";
            exportFilenameInput.value = "";
        }

        confirmExportButton.addEventListener('click', () => {
            const desiredFilename = exportFilenameInput.value.trim();
            if (desiredFilename === "") {
                alert("Please enter a valid filename.");
                return;
            }
            const sanitizedFilename = desiredFilename.replace(/[^a-zA-Z0-9-_.]/g, "_");
            let finalFilename = sanitizedFilename;
            if (!finalFilename.toLowerCase().endsWith(".csv")) {
                finalFilename += ".csv";
            }

            exportCSV(finalFilename);
            hideExportPrompt();
        });

        cancelExportButton.addEventListener('click', () => {
            hideExportPrompt();
            message.textContent = "Export cancelled.";
        });

        function exportCSV(filename) {
            const velocityData = [];
            for (let i = 1; i < frameData.length; i++) {
                const deltaTime = frameData[i].time - frameData[i - 1].time;
                if (deltaTime <= 0) {
                    velocityData.push({ v_x: "", v_y: "" });
                    continue;
                }
                const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
                const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };

                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;

                const v_x = (deltaX * scaleFactor) / deltaTime;
                const v_y = (deltaY * scaleFactor) / deltaTime;

                velocityData.push({ v_x, v_y });
            }

            let csvContent = `Time (s),x (${scaleUnit}),y (${scaleUnit}),v_x (${scaleUnit}/s),v_y (${scaleUnit}/s)\n`;

            for (let i = 0; i < frameData.length; i++) {
                const xAdj = (frameData[i].x - (originSet ? originPoint.x : 0)) * scaleFactor;
                const yAdj = (frameData[i].y - (originSet ? originPoint.y : 0)) * scaleFactor;

                const time = frameData[i].time.toFixed(3);
                const x = xAdj.toFixed(3);
                const y = yAdj.toFixed(3);
                const v_x = i > 0 && velocityData[i - 1].v_x !== undefined ? velocityData[i - 1].v_x.toFixed(3) : "";
                const v_y = i > 0 && velocityData[i - 1].v_y !== undefined ? velocityData[i - 1].v_y.toFixed(3) : "";
                csvContent += `${time},${x},${y},${v_x},${v_y}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            message.textContent = `Data exported as ${filename}.`;
        }

        function formatTime(time) {
            if (!isFinite(time) || time < 0) time = 0;
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time - Math.floor(time)) * 1000);
            return `${minutes}:${seconds.toString().padStart(2, "0")}.${milliseconds.toString().padStart(3, "0")}`;
        }

        function drawOverlay() {
            if (!videoElement.videoWidth || !videoElement.videoHeight) return;
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            const gridSize = 50; 
            overlayCtx.strokeStyle = "rgba(200, 200, 200, 0.7)";
            overlayCtx.lineWidth = 1;

            const width = overlayCanvas.width;
            const height = overlayCanvas.height;

            for (let x = 0; x <= width; x += gridSize) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(x, 0);
                overlayCtx.lineTo(x, height);
                overlayCtx.stroke();
            }

            for (let y = 0; y <= height; y += gridSize) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(0, y);
                overlayCtx.lineTo(width, y);
                overlayCtx.stroke();
            }

            if (mode === "analyze") {
                let ox = originSet ? originPoint.x : 0;
                let oy = originSet ? originPoint.y : 0;

                const originCanvasX = ox;
                const originCanvasY = cartesianYToCanvasY(oy);

                overlayCtx.save();
                overlayCtx.lineWidth = 4;
                overlayCtx.strokeStyle = 'black';

                overlayCtx.beginPath();
                overlayCtx.moveTo(0, originCanvasY);
                overlayCtx.lineTo(width, originCanvasY);
                overlayCtx.stroke();

                overlayCtx.beginPath();
                overlayCtx.moveTo(originCanvasX, 0);
                overlayCtx.lineTo(originCanvasX, height);
                overlayCtx.stroke();

                overlayCtx.lineWidth = 2;
                overlayCtx.strokeStyle = 'white';

                overlayCtx.beginPath();
                overlayCtx.moveTo(0, originCanvasY);
                overlayCtx.lineTo(width, originCanvasY);
                overlayCtx.stroke();

                overlayCtx.beginPath();
                overlayCtx.moveTo(originCanvasX, 0);
                overlayCtx.lineTo(originCanvasX, height);
                overlayCtx.stroke();

                overlayCtx.fillStyle = "cyan";
                overlayCtx.beginPath();
                overlayCtx.arc(originCanvasX, originCanvasY, 5, 0, 2 * Math.PI);
                overlayCtx.fill();

                overlayCtx.restore();
            }

            if (calibrationStart && calibrationEnd) {
                overlayCtx.strokeStyle = "orange";
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([5, 5]); 
                overlayCtx.beginPath();
                overlayCtx.moveTo(calibrationStart.x, cartesianYToCanvasY(calibrationStart.y));
                overlayCtx.lineTo(calibrationEnd.x, cartesianYToCanvasY(calibrationEnd.y));
                overlayCtx.stroke();
                overlayCtx.setLineDash([]); 
            }
        }

        calibrateButton.addEventListener('click', () => {
            if (mode !== "analyze") return;
            originMode = false;
            crosshair.style.display = "none";
            overlayCanvas.style.pointerEvents = "auto"; 
            calibrationMode = true;
            isDrawingCalibration = false;
            calibrationStart = null;
            calibrationEnd = null;
            message.textContent = "Calibration: Press and drag on the video to draw a calibration line.";
            frameCanvas.style.cursor = "crosshair";
        });

        confirmCalibrationButton.addEventListener('click', () => {
            const actualLength = parseFloat(actualLengthInput.value);
            const actualUnit = actualUnitInput.value.trim();

            if (isNaN(actualLength) || actualLength <= 0 || actualUnit === "") {
                alert("Please enter a valid actual length (positive number) and unit.");
                return;
            }

            const deltaX = calibrationEnd.x - calibrationStart.x;
            const deltaY = calibrationEnd.y - calibrationStart.y;
            const pixelLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (pixelLength === 0) {
                alert("Calibration line length cannot be zero.");
                return;
            }

            scaleFactor = actualLength / pixelLength;
            scaleUnit = actualUnit;

            hideCalibrationPrompt();
            drawOverlay();
            drawFrame();
            plotPosition();
            message.textContent = `Calibration successful: 1 pixel = ${scaleFactor.toFixed(4)} ${scaleUnit}`;
            crosshair.style.display = "none";
        });

        cancelCalibrationButton.addEventListener('click', () => {
            hideCalibrationPrompt();
            calibrationMode = false;
            isDrawingCalibration = false;
            calibrationStart = null;
            calibrationEnd = null;
            drawOverlay();
            drawFrame();
            crosshair.style.display = "none";
            message.textContent = "Calibration cancelled.";
        });

        window.addEventListener('click', (event) => {
            if (event.target == calibrationPrompt) {
                calibrationPrompt.style.display = "none";
                calibrationMode = false;
                isDrawingCalibration = false;
                calibrationStart = null;
                calibrationEnd = null;
                message.textContent = "Calibration cancelled.";
                drawOverlay();
                drawFrame();
                crosshair.style.display = "none";
            }
            if (event.target == exportPrompt) {
                hideExportPrompt();
                message.textContent = "Export cancelled.";
            }
        });

        setOriginButton.addEventListener('click', () => {
            if (mode !== "analyze") return;
            calibrationMode = false;
            isDrawingCalibration = false;
            originMode = true;
            overlayCanvas.style.pointerEvents = "none"; 
            message.textContent = "Tap on the video area to set the new origin.";
            frameCanvas.style.cursor = "crosshair";
            crosshair.style.display = "block";
        });
    </script>
</body>
</html>
