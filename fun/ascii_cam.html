<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Live ASCII Camera with 8-bit Color</title>
	<style>
		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			background: #111;
			color: #eee;
			font-family: monospace;
			margin: 0;
			height: 100vh;
			overflow: hidden;
		}

		/* font-size & line-height are set dynamically in JS */
		#ascii {
			margin-top: 1rem;
		}

		#controls {
			margin-top: 1rem;
			display: flex;
			align-items: center;
			gap: .75rem;
			flex-wrap: wrap
		}

		label {
			font-size: 1rem;
			display: flex;
			align-items: center;
			gap: .35rem;
		}

		input[type=range] {
			width: 200px;
		}

		select {
			background: #222;
			color: #eee;
			border: 1px solid #444;
			border-radius: 4px;
			padding: .25rem .4rem
		}

		video,
		canvas {
			display: none;
		}

		/* each ASCII “pixel” lives in a span so we can colour it */
		span {
			display: inline-block;
			width: .65em;
		}
	</style>
</head>

<body>
	<h1>Live ASCII Camera with 8-bit Color</h1>

	<div id="controls">
		<label for="resolutionRange">Resolution:
			<input type="range" id="resolutionRange" min="2" max="20" value="10" />
		</label>

		<label for="mirrorToggle">
			<input type="checkbox" id="mirrorToggle" checked />
			Mirror
		</label>

		<label for="cameraSelect">
			Camera:
			<select id="cameraSelect" disabled>
				<option>Loading…</option>
			</select>
		</label>

		<button id="captureBtn">Capture ASCII</button>
	</div>

	<div id="ascii"></div>

	<video id="video" autoplay playsinline></video>
	<canvas id="canvas"></canvas>

	<script>
		/* ---------- DOM handles ---------- */
		const video = document.getElementById('video');
		const canvas = document.getElementById('canvas');
		const asciiDiv = document.getElementById('ascii');
		const resolutionRange = document.getElementById('resolutionRange');
		const captureBtn = document.getElementById('captureBtn');
		const mirrorToggle = document.getElementById('mirrorToggle');
		const cameraSelect = document.getElementById('cameraSelect');

		/* ---------- constants ---------- */
		const charRamp = "@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\"^`'. ";
		const MIN_CELL = 2; // smallest block (highest detail)
		const MAX_CELL = 20; // largest block  (lowest detail)
		const LS_KEYS = {
			mirror: 'asciiCam-mirror',
			camera: 'asciiCam-cameraId'
		};

		let currentStream = null;
		let hasPopulated = false;

		/* Map slider value (2–20) so that 20→2, 2→20 */
		function getCellSize() {
			const val = +resolutionRange.value;
			return MAX_CELL - (val - MIN_CELL);
		}

		/* Keep the panel’s footprint fixed by resizing font/line-height */
		function updateFont() {
			const sz = getCellSize();
			asciiDiv.style.fontSize = sz + 'px';
			asciiDiv.style.lineHeight = sz + 'px';
		}

		/* Stop any existing stream tracks */
		function stopCurrentStream() {
			if (currentStream) {
				currentStream.getTracks().forEach(t => t.stop());
				currentStream = null;
			}
		}

		/* Start webcam, optionally by deviceId */
		async function startCamera(deviceId) {
			try {
				stopCurrentStream();
				// Prefer exact deviceId if provided, else default to facingMode:user (front camera on phones)
				const constraints = {
					video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: 'user' }
				};
				const stream = await navigator.mediaDevices.getUserMedia(constraints);
				currentStream = stream;
				video.srcObject = stream;

				// On first successful start, populate device list (labels need permission)
				if (!hasPopulated) {
					await populateCameras(deviceId || loadCameraPref());
					hasPopulated = true;
				}
			} catch (err) {
				console.error('Camera error:', err);
				// If exact deviceId failed, try default
				if (deviceId) {
					try {
						const stream = await navigator.mediaDevices.getUserMedia({ video: true });
						currentStream = stream;
						video.srcObject = stream;
						if (!hasPopulated) {
							await populateCameras();
							hasPopulated = true;
						}
					} catch (e) {
						console.error('Fallback camera error:', e);
					}
				}
			}
		}

		/* Get list of cameras and populate the select */
		async function populateCameras(preferId) {
			try {
				const devices = await navigator.mediaDevices.enumerateDevices();
				const cams = devices.filter(d => d.kind === 'videoinput');

				cameraSelect.innerHTML = '';
				cams.forEach((cam, idx) => {
					const opt = document.createElement('option');
					// Safari/iOS sometimes gives empty labels until permission is granted
					let label = cam.label || `Camera ${idx+1}`;
					// Helpful hint: try to label likely front/back when available
					const lower = label.toLowerCase();
					if (!cam.label && cams.length === 2) {
						label = idx === 0 ? 'Camera 1' : 'Camera 2';
					} else if (lower.includes('back') || lower.includes('rear')) {
						label += ' (Back)';
					} else if (lower.includes('front') || lower.includes('user') || lower.includes('true')) {
						label += ' (Front)';
					}
					opt.textContent = label;
					opt.value = cam.deviceId;
					cameraSelect.appendChild(opt);
				});

				cameraSelect.disabled = cams.length === 0;

				// Select preferred camera if present
				const want = preferId || loadCameraPref();
				if (want && cams.some(c => c.deviceId === want)) {
					cameraSelect.value = want;
				} else if (cams.length) {
					// Keep current active device if we can detect it
					const activeTrack = currentStream?.getVideoTracks?.()[0];
					const settings = activeTrack?.getSettings?.();
					if (settings?.deviceId && cams.some(c => c.deviceId === settings.deviceId)) {
						cameraSelect.value = settings.deviceId;
					} else {
						cameraSelect.value = cams[0].deviceId;
					}
				}
			} catch (err) {
				console.error('enumerateDevices error:', err);
				cameraSelect.innerHTML = '<option>Unavailable</option>';
				cameraSelect.disabled = true;
			}
		}

		/* Remember mirror preference */
		(function initMirrorPref() {
			const saved = localStorage.getItem(LS_KEYS.mirror);
			if (saved !== null) mirrorToggle.checked = saved === '1';
			mirrorToggle.addEventListener('change', () => {
				localStorage.setItem(LS_KEYS.mirror, mirrorToggle.checked ? '1' : '0');
			});
		})();

		function saveCameraPref(id) {
			if (id) localStorage.setItem(LS_KEYS.camera, id);
		}

		function loadCameraPref() {
			return localStorage.getItem(LS_KEYS.camera) || null;
		}

		/* Quantise (r,g,b) into 6×6×6 colour cube */
		function quantizeTo8bit(r, g, b) {
			const r6 = Math.round(r / 255 * 5),
				g6 = Math.round(g / 255 * 5),
				b6 = Math.round(b / 255 * 5);
			return {
				r: Math.floor(r6 * 255 / 5),
				g: Math.floor(g6 * 255 / 5),
				b: Math.floor(b6 * 255 / 5)
			};
		}

		/* Main render loop */
		function drawAscii() {
			const cell = getCellSize();
			const w = Math.floor(video.videoWidth / cell);
			const h = Math.floor(video.videoHeight / cell);
			if (w <= 0 || h <= 0) { requestAnimationFrame(drawAscii); return; }

			canvas.width = w;
			canvas.height = h;
			const ctx = canvas.getContext('2d');

			// Draw the video frame into the canvas (mirrored or not)
			ctx.save();
			if (mirrorToggle.checked) {
				ctx.translate(w, 0);
				ctx.scale(-1, 1); // horizontal flip
			}
			ctx.drawImage(video, 0, 0, w, h);
			ctx.restore();

			const data = ctx.getImageData(0, 0, w, h).data;

			let html = '';
			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const i = (y * w + x) * 4,
						r = data[i],
						g = data[i + 1],
						b = data[i + 2],
						brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255,
						char = charRamp.charAt(Math.floor((charRamp.length - 1) * (1 - brightness))),
						{ r: rq, g: gq, b: bq } = quantizeTo8bit(r, g, b);
					html += `<span style="color:rgb(${rq},${gq},${bq})">${char}</span>`;
				}
				html += '<br/>';
			}
			asciiDiv.innerHTML = html;
			requestAnimationFrame(drawAscii);
		}

		/* ---------- events ---------- */
		video.addEventListener('playing', drawAscii);
		resolutionRange.addEventListener('input', updateFont);

		captureBtn.addEventListener('click', () => {
			const txt = asciiDiv.innerText; // plain ASCII
			const blob = new Blob([txt], { type: 'text/plain' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'ascii_capture.txt';
			a.click();
			URL.revokeObjectURL(a.href);
		});

		// Switch camera when user changes selection
		cameraSelect.addEventListener('change', async () => {
			const id = cameraSelect.value;
			saveCameraPref(id);
			await startCamera(id);
		});

		// If devices are added/removed, refresh the list
		if (navigator.mediaDevices && 'addEventListener' in navigator.mediaDevices) {
			navigator.mediaDevices.addEventListener('devicechange', async () => {
				const activeId = cameraSelect.value;
				await populateCameras(activeId);
			});
		}

		/* ---------- kick-off ---------- */
		(async function init() {
			updateFont(); // set initial font size

			// On first load, request the last used camera if any, else default
			const preferred = loadCameraPref();
			await startCamera(preferred);

			// After permission, ensure device labels are populated
			await populateCameras(preferred);
		})();
	</script>
</body>

</html>