<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Live ASCII Camera with 8-bit Color</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<script>
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('/sw.js')
					.catch((err) => console.log('Service Worker registration failed', err));
			});
		}
	</script>
	<style>
		* {
			box-sizing: border-box;
		}

		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
			color: #e0e0e0;
			font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
			margin: 0;
			min-height: 100vh;
			overflow-x: hidden;
			padding: 1rem;
		}

		.header {
			text-align: center;
			margin-bottom: 1.5rem;
		}

		h1 {
			font-size: clamp(1.2rem, 4vw, 1.8rem);
			font-weight: 600;
			background: linear-gradient(135deg, #00d4ff, #7c3aed, #f472b6);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			margin: 0 0 0.5rem 0;
			letter-spacing: -0.5px;
		}

		.subtitle {
			color: #666;
			font-size: 0.85rem;
			margin: 0;
		}

		#controls {
			background: rgba(255, 255, 255, 0.03);
			border: 1px solid rgba(255, 255, 255, 0.08);
			border-radius: 16px;
			padding: 1rem 1.5rem;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 1.5rem;
			flex-wrap: wrap;
			backdrop-filter: blur(10px);
			box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
			max-width: 100%;
		}

		.control-group {
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.control-label {
			font-size: 0.8rem;
			color: #888;
			text-transform: uppercase;
			letter-spacing: 0.5px;
			font-weight: 500;
		}

		/* Custom range slider */
		input[type=range] {
			-webkit-appearance: none;
			appearance: none;
			width: 120px;
			height: 6px;
			background: linear-gradient(90deg, #2a2a4a, #3a3a5a);
			border-radius: 3px;
			outline: none;
			cursor: pointer;
		}

		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 18px;
			height: 18px;
			background: linear-gradient(135deg, #00d4ff, #7c3aed);
			border-radius: 50%;
			cursor: pointer;
			box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
			transition: transform 0.2s ease, box-shadow 0.2s ease;
		}

		input[type=range]::-webkit-slider-thumb:hover {
			transform: scale(1.15);
			box-shadow: 0 2px 12px rgba(0, 212, 255, 0.6);
		}

		input[type=range]::-moz-range-thumb {
			width: 18px;
			height: 18px;
			background: linear-gradient(135deg, #00d4ff, #7c3aed);
			border-radius: 50%;
			cursor: pointer;
			border: none;
			box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
		}

		/* Custom checkbox */
		.toggle-wrapper {
			position: relative;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		input[type=checkbox] {
			-webkit-appearance: none;
			appearance: none;
			width: 44px;
			height: 24px;
			background: #2a2a4a;
			border-radius: 12px;
			cursor: pointer;
			position: relative;
			transition: background 0.3s ease;
		}

		input[type=checkbox]::after {
			content: '';
			position: absolute;
			top: 3px;
			left: 3px;
			width: 18px;
			height: 18px;
			background: #666;
			border-radius: 50%;
			transition: transform 0.3s ease, background 0.3s ease;
		}

		input[type=checkbox]:checked {
			background: linear-gradient(135deg, #00d4ff, #7c3aed);
		}

		input[type=checkbox]:checked::after {
			transform: translateX(20px);
			background: #fff;
		}

		/* Custom select */
		select {
			background: #1a1a2e;
			color: #e0e0e0;
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 8px;
			padding: 0.5rem 2rem 0.5rem 0.75rem;
			font-size: 0.85rem;
			font-family: inherit;
			cursor: pointer;
			outline: none;
			transition: border-color 0.2s ease, box-shadow 0.2s ease;
			-webkit-appearance: none;
			appearance: none;
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
			background-repeat: no-repeat;
			background-position: right 0.75rem center;
		}

		select:hover,
		select:focus {
			border-color: rgba(0, 212, 255, 0.5);
			box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
		}

		/* Button styling */
		button {
			background: linear-gradient(135deg, #7c3aed, #5b21b6);
			color: #fff;
			border: none;
			border-radius: 8px;
			padding: 0.6rem 1.2rem;
			font-size: 0.85rem;
			font-family: inherit;
			font-weight: 500;
			cursor: pointer;
			transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
			display: flex;
			align-items: center;
			gap: 0.4rem;
		}

		button:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 16px rgba(124, 58, 237, 0.4);
			background: linear-gradient(135deg, #8b5cf6, #6d28d9);
		}

		button:active {
			transform: translateY(0);
		}

		button svg {
			width: 16px;
			height: 16px;
		}

		/* ASCII display area */
		#ascii {
			margin-top: 1.25rem;
			padding: 0.5rem;
			border-radius: 12px;
			background: rgba(0, 0, 0, 0.3);
			box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
		}

		video,
		canvas {
			display: none;
		}

		/* each ASCII "pixel" lives in a span so we can colour it */
		span {
			display: inline-block;
			width: .65em;
		}

		footer {
			margin-top: auto;
			padding-top: 1rem;
			font-size: 0.8rem;
			text-align: center;
			color: #444;
		}

		footer a {
			color: #7c3aed;
			text-decoration: none;
			transition: color 0.2s ease;
		}

		footer a:hover {
			color: #a78bfa;
			text-decoration: underline;
		}

		/* Mobile optimizations */
		@media (max-width: 600px) {
			body {
				padding: 0.75rem;
			}

			#controls {
				padding: 0.75rem 1rem;
				gap: 1rem;
			}

			.control-group {
				width: 100%;
				justify-content: space-between;
			}

			input[type=range] {
				width: 100px;
			}

			select {
				flex: 1;
				max-width: 180px;
			}

			button {
				width: 100%;
				justify-content: center;
			}
		}

		@media (pointer: coarse) {
			button,
			select {
				min-height: 44px;
				touch-action: manipulation;
			}

			input[type=range] {
				height: 44px;
			}

			input[type=checkbox] {
				width: 50px;
				height: 28px;
			}

			input[type=checkbox]::after {
				width: 22px;
				height: 22px;
			}

			input[type=checkbox]:checked::after {
				transform: translateX(22px);
			}
		}
	</style>
</head>

<body>
	<div class="header">
		<h1>ASCII Camera</h1>
		<p class="subtitle">Live webcam to ASCII art with 8-bit color</p>
	</div>

	<div id="controls">
		<div class="control-group">
			<span class="control-label">Resolution</span>
			<input type="range" id="resolutionRange" min="2" max="14" value="10" />
		</div>

		<div class="control-group toggle-wrapper">
			<span class="control-label">Mirror</span>
			<input type="checkbox" id="mirrorToggle" checked />
		</div>

		<div class="control-group">
			<span class="control-label">Camera</span>
			<select id="cameraSelect" disabled>
				<option>Loading…</option>
			</select>
		</div>

		<button id="captureBtn">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
				<polyline points="7 10 12 15 17 10"/>
				<line x1="12" y1="15" x2="12" y2="3"/>
			</svg>
			Capture
		</button>
	</div>

	<div id="ascii"></div>

	<video id="video" autoplay playsinline></video>
	<canvas id="canvas"></canvas>

	<footer>
		<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support</a>
	</footer>

	<script>
		/* ---------- DOM handles ---------- */
		const video = document.getElementById('video');
		const canvas = document.getElementById('canvas');
		const asciiDiv = document.getElementById('ascii');
		const resolutionRange = document.getElementById('resolutionRange');
		const captureBtn = document.getElementById('captureBtn');
		const mirrorToggle = document.getElementById('mirrorToggle');
		const cameraSelect = document.getElementById('cameraSelect');

		/* ---------- constants ---------- */
		const charRamp = "@$B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\"^`'. ";
		const MIN_CELL = 2; // smallest block (highest detail)
		const MAX_CELL = 20; // largest block  (lowest detail)
		const LS_KEYS = {
			mirror: 'asciiCam-mirror',
			camera: 'asciiCam-cameraId'
		};

		let currentStream = null;
		let hasPopulated = false;
		let hasStartedDraw = false;

		/* Map slider value (2–20) so that 20→2, 2→20 */
		function getCellSize() {
			const val = +resolutionRange.value;
			return MAX_CELL - (val - MIN_CELL);
		}

		/* Keep the panel’s footprint fixed by resizing font/line-height */
		function updateFont() {
			const sz = getCellSize();
			asciiDiv.style.fontSize = sz + 'px';
			asciiDiv.style.lineHeight = sz + 'px';
		}

		/* Stop any existing stream tracks */
		function stopCurrentStream() {
			if (currentStream) {
				currentStream.getTracks().forEach(t => t.stop());
				currentStream = null;
			}
		}

		/* Start webcam, optionally by deviceId */
		async function startCamera(deviceId) {
			try {
				stopCurrentStream();
				// Prefer exact deviceId if provided, else default to facingMode:user (front camera on phones)
				const constraints = {
					video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: 'user' }
				};
				const stream = await navigator.mediaDevices.getUserMedia(constraints);
				currentStream = stream;
				video.srcObject = stream;
				video.muted = true;
				video.playsInline = true;
				try {
					await video.play();
				} catch (playErr) {
					console.warn('Video play was blocked:', playErr);
				}
				startDrawLoop();

				// On first successful start, populate device list (labels need permission)
				if (!hasPopulated) {
					await populateCameras(deviceId || loadCameraPref());
					hasPopulated = true;
				}
			} catch (err) {
				console.error('Camera error:', err);
				// If exact deviceId failed, try default
				if (deviceId) {
					try {
						const stream = await navigator.mediaDevices.getUserMedia({ video: true });
						currentStream = stream;
						video.srcObject = stream;
						video.muted = true;
						video.playsInline = true;
						try {
							await video.play();
						} catch (playErr) {
							console.warn('Video play was blocked:', playErr);
						}
						startDrawLoop();
						if (!hasPopulated) {
							await populateCameras();
							hasPopulated = true;
						}
					} catch (e) {
						console.error('Fallback camera error:', e);
					}
				}
			}
		}

		/* Get list of cameras and populate the select */
		async function populateCameras(preferId) {
			try {
				const devices = await navigator.mediaDevices.enumerateDevices();
				const cams = devices.filter(d => d.kind === 'videoinput');

				cameraSelect.innerHTML = '';
				cams.forEach((cam, idx) => {
					const opt = document.createElement('option');
					// Safari/iOS sometimes gives empty labels until permission is granted
					let label = cam.label || `Camera ${idx+1}`;
					// Helpful hint: try to label likely front/back when available
					const lower = label.toLowerCase();
					if (!cam.label && cams.length === 2) {
						label = idx === 0 ? 'Camera 1' : 'Camera 2';
					} else if (lower.includes('back') || lower.includes('rear')) {
						label += ' (Back)';
					} else if (lower.includes('front') || lower.includes('user') || lower.includes('true')) {
						label += ' (Front)';
					}
					opt.textContent = label;
					opt.value = cam.deviceId;
					cameraSelect.appendChild(opt);
				});

				cameraSelect.disabled = cams.length === 0;

				// Select preferred camera if present
				const want = preferId || loadCameraPref();
				if (want && cams.some(c => c.deviceId === want)) {
					cameraSelect.value = want;
				} else if (cams.length) {
					// Keep current active device if we can detect it
					const activeTrack = currentStream?.getVideoTracks?.()[0];
					const settings = activeTrack?.getSettings?.();
					if (settings?.deviceId && cams.some(c => c.deviceId === settings.deviceId)) {
						cameraSelect.value = settings.deviceId;
					} else {
						cameraSelect.value = cams[0].deviceId;
					}
				}
			} catch (err) {
				console.error('enumerateDevices error:', err);
				cameraSelect.innerHTML = '<option>Unavailable</option>';
				cameraSelect.disabled = true;
			}
		}

		/* Remember mirror preference */
		(function initMirrorPref() {
			const saved = localStorage.getItem(LS_KEYS.mirror);
			if (saved !== null) mirrorToggle.checked = saved === '1';
			mirrorToggle.addEventListener('change', () => {
				localStorage.setItem(LS_KEYS.mirror, mirrorToggle.checked ? '1' : '0');
			});
		})();

		function saveCameraPref(id) {
			if (id) localStorage.setItem(LS_KEYS.camera, id);
		}

		function loadCameraPref() {
			return localStorage.getItem(LS_KEYS.camera) || null;
		}

		/* Quantise (r,g,b) into 6×6×6 colour cube */
		function quantizeTo8bit(r, g, b) {
			const r6 = Math.round(r / 255 * 5),
				g6 = Math.round(g / 255 * 5),
				b6 = Math.round(b / 255 * 5);
			return {
				r: Math.floor(r6 * 255 / 5),
				g: Math.floor(g6 * 255 / 5),
				b: Math.floor(b6 * 255 / 5)
			};
		}

		/* Main render loop */
		function drawAscii() {
			const cell = getCellSize();
			const w = Math.floor(video.videoWidth / cell);
			const h = Math.floor(video.videoHeight / cell);
			if (w <= 0 || h <= 0) { requestAnimationFrame(drawAscii); return; }

			canvas.width = w;
			canvas.height = h;
			const ctx = canvas.getContext('2d');

			// Draw the video frame into the canvas (mirrored or not)
			ctx.save();
			if (mirrorToggle.checked) {
				ctx.translate(w, 0);
				ctx.scale(-1, 1); // horizontal flip
			}
			ctx.drawImage(video, 0, 0, w, h);
			ctx.restore();

			const data = ctx.getImageData(0, 0, w, h).data;

			let html = '';
			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const i = (y * w + x) * 4,
						r = data[i],
						g = data[i + 1],
						b = data[i + 2],
						brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255,
						char = charRamp.charAt(Math.floor((charRamp.length - 1) * (1 - brightness))),
						{ r: rq, g: gq, b: bq } = quantizeTo8bit(r, g, b);
					html += `<span style="color:rgb(${rq},${gq},${bq})">${char}</span>`;
				}
				html += '<br/>';
			}
			asciiDiv.innerHTML = html;
			requestAnimationFrame(drawAscii);
		}

		function startDrawLoop() {
			if (hasStartedDraw) return;
			hasStartedDraw = true;
			requestAnimationFrame(drawAscii);
		}

		/* ---------- events ---------- */
		video.addEventListener('playing', startDrawLoop);
		video.addEventListener('loadedmetadata', startDrawLoop);
		video.addEventListener('canplay', startDrawLoop);
		resolutionRange.addEventListener('input', updateFont);

		captureBtn.addEventListener('click', () => {
			const txt = asciiDiv.innerText; // plain ASCII
			const blob = new Blob([txt], { type: 'text/plain' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'ascii_capture.txt';
			a.click();
			URL.revokeObjectURL(a.href);
		});

		// Switch camera when user changes selection
		cameraSelect.addEventListener('change', async () => {
			const id = cameraSelect.value;
			saveCameraPref(id);
			await startCamera(id);
		});

		// If devices are added/removed, refresh the list
		if (navigator.mediaDevices && 'addEventListener' in navigator.mediaDevices) {
			navigator.mediaDevices.addEventListener('devicechange', async () => {
				const activeId = cameraSelect.value;
				await populateCameras(activeId);
			});
		}

		/* ---------- kick-off ---------- */
		(async function init() {
			updateFont(); // set initial font size

			// On first load, request the last used camera if any, else default
			const preferred = loadCameraPref();
			await startCamera(preferred);

			// After permission, ensure device labels are populated
			await populateCameras(preferred);
		})();
	</script>
</body>

</html>
