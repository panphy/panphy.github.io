<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dodge the Asteroids</title>
  <link rel="icon" type="image/png" href="/favicon.png">
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .catch((err) => console.log('Service Worker registration failed', err));
      });
    }
  </script>
  <style>
    /* Reset and Body Styling */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: url('') no-repeat center center fixed;
      background-size: cover;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      padding: 20px;
    }

    a {
      color: #ffc107;
      text-decoration: none;
      transition: color 0.2s ease, text-shadow 0.2s ease;
    }

    a:hover {
      color: #ffeb3b;
      text-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
    }

    a:visited {
      color: #ffc107;
    }

    /* Overlay for dimming the background */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, rgba(10, 15, 30, 0.8) 100%);
      pointer-events: none;
      z-index: -1;
    }

    /* Main Container */
    #container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      max-width: 1100px;
      width: 100%;
      position: relative;
      z-index: 1;
      gap: 24px;
    }

    /* Top Scores Section */
    #topScores {
      flex: 0 0 180px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px 16px;
      text-align: center;
    }

    #topScores h1 {
      font-size: 1.1em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #ffc107;
      text-shadow: 0 0 12px rgba(255, 193, 7, 0.4);
      border-bottom: none;
      padding-bottom: 12px;
      margin: 0 0 12px 0;
      position: relative;
    }

    #topScores h1::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ffc107, transparent);
    }

    #topScores ol {
      list-style: none;
      padding: 0;
      margin: 0;
      counter-reset: score-counter;
    }

    #topScores li {
      font-size: 1.1em;
      text-align: center;
      padding: 10px 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      counter-increment: score-counter;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: background 0.2s ease;
    }

    #topScores li:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    #topScores li::before {
      content: counter(score-counter) ".";
      color: rgba(255, 193, 7, 0.7);
      font-weight: 600;
      min-width: 24px;
    }

    #topScores li:last-child {
      border-bottom: none;
    }

    #topScores li:first-child {
      color: #ffd54f;
      font-weight: 600;
    }

    /* Game Section */
    #gameContainer {
      flex: 1;
      max-width: 750px;
      text-align: center;
    }

    #gameContainer h1 {
      font-size: 2.2em;
      font-weight: 700;
      color: #4ade80;
      text-shadow: 0 0 20px rgba(74, 222, 128, 0.5), 0 0 40px rgba(74, 222, 128, 0.2);
      margin: 0 0 16px 0;
      letter-spacing: 1px;
    }

    /* Canvas Wrapper for glow effect */
    .canvas-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
      max-width: 700px;
      border-radius: 14px;
      padding: 3px;
      background: linear-gradient(135deg, #4ade80, #22c55e, #16a34a);
    }

    .canvas-wrapper::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, #4ade80, #22c55e, #16a34a);
      border-radius: 16px;
      z-index: -1;
      filter: blur(12px);
      opacity: 0.6;
    }

    /* Responsive Canvas Styling */
    #gameContainer canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 3 / 2;
      border-radius: 12px;
      display: block;
      touch-action: none;
      -ms-touch-action: none;
      background: #0a0f1e;
    }

    /* Instructions */
    .instructions {
      margin-top: 20px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .instructions p {
      font-size: 0.95em;
      margin: 6px 0;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.8);
    }

    .instructions p:first-child {
      margin-top: 0;
    }

    .instructions p:last-child {
      margin-bottom: 0;
    }

    .instructions .key {
      display: inline-block;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      padding: 2px 8px;
      font-size: 0.9em;
      font-weight: 500;
      color: #ffc107;
      margin: 0 2px;
    }

    .instructions .highlight {
      color: #f87171;
      font-weight: 500;
    }

    /* Footer */
    .footer {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .footer p {
      font-size: 0.9em;
      color: rgba(255, 255, 255, 0.6);
      margin: 0;
    }

    /* Responsive Design */
    @media (max-width: 900px) {
      #container {
        flex-direction: column;
        align-items: center;
      }

      #topScores {
        flex: none;
        width: 100%;
        max-width: 400px;
        order: 2;
        margin-top: 24px;
      }

      #topScores ol {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
      }

      #topScores li {
        flex: 0 0 auto;
        padding: 8px 16px;
        border-bottom: none;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
      }

      #topScores li:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      #gameContainer {
        order: 1;
        width: 100%;
      }

      #gameContainer h1 {
        font-size: 1.8em;
      }
    }

    @media (max-width: 500px) {
      body {
        padding: 12px;
      }

      #gameContainer h1 {
        font-size: 1.5em;
        margin-bottom: 12px;
      }

      .instructions {
        padding: 12px 14px;
      }

      .instructions p {
        font-size: 0.85em;
      }
    }
  </style>
</head>

<body>
  <!-- Background overlay (for dimming) -->
  <div id="overlay"></div>

  <div id="container">
    <!-- Top Scores Section -->
    <div id="topScores">
      <h1>Top Scores</h1>
      <ol id="scoreList">
      </ol>
    </div>

    <!-- Game Section -->
    <div id="gameContainer">
      <h1>Dodge the Asteroids</h1>
      <div class="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
      </div>
      <div class="instructions">
        <p>Use <span class="key">Arrow Keys</span> or <span class="key">Drag</span> the spaceship to move. Avoid the <span class="highlight">asteroids</span>!</p>
        <p>Press <span class="key">Enter</span> or <span class="key">Tap</span> the canvas to restart after Game Over.</p>
      </div>
      <div class="footer">
        <p>&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
          <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
        </p>
      </div>
    </div>
  </div>

  <script>
    /* -----------------------------------------------------------
     * Base Canvas Size and Scaling Factors
     * -----------------------------------------------------------
     */
    const BASE_WIDTH = 600;
    const BASE_HEIGHT = 400;
    let scaleX = 1;
    let scaleY = 1;

    function updateScaleFactors() {
      scaleX = SCREEN_WIDTH / BASE_WIDTH;
      scaleY = SCREEN_HEIGHT / BASE_HEIGHT;
    }

    /* -----------------------------------------------------------
     * Responsive Canvas Setup
     * -----------------------------------------------------------
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Initial dimensions (will be updated)
    let SCREEN_WIDTH = 600;
    let SCREEN_HEIGHT = 400;

    function resizeCanvas() {
      // Get the device pixel ratio, falling back to 1.
      const dpr = window.devicePixelRatio || 1;

      // Get the size the canvas is being displayed.
      const rect = canvas.getBoundingClientRect();

      // Set the internal size of the canvas to match the displayed size * device pixel ratio.
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      // Scale the drawing context to account for the device pixel ratio.
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Update game variables based on the new size
      SCREEN_WIDTH = rect.width;
      SCREEN_HEIGHT = rect.height;

      // Update scaling factors
      updateScaleFactors();

      // Update existing game elements
      if (player) player.updateScale();
      updateAsteroidsScale();

      // Optionally, reset the game
      // resetGame(); // Uncomment if you want to reset on resize
    }

    // Initial resize and render top scores from local storage
    window.addEventListener('load', () => {
      resizeCanvas();
      renderTopScores();
      if (assetsLoaded === 3) {
        resetGame();
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      resizeCanvas();
    });

    /* -----------------------------------------------------------
     * Global Variables
     * -----------------------------------------------------------
     */

    // Images
    const backgroundImg = new Image();
    backgroundImg.src = 'dodge_canvas.png';
    const spaceshipImg = new Image();
    spaceshipImg.src = 'dodge_spaceship.png';
    const asteroidImg = new Image();
    asteroidImg.src = 'dodge_asteroid.png';

    // Preload the background image
    const preloadedBkgrd = new Image();
    preloadedBkgrd.src = 'dodge_bkgrd.webp';
    preloadedBkgrd.onload = () => {
      // Once the background image is loaded, set it as the background
      document.body.style.backgroundImage = "url('dodge_bkgrd.webp')";
    };

    let gameOver = false;
    let score = 0;
    let asteroids = [];
    let player;
    let keys = {};
    let animationId;
    let speedIntervalId;
    // Use localStorage for top scores with a game-specific key
    let topScores = JSON.parse(localStorage.getItem("dodgeTheAsteroids_topScores") || "[]");

    // Asteroid spawn & speed parameters
    let MIN_ASTEROID_SPEED = 2;
    let MAX_ASTEROID_SPEED = 6;
    let asteroidSpawnRate = 3;
    const speedIncreaseInterval = 1500; // 1.5 seconds

    // Pointer control variables
    let isPointerDown = false;
    let pointerStartX = 0;
    let pointerStartY = 0;
    let spaceshipStartX = 0;
    let spaceshipStartY = 0;

    // We track when all images are loaded
    let assetsLoaded = 0;

    /* -----------------------------------------------------------
     * Background Scrolling Variables
     * -----------------------------------------------------------
     * backgroundOffsetY: the vertical offset
     * backgroundScrollSpeed: how fast the background scrolls.
     * Adjust backgroundScrollSpeed to make the rolling faster or slower.
     */
    let backgroundOffsetY = 0;
    let backgroundScrollSpeed = 2; // <-- Adjust this value to control background rolling speed

    /* -----------------------------------------------------------
     * Spaceship Class
     * -----------------------------------------------------------
     */
    class Spaceship {
      constructor() {
        // Base dimensions based on BASE_WIDTH and BASE_HEIGHT
        this.baseWidth = 50;
        this.baseHeight = 50;
        this.baseRadius = 15;
        this.baseSpeed = 5;

        // Apply scaling
        this.width = this.baseWidth * scaleX;
        this.height = this.baseHeight * scaleY;
        this.radius = this.baseRadius * ((scaleX + scaleY) / 2); // Average scaling
        this.speed = this.baseSpeed * ((scaleX + scaleY) / 2); // Average scaling

        // Start at center
        this.x = SCREEN_WIDTH / 2;
        this.y = SCREEN_HEIGHT / 2;
      }

      updateScale() {
        this.width = this.baseWidth * scaleX;
        this.height = this.baseHeight * scaleY;
        this.radius = this.baseRadius * ((scaleX + scaleY) / 2);
        this.speed = this.baseSpeed * ((scaleX + scaleY) / 2);
      }

      move() {
        let deltaX = 0;
        let deltaY = 0;

        if (keys['ArrowLeft']) {
          deltaX -= 1;
        }
        if (keys['ArrowRight']) {
          deltaX += 1;
        }
        if (keys['ArrowUp']) {
          deltaY -= 1;
        }
        if (keys['ArrowDown']) {
          deltaY += 1;
        }

        if (deltaX !== 0 || deltaY !== 0) {
          const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const normX = (deltaX / magnitude) * this.speed;
          const normY = (deltaY / magnitude) * this.speed;

          const newX = this.x + normX;
          const newY = this.y + normY;

          // Boundary checks
          if (newX - this.radius >= 0 && newX + this.radius <= SCREEN_WIDTH) {
            this.x = newX;
          }
          if (newY - this.radius >= 0 && newY + this.radius <= SCREEN_HEIGHT) {
            this.y = newY;
          }
        }
      }

      setPosition(newX, newY) {
        this.x = newX;
        this.y = newY;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(
          spaceshipImg,
          -this.width / 2,
          -this.height / 2,
          this.width,
          this.height
        );
        ctx.restore();
      }
    }

    /* -----------------------------------------------------------
     * Asteroid Class
     * -----------------------------------------------------------
     */
    class Asteroid {
      constructor() {
        // Base dimensions
        this.baseSize = 32; // Base width and height
        this.baseRadius = (this.baseSize + this.baseSize) / 4; // As per original calculation
        this.spawn();
        this.baseSpeed =
          Math.random() * (MAX_ASTEROID_SPEED - MIN_ASTEROID_SPEED) + MIN_ASTEROID_SPEED;
        // Random speed between MIN and MAX, scaled
        this.speed = this.baseSpeed * ((scaleX + scaleY) / 2);

        // Random rotation angle + spin speed
        this.angle = Math.random() * 2 * Math.PI;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;

        // Random scale for the asteroid (0.5x to 2x) based on current scaling
        this.scale = (0.5 + Math.random() * 1.5) * ((scaleX + scaleY) / 2);
        this.width = this.baseSize * this.scale;
        this.height = this.baseSize * this.scale;
        this.radius = (this.width + this.height) / 4;
      }

      updateScale() {
        this.scale = (0.5 + Math.random() * 1.5) * ((scaleX + scaleY) / 2);
        this.width = this.baseSize * this.scale;
        this.height = this.baseSize * this.scale;
        this.radius = (this.width + this.height) / 4;
        this.speed = this.baseSpeed * ((scaleX + scaleY) / 2);
      }

      spawn() {
        const edge = Math.floor(Math.random() * 4);
        switch (edge) {
          case 0: // Top
            this.x = Math.random() * SCREEN_WIDTH;
            this.y = -40 * scaleY;
            break;
          case 1: // Bottom
            this.x = Math.random() * SCREEN_WIDTH;
            this.y = SCREEN_HEIGHT + 40 * scaleY;
            break;
          case 2: // Left
            this.x = -40 * scaleX;
            this.y = Math.random() * SCREEN_HEIGHT;
            break;
          case 3: // Right
            this.x = SCREEN_WIDTH + 40 * scaleX;
            this.y = Math.random() * SCREEN_HEIGHT;
            break;
        }
        const angle = Math.random() * 2 * Math.PI;
        this.dx = Math.cos(angle);
        this.dy = Math.sin(angle);
      }

      move() {
        this.x += this.dx * this.speed;
        this.y += this.dy * this.speed;
        this.angle += this.rotationSpeed;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.drawImage(
          asteroidImg,
          -this.width / 2,
          -this.height / 2,
          this.width,
          this.height
        );
        ctx.restore();
      }

      isOffScreen() {
        return (
          this.x < -100 * scaleX ||
          this.x > SCREEN_WIDTH + 100 * scaleX ||
          this.y < -100 * scaleY ||
          this.y > SCREEN_HEIGHT + 100 * scaleY
        );
      }
    }

    /* -----------------------------------------------------------
     * Asset Loading
     * -----------------------------------------------------------
     */
    function startIfReady() {
      assetsLoaded++;
      if (assetsLoaded === 3) {
        // Once all images are loaded, start the game
        resetGame();
      }
    }

    backgroundImg.onload = () => {
      startIfReady();
      if (animationId) {
        drawRollingBackground();
      }
    };
    spaceshipImg.onload = startIfReady;
    asteroidImg.onload = startIfReady;

    /* -----------------------------------------------------------
     * Input Handlers
     * -----------------------------------------------------------
     */
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault(); // Prevent scrolling
        keys[e.key] = true;
      }

      if (gameOver && e.key === 'Enter') {
        resetGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        keys[e.key] = false;
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (!player) {
        return;
      }
      if (gameOver) {
        e.preventDefault();
        resetGame();
        return;
      }
      e.preventDefault();
      isPointerDown = true;
      pointerStartX = e.clientX;
      pointerStartY = e.clientY;
      spaceshipStartX = player.x;
      spaceshipStartY = player.y;
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!player) {
        return;
      }
      if (isPointerDown && !gameOver) {
        e.preventDefault();
        const deltaX = e.clientX - pointerStartX;
        const deltaY = e.clientY - pointerStartY;
        let newX = spaceshipStartX + deltaX;
        let newY = spaceshipStartY + deltaY;

        newX = Math.max(player.radius, Math.min(SCREEN_WIDTH - player.radius, newX));
        newY = Math.max(player.radius, Math.min(SCREEN_HEIGHT - player.radius, newY));
        player.setPosition(newX, newY);
      }
    }, { passive: false });

    canvas.addEventListener('pointerup', (e) => {
      if (isPointerDown) {
        e.preventDefault();
        isPointerDown = false;
      }
    }, { passive: false });

    canvas.addEventListener('pointercancel', (e) => {
      if (isPointerDown) {
        e.preventDefault();
        isPointerDown = false;
      }
    }, { passive: false });

    /* -----------------------------------------------------------
     * Collision Detection
     * -----------------------------------------------------------
     */
    function checkCollision(ship, asteroid) {
      const dx = ship.x - asteroid.x;
      const dy = ship.y - asteroid.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < ship.radius + asteroid.radius;
    }

    /* -----------------------------------------------------------
     * Game Logic
     * -----------------------------------------------------------
     */
    function resetGame() {
      player = new Spaceship();
      asteroids = [];
      score = 0;
      asteroidSpawnRate = 3;
      MIN_ASTEROID_SPEED = 2;
      MAX_ASTEROID_SPEED = 7;
      gameOver = false;

      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      if (speedIntervalId) {
        clearInterval(speedIntervalId);
      }
      speedIntervalId = setInterval(() => {
        MIN_ASTEROID_SPEED += 0.1;
        MAX_ASTEROID_SPEED += 0.2;
      }, speedIncreaseInterval);
      gameLoop();
    }

    function updateTopScores(newScore) {
      topScores.push(newScore);
      topScores.sort((a, b) => b - a);
      topScores = topScores.slice(0, 5);
      localStorage.setItem("dodgeTheAsteroids_topScores", JSON.stringify(topScores));
      renderTopScores();
    }

    function renderTopScores() {
      const scoreList = document.getElementById('scoreList');
      scoreList.innerHTML = '';
      topScores.forEach((sc) => {
        const li = document.createElement('li');
        li.textContent = sc;
        scoreList.appendChild(li);
      });
    }

    /* -----------------------------------------------------------
     * Update Existing Asteroids on Resize
     * -----------------------------------------------------------
     */
    function updateAsteroidsScale() {
      asteroids.forEach((asteroid) => {
        asteroid.updateScale();
      });
    }

    /* -----------------------------------------------------------
     * Rolling Background Function
     * -----------------------------------------------------------
     * We shift the background image down by backgroundOffsetY
     * each frame. Once offset >= backgroundImg.height, reset it
     * to 0 to create a seamless rolling effect.
     */
    function drawRollingBackground() {
      if (!backgroundImg.complete || backgroundImg.width === 0) {
        return;
      }
      // Increase the offset to "scroll" the background
      backgroundOffsetY += backgroundScrollSpeed * ((scaleX + scaleY) / 2);

      // Once it passes the image's height, wrap around
      if (backgroundOffsetY >= backgroundImg.height) {
        backgroundOffsetY = 0;
      }

      // Draw the tiled background in vertical strips
      for (let y = -backgroundImg.height; y < SCREEN_HEIGHT; y += backgroundImg.height) {
        for (let x = 0; x < SCREEN_WIDTH; x += backgroundImg.width) {
          ctx.drawImage(backgroundImg, x, y + backgroundOffsetY, backgroundImg.width, backgroundImg.height);
        }
      }
    }

    /* -----------------------------------------------------------
     * The main game loop
     * -----------------------------------------------------------
     */
    function gameLoop() {
      if (!gameOver) {
        ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        // 1) Draw the rolling background
        drawRollingBackground();

        // 2) Increase and display score
        score++;
        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${18 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.fillText('Score: ' + score, 10, 20);

        // 3) Move and draw the spaceship
        player.move();
        player.draw();

        // 4) Spawn asteroids
        if (Math.random() * 100 < asteroidSpawnRate) {
          asteroids.push(new Asteroid());
        }

        // 5) Update and draw asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const m = asteroids[i];
          m.move();
          m.draw();

          // Collision?
          if (checkCollision(player, m)) {
            gameOver = true;
            updateTopScores(score);
            if (speedIntervalId) {
              clearInterval(speedIntervalId);
              speedIntervalId = null;
            }
          }

          // Remove if off screen
          if (m.isOffScreen()) {
            asteroids.splice(i, 1);
          }
        }

        // 6) Gradually increase difficulty (spawn rate)
        asteroidSpawnRate += 0.02;

        // Request the next frame
        animationId = requestAnimationFrame(gameLoop);
      } else {
        // Slightly darken the screen
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Game Over text
        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${40 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 40 * ((scaleX + scaleY) / 2));

        // Final score
        ctx.font = `${30 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.fillText('Score: ' + score, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);

        // Restart instruction
        ctx.font = `${20 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.fillText('Press Enter or Tap the Game Canvas to restart', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 40 * ((scaleX + scaleY) / 2));
        ctx.textAlign = 'start';
      }
    }
  </script>

</body>

</html>
