<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Asteroid Storm</title>
  <link rel="icon" type="image/png" href="/favicon.png">
  <!-- Supabase Client Library (UMD bundle for browser) -->
  <script
    id="supabaseScript"
    src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"
    defer
  ></script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .catch((err) => console.log('Service Worker registration failed', err));
      });
    }
  </script>
  <script>
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (event) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background: url('') no-repeat center center fixed;
      background-size: cover;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      padding: 20px;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }

    .logo-container {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 100;
    }

    .logo-container img {
      max-height: 40px;
      filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.5));
    }

    .sound-toggle {
      position: fixed;
      bottom: 16px;
      left: 16px;
      z-index: 120;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 214, 102, 0.6);
      background: rgba(10, 15, 30, 0.85);
      color: #fff3c4;
      font-size: 0.9em;
      font-weight: 600;
      letter-spacing: 0.4px;
      cursor: pointer;
      box-shadow: 0 0 0 2px rgba(255, 214, 102, 0.25), 0 0 16px rgba(255, 214, 102, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease, border-color 0.2s ease;
    }

    .sound-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 0 2px rgba(255, 214, 102, 0.35), 0 0 22px rgba(255, 214, 102, 0.6);
      filter: brightness(1.08);
      border-color: rgba(255, 222, 128, 0.8);
    }

    .sound-toggle:active {
      transform: translateY(0);
      box-shadow: 0 0 0 2px rgba(255, 214, 102, 0.25), 0 0 14px rgba(255, 214, 102, 0.4);
    }

    .sound-toggle.muted {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
      border-color: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.6);
    }

    .sound-toggle .icon {
      font-size: 1em;
      line-height: 1;
    }

    a {
      color: #ffc107;
      text-decoration: none;
      transition: color 0.2s ease, text-shadow 0.2s ease;
    }

    a:hover {
      color: #ffeb3b;
      text-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
    }

    a:visited { color: #ffc107; }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, rgba(10, 15, 30, 0.8) 100%);
      pointer-events: none;
      z-index: -1;
    }

    #container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      max-width: 1100px;
      width: 100%;
      position: relative;
      z-index: 1;
      gap: 24px;
    }

    #topScores {
      flex: 0 0 260px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px 16px;
      text-align: center;
    }

    #topScores h1 {
      font-size: 1.1em;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #ffc107;
      text-shadow: 0 0 12px rgba(255, 193, 7, 0.4);
      border-bottom: none;
      padding-bottom: 12px;
      margin: 0 0 12px 0;
      position: relative;
    }

    #topScores h1::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #ffc107, transparent);
    }

    #topScores ol {
      list-style: none;
      padding: 0;
      margin: 0;
      counter-reset: score-counter;
    }

    #topScores li {
      font-size: 1.1em;
      text-align: left;
      padding: 10px 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      counter-increment: score-counter;
      display: grid;
      grid-template-columns: 32px minmax(56px, 1fr) minmax(90px, 1fr);
      align-items: center;
      justify-items: start;
      column-gap: 12px;
      white-space: nowrap;
      transition: background 0.2s ease;
    }

    #topScores li:hover { background: rgba(255, 255, 255, 0.05); }

    #topScores li::before {
      content: counter(score-counter) ".";
      color: rgba(255, 193, 7, 0.7);
      font-weight: 600;
      min-width: 24px;
      justify-self: start;
    }

    #topScores li:last-child { border-bottom: none; }
    #topScores li:first-child { color: #ffd54f; font-weight: 600; }

    #topScores li.highlight {
      background: rgba(255, 193, 7, 0.18);
      box-shadow: 0 0 14px rgba(255, 193, 7, 0.6), inset 0 0 18px rgba(255, 193, 7, 0.25);
      animation: scoreGlow 1.6s ease-in-out infinite;
    }

    #topScores li.highlight .score-value {
      color: #fff9db;
      font-weight: 600;
    }

    @keyframes scoreGlow {
      0% { box-shadow: 0 0 8px rgba(255, 193, 7, 0.35), inset 0 0 12px rgba(255, 193, 7, 0.2); }
      50% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.75), inset 0 0 20px rgba(255, 193, 7, 0.35); }
      100% { box-shadow: 0 0 8px rgba(255, 193, 7, 0.35), inset 0 0 12px rgba(255, 193, 7, 0.2); }
    }

    #gameContainer {
      flex: 1;
      max-width: 750px;
      text-align: center;
    }

    #gameContainer h1 {
      font-size: 2.2em;
      font-weight: 700;
      color: #4ade80;
      text-shadow: 0 0 20px rgba(74, 222, 128, 0.5), 0 0 40px rgba(74, 222, 128, 0.2);
      margin: 0 0 16px 0;
      letter-spacing: 1px;
    }

    .canvas-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
      max-width: 700px;
      border-radius: 14px;
      padding: 3px;
      background: linear-gradient(135deg, #4ade80, #22c55e, #16a34a);
    }

    .canvas-wrapper::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, #4ade80, #22c55e, #16a34a);
      border-radius: 16px;
      z-index: -1;
      filter: blur(12px);
      opacity: 0.6;
    }

    #gameContainer canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 3 / 2;
      border-radius: 12px;
      display: block;
      touch-action: none;
      -ms-touch-action: none;
      background: #0a0f1e;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .asset-error {
      margin-top: 14px;
      padding: 12px 16px;
      border-radius: 10px;
      border: 1px solid rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.12);
      color: #fecaca;
      font-weight: 600;
      letter-spacing: 0.2px;
      display: none;
    }

    .asset-error.show { display: block; }

    .instructions {
      margin-top: 20px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .instructions p {
      font-size: 0.95em;
      margin: 6px 0;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.8);
    }

    .instructions .key {
      display: inline-block;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      padding: 2px 8px;
      font-size: 0.9em;
      font-weight: 500;
      color: #ffc107;
      margin: 0 2px;
    }

    .instructions .highlight { color: #f87171; font-weight: 500; }

    .footer {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .footer p {
      font-size: 0.9em;
      color: #f87171;
      margin: 0;
    }

    .footer a,
    .footer a:visited,
    .footer a:hover {
      color: #f87171;
    }

    @media (max-width: 900px) {
      #container { flex-direction: column; align-items: center; }

      #topScores {
        flex: none;
        width: 100%;
        max-width: 400px;
        order: 2;
        margin-top: 24px;
      }

      #topScores ol {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
      }

      #topScores li {
        flex: 0 0 auto;
        padding: 8px 16px;
        border-bottom: none;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
      }

      #topScores li:hover { background: rgba(255, 255, 255, 0.1); }

      #gameContainer { order: 1; width: 100%; }
      #gameContainer h1 { font-size: 1.8em; }
    }

    @media (max-width: 500px) {
      body { padding: 12px; }
      #gameContainer h1 { font-size: 1.5em; margin-bottom: 12px; }
      .instructions { padding: 12px 14px; }
      .instructions p { font-size: 0.85em; }
    }

    #initialsModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    #initialsModal.show { display: flex; }

    .modal-content {
      background: linear-gradient(135deg, rgba(30, 40, 60, 0.95) 0%, rgba(20, 30, 50, 0.98) 100%);
      border: 2px solid #ffc107;
      border-radius: 16px;
      padding: 32px 40px;
      text-align: center;
      box-shadow: 0 0 40px rgba(255, 193, 7, 0.3), 0 0 80px rgba(255, 193, 7, 0.1);
      animation: modalPop 0.3s ease-out;
    }

    @keyframes modalPop {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .modal-content h2 {
      color: #4ade80;
      font-size: 1.8em;
      margin: 0 0 8px 0;
      text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
    }

    .modal-content .high-score-text {
      color: #ffc107;
      font-size: 1.2em;
      margin: 0 0 24px 0;
    }

    .modal-content .score-display {
      font-size: 2.5em;
      font-weight: 700;
      color: #fff;
      margin: 0 0 24px 0;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .modal-content label {
      display: block;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.95em;
      margin-bottom: 12px;
    }

    #initialsInput {
      width: 160px;
      padding: 12px 16px;
      font-size: 2em;
      font-family: 'Inter', monospace;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 193, 7, 0.5);
      border-radius: 8px;
      color: #ffc107;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    #initialsInput:focus {
      border-color: #ffc107;
      box-shadow: 0 0 20px rgba(255, 193, 7, 0.3);
    }

    #initialsInput::placeholder {
      color: rgba(255, 193, 7, 0.3);
      letter-spacing: 4px;
    }

    .modal-content .submit-btn {
      display: block;
      width: 100%;
      margin-top: 20px;
      padding: 14px 32px;
      font-size: 1.1em;
      font-weight: 600;
      color: #0a0f1e;
      background: linear-gradient(135deg, #ffc107 0%, #ffca28 100%);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .modal-content .submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(255, 193, 7, 0.4);
    }

    .modal-content .submit-btn:active { transform: translateY(0); }

    .modal-content .submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .modal-content .error-text {
      color: #f87171;
      font-size: 0.85em;
      margin-top: 8px;
      min-height: 20px;
    }

    #topScores li .initials {
      font-family: 'Inter', monospace;
      font-weight: 600;
      color: #ffc107;
      letter-spacing: 2px;
      min-width: 48px;
      justify-self: start;
    }

    #topScores li .score-value {
      color: #f5f5f5;
      font-weight: 500;
      justify-self: start;
      text-align: left;
    }

    #topScores .loading {
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
      padding: 20px;
    }
  </style>
</head>

<body>
  <div class="logo-container">
    <a href="https://panphy.github.io/">
      <img src="/panphy.png" alt="PanPhy logo">
    </a>
  </div>

  <button class="sound-toggle" id="soundToggle" type="button" aria-pressed="false">
    <span class="icon" aria-hidden="true">ðŸ”Š</span>
    <span class="label">Sound On</span>
  </button>

  <div id="overlay"></div>
  <audio id="bgm" src="dodge_assets/dodge_bgm.mp3" loop preload="auto"></audio>
  <audio id="gameOverSfx" src="dodge_assets/dodge_gameover.mp3" preload="auto"></audio>

  <div id="initialsModal">
    <div class="modal-content">
      <h2>New High Survival Time!</h2>
      <p class="high-score-text">You are a Top Survivor!</p>
      <p class="score-display" id="modalScore">0</p>
      <label for="initialsInput">Enter your initials (3 characters)</label>
      <input type="text" id="initialsInput" maxlength="3" placeholder="AAA" autocomplete="off" />
      <p class="error-text" id="initialsError"></p>
      <button class="submit-btn" id="submitInitials">Submit Survival Time</button>
    </div>
  </div>

  <div id="container">
    <div id="topScores">
      <h1>Top Survivors</h1>
      <ol id="scoreList"></ol>
      <div class="footer">
        <p>
          &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a><br>
          <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
        </p>
      </div>
    </div>

    <div id="gameContainer">
      <h1>Survive the Asteroid Storm!</h1>
      <div class="canvas-wrapper">
        <!-- give a safe default intrinsic size -->
        <canvas id="gameCanvas" width="600" height="400"></canvas>
      </div>
      <p id="assetError" class="asset-error" role="status" aria-live="polite">
        Game assets failed to load. Please refresh or check your connection.
      </p>
      <div class="instructions">
        <p>Use <span class="key">Arrow Keys</span> or <span class="key">Drag</span> the spaceship to move. Avoid the <span class="highlight">asteroids</span>!</p>
        <p>Press <span class="key">Enter</span> or <span class="key">Tap</span> the canvas to restart after Game Over.</p>
        <p>Press <span class="key">Spacebar</span> to toggle sound on/off.</p>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    /* -----------------------------------------------------------
     * Supabase Configuration
     * -----------------------------------------------------------
     */
    const SUPABASE_URL = 'https://ldkgodxalwuvkqygchns.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxka2dvZHhhbHd1dmtxeWdjaG5zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk3NzEyNTgsImV4cCI6MjA4NTM0NzI1OH0.PZ3rbRZCfwzniQgq5RiZ9cikPNvdYwr9uGYNwN6xQKY';
    const SCORE_FIELD = 'survival_time';
    const LEADERBOARD_CACHE_KEY = 'dodgeLeaderboardCacheV1';
    const MIN_SUBMISSION_SCORE = 0;
    const MAX_SUBMISSION_SCORE = Number.POSITIVE_INFINITY;

    let supabase = null;

    const bgm = document.getElementById('bgm');
    const gameOverSfx = document.getElementById('gameOverSfx');
    let bgmStarted = false;
    let isMuted = false;
    let gameOverSfxPrimed = false;

    const soundToggle = document.getElementById('soundToggle');
    const soundToggleLabel = soundToggle ? soundToggle.querySelector('.label') : null;
    const soundToggleIcon = soundToggle ? soundToggle.querySelector('.icon') : null;

    function updateSoundToggle() {
      if (!soundToggle) return;
      soundToggle.classList.toggle('muted', isMuted);
      soundToggle.setAttribute('aria-pressed', String(isMuted));
      const labelText = isMuted ? 'Sound Off' : 'Sound On';
      const iconText = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
      if (soundToggleLabel) soundToggleLabel.textContent = labelText;
      if (soundToggleIcon) soundToggleIcon.textContent = iconText;
      soundToggle.setAttribute('aria-label', isMuted ? 'Enable sound' : 'Mute sound');
      if (bgm) bgm.muted = isMuted;
      if (gameOverSfx) gameOverSfx.muted = isMuted;
    }

    function startBackgroundMusic() {
      if (bgmStarted || !bgm || isMuted) return;
      bgmStarted = true;
      const playPromise = bgm.play();
      if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch(() => {
          bgmStarted = false;
        });
      }
      primeGameOverSound();
    }

    function stopBackgroundMusic() {
      if (!bgm) return;
      bgm.pause();
      bgm.currentTime = 0;
      bgmStarted = false;
    }

    function playGameOverSound() {
      if (!gameOverSfx || isMuted) return;
      gameOverSfx.currentTime = 0;
      const playPromise = gameOverSfx.play();
      if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch(() => {
          // ignore play errors
        });
      }
    }

    function stopGameOverSound() {
      if (!gameOverSfx) return;
      gameOverSfx.pause();
      gameOverSfx.currentTime = 0;
    }

    function primeGameOverSound() {
      if (!gameOverSfx || isMuted || gameOverSfxPrimed) return;
      gameOverSfxPrimed = true;
      const originalVolume = gameOverSfx.volume;
      gameOverSfx.volume = 0;
      const playPromise = gameOverSfx.play();
      if (playPromise && typeof playPromise.then === 'function') {
        playPromise
          .then(() => {
            gameOverSfx.pause();
            gameOverSfx.currentTime = 0;
            gameOverSfx.volume = originalVolume;
          })
          .catch(() => {
            gameOverSfxPrimed = false;
            gameOverSfx.volume = originalVolume;
          });
      } else {
        gameOverSfx.pause();
        gameOverSfx.currentTime = 0;
        gameOverSfx.volume = originalVolume;
      }
    }

    function setMutedState(nextMuted) {
      isMuted = Boolean(nextMuted);
      if (isMuted) {
        stopBackgroundMusic();
        stopGameOverSound();
      }
      updateSoundToggle();
      try {
        localStorage.setItem('dodgeMuted', isMuted ? '1' : '0');
      } catch (e) {
        // ignore storage errors
      }
    }

    if (soundToggle) {
      soundToggle.addEventListener('click', () => {
        setMutedState(!isMuted);
        if (!isMuted) {
          startBackgroundMusic();
          primeGameOverSound();
        }
      });
    }

    if (gameOverSfx) {
      gameOverSfx.load();
    }

    function initSupabaseClient() {
      if (supabase) return supabase;
      try {
        const sb = window.supabase || window.Supabase || null;
        if (sb && typeof sb.createClient === 'function' && SUPABASE_URL && SUPABASE_ANON_KEY) {
          supabase = sb.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
      } catch (e) {
        console.warn('Supabase initialization failed:', e);
      }
      return supabase;
    }

    function getSupabaseRestHeaders(accessToken = null) {
      return {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${accessToken || SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      };
    }

    function loadLeaderboardCache() {
      try {
        const raw = localStorage.getItem(LEADERBOARD_CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.scores)) return null;
        return parsed;
      } catch (e) {
        return null;
      }
    }

    function saveLeaderboardCache(scores) {
      try {
        const payload = { scores: scores || [], savedAt: Date.now() };
        localStorage.setItem(LEADERBOARD_CACHE_KEY, JSON.stringify(payload));
      } catch (e) {
        // ignore storage errors
      }
    }

    function isSameLeaderboard(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b)) return false;
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        const left = a[i] || {};
        const right = b[i] || {};
        if (left.initials !== right.initials) return false;
        if (Number(left.score) !== Number(right.score)) return false;
      }
      return true;
    }

    async function fetchTopScoresRest() {
      const url = new URL(`${SUPABASE_URL}/rest/v1/dodge_leaderboard`);
      url.searchParams.set('select', `initials,${SCORE_FIELD}`);
      url.searchParams.set('order', `${SCORE_FIELD}.desc`);
      url.searchParams.set('limit', '10');
      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: getSupabaseRestHeaders(),
      });
      if (!response.ok) {
        throw new Error(`Supabase REST fetch failed: ${response.status}`);
      }
      return response.json();
    }

    async function submitScoreRest(initials, scoreValue, accessToken = null) {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/submit_dodge_score`, {
        method: 'POST',
        headers: {
          ...getSupabaseRestHeaders(accessToken),
          Prefer: 'return=minimal',
        },
        body: JSON.stringify({
          initials: initials.toUpperCase(),
          survival_time: scoreValue,
        }),
      });
      if (!response.ok) {
        throw new Error(`Supabase RPC insert failed: ${response.status}`);
      }
      return true;
    }

    /* -----------------------------------------------------------
     * Base Canvas Size and Scaling Factors
     * -----------------------------------------------------------
     */
    const BASE_WIDTH = 600;
    const BASE_HEIGHT = 400;
    let scaleX = 1;
    let scaleY = 1;

    // Initial dimensions (will be updated)
    let SCREEN_WIDTH = BASE_WIDTH;
    let SCREEN_HEIGHT = BASE_HEIGHT;

    function updateScaleFactors() {
      scaleX = SCREEN_WIDTH / BASE_WIDTH;
      scaleY = SCREEN_HEIGHT / BASE_HEIGHT;
    }

    /* -----------------------------------------------------------
     * Responsive Canvas Setup
     * -----------------------------------------------------------
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let canvasReady = false;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;

      // Sometimes first layout can report 0x0. Fall back to wrapper width.
      const rect = canvas.getBoundingClientRect();
      let cssW = rect.width;
      let cssH = rect.height;

      if (!cssW || !cssH) {
        const parent = canvas.parentElement;
        const parentRect = parent ? parent.getBoundingClientRect() : { width: BASE_WIDTH, height: BASE_HEIGHT };
        cssW = parentRect.width ? Math.max(200, parentRect.width) : BASE_WIDTH;
        cssH = cssW * (2 / 3); // keep 3:2 aspect ratio
      }

      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      // Make 1 unit in code = 1 CSS pixel (crisp due to dpr scaling)
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      SCREEN_WIDTH = cssW;
      SCREEN_HEIGHT = cssH;

      updateScaleFactors();

      if (player) player.updateScale();
      updateAsteroidsScale();

      canvasReady = true;
      tryStartGame();
    }

    window.addEventListener('load', () => {
      resizeCanvas();
      try {
        const storedMuted = localStorage.getItem('dodgeMuted');
        if (storedMuted !== null) {
          isMuted = storedMuted === '1';
        }
      } catch (e) {
        // ignore storage errors
      }
      updateSoundToggle();
      initSupabaseClient();
      const cachedLeaderboard = loadLeaderboardCache();
      if (cachedLeaderboard && cachedLeaderboard.scores.length > 0) {
        topScores = mergeRecentSubmission(normalizeCachedScores(cachedLeaderboard.scores));
        renderTopScores();
      } else {
        renderLoadingScores();
      }
      fetchTopScores({ preferRemote: true, showLoading: false });
      tryStartGame();
    });

    window.addEventListener('resize', () => resizeCanvas());

    /* -----------------------------------------------------------
     * Assets (robust loading: never crash on broken images)
     * -----------------------------------------------------------
     */
    const assetBase = new URL('dodge_assets/', window.location.href);
    const resolveAsset = (fileName) => new URL(fileName, assetBase).toString();

    const assets = {
      background: { img: new Image(), src: resolveAsset('dodge_canvas.png'), ok: false },
      ship: { img: new Image(), src: resolveAsset('dodge_spaceship.png'), ok: false },
      asteroid: { img: new Image(), src: resolveAsset('dodge_asteroid.png'), ok: false },
    };

    let assetsReady = false;
    let bgPattern = null;

    function loadImageAsset(a) {
      return new Promise((resolve) => {
        const img = a.img;

        const done = (ok) => {
          a.ok = ok;
          resolve(ok);
        };

        img.addEventListener('load', () => done(true), { once: true });
        img.addEventListener('error', () => {
          console.warn(`Failed to load game asset: ${a.src}`);
          done(false);
        }, { once: true });

        img.src = a.src;

        // Handle cache-hit edge cases
        if (img.complete) {
          if (img.naturalWidth > 0) done(true);
          else done(false);
        }
      });
    }

    Promise.all([
      loadImageAsset(assets.background),
      loadImageAsset(assets.ship),
      loadImageAsset(assets.asteroid),
    ]).then((results) => {
      const allOk = results.every(Boolean);
      assetsReady = allOk;
      if (!allOk) {
        if (assetError) assetError.classList.add('show');
        return;
      }
      // create background pattern if possible (after first resize so ctx exists)
      if (assets.background.ok) {
        try { bgPattern = ctx.createPattern(assets.background.img, 'repeat'); } catch (_) { bgPattern = null; }
      }
      tryStartGame();
    });

    // Preload the page background image (cosmetic)
    const preloadedBkgrd = new Image();
    preloadedBkgrd.src = resolveAsset('dodge_bkgrd.webp');
    preloadedBkgrd.onload = () => {
      document.body.style.backgroundImage = `url('${resolveAsset('dodge_bkgrd.webp')}')`;
    };

    function tryStartGame() {
      if (!assetsReady || !canvasReady) return;
      resetGame();
    }

    /* -----------------------------------------------------------
     * Global Variables
     * -----------------------------------------------------------
     */
    let gameOver = false;
    let score = 0;
    let gameStartTime = 0;
    let asteroids = [];
    let player = null;
    let keys = {};
    let animationId = null;
    let speedIntervalId = null;
    let isPaused = false;
    let pauseStartTime = 0;

    let topScores = [];
    let pendingScore = 0;
    let isSubmittingScore = false;
    let recentSubmission = null;
    const HIGHLIGHT_DURATION_MS = 6000;

    let MIN_ASTEROID_SPEED = 2;
    let MAX_ASTEROID_SPEED = 6;
    let asteroidSpawnRate = 3;
    const speedIncreaseInterval = 1500;

    let isPointerDown = false;
    let pointerStartX = 0;
    let pointerStartY = 0;
    let spaceshipStartX = 0;
    let spaceshipStartY = 0;
    const assetError = document.getElementById('assetError');

    const initialsModal = document.getElementById('initialsModal');
    const initialsInput = document.getElementById('initialsInput');
    const initialsError = document.getElementById('initialsError');
    const submitBtn = document.getElementById('submitInitials');
    const modalScoreDisplay = document.getElementById('modalScore');

    /* -----------------------------------------------------------
     * Background Scrolling Variables
     * -----------------------------------------------------------
     */
    let backgroundOffsetY = 0;
    let backgroundScrollSpeed = 2;

    function formatSurvivalTime(value) {
      const numericValue = Number(value);
      if (!Number.isFinite(numericValue)) return '0.00 s';
      return `${numericValue.toFixed(2)} s`;
    }

    /* -----------------------------------------------------------
     * Spaceship Class
     * -----------------------------------------------------------
     */
    class Spaceship {
      constructor() {
        this.baseWidth = 50;
        this.baseHeight = 50;
        this.baseRadius = 15;
        this.baseSpeed = 5;

        this.updateScale();

        this.x = SCREEN_WIDTH / 2;
        this.y = SCREEN_HEIGHT / 2;
      }

      updateScale() {
        this.width = this.baseWidth * scaleX;
        this.height = this.baseHeight * scaleY;
        this.radius = this.baseRadius * ((scaleX + scaleY) / 2);
        this.speed = this.baseSpeed * ((scaleX + scaleY) / 2);
      }

      move() {
        let deltaX = 0;
        let deltaY = 0;

        if (keys['ArrowLeft']) deltaX -= 1;
        if (keys['ArrowRight']) deltaX += 1;
        if (keys['ArrowUp']) deltaY -= 1;
        if (keys['ArrowDown']) deltaY += 1;

        if (deltaX !== 0 || deltaY !== 0) {
          const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const normX = (deltaX / magnitude) * this.speed;
          const normY = (deltaY / magnitude) * this.speed;

          const newX = this.x + normX;
          const newY = this.y + normY;

          if (newX - this.radius >= 0 && newX + this.radius <= SCREEN_WIDTH) this.x = newX;
          if (newY - this.radius >= 0 && newY + this.radius <= SCREEN_HEIGHT) this.y = newY;
        }
      }

      setPosition(newX, newY) { this.x = newX; this.y = newY; }

      draw() {
        if (!assets.ship.ok) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.drawImage(assets.ship.img, -this.width / 2, -this.height / 2, this.width, this.height);
        ctx.restore();
      }
    }

    /* -----------------------------------------------------------
     * Asteroid Class
     * -----------------------------------------------------------
     */
    class Asteroid {
      constructor() {
        this.baseSize = 32;
        this.baseScale = 0.5 + Math.random() * 1.5;
        this.spawn();

        this.baseSpeed = Math.random() * (MAX_ASTEROID_SPEED - MIN_ASTEROID_SPEED) + MIN_ASTEROID_SPEED;
        this.speed = 0;

        this.angle = Math.random() * 2 * Math.PI;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;

        this.scale = 1;
        this.width = 0;
        this.height = 0;
        this.radius = 0;
        this.updateScale();
      }

      updateScale() {
        // preserve relative size without re-randomising too aggressively
        const avg = ((scaleX + scaleY) / 2);
        this.scale = this.baseScale * avg;
        this.width = this.baseSize * this.scale;
        this.height = this.baseSize * this.scale;
        this.radius = (this.width + this.height) / 4;
        this.speed = this.baseSpeed * avg;
      }

      spawn() {
        const edge = Math.floor(Math.random() * 4);
        switch (edge) {
          case 0:
            this.x = Math.random() * SCREEN_WIDTH;
            this.y = -40 * scaleY;
            break;
          case 1:
            this.x = Math.random() * SCREEN_WIDTH;
            this.y = SCREEN_HEIGHT + 40 * scaleY;
            break;
          case 2:
            this.x = -40 * scaleX;
            this.y = Math.random() * SCREEN_HEIGHT;
            break;
          default:
            this.x = SCREEN_WIDTH + 40 * scaleX;
            this.y = Math.random() * SCREEN_HEIGHT;
            break;
        }
        const a = Math.random() * 2 * Math.PI;
        this.dx = Math.cos(a);
        this.dy = Math.sin(a);
      }

      move() {
        this.x += this.dx * this.speed;
        this.y += this.dy * this.speed;
        this.angle += this.rotationSpeed;
      }

      draw() {
        if (!assets.asteroid.ok) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.drawImage(assets.asteroid.img, -this.width / 2, -this.height / 2, this.width, this.height);
        ctx.restore();
      }

      isOffScreen() {
        return (
          this.x < -100 * scaleX ||
          this.x > SCREEN_WIDTH + 100 * scaleX ||
          this.y < -100 * scaleY ||
          this.y > SCREEN_HEIGHT + 100 * scaleY
        );
      }
    }

    /* -----------------------------------------------------------
     * Input Handlers
     * -----------------------------------------------------------
     */
    document.addEventListener('keydown', (e) => {
      const isTextInput = e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement;
      if (!gameOver && !initialsModal.classList.contains('show')) {
        startBackgroundMusic();
      }
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keys[e.key] = true;
      }
      if ((e.key === ' ' || e.key === 'Spacebar') && !isTextInput) {
        e.preventDefault();
        setMutedState(!isMuted);
        if (!isMuted) {
          startBackgroundMusic();
        }
      }
      if (gameOver && e.key === 'Enter' && !initialsModal.classList.contains('show')) {
        resetGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        keys[e.key] = false;
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (!gameOver && !initialsModal.classList.contains('show')) {
        startBackgroundMusic();
      }
      if (!player) return;

      if (gameOver && !initialsModal.classList.contains('show')) {
        e.preventDefault();
        resetGame();
        return;
      }
      if (gameOver) return;

      e.preventDefault();
      isPointerDown = true;
      pointerStartX = e.clientX;
      pointerStartY = e.clientY;
      spaceshipStartX = player.x;
      spaceshipStartY = player.y;
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!player) return;
      if (isPointerDown && !gameOver) {
        e.preventDefault();
        const deltaX = e.clientX - pointerStartX;
        const deltaY = e.clientY - pointerStartY;

        let newX = spaceshipStartX + deltaX;
        let newY = spaceshipStartY + deltaY;

        newX = Math.max(player.radius, Math.min(SCREEN_WIDTH - player.radius, newX));
        newY = Math.max(player.radius, Math.min(SCREEN_HEIGHT - player.radius, newY));
        player.setPosition(newX, newY);
      }
    }, { passive: false });

    canvas.addEventListener('pointerup', (e) => {
      if (isPointerDown) { e.preventDefault(); isPointerDown = false; }
    }, { passive: false });

    canvas.addEventListener('pointercancel', (e) => {
      if (isPointerDown) { e.preventDefault(); isPointerDown = false; }
    }, { passive: false });

    /* -----------------------------------------------------------
     * Collision Detection
     * -----------------------------------------------------------
     */
    function checkCollision(ship, asteroid) {
      const dx = ship.x - asteroid.x;
      const dy = ship.y - asteroid.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < ship.radius + asteroid.radius;
    }

    /* -----------------------------------------------------------
     * Game Logic
     * -----------------------------------------------------------
     */
    function resetGame() {
      player = new Spaceship();
      asteroids = [];
      score = 0;
      gameStartTime = performance.now();
      isPaused = false;
      pauseStartTime = 0;
      asteroidSpawnRate = 3;
      MIN_ASTEROID_SPEED = 2;
      MAX_ASTEROID_SPEED = 7;
      gameOver = false;

      if (animationId) cancelAnimationFrame(animationId);
      if (speedIntervalId) clearInterval(speedIntervalId);
      stopGameOverSound();

      startSpeedInterval();

      startBackgroundMusic();
      gameLoop();
    }

    function startSpeedInterval() {
      if (speedIntervalId) clearInterval(speedIntervalId);
      speedIntervalId = setInterval(() => {
        MIN_ASTEROID_SPEED += 0.1;
        MAX_ASTEROID_SPEED += 0.2;
      }, speedIncreaseInterval);
    }

    function pauseGame() {
      if (gameOver || isPaused) return;
      isPaused = true;
      pauseStartTime = performance.now();
      if (animationId) cancelAnimationFrame(animationId);
      if (speedIntervalId) {
        clearInterval(speedIntervalId);
        speedIntervalId = null;
      }
      stopBackgroundMusic();
    }

    function resumeGame() {
      if (gameOver || !isPaused) return;
      const now = performance.now();
      gameStartTime += now - pauseStartTime;
      isPaused = false;
      startSpeedInterval();
      startBackgroundMusic();
      gameLoop();
    }

    /* -----------------------------------------------------------
     * Supabase Score Functions
     * -----------------------------------------------------------
     */
    function waitForSupabaseClient({ timeoutMs = 4000, intervalMs = 200 } = {}) {
      return new Promise((resolve) => {
        const start = Date.now();
        const check = () => {
          const client = initSupabaseClient();
          if (client) {
            resolve(client);
            return;
          }
          if (Date.now() - start >= timeoutMs) {
            resolve(null);
            return;
          }
          setTimeout(check, intervalMs);
        };
        check();
      });
    }

    async function ensureSupabaseSession(client) {
      if (!client || !client.auth) return null;
      try {
        const { data } = await client.auth.getSession();
        if (data && data.session) return data.session;
        const { data: authData, error } = await client.auth.signInAnonymously();
        if (error) {
          console.warn('Supabase anonymous auth failed:', error);
          return null;
        }
        return authData ? authData.session : null;
      } catch (e) {
        console.warn('Supabase session check failed:', e);
        return null;
      }
    }

    async function fetchTopScores({ preferRemote = false, showLoading = true } = {}) {
      if (showLoading) renderLoadingScores();
      const cachedScores = normalizeCachedScores(loadLeaderboardCache()?.scores || []);

      let client = initSupabaseClient();
      if (!client && preferRemote) {
        client = await waitForSupabaseClient();
      }

      try {
        let fetchedScores = [];
        if (client) {
          const { data, error } = await client
            .from('dodge_leaderboard')
            .select(`initials, ${SCORE_FIELD}`)
            .order(SCORE_FIELD, { ascending: false })
            .limit(10);

          if (error) throw error;
          fetchedScores = normalizeScores(data || []);
        } else {
          fetchedScores = normalizeScores(await fetchTopScoresRest());
        }
        const mergedScores = mergeRecentSubmission(fetchedScores);
        if (!isSameLeaderboard(fetchedScores, cachedScores) || topScores.length === 0) {
          topScores = mergedScores;
          renderTopScores();
          saveLeaderboardCache(fetchedScores);
        }
      } catch (e) {
        console.warn('Supabase client fetch failed, retrying with REST fallback.', e);
        try {
          const fetchedScores = normalizeScores(await fetchTopScoresRest());
          const mergedScores = mergeRecentSubmission(fetchedScores);
          if (!isSameLeaderboard(fetchedScores, cachedScores) || topScores.length === 0) {
            topScores = mergedScores;
            renderTopScores();
            saveLeaderboardCache(fetchedScores);
          }
          return;
        } catch (restError) {
          console.error('Failed to fetch scores:', restError);
          if (topScores.length === 0) {
            const scoreList = document.getElementById('scoreList');
            scoreList.innerHTML = '<li class="loading">Unable to load scores. Check Supabase URL/key and RLS policies.</li>';
          }
        }
      }
    }

    const supabaseScript = document.getElementById('supabaseScript');
    if (supabaseScript) {
      supabaseScript.addEventListener('load', () => {
        fetchTopScores({ preferRemote: true, showLoading: false });
      });
    }

    async function submitScore(initials, scoreValue) {
      let client = initSupabaseClient();
      if (!client) {
        client = await waitForSupabaseClient();
      }
      const session = await ensureSupabaseSession(client);
      const accessToken = session ? session.access_token : null;

      try {
        if (client) {
          const { error } = await client.rpc('submit_dodge_score', {
            initials: initials.toUpperCase(),
            survival_time: scoreValue,
          });

          if (error) throw error;
        } else {
          await submitScoreRest(initials, scoreValue, accessToken);
        }

        registerRecentSubmission(initials, scoreValue);
        topScores = mergeRecentSubmission(topScores);
        renderTopScores();
        saveLeaderboardCache(topScores);
        setTimeout(() => fetchTopScores({ preferRemote: true, showLoading: false }), 800);
        return true;
      } catch (e) {
        console.warn('Supabase client insert failed, retrying with REST fallback.', e);
        try {
          await submitScoreRest(initials, scoreValue, accessToken);
          registerRecentSubmission(initials, scoreValue);
          topScores = mergeRecentSubmission(topScores);
          renderTopScores();
          saveLeaderboardCache(topScores);
          setTimeout(() => fetchTopScores({ preferRemote: true, showLoading: false }), 800);
          return true;
        } catch (restError) {
          console.error('Failed to submit score:', restError);
          return false;
        }
      }
    }

    function normalizeScores(entries) {
      return (entries || [])
        .map((entry) => {
          const scoreValue = sanitizeScoreValue(entry[SCORE_FIELD]);
          if (scoreValue === null) return null;
          return {
            initials: entry.initials,
            score: scoreValue,
          };
        })
        .filter(Boolean);
    }

    function normalizeCachedScores(entries) {
      return (entries || [])
        .map((entry) => {
          const scoreValue = sanitizeScoreValue(entry.score);
          if (scoreValue === null) return null;
          return {
            initials: entry.initials,
            score: scoreValue,
          };
        })
        .filter(Boolean);
    }

    function registerRecentSubmission(initials, scoreValue) {
      recentSubmission = {
        initials: initials.toUpperCase(),
        score: scoreValue,
        expiresAt: Date.now() + HIGHLIGHT_DURATION_MS,
      };
    }

    function hasRecentSubmission(entry) {
      if (!recentSubmission) return false;
      if (Date.now() > recentSubmission.expiresAt) {
        recentSubmission = null;
        return false;
      }
      return (
        entry &&
        entry.initials === recentSubmission.initials &&
        entry.score === recentSubmission.score
      );
    }

    function mergeRecentSubmission(entries) {
      if (!recentSubmission) return entries || [];
      if (Date.now() > recentSubmission.expiresAt) {
        recentSubmission = null;
        return entries || [];
      }
      const list = Array.isArray(entries) ? [...entries] : [];
      const exists = list.some((entry) => hasRecentSubmission(entry));
      if (!exists) {
        list.push({ initials: recentSubmission.initials, score: recentSubmission.score });
      }
      list.sort((a, b) => b.score - a.score);
      return list.slice(0, 10);
    }

    function checkIfHighScore(newScore) {
      if (topScores.length < 10) return true;
      const lowestScore = topScores[topScores.length - 1]?.score || 0;
      return newScore > lowestScore;
    }

    function sanitizeScoreValue(scoreValue) {
      const numeric = Number(scoreValue);
      if (!Number.isFinite(numeric)) return null;
      if (numeric < MIN_SUBMISSION_SCORE) return null;
      if (numeric > MAX_SUBMISSION_SCORE) return null;
      return Math.round(numeric * 100) / 100;
    }

    function handleGameOver(finalScore) {
      const sanitizedScore = sanitizeScoreValue(finalScore);
      if (sanitizedScore === null) {
        console.warn('Score out of allowed range, ignoring submission.', finalScore);
        return;
      }
      if (checkIfHighScore(sanitizedScore)) showInitialsModal(sanitizedScore);
    }

    /* -----------------------------------------------------------
     * Initials Modal Functions
     * -----------------------------------------------------------
     */
    function showInitialsModal(scoreValue) {
      pendingScore = scoreValue;
      modalScoreDisplay.textContent = formatSurvivalTime(scoreValue);
      initialsInput.value = '';
      initialsError.textContent = '';
      submitBtn.disabled = false;
      initialsModal.classList.add('show');
      setTimeout(() => initialsInput.focus(), 100);
    }

    function hideInitialsModal() {
      initialsModal.classList.remove('show');
      pendingScore = 0;
      isSubmittingScore = false;
    }

    function validateInitials(value) {
      const pattern = /^[A-Za-z0-9]{3}$/;
      return pattern.test(value);
    }

    initialsInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
      initialsError.textContent = '';
    });

    initialsInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleSubmitInitials();
      }
    });

    submitBtn.addEventListener('click', handleSubmitInitials);

    async function handleSubmitInitials() {
      if (isSubmittingScore) return;

      const initials = initialsInput.value.trim().toUpperCase();
      if (!validateInitials(initials)) {
        initialsError.textContent = 'Please enter exactly 3 letters or numbers';
        initialsInput.focus();
        return;
      }

      isSubmittingScore = true;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';

      const sanitizedScore = sanitizeScoreValue(pendingScore);
      if (sanitizedScore === null) {
        initialsError.textContent = 'Score was out of range and could not be submitted.';
        isSubmittingScore = false;
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Survival Time';
        return;
      }

      const success = await submitScore(initials, sanitizedScore);

      if (success) {
        hideInitialsModal();
      } else {
        initialsError.textContent = 'Failed to submit score. Please try again.';
        isSubmittingScore = false;
        submitBtn.disabled = false;
      }

      submitBtn.textContent = 'Submit Survival Time';
    }

    initialsModal.addEventListener('click', (e) => {
      if (e.target === initialsModal && !isSubmittingScore) hideInitialsModal();
    });

    function renderTopScores() {
      const scoreList = document.getElementById('scoreList');
      scoreList.innerHTML = '';

      if (topScores.length === 0) {
        const li = document.createElement('li');
        li.className = 'loading';
        li.textContent = 'No scores yet!';
        scoreList.appendChild(li);
        return;
      }

      topScores.forEach((entry) => {
        const li = document.createElement('li');
        const initials = typeof entry === 'object' ? entry.initials : '???';
        const scoreValue = typeof entry === 'object' ? entry.score : entry;
        if (hasRecentSubmission({ initials, score: scoreValue })) {
          li.classList.add('highlight');
        }
        const initialsSpan = document.createElement('span');
        initialsSpan.className = 'initials';
        initialsSpan.textContent = initials;
        const scoreSpan = document.createElement('span');
        scoreSpan.className = 'score-value';
        scoreSpan.textContent = formatSurvivalTime(scoreValue);
        li.append(initialsSpan, scoreSpan);
        scoreList.appendChild(li);
      });
    }

    function renderLoadingScores() {
      const scoreList = document.getElementById('scoreList');
      scoreList.innerHTML = '<li class="loading">Loading...</li>';
    }

    /* -----------------------------------------------------------
     * Update Existing Asteroids on Resize
     * -----------------------------------------------------------
     */
    function updateAsteroidsScale() {
      asteroids.forEach((asteroid) => asteroid.updateScale());
    }

    /* -----------------------------------------------------------
     * Rolling Background
     * -----------------------------------------------------------
     */
    function drawRollingBackground() {
      backgroundOffsetY += backgroundScrollSpeed * ((scaleX + scaleY) / 2);

      if (assets.background.ok && bgPattern) {
        // pattern scroll: translate, then fill
        ctx.save();
        const tileH = assets.background.img.height || 256;
        if (backgroundOffsetY >= tileH) backgroundOffsetY = 0;
        ctx.translate(0, backgroundOffsetY);
        ctx.fillStyle = bgPattern;
        ctx.fillRect(0, -backgroundOffsetY, SCREEN_WIDTH, SCREEN_HEIGHT + tileH);
        ctx.restore();
      }
    }

    /* -----------------------------------------------------------
     * Main game loop
     * -----------------------------------------------------------
     */
    function gameLoop() {
      if (isPaused) return;
      if (!gameOver) {
        ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        drawRollingBackground();

        const elapsedMs = performance.now() - gameStartTime;
        score = Math.floor(elapsedMs / 10) / 100;
        const scoreDisplay = formatSurvivalTime(score);
        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${18 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.textAlign = 'start';
        ctx.fillText('Survival Time: ' + scoreDisplay, 10, 20);

        player.move();
        player.draw();

        if (Math.random() * 100 < asteroidSpawnRate) {
          asteroids.push(new Asteroid());
        }

        for (let i = asteroids.length - 1; i >= 0; i--) {
          const m = asteroids[i];
          m.move();
          m.draw();

          if (!gameOver && checkCollision(player, m)) {
            gameOver = true;
            playGameOverSound();
            handleGameOver(score);
            stopBackgroundMusic();
            if (speedIntervalId) {
              clearInterval(speedIntervalId);
              speedIntervalId = null;
            }
          }

          if (m.isOffScreen()) asteroids.splice(i, 1);
        }

        asteroidSpawnRate += 0.02;

        animationId = requestAnimationFrame(gameLoop);
      } else {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        ctx.fillStyle = '#f5f5f5';
        ctx.font = `${40 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 40 * ((scaleX + scaleY) / 2));

        ctx.font = `${30 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.fillText('Survival Time: ' + formatSurvivalTime(score), SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);

        ctx.font = `${20 * ((scaleX + scaleY) / 2)}px Arial`;
        ctx.fillText('Press Enter or Tap the Game Canvas to restart', SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 40 * ((scaleX + scaleY) / 2));
        ctx.textAlign = 'start';
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        pauseGame();
      } else {
        resumeGame();
      }
    });
  </script>
</body>

</html>
