<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Plotting & Curve Fitting</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <!-- Plotly.js for graphing -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Math.js for computations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <!-- MathJax v2 for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>

    <style>
        :root {
            --add-row-btn-color: #6aa84f;
            --clear-all-btn-color: #e06666;
            --import-csv-btn-color: #45818e;
            --export-csv-btn-color: #7f7f7f;
            --export-md-btn-color: #7f7f7f;
        }

        body {
            font-family: Helvetica, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .banner {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #333;
            color: white;
            padding: 20px;
            font-size: 24px;
            font-weight: bold;
            position: relative;
        }

        .banner-left {
            width: 120px;
            /* Spacer for centering */
        }

        .banner-title {
            flex: 1;
            text-align: center;
        }

        .banner-buttons {
            display: flex;
            gap: 0px;
            width: 110px;
            /* Fixed width to match banner-left */
        }

        .banner-button {
            background: none;
            border: none;
            color: grey;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            padding: 0px 0px;
            transition: color 0.3s;
        }

        .banner-button:hover {
            color: #ddd;
        }

        .reminder {
            color: #999999;
            margin: 3px;
            font-size: 13px;
            text-align: center;
        }

        .container {
            display: flex;
            flex-direction: row;
            padding: 0px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .input-section,
        .graph-section {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
            height: 80vh;
            /* fixed height for scrolling */
            overflow-y: auto;
            /* adds vertical scroll when needed */
        }

        .input-section {
            flex: 1 1 400px;
            max-width: 400px;
        }

        .graph-section {
            flex: 2 1 600px;
            min-width: 300px;
        }


        .input-section h2,
        .graph-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .data-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            table-layout: auto;
        }

        .data-table th,
        .data-table td {
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
            vertical-align: middle;
            white-space: normal;
        }

        .data-table th input {
            width: 90%;
            border: none;
            outline: none;
            font-size: 16px;
            text-align: center;
            background-color: transparent;
            font-weight: normal;
            padding: 4px;
        }

        .data-table th input:focus {
            border-bottom: 2px solid #007bff;
        }

        .data-table .latex-display {
            margin-top: 4px;
            background-color: #f0f8ff;
            border: 1px solid #add8e6;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            max-width: 100%;
            word-wrap: break-word;
        }

        .data-table td input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 14px;
            text-align: center;
            background-color: transparent;
            padding: 4px;
        }

        .data-table td input:focus {
            outline: 1px solid #007bff;
        }

        .data-table tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #ffffff;
        }

        button {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
            flex: 1;
            transition: background-color 0.3s, filter 0.3s;
        }

        button:hover {
            filter: brightness(90%);
        }

        .btn-add-row {
            background-color: var(--add-row-btn-color);
        }

        .btn-clear-all {
            background-color: var(--clear-all-btn-color);
        }

        .btn-import-csv {
            background-color: var(--import-csv-btn-color);
        }

        .btn-export-csv {
            background-color: var(--export-csv-btn-color);
        }

        .btn-export-md {
            background-color: var(--export-md-btn-color);
        }

        .fit-button {
            background-color: #17a2b8;
            width: 100%;
            height: 40px;
            padding: 0;
            margin: 0;
            flex: 1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .fit-button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .button-row {
            display: flex;
            flex-direction: row;
            gap: 2px;
            width: 100%;
        }

        .global-uncertainty {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .global-uncertainty h2 {
            margin-bottom: 10px;
            text-align: center;
        }

        .uncertainty-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 20px;
        }

        .uncertainty-controls div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .global-uncertainty-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .global-uncertainty-item input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .global-uncertainty-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .global-uncertainty-item button {
            background-color: #6fa8dc;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s, filter 0.3s;
        }

        .global-uncertainty-item button:hover {
            background-color: #6fa8dc;
            filter: brightness(90%);
        }

        .advanced-fit-section {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .advanced-fit-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .advanced-fit-section select,
        .advanced-fit-section .fit-method-select {
            width: auto;
            min-width: 150px;
            max-width: 300px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .advanced-fit-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            margin-bottom: 10px;
        }

        .advanced-fit-item label {
            flex: none;
            text-align: left;
            white-space: nowrap;
        }

        .advanced-fit-item input {
            flex: none;
            width: auto;
            max-width: 200px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .advanced-fit-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .advanced-fit-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .advanced-fit-buttons button {
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 12px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .advanced-fit-buttons button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .parameter-section {
            display: none;
        }

        .parameter-section.active {
            display: block;
        }

        .general-equation {
            margin-top: 20px;
            background-color: #e9ecef;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            justify-content: flex-start;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .tabs button {
            background-color: #f3f3f3;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: background-color 0.3s, filter 0.3s;
            font-size: 16px;
            border-radius: 4px;
            color: #999999;
            width: 50%;
        }

        .tabs button:hover {
            background-color: #eeeeee;
            filter: brightness(95%);
        }

        .tabs button.active {
            background-color: #ffd966;
            color: black;
        }

        .tab-content {
            display: none;
            padding: 15px 1px;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .result {
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }

        .result h3 {
            margin-top: 0;
        }

        .result p {
            margin: 10px 0;
            font-size: 16px;
        }

        #plot {
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .input-section,
            .graph-section {
                max-width: 100%;
                flex: none;
            }

            .banner-left,
            .banner-buttons {
                width: auto;
            }
        }

        .graph-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .graph-title-container label {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }

        .graph-title-container input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .graph-title-container input:focus {
            border-color: #007bff;
            outline: none;
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #f4f4f4;
            color: #555;
            margin-top: 10px;
        }

        footer a {
            color: #e1b400
        }
    </style>
</head>

<body>
    <div class="banner">
        <div class="banner-left"></div> <!-- Spacer for centering -->
        <div class="banner-title">Graph Plotting & Curve Fitting</div>
        <div class="banner-buttons">
            <a href="/curve_fitting_manual.html" class="banner-button">Manual</a>
        </div>
    </div>

    <div class="reminder">
        <p align="center">
            Note: Headings and Title accept LaTeX input.
        </p>
    </div>

    <div class="container">
        <!-- Input section -->
        <div class="input-section">
            <h2>Data Input</h2>

            <div class="table-container">
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <th>
                                <input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
                                <div id="x-column-latex" class="latex-display">\( x \)</div>
                            </th>
                            <th>
                                <input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
                                <div id="y-column-latex" class="latex-display">\( y \)</div>
                            </th>
                            <th class="error-column" id="x-error-header" style="display: none;">
                                <div id="x-error-header-latex" class="latex-display">\( \pm \Delta x \)</div>
                            </th>
                            <th class="error-column" id="y-error-header" style="display: none;">
                                <div id="y-error-header-latex" class="latex-display">\( \pm \Delta y \)</div>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rows initialized in JS -->
                    </tbody>
                </table>
            </div>

            <div class="button-container">
                <div class="button-row">
                    <button class="btn-add-row" onclick="addRow()">Add Row</button>
                    <button class="btn-clear-all" onclick="clearRows()">Clear All</button>
                </div>
                <div class="button-row">
                    <button class="btn-import-csv" onclick="document.getElementById('csv-file-input').click()">Import
                        .csv</button>
                    <button class="btn-export-csv" onclick="exportCSV()">Export .csv</button>
                    <button class="btn-export-md" onclick="exportPlainText()">Export .md</button>
                </div>
            </div>
            <input type="file" id="csv-file-input" accept=".csv" style="display: none;"
                onchange="handleCSVUpload(event)" />

            <div class="global-uncertainty">
                <h2>Uncertainties</h2>

                <div class="uncertainty-controls">
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
                            Δx
                        </label>
                        <select id="x-error-type" onchange="updateErrorType('x')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
                            Δy
                        </label>
                        <select id="y-error-type" onchange="updateErrorType('y')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                </div>

                <h3>Apply Global Uncertainty</h3>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
                    <button onclick="applyGlobalUncertainties('x')">Apply Δx</button>
                </div>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
                    <button onclick="applyGlobalUncertainties('y')">Apply Δy</button>
                </div>
            </div>

            <div class="fit-method-section">
                <h2>Curve Fitting</h2>
                <div class="tabs">
                    <button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
                    <button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
                </div>

                <div id="BasicFit" class="tab-content active">
                    <label for="fit-method">Fit Method:</label>
                    <select id="fit-method" onchange="updateBasicFitEquation()">
                        <option value="Linear">Linear</option>
                        <option value="Polynomial-2">Polynomial (2nd Degree)</option>
                        <option value="Polynomial-3">Polynomial (3rd Degree)</option>
                        <option value="Polynomial-4">Polynomial (4th Degree)</option>
                        <option value="Exponential">Exponential</option>
                        <option value="Power">Power</option>
                    </select>
                    <div id="basic-fit-equation" class="general-equation">
                        \( y = mx + c \)
                    </div>
                    <button class="fit-button" onclick="fitCurve()">Fit Curve</button>
                </div>

                <div id="AdvancedFit" class="tab-content">
                    <label for="advanced-fit-method">Advanced Fit Method:</label>
                    <select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
                        <option value="Sinusoidal">Sinusoidal</option>
                        <option value="Gaussian">Gaussian</option>
                    </select>
                    <div id="advanced-fit-general-equation" class="general-equation">
                        \( y = A e^{bx} \sin(kx - \phi) + c \)
                    </div>
                    <p class="table-prompt">Enter initial fitting parameters below.</p><br>

                    <!-- Sinusoidal Parameters -->
                    <div id="Sinusoidal-parameters" class="parameter-section active">
                        <div class="advanced-fit-item">
                            <label for="initial-A">A:</label>
                            <input type="number" id="initial-A" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b">b:</label>
                            <input type="number" id="initial-b" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-k">k:</label>
                            <input type="number" id="initial-k" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-phi">φ:</label>
                            <input type="number" id="initial-phi" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c">c:</label>
                            <input type="number" id="initial-c" value="0" step="any">
                        </div>
                    </div>

                    <!-- Gaussian Parameters -->
                    <div id="Gaussian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-gaussian">A:</label>
                            <input type="number" id="initial-A-gaussian" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-mu">μ:</label>
                            <input type="number" id="initial-mu" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-sigma">σ:</label>
                            <input type="number" id="initial-sigma" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-gaussian">c:</label>
                            <input type="number" id="initial-c-gaussian" value="0" step="any">
                        </div>
                    </div>

                    <div class="advanced-fit-buttons">
                        <button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Graph section -->
        <div class="graph-section">
            <h2>Graph</h2>
            <div class="graph-title-container">
                <label for="graph-title">Title:</label>
                <input type="text" id="graph-title" placeholder="Enter graph title"
                    oninput="debouncedUpdatePlotAndRenderLatex()">

            </div>
            <div id="plot"></div>

            <div class="result">
                <h3>Fitting Result</h3>
                <p id="fit-equation" style="display: none;"></p>
                <p id="r-squared-container" style="display: none;"></p>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let isSyncing = false;

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);

        function processLabel(label) {
            return label ? `$${formatLabelForLatex(label)}$` : '';
        }

        function initializeTable(initialRows = 7) {
            const tableBody = document.querySelector('#data-table tbody');
            for (let i = 0; i < initialRows; i++) {
                const newRow = tableBody.insertRow();
                newRow.innerHTML = `
                    <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                    <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                    <td class="error-column" style="display: none;"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                    <td class="error-column" style="display: none;"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                `;
            }
            updateData();
        }

        function addRow() {
            const tableBody = document.querySelector('#data-table tbody');
            const newRow = tableBody.insertRow();
            newRow.innerHTML = `
                <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
            `;
            updateData();
        }

        function clearRows(resetHeaders = true) {
            const tableBody = document.querySelector('#data-table tbody');
            tableBody.innerHTML = '';

            if (resetHeaders) {
                isSyncing = true;
                document.getElementById('x-column-name').value = 'x';
                document.getElementById('y-column-name').value = 'y';
                renderLatex('#x-column-latex', formatLabelForLatex('x'));
                renderLatex('#y-column-latex', formatLabelForLatex('y'));

                // Update the graph title using our helper
                updateGraphTitle();

                isSyncing = false;
            }

            initializeTable();

            // Uncheck uncertainty toggles and hide error columns
            document.getElementById('toggle-x-error').checked = false;
            toggleErrorColumn('x');
            document.getElementById('toggle-y-error').checked = false;
            toggleErrorColumn('y');

            // Reset fitting parameters to defaults
            setInitialParameters(getCurrentAdvancedFitMethod());
        }

        function navigateTable(event) {
            const key = event.key;
            const currentInput = event.target;

            const currentCell = currentInput.parentElement;
            const currentRow = currentCell.parentElement;
            const table = currentRow.parentElement.parentElement;
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const rowIndex = rows.indexOf(currentRow);
            const cells = Array.from(currentRow.children);
            const colIndex = cells.indexOf(currentCell);

            let targetRow = rowIndex;
            let targetCol = colIndex;

            switch (key) {
                case 'Enter':
                    event.preventDefault();
                    targetRow = rowIndex + 1;
                    targetCol = colIndex;
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    targetCol = colIndex + 1;
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    targetCol = colIndex - 1;
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    targetRow = rowIndex + 1;
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    targetRow = rowIndex - 1;
                    break;
                default:
                    return;
            }

            if (targetRow < 0) targetRow = 0;
            if (targetRow >= rows.length) targetRow = rows.length - 1;
            if (targetCol < 0) targetCol = 0;
            if (targetCol >= cells.length) targetCol = cells.length - 1;

            const targetCell = rows[targetRow].children[targetCol];
            const targetInput = targetCell.querySelector('input');

            if (targetInput && targetInput.offsetParent !== null) {
                targetInput.focus();
            }
        }

        function toggleErrorColumn(axis) {
            const errorHeader = document.getElementById(`${axis}-error-header`);
            const checkBox = document.getElementById(`toggle-${axis}-error`);
            const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

            if (checkBox.checked) {
                errorHeader.style.display = 'table-cell';
                updateUncertaintyHeaders(axis);
                errorInputs.forEach((input) => {
                    const errorCell = input.parentElement;
                    if (errorCell) {
                        errorCell.style.display = 'table-cell';
                    }
                });
            } else {
                errorHeader.style.display = 'none';
                errorInputs.forEach((input) => {
                    const errorCell = input.parentElement;
                    if (errorCell) {
                        errorCell.style.display = 'none';
                        input.value = '';
                    }
                });
            }

            updateData();

            // Update initial parameters based on the selected advanced fit method
            setInitialParameters(getCurrentAdvancedFitMethod());
        }

        function updateUncertaintyHeaders(axis) {
            const columnName = document.getElementById(`${axis}-column-name`).value.trim() || (axis === 'x' ? 'x' : 'y');
            const errorType = document.getElementById(`${axis}-error-type`).value;
            let headerLatex = `\\pm \\Delta ${formatLabelForLatex(columnName)}`;
            let headerFull = `\\( ${headerLatex} \\)`;
            if (errorType === 'percentage') {
                headerFull += ' (%)';
            }

            const headerElement = document.getElementById(`${axis}-error-header-latex`);
            if (headerElement) {
                headerElement.innerHTML = headerFull;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
            }
        }


        function updateErrorType(axis) {
            if (document.getElementById(`toggle-${axis}-error`).checked) {
                updateUncertaintyHeaders(axis);
            }

            updateData();

            // Update initial parameters based on the selected advanced fit method
            setInitialParameters(getCurrentAdvancedFitMethod());
        }

        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.onerror = function () {
                alert('Error reading the file!');
            };
            reader.readAsText(file);
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                alert('CSV file must contain at least two rows (headers and one data row).');
                return;
            }

            // 1) Parse headers
            const headers = parseCSVLine(lines[0]);
            if (headers.length < 2) {
                alert('CSV file must have at least two columns.');
                return;
            }
            // Determine if the CSV *initially* has X and Y errors
            const hasXError = headers.length >= 3;
            const hasYError = headers.length >= 4;

            // 2) Update top-level inputs & toggles just once
            isSyncing = true;
            document.getElementById('x-column-name').value = headers[0];
            document.getElementById('y-column-name').value = headers[1];
            renderLatex('#x-column-latex', formatLabelForLatex(headers[0]));
            renderLatex('#y-column-latex', formatLabelForLatex(headers[1]));
            updateGraphTitle();
            isSyncing = false;

            // Clear existing rows (without resetting headers)
            clearRows(false);

            // Set the toggles to match the CSV's existing columns
            document.getElementById('toggle-x-error').checked = hasXError;
            document.getElementById('toggle-y-error').checked = hasYError;

            // 3) Build the new rows in memory
            const dataRows = lines.slice(1);
            const tableBody = document.querySelector('#data-table tbody');
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < dataRows.length; i++) {
                const rowData = parseCSVLine(dataRows[i]);
                const tr = document.createElement('tr');

                // x cell
                const tdX = document.createElement('td');
                tdX.innerHTML = `
            <input type="text" class="x-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[0] || ''}">
        `;
                tr.appendChild(tdX);

                // y cell
                const tdY = document.createElement('td');
                tdY.innerHTML = `
            <input type="text" class="y-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[1] || ''}">
        `;
                tr.appendChild(tdY);

                // Always create the X-error column
                const tdXErr = document.createElement('td');
                tdXErr.className = 'error-column x-error-td';
                tdXErr.innerHTML = `
            <input type="text" class="x-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[2] || ''}">
        `;
                // If CSV had no X errors, hide this column for now
                if (!hasXError) tdXErr.style.display = 'none';
                tr.appendChild(tdXErr);

                // Always create the Y-error column
                const tdYErr = document.createElement('td');
                tdYErr.className = 'error-column y-error-td';
                tdYErr.innerHTML = `
            <input type="text" class="y-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[3] || ''}">
        `;
                if (!hasYError) tdYErr.style.display = 'none';
                tr.appendChild(tdYErr);

                fragment.appendChild(tr);
            }

            // 4) Replace the old table rows with our newly built fragment
            tableBody.innerHTML = '';
            tableBody.appendChild(fragment);

            // 5) Update data, re-plot, etc.
            updateData();
            updatePlotAndRenderLatex();
            setInitialParameters(getCurrentAdvancedFitMethod());

            // Finally, let toggleErrorColumn re-apply the current show/hide logic
            toggleErrorColumn('x');
            toggleErrorColumn('y');
        }

        function updateLabels(type) {
            if (isSyncing) return;
            isSyncing = true;
            const value = document.getElementById(`${type}-column-name`).value;
            renderLatex(`#${type}-column-latex`, formatLabelForLatex(value));

            if (document.getElementById(`toggle-${type}-error`).checked) {
                updateUncertaintyHeaders(type);
            }

            debouncedUpdatePlotAndRenderLatex();
            isSyncing = false;

            // Update the graph title dynamically based on both headers
            const xColumn = document.getElementById('x-column-name').value || 'x';
            const yColumn = document.getElementById('y-column-name').value || 'y';
            document.getElementById('graph-title').value = `${yColumn} \\space \\text{vs} \\space ${xColumn}`;

            // Update initial parameters based on the selected advanced fit method
            setInitialParameters(getCurrentAdvancedFitMethod());
        }


        function renderLatex(elementId, latexString) {
            const element = document.querySelector(elementId);
            if (!element) return;
            element.innerHTML = `\\(${latexString}\\)`;
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        }

        function updatePlotAndRenderLatex() {
            if (isSyncing) return;
            isSyncing = true;

            plotGraph();
            const xColumnName = document.getElementById('x-column-name').value || 'x';
            renderLatex('#x-column-latex', formatLabelForLatex(xColumnName));

            const yColumnName = document.getElementById('y-column-name').value || 'y';
            renderLatex('#y-column-latex', formatLabelForLatex(yColumnName));

            isSyncing = false;
        }

        function openTab(evt, tabName) {
            const tablinks = document.getElementsByClassName("tablink");
            const tabContents = document.getElementsByClassName("tab-content");

            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }

            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove("active");
            }

            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");

            if (tabName === 'BasicFit') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
            } else if (tabName === 'AdvancedFit') {
                changeAdvancedFitMethod();
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
            }
        }

        function updateGraphTitle() {
            const xColumn = document.getElementById('x-column-name').value || 'x';
            const yColumn = document.getElementById('y-column-name').value || 'y';
            // Set the title as "y vs x"
            document.getElementById('graph-title').value = `${yColumn} \\space \\text{vs} \\space ${xColumn}`;
        }


        function plotGraph(fittedX = null, fittedY = null) {
            const x = rawData.map(point => point.x);
            const y = rawData.map(point => point.y);
            const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
            const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
            const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
            const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

            const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
            const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Data',
                    marker: { color: '#ff6c61' },
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal',
                        thickness: 0.5,
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal',
                        thickness: 0.5,
                        width: 2
                    }
                }
            ];

            if (fittedX && fittedY) {
                traces.push({
                    x: fittedX,
                    y: fittedY,
                    mode: 'lines',
                    name: 'Fit',
                    line: { color: '#4595dd' }
                });
            }

            const layout = {
                xaxis: { title: processLabel(document.getElementById('x-column-name').value || 'x') },
                yaxis: { title: processLabel(document.getElementById('y-column-name').value || 'y') },
                title: processLabel(document.getElementById('graph-title').value || `${yColumn} \\space \\text{vs} \\space ${xColumn}`),
            };

            Plotly.react('plot', traces, layout, {
                toImageButtonOptions: {
                    format: 'svg',
                    filename: 'data_plot',
                    scale: 1
                }
            });
        }

        function fitCurve() {
            if (rawData.length < 2) {
                alert('Please enter at least two data points.');
                return;
            }

            const fitMethod = document.getElementById('fit-method').value;

            if (fitMethod === 'Linear') {
                performLinearFit(rawData.map(p => p.x), rawData.map(p => p.y));
            } else if (fitMethod.startsWith('Polynomial')) {
                const degree = parseInt(fitMethod.split('-')[1]);
                performPolynomialFit(rawData.map(p => p.x), rawData.map(p => p.y), degree);
            } else if (fitMethod === 'Exponential') {
                performExponentialFit();
            } else if (fitMethod === 'Power') {
                performPowerFit();
            }
        }

        function updateBasicFitEquation() {
            const fitMethod = document.getElementById('fit-method').value;
            let equation = '';

            if (fitMethod === 'Linear') {
                equation = 'y = mx + c';
            } else if (fitMethod.startsWith('Polynomial')) {
                const degree = parseInt(fitMethod.split('-')[1]);
                let terms = [];
                for (let i = degree; i >= 0; i--) {
                    terms.push(`a_${i}x^{${i}}`);
                }
                equation = 'y = ' + terms.join(' + ');
            } else if (fitMethod === 'Exponential') {
                equation = 'y = A e^{bx}';
            } else if (fitMethod === 'Power') {
                equation = 'y = A x^{b}';
            }

            const equationElement = document.getElementById('basic-fit-equation');
            if (equationElement) {
                equationElement.innerHTML = `\\( ${equation} \\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
            }
        }

        function changeAdvancedFitMethod() {
            const selectedMethod = document.getElementById('advanced-fit-method').value;
            const methods = ['Sinusoidal', 'Gaussian'];

            methods.forEach(method => {
                const section = document.getElementById(`${method}-parameters`);
                if (method === selectedMethod) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });

            updateAdvancedFitEquation(selectedMethod);
            setInitialParameters(selectedMethod);
        }

        function updateAdvancedFitEquation(selectedMethod) {
            let equation = '';
            if (selectedMethod === 'Sinusoidal') {
                equation = 'y = A e^{bx} \\sin(kx - \\phi) + c';
            } else if (selectedMethod === 'Gaussian') {
                equation = 'y = A e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}} + c';
            }

            const equationElement = document.getElementById('advanced-fit-general-equation');
            if (equationElement) {
                equationElement.innerHTML = `\\(${equation}\\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
            }
        }

        // Helper function to calculate FWHM for Gaussian Fit (optional, not used here)
        function calculateFWHM(x, y, maxY) {
            const halfMax = maxY / 2;
            let left = null, right = null;

            // Sort data by x
            const sortedData = rawData.slice().sort((a, b) => a.x - b.x);

            // Find left crossing
            for (let i = 1; i < sortedData.length; i++) {
                if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                    const x1 = sortedData[i - 1].x;
                    const y1 = sortedData[i - 1].y;
                    const x2 = sortedData[i].x;
                    const y2 = sortedData[i].y;
                    left = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                    break;
                }
            }

            // Find right crossing
            for (let i = sortedData.length - 1; i > 0; i--) {
                if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                    const x1 = sortedData[i - 1].x;
                    const y1 = sortedData[i - 1].y;
                    const x2 = sortedData[i].x;
                    const y2 = sortedData[i].y;
                    right = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                    break;
                }
            }

            if (left !== null && right !== null && right > left) {
                return right - left;
            } else {
                const minX = Math.min(...x);
                const maxX = Math.max(...x);
                return (maxX - minX) / 4;
            }
        }

        // Function to set initial parameters based on selected method and data
        function setInitialParameters(method) {
            if (!method) return; // If method is undefined, do nothing

            if (rawData.length === 0) return;

            const x = rawData.map(p => p.x);
            const y = rawData.map(p => p.y);
            const meanX = x.reduce((sum, val) => sum + val, 0) / x.length;
            const stdX = Math.sqrt(x.reduce((sum, val) => sum + Math.pow(val - meanX, 2), 0) / x.length);
            const maxY = Math.max(...y);
            const FWHM = calculateFWHM(x, y, maxY);

            if (method === 'Gaussian') {
                document.getElementById('initial-A-gaussian').value = maxY.toFixed(3);
                document.getElementById('initial-mu').value = meanX.toFixed(3);
                document.getElementById('initial-sigma').value = (FWHM / (2 * Math.sqrt(2 * Math.log(2)))).toFixed(3);
                document.getElementById('initial-c-gaussian').value = '0';
            } else if (method === 'Sinusoidal') {
                // Set A to maxY, b to slope from linear fit, phi to 0, c to meanY
                const meanY = y.reduce((sum, val) => sum + val, 0) / y.length;
                const linearFit = computeLinearFit(x, y);
                const A = maxY - meanY;
                const b = linearFit.slope;
                const phi = 0;
                const c = meanY;

                // Estimate k from data and set it
                const estimatedK = estimateKFromData();
                if (estimatedK !== null) {
                    document.getElementById('initial-k').value = estimatedK.toFixed(3);
                } else {
                    document.getElementById('initial-k').value = '1'; // Default value if estimation fails
                }

                document.getElementById('initial-A').value = A.toFixed(3);
                document.getElementById('initial-b').value = b.toFixed(3);
                document.getElementById('initial-phi').value = phi.toFixed(3);
                document.getElementById('initial-c').value = c.toFixed(3);
            }
        }

        function getCurrentAdvancedFitMethod() {
            return document.getElementById('advanced-fit-method').value;
        }

        function computeLinearFit(x, y) {
            try {
                const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
                const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

                let numerator = 0, denominator = 0;
                for (let i = 0; i < x.length; i++) {
                    numerator += (x[i] - xMean) * (y[i] - yMean);
                    denominator += (x[i] - xMean) ** 2;
                }

                const slope = numerator / denominator;
                const intercept = yMean - slope * xMean;

                return { slope, intercept };
            } catch (error) {
                console.error('Error computing linear fit:', error);
                throw error;
            }
        }

        function updateResults(equation, x, y, fitFunction) {
            try {
                const yPredicted = x.map(point => fitFunction(point));
                const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

                let ssTotal = 0, ssResidual = 0;
                for (let i = 0; i < y.length; i++) {
                    ssTotal += (y[i] - meanY) ** 2;
                    ssResidual += (y[i] - yPredicted[i]) ** 2;
                }

                const rSquared = 1 - ssResidual / ssTotal;

                const fitEquationElement = document.getElementById('fit-equation');
                if (fitEquationElement) {
                    fitEquationElement.innerHTML = `\\(${equation}\\)`;
                    fitEquationElement.style.display = 'block';
                }

                const rSquaredContainer = document.getElementById('r-squared-container');
                if (rSquaredContainer) {
                    rSquaredContainer.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
                    rSquaredContainer.style.display = 'block';
                }

                MathJax.Hub.Queue(["Typeset", MathJax.Hub, fitEquationElement]);
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, rSquaredContainer]);
            } catch (error) {
                console.error('Error updating results:', error);
            }
        }

        function polyfit(x, y, degree) {
            try {
                const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
                const Xt = math.transpose(X);
                const XtX = math.multiply(Xt, X);
                const XtY = math.multiply(Xt, y);
                const coefficients = math.lusolve(XtX, XtY).flat();
                return coefficients;
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                throw error;
            }
        }

        function polyEval(coefficients, x) {
            try {
                return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
            } catch (error) {
                console.error('Error evaluating polynomial:', error);
                throw error;
            }
        }

        function updateData() {
            try {
                const xInputs = document.querySelectorAll('.x-input');
                const yInputs = document.querySelectorAll('.y-input');
                const xErrorInputs = document.querySelectorAll('.x-error-input');
                const yErrorInputs = document.querySelectorAll('.y-error-input');

                rawData = [];
                for (let i = 0; i < xInputs.length; i++) {
                    const x = parseFloat(xInputs[i].value);
                    const y = parseFloat(yInputs[i].value);
                    const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
                    const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

                    if (!isNaN(x) && !isNaN(y)) {
                        rawData.push({
                            x: x,
                            y: y,
                            xErrorRaw: xErrorRaw,
                            yErrorRaw: yErrorRaw
                        });
                    }
                }

                plotGraph();
            } catch (error) {
                console.error('Error updating data:', error);
            }
        }

        window.onload = function () {
            initializeTable();
            ['x-column-name', 'y-column-name'].forEach(id => {
                const value = document.getElementById(id).value;
                renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
            });

            // Update the graph title based on the current column headings:
            updateGraphTitle();

            // Trigger typesetting for the new graph title if necessary.
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);

            updateBasicFitEquation();
            const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
            changeAdvancedFitMethod();
        };

        document.addEventListener("DOMContentLoaded", function () {

            ['x-column-name', 'y-column-name'].forEach(id => {
                const value = document.getElementById(id).value;
                renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
            });

            // Update the graph title based on the current column headings:
            updateGraphTitle();

            // Trigger MathJax typesetting for the graph title (if necessary)
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);

            updateBasicFitEquation();
            const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
            changeAdvancedFitMethod();
        });

        function formatDataForExport(valueStr, errorStr, errorEnabled, errorType, val, rowVal, rowErr) {
            if (!errorEnabled) {
                return valueStr;
            }

            if (isNaN(rowErr)) return valueStr;

            if (errorType === 'absolute') {
                const dp = countDecimalPlaces(errorStr);
                return val.toFixed(dp);
            } else if (errorType === 'percentage') {
                const perc = parseFloat(errorStr);
                if (isNaN(perc)) {
                    return valueStr;
                }

                // Use 1 significant figure if percentage uncertainty is >= 50%
                let sigFigs;
                if (perc >= 50) {
                    sigFigs = 1;
                } else if (perc <= 10) {
                    sigFigs = 3;
                } else {
                    sigFigs = 2;
                }

                const sfVal = toSigFigs(val, sigFigs);
                return sfVal;
            } else {
                return valueStr;
            }
        }


        /**
         * Formats labels for LaTeX by replacing spaces with \space.
         * @param {string} label - The label to format.
         * @returns {string} - The LaTeX-formatted label.
         */
        function formatLabelForLatex(label) {
            return label ? label.replace(/ /g, '\\space ') : '';
        }


        /**
         * Counts the number of decimal places in a number string.
         * @param {string} numStr - The number as a string.
         * @returns {number} - The number of decimal places.
         */
        function countDecimalPlaces(numStr) {
            if (!numStr.includes('.')) return 0;
            return numStr.length - numStr.indexOf('.') - 1;
        }

        /**
         * Formats a number to the specified number of significant figures without using scientific notation.
         * Preserves trailing zeros by returning a string.
         * @param {number} num - The number to format.
         * @param {number} sigFigs - The number of significant figures.
         * @returns {string} - The formatted number as a string.
         */
        function toSigFigs(num, sigFigs) {
            if (num === 0) return '0';

            if (sigFigs === 1) {
                const order = Math.floor(Math.log10(Math.abs(num)));
                const factor = Math.pow(10, order);
                const rounded = Math.floor(num / factor) * factor;
                return order >= 0 ? rounded.toString() : rounded.toFixed(Math.abs(order));
            }

            let numStr = num.toPrecision(sigFigs);
            if (numStr.includes('e') || numStr.includes('E')) {
                const [mantissa, exponent] = numStr.split(/e/i);
                const exponentVal = parseInt(exponent, 10);
                let fixedNum = parseFloat(mantissa) * Math.pow(10, exponentVal);
                const decimalPlaces = sigFigs - 1 - Math.floor(Math.log10(Math.abs(num)));
                return fixedNum.toFixed(decimalPlaces > 0 ? decimalPlaces : 0);
            }
            return numStr;
        }

        /**
         * Formats a number into scientific notation for LaTeX with specified significant figures.
         * @param {number} num - The number to format.
         * @param {number} sigFigs - The number of significant figures.
         * @returns {string} - The LaTeX-formatted scientific notation string.
         */
        function formatScientificNotation(num, sigFigs) {
            if (sigFigs === 1) {
                return toSigFigs(num, sigFigs);
            }
            let numStr = num.toExponential(sigFigs - 1);
            return numStr;
        }


        /**
         * Formats data values based on the uncertainty type.
         *
         * For 'absolute' uncertainty:
         *   - If the absolute uncertainty is ≥ 1, the data value is rounded down (via Math.floor)
         *     to the nearest multiple determined by the order of magnitude of the uncertainty.
         *     For example, 1455 with an uncertainty of 40 becomes 1450.
         *   - If the absolute uncertainty is < 1, the data value is formatted to the same number of
         *     decimal places as the uncertainty (preserving trailing zeros).
         *
         * For 'percentage' uncertainty:
         *   - When the percentage uncertainty is greater than or equal to 50%, the data value is formatted
         *     to 1 significant figure.
         *   - Otherwise, the data value is formatted to a fixed number of significant figures:
         *       * 3 significant figures if the uncertainty is less than 10,
         *       * 2 significant figures otherwise.
         *   - Scientific notation is applied if indicated.
         *
         * If no uncertainty is provided, the data value is simply returned as a string.
         *
         * @param {number} dataVal - The data value.
         * @param {number} uncertaintyVal - The uncertainty value.
         * @param {string} uncertaintyType - The type of uncertainty ('absolute' or 'percentage').
         * @param {boolean} useSciNotation - Whether to apply scientific notation.
         * @returns {string} - The formatted data value.
         */
        function formatDataValue(dataVal, uncertaintyVal, uncertaintyType, useSciNotation) {
            if (uncertaintyType === 'absolute') {
                if (Math.abs(uncertaintyVal) >= 1) {
                    const order = Math.floor(Math.log10(Math.abs(uncertaintyVal)));
                    const factor = Math.pow(10, order);
                    const roundedValue = Math.floor(dataVal / factor) * factor;
                    return roundedValue.toFixed(0);
                } else {
                    const dp = countDecimalPlaces(uncertaintyVal.toString());
                    // Simply return the data value formatted with 'dp' decimal places,
                    // preserving all trailing zeros.
                    return dataVal.toFixed(dp);
                }
            } else if (uncertaintyType === 'percentage') {
                const perc = parseFloat(uncertaintyVal);
                if (isNaN(perc)) return dataVal.toString();
                // Use 1 s.f. if percentage uncertainty is >= 50, else use 3 s.f. if error < 10, otherwise 2 s.f.
                const sigFigs = perc >= 50 ? 1 : (perc < 10 ? 3 : 2);
                if (useSciNotation) {
                    return formatScientificNotation(dataVal, sigFigs);
                } else {
                    return toSigFigs(dataVal, sigFigs);
                }
            } else {
                return dataVal.toString();
            }
        }

        /**
         * Formats uncertainties based on their type.
         * - For percentage uncertainties: preserves the exact input (optionally add '\\%' if needed).
         * - For absolute uncertainties: preserves trailing zeros based on the number of decimal places.
         * @param {string} errStr - The uncertainty value as a string.
         * @param {string} errorType - The type of uncertainty ('absolute' or 'percentage').
         * @returns {string} - The formatted uncertainty string.
         */
        function formatUncertainty(errStr, errorType) {
            if (errorType === 'percentage') {
                return errStr; // Optionally: return errStr + '\\%' if desired.
            } else if (errorType === 'absolute') {
                const dp = countDecimalPlaces(errStr);
                const errVal = parseFloat(errStr);
                if (isNaN(errVal)) return errStr;
                return errVal.toFixed(dp);
            } else {
                return errStr;
            }
        }

        /**
         * Exports the data as a Markdown (.md) file with LaTeX formatting.
         */
        function exportPlainText() {
            try {
                // Retrieve axis headings
                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';

                // Check if uncertainties are enabled
                const xErrorEnabled = document.getElementById('toggle-x-error').checked;
                const yErrorEnabled = document.getElementById('toggle-y-error').checked;

                // Get uncertainty types
                const xErrorType = document.getElementById('x-error-type').value;
                const yErrorType = document.getElementById('y-error-type').value;

                // Get all rows from the data table's tbody
                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tbody tr');

                // Initialize arrays to collect all x and y values
                let xValues = [];
                let yValues = [];

                // Collect all x and y values for notation decision
                rows.forEach(row => {
                    const xInputElem = row.querySelector('.x-input');
                    const yInputElem = row.querySelector('.y-input');

                    if (!xInputElem || !yInputElem) return;

                    const xValStr = xInputElem.value.trim();
                    const yValStr = yInputElem.value.trim();

                    if (xValStr !== '') {
                        const xVal = parseFloat(xValStr);
                        if (!isNaN(xVal)) xValues.push(xVal);
                    }
                    if (yValStr !== '') {
                        const yVal = parseFloat(yValStr);
                        if (!isNaN(yVal)) yValues.push(yVal);
                    }
                });

                // Determine if scientific notation is needed for x and y
                const xUseSciNotation = xErrorEnabled && xErrorType === 'percentage' &&
                    xValues.some(val => val < -10000 || val > 10000);
                const yUseSciNotation = yErrorEnabled && yErrorType === 'percentage' &&
                    yValues.some(val => val < -10000 || val > 10000);

                // Initialize headers with LaTeX formatting
                let headers = [
                    `$${formatLabelForLatex(xHeader)}$`,
                    `$${formatLabelForLatex(yHeader)}$`
                ];

                if (xErrorEnabled) {
                    let xUncHeading = `\\pm \\Delta ${formatLabelForLatex(xHeader)}`;
                    if (xErrorType === 'percentage') xUncHeading += ' \\space (\\%)';
                    headers.push(`$${xUncHeading}$`);
                }
                if (yErrorEnabled) {
                    let yUncHeading = `\\pm \\Delta ${formatLabelForLatex(yHeader)}`;
                    if (yErrorType === 'percentage') yUncHeading += ' \\space (\\%)';
                    headers.push(`$${yUncHeading}$`);
                }

                let markdown = `| ${headers.join(' | ')} |\n`;
                markdown += `|${headers.map(() => ':---:').join('|')}|\n`;

                // Process each row
                rows.forEach(row => {
                    const xInputElem = row.querySelector('.x-input');
                    const yInputElem = row.querySelector('.y-input');
                    if (!xInputElem || !yInputElem) return;

                    const xValStr = xInputElem.value.trim();
                    const yValStr = yInputElem.value.trim();
                    if (xValStr === '' && yValStr === '') return;

                    const xVal = parseFloat(xValStr);
                    const yVal = parseFloat(yValStr);

                    const xErrInput = row.querySelector('.x-error-input');
                    const yErrInput = row.querySelector('.y-error-input');
                    const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                    const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                    const xErrVal = parseFloat(xErrStr);
                    const yErrVal = parseFloat(yErrStr);
                    const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                    const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                    let rowData = [];

                    // Format X value
                    let xFormatted = xValStr;
                    if (!isNaN(xVal)) {
                        if (xUseSciNotation && xErrorEnabledThisRow && xErrorType === 'percentage') {
                            const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
                            const sciFormatted = formatScientificNotation(xVal, sigFigs);
                            xFormatted = `$${sciFormatted}$`;
                        } else if (xErrorEnabledThisRow && xErrorType === 'percentage') {
                            const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
                            const sigFormatted = toSigFigs(xVal, sigFigs);
                            xFormatted = `$${sigFormatted}$`;
                        } else if (xErrorEnabledThisRow && xErrorType === 'absolute') {
                            const formattedData = formatDataValue(xVal, xErrVal, 'absolute', false);
                            xFormatted = `$${formattedData}$`;
                        } else {
                            xFormatted = `$${xValStr}$`;
                        }
                    }

                    // Format Y value
                    let yFormatted = yValStr;
                    if (!isNaN(yVal)) {
                        if (yUseSciNotation && yErrorEnabledThisRow && yErrorType === 'percentage') {
                            const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
                            const sciFormatted = formatScientificNotation(yVal, sigFigs);
                            yFormatted = `$${sciFormatted}$`;
                        } else if (yErrorEnabledThisRow && yErrorType === 'percentage') {
                            const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
                            const sigFormatted = toSigFigs(yVal, sigFigs);
                            yFormatted = `$${sigFormatted}$`;
                        } else if (yErrorEnabledThisRow && yErrorType === 'absolute') {
                            const formattedData = formatDataValue(yVal, yErrVal, 'absolute', false);
                            yFormatted = `$${formattedData}$`;
                        } else {
                            yFormatted = `$${yValStr}$`;
                        }
                    }

                    rowData.push(xFormatted);
                    rowData.push(yFormatted);
                    if (xErrorEnabled) {
                        let xErrorFormatted = xErrorEnabledThisRow ? formatUncertainty(xErrStr, xErrorType) : '';
                        if (xErrorFormatted !== '') xErrorFormatted = `$${xErrorFormatted}$`;
                        rowData.push(xErrorFormatted);
                    }
                    if (yErrorEnabled) {
                        let yErrorFormatted = yErrorEnabledThisRow ? formatUncertainty(yErrStr, yErrorType) : '';
                        if (yErrorFormatted !== '') yErrorFormatted = `$${yErrorFormatted}$`;
                        rowData.push(yErrorFormatted);
                    }
                    markdown += `| ${rowData.join(' | ')} |\n`;
                });

                console.log("Final Markdown Content:\n", markdown);
                const blob = new Blob([markdown], { type: 'text/plain;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'data.md');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting plain text:', error);
                alert('An error occurred while exporting the Markdown file. Please check the console for details.');
            }
        }


        function exportCSV() {
            try {
                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tr');
                let csvContent = '';

                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
                const xErrorEnabled = document.getElementById('toggle-x-error').checked;
                const yErrorEnabled = document.getElementById('toggle-y-error').checked;

                const headers = [xHeader, yHeader];
                if (xErrorEnabled) {
                    const xErrorType = document.getElementById('x-error-type').value;
                    const xErrorHead = xErrorType === 'percentage' ? `delta ${xHeader} (%)` : `delta ${xHeader}`;
                    headers.push(xErrorHead);
                }
                if (yErrorEnabled) {
                    const yErrorType = document.getElementById('y-error-type').value;
                    const yErrorHead = yErrorType === 'percentage' ? `delta ${yHeader} (%)` : `delta ${yHeader}`;
                    headers.push(yErrorHead);
                }

                csvContent += headers.join(',') + '\n';

                const dataRows = table.querySelectorAll('tbody tr');

                for (let i = 0; i < dataRows.length; i++) {
                    const xValStr = dataRows[i].querySelector('.x-input')?.value.trim() || '';
                    const yValStr = dataRows[i].querySelector('.y-input')?.value.trim() || '';
                    if (xValStr === '' && yValStr === '') continue;

                    let xVal = parseFloat(xValStr);
                    let yVal = parseFloat(yValStr);

                    const xErrInput = dataRows[i].querySelector('.x-error-input');
                    const yErrInput = dataRows[i].querySelector('.y-error-input');

                    const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                    const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                    const xErrVal = parseFloat(xErrStr);
                    const yErrVal = parseFloat(yErrStr);

                    const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                    const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                    const xErrorType = document.getElementById('x-error-type').value;
                    const yErrorType = document.getElementById('y-error-type').value;

                    let rowData = [];

                    let xFormatted = xValStr;
                    if (!isNaN(xVal)) {
                        xFormatted = formatDataForExport(
                            xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
                        );
                    }

                    let yFormatted = yValStr;
                    if (!isNaN(yVal)) {
                        yFormatted = formatDataForExport(
                            yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
                        );
                    }

                    rowData.push(xFormatted);
                    rowData.push(yFormatted);

                    if (xErrorEnabled) {
                        rowData.push(xErrorEnabledThisRow ? xErrStr : '');
                    }

                    if (yErrorEnabled) {
                        rowData.push(yErrorEnabledThisRow ? yErrStr : '');
                    }

                    csvContent += rowData.join(',') + '\n';
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('An error occurred while exporting the CSV. Please check the console for details.');
            }
        }

        function applyGlobalUncertainties(axis) {
            const globalVal = document.getElementById(`global-${axis}-uncertainty`).value.trim();
            const tableBody = document.querySelector('#data-table tbody');
            const rows = tableBody.querySelectorAll('tr');

            rows.forEach((row) => {
                const xInput = row.querySelector('.x-input').value.trim();
                const yInput = row.querySelector('.y-input').value.trim();

                if (xInput !== '' && yInput !== '') {
                    const errorInput = row.querySelector(`.${axis}-error-input`);
                    if (document.getElementById(`toggle-${axis}-error`).checked && errorInput) {
                        errorInput.value = globalVal !== '' ? globalVal : '';
                    }
                }
            });

            updateData();
            document.getElementById(`global-${axis}-uncertainty`).value = '';

            // Update initial parameters based on the selected advanced fit method
            setInitialParameters(getCurrentAdvancedFitMethod());
        }

        function fitAdvancedCurve() {
            if (rawData.length < 4) { // Increased to 4 for more complex fits
                alert('Please enter at least four data points for advanced fitting.');
                return;
            }

            const fitMethod = document.getElementById('advanced-fit-method').value;

            if (fitMethod === 'Sinusoidal') {
                performSinusoidalFit();
            } else if (fitMethod === 'Gaussian') {
                performGaussianFit();
            }
        }

        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                let equation = `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
                if (intercept < 0) {
                    equation = `y = ${slope.toFixed(3)}x - ${Math.abs(intercept).toFixed(3)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return;

                    const absC = Math.abs(c).toFixed(3);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        function performExponentialFit() {
            try {
                // Ensure all y values are positive
                const validData = rawData.filter(point => point.y > 0);
                if (validData.length < 2) {
                    alert('Exponential fit requires all y values to be positive.');
                    return;
                }

                const x = validData.map(p => p.x);
                const y = validData.map(p => Math.log(p.y));

                const { slope, intercept } = computeLinearFit(x, y);

                const b = slope;
                const A = Math.exp(intercept);

                // Generate fitted curve
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => A * Math.exp(b * xi));

                const fitFunction = xi => A * Math.exp(b * xi);

                // Equation string
                let equation = `y = ${A.toFixed(3)} e^{${b.toFixed(3)}x}`;

                updateResults(equation, x, validData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        function performPowerFit() {
            try {
                // Ensure all y and x values are positive
                const validData = rawData.filter(point => point.y > 0 && point.x > 0);
                if (validData.length < 2) {
                    alert('Power fit requires all x and y values to be positive.');
                    return;
                }

                const x = validData.map(p => Math.log(p.x));
                const y = validData.map(p => Math.log(p.y));

                const { slope, intercept } = computeLinearFit(x, y);

                const b = slope;
                const A = Math.exp(intercept);

                // Generate fitted curve
                const xOriginal = validData.map(p => p.x);
                const xFitOriginal = Array.from({ length: 100 }, (_, i) => Math.min(...xOriginal) + i * (Math.max(...xOriginal) - Math.min(...xOriginal)) / 99);
                const yFit = xFitOriginal.map(xi => A * Math.pow(xi, b));

                const fitFunction = xi => A * Math.pow(xi, b);

                // Equation string
                let equation = `y = ${A.toFixed(3)} x^{${b.toFixed(3)}}`;

                updateResults(equation, validData.map(p => p.x), validData.map(p => p.y), fitFunction);
                plotGraph(xFitOriginal, yFit);
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }

        function estimateKFromData() {
            if (!rawData || rawData.length < 4) {
                console.warn("Not enough data points to estimate k.");
                return null;
            }

            // === 1. Sort & detrend ===
            const sortedData = [...rawData].sort((a, b) => a.x - b.x);
            const x = sortedData.map(p => p.x);
            const y = sortedData.map(p => p.y);

            const N = x.length;
            const xMin = x[0];
            const xMax = x[N - 1];
            const dataSpan = xMax - xMin;
            if (dataSpan <= 0) {
                console.warn("Degenerate or invalid X range.");
                return null;
            }

            // Mean of y for detrending
            const meanY = y.reduce((acc, val) => acc + val, 0) / N;
            const yDetrended = y.map(val => val - meanY);

            // We'll also need an approximate sampling step to gauge a "Nyquist" limit
            //   (roughly valid if data is close to uniform in x).
            const avgDx = dataSpan / (N - 1);
            // A naive Nyquist frequency ~ π / avgDx
            const nyquist = Math.PI / avgDx;

            // === 2. Optional: Peak-detection for rough kGuess ===
            let peaks = [];
            for (let i = 1; i < N - 1; i++) {
                if (y[i] > y[i - 1] && y[i] > y[i + 1]) {
                    peaks.push(x[i]);
                }
            }
            let kGuess = null;
            if (peaks.length >= 2) {
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i] - peaks[i - 1]);
                }
                const avgPeriod = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                kGuess = (2 * Math.PI) / avgPeriod;
                console.log(
                    `Peak-detect guess => period ~ ${avgPeriod.toFixed(4)}, kGuess ~ ${kGuess.toFixed(4)}`
                );
            } else {
                console.log("Not enough peaks for a peak-based guess.");
            }

            // === 3. Define an initial log-spaced frequency range ===
            // We'll define a broad range, but not infinite.
            // Lower bound: say 2π / (5 * dataSpan) => up to ~5 cycles across the entire domain
            // or 1e-3 if that is bigger, just to avoid going too close to zero.
            const minCandidate = Math.max(1e-3, (2 * Math.PI) / (5 * dataSpan));

            // Upper bound: let's pick something around 5 × the naive Nyquist as a default
            // (i.e. 5 × π / avgDx), but not less than, say, 10 if the data is extremely well-sampled.
            let maxCandidate = Math.max(10, nyquist * 5);

            // If we do have a kGuess, ensure that we include it by possibly expanding the range:
            if (kGuess && Number.isFinite(kGuess) && kGuess > 0) {
                if (kGuess < minCandidate) {
                    // expand downward
                    console.log(
                        `kGuess < minCandidate => adjusting minCandidate from ${minCandidate.toFixed(4)} to ~${kGuess / 5}`
                    );
                    minCandidate <= 1e-7
                        ? (minCandidate = 1e-7)
                        : (minCandidate = Math.max(1e-7, kGuess / 5));
                }
                if (kGuess > maxCandidate) {
                    console.log(
                        `kGuess > maxCandidate => adjusting maxCandidate from ${maxCandidate.toFixed(4)} to ~${kGuess * 5}`
                    );
                    maxCandidate = kGuess * 5;
                }
            }

            console.log(
                `Log-search range: [${minCandidate.toFixed(4)}, ${maxCandidate.toFixed(4)}]`
            );

            // === 4. Coarse search in log space ===
            // We'll sample frequencies log-spaced from minCandidate to maxCandidate
            const numLogSamples = 200; // ~200 log steps
            const logMin = Math.log(minCandidate);
            const logMax = Math.log(maxCandidate);

            let bestCoarseOmega = 0;
            let bestCoarseScore = -Infinity;

            for (let i = 0; i < numLogSamples; i++) {
                // Log spacing
                const frac = i / (numLogSamples - 1);
                const omega = Math.exp(logMin + frac * (logMax - logMin));

                let sumSin = 0;
                let sumCos = 0;
                for (let j = 0; j < N; j++) {
                    const val = yDetrended[j];
                    const phase = omega * x[j];
                    sumSin += val * Math.sin(phase);
                    sumCos += val * Math.cos(phase);
                }
                const score = sumSin * sumSin + sumCos * sumCos;
                if (score > bestCoarseScore) {
                    bestCoarseScore = score;
                    bestCoarseOmega = omega;
                }
            }
            console.log(
                `Log-coarse best => omega = ${bestCoarseOmega.toFixed(4)}, score = ${bestCoarseScore.toExponential(3)}`
            );

            // === 5. Fine local linear search around bestCoarseOmega ===
            // We'll do ± 30% in linear space (adjust as desired)
            const fineFactor = 0.3;
            const fineMin = Math.max(minCandidate, bestCoarseOmega * (1 - fineFactor));
            const fineMax = Math.min(maxCandidate, bestCoarseOmega * (1 + fineFactor));

            let bestFineOmega = bestCoarseOmega;
            let bestFineScore = bestCoarseScore;

            if (fineMax <= fineMin) {
                console.warn(
                    `Fine search range is degenerate => [${fineMin}, ${fineMax}]. Returning coarse result.`
                );
                return bestCoarseOmega;
            }

            const numFine = 3000; // ~3k linear steps
            const step = (fineMax - fineMin) / (numFine - 1);

            for (let i = 0; i < numFine; i++) {
                const omega = fineMin + i * step;
                let sumSin = 0;
                let sumCos = 0;
                for (let j = 0; j < N; j++) {
                    const val = yDetrended[j];
                    const phase = omega * x[j];
                    sumSin += val * Math.sin(phase);
                    sumCos += val * Math.cos(phase);
                }
                const score = sumSin * sumSin + sumCos * sumCos;
                if (score > bestFineScore) {
                    bestFineScore = score;
                    bestFineOmega = omega;
                }
            }
            console.log(
                `Fine search best => omega = ${bestFineOmega.toFixed(4)}, score = ${bestFineScore.toExponential(3)}`
            );

            // === 6. Final sanity check vs. Nyquist? ===
            if (bestFineOmega > 2 * nyquist) {
                console.warn(
                    `Warning: best freq = ${bestFineOmega.toFixed(4)} is > 2 × Nyquist (~${(2 * nyquist).toFixed(4)}). Data may be under-sampled.`
                );
            }

            console.log(
                `Final estimated k = ${bestFineOmega.toFixed(4)}`
            );
            return bestFineOmega;
        }

        function performSinusoidalFit() {
            try {
                // Parse initial parameters
                let A = parseFloat(document.getElementById('initial-A').value);
                let b = parseFloat(document.getElementById('initial-b').value);
                let k = parseFloat(document.getElementById('initial-k').value);
                let phi = parseFloat(document.getElementById('initial-phi').value);
                let c = parseFloat(document.getElementById('initial-c').value);

                // Estimate k if not valid
                if (isNaN(k) || k <= 0) {
                    const estimatedK = estimateKFromData();
                    if (estimatedK !== null) {
                        k = estimatedK;
                        console.log(`Using estimated k: ${k}`);
                        document.getElementById('initial-k').value = k.toFixed(3);
                    } else {
                        alert('Failed to estimate k. Please provide an initial value.');
                        return;
                    }
                }

                // Validate other parameters
                if (isNaN(A) || isNaN(b) || isNaN(phi) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Sinusoidal fit.');
                    return;
                }

                // Define parameters object
                let params = { A: A, b: b, k: k, phi: phi, c: c };

                // Settings for the optimizer
                let learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;
                let previousError = Infinity;
                let iterationsCount = 0;

                // Learning rate decay (optional)
                const decayRate = 0.99995;

                // Parameter for Huber loss
                const delta = 1.0;  // You can adjust delta as needed

                // Fitting loop using the Huber loss
                while (iterationsCount < maxIterations) {
                    let totalLoss = 0;

                    // Initialize gradients to zero
                    let dA = 0, db = 0, dk = 0, dphi = 0, dc = 0;

                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;

                        const expTerm = Math.exp(params.b * xi);
                        const sinTerm = Math.sin(params.k * xi - params.phi);
                        const cosTerm = Math.cos(params.k * xi - params.phi);

                        // Prediction for the current point
                        const prediction = params.A * expTerm * sinTerm + params.c;

                        // Compute the error
                        const error = yi - prediction;

                        // Compute Huber loss and its derivative
                        let huberGrad;
                        if (Math.abs(error) <= delta) {
                            // Quadratic case
                            totalLoss += error ** 2;
                            huberGrad = 2 * error;
                        } else {
                            // Linear case
                            totalLoss += 2 * delta * Math.abs(error) - delta ** 2;
                            huberGrad = 2 * delta * Math.sign(error);
                        }

                        // Accumulate gradients using the chain rule.
                        // Remember: derivative of loss wrt parameter = huberGrad * (derivative of prediction wrt parameter)
                        dA += -huberGrad * expTerm * sinTerm;
                        db += -huberGrad * params.A * xi * expTerm * sinTerm;
                        dk += -huberGrad * params.A * expTerm * xi * cosTerm;
                        dphi += huberGrad * params.A * expTerm * cosTerm;
                        dc += -huberGrad;
                    }

                    // Average loss over data points for comparison with tolerance
                    const mse = totalLoss / rawData.length;

                    // Check convergence
                    if (Math.abs(previousError - mse) < tolerance) {
                        console.log(`Convergence reached after ${iterationsCount} iterations.`);
                        break;
                    }
                    previousError = mse;

                    // Update parameters
                    params.A -= learningRate * dA;
                    params.b -= learningRate * db;
                    params.k -= learningRate * dk;
                    params.phi -= learningRate * dphi;
                    params.c -= learningRate * dc;

                    // Optionally decay the learning rate to help convergence near minima.
                    learningRate *= decayRate;

                    iterationsCount++;
                }

                if (iterationsCount === maxIterations) {
                    alert('Sinusoidal fitting did not converge. Please try different initial parameters.');
                    return;
                }

                // Generate fitted data for plotting
                const xMin = Math.min(...rawData.map(p => p.x));
                const xMax = Math.max(...rawData.map(p => p.x));
                const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
                const yFit = xFit.map(xi =>
                    params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c
                );

                // Create the fit function
                const fitFunction = xi =>
                    params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c;

                // Construct the equation string nicely
                let equation = `y = ${params.A.toFixed(3)} e^{${params.b.toFixed(3)}x} \\sin(${params.k.toFixed(3)}x`;
                if (params.phi > 0) {
                    equation += ` - ${params.phi.toFixed(3)}`;
                } else if (params.phi < 0) {
                    equation += ` + ${Math.abs(params.phi).toFixed(3)}`;
                }
                equation += `)`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(3)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(3)}`;
                }

                // Update the UI with results and plot
                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing sinusoidal fit:', error);
                alert('An error occurred during sinusoidal fitting. Please check the console for details.');
            }
        }

        function performGaussianFit() {
            try {
                // Parse initial parameters from the DOM
                let A = parseFloat(document.getElementById('initial-A-gaussian').value);
                let mu = parseFloat(document.getElementById('initial-mu').value);
                let sigma = parseFloat(document.getElementById('initial-sigma').value);
                let c = parseFloat(document.getElementById('initial-c-gaussian').value);

                if (isNaN(A) || isNaN(mu) || isNaN(sigma) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Gaussian fit.');
                    return;
                }

                // Package our parameters in an object
                const params = { A, mu, sigma, c };

                // -- Settings for the gradient descent --
                const learningRateA = 1e-7;
                const learningRateMu = 1e-7;
                const learningRateSigma = 1e-7;
                const learningRateC = 1e-7;

                const maxIterations = 50000;
                const tolerance = 1e-8;

                // Gaussian function
                function gaussian(x, p) {
                    return p.A * Math.exp(-((x - p.mu) ** 2) / (2 * p.sigma ** 2)) + p.c;
                }

                // Compute mean-squared error for the current parameters
                function computeMSE(p) {
                    let mseSum = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const { x, y } = rawData[i];
                        const prediction = gaussian(x, p);
                        const error = y - prediction;
                        mseSum += error * error;
                    }
                    return mseSum / rawData.length;
                }

                let previousError = computeMSE(params);

                // Gradient descent main loop
                for (let iteration = 0; iteration < maxIterations; iteration++) {
                    // Accumulators for the partial derivatives
                    let dA = 0, dMu = 0, dSigma = 0, dC = 0;

                    // Compute partial derivatives for each data point and sum them
                    for (let i = 0; i < rawData.length; i++) {
                        const { x, y } = rawData[i];
                        const expTerm = Math.exp(-((x - params.mu) ** 2) / (2 * params.sigma ** 2));
                        const prediction = params.A * expTerm + params.c;
                        const error = y - prediction; // error = (actual - predicted)

                        // Accumulate derivatives
                        dA += error * expTerm;
                        dMu += error * params.A * expTerm * ((x - params.mu) / (params.sigma ** 2));
                        dSigma += error * params.A * expTerm * ((x - params.mu) ** 2) / (params.sigma ** 3);
                        dC += error;
                    }

                    // Average gradients and apply factor -2/N
                    const N = rawData.length;
                    dA = -2 * dA / N;
                    dMu = -2 * dMu / N;
                    dSigma = -2 * dSigma / N;
                    dC = -2 * dC / N;

                    // Update parameters with separate learning rates
                    params.A -= learningRateA * dA;
                    params.mu -= learningRateMu * dMu;
                    params.sigma -= learningRateSigma * dSigma;
                    params.c -= learningRateC * dC;

                    // Ensure sigma stays positive
                    if (params.sigma <= 0) {
                        params.sigma = Math.abs(params.sigma) || 1e-6;
                    }

                    // Compute error and check convergence
                    const currentError = computeMSE(params);
                    if (Math.abs(previousError - currentError) < tolerance) {
                        break;
                    }
                    previousError = currentError;
                }

                // Generate fitted curve data for plotting
                const xValues = rawData.map(p => p.x);
                const yValues = rawData.map(p => p.y);
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
                const yFit = xFit.map(xi => gaussian(xi, params));

                // Construct a LaTeX formatted equation string
                // Adjusting the mu term so that if mu is negative it appears as x + |mu|
                let muTerm;
                if (params.mu < 0) {
                    muTerm = `(x + ${Math.abs(params.mu).toFixed(3)})`;
                } else {
                    muTerm = `(x - ${params.mu.toFixed(3)})`;
                }

                let equation = `y = ${params.A.toFixed(3)} \\; e^{-\\frac{${muTerm}^2}{2 \\; (${params.sigma.toFixed(3)})^2}}`;
                if (params.c > 0) {
                    equation += ` \\; + \\; ${params.c.toFixed(3)}`;
                } else if (params.c < 0) {
                    equation += ` \\; - \\; ${Math.abs(params.c).toFixed(3)}`;
                };

                // Function for the fitted Gaussian
                const fitFunction = xi => gaussian(xi, params);

                // Update results in your UI (make sure your UI can render LaTeX)
                updateResults(equation, xValues, yValues, fitFunction);

                // Plot the graph with the fitted data
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing Gaussian fit:', error);
                alert('An error occurred during Gaussian fitting. Please check the console for details.');
            }
        }

    </script>
    <footer>
        &copy; 2025 <a href="https://panphy.github.io/">PanPhy</a>. All rights reserved.
    </footer>
</body>

</html>