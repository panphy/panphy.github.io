<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve Fitting Tool</title>
    <!-- Plotly.js for graphing -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Math.js for mathematical computations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <!-- MathJax v2 for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>
    <style>
        /* Basic Reset and Styling */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        /* Banner Styling */
        .banner {
            background-color: #333;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        /* Container for Input and Graph Sections */
        .container {
            display: flex;
            flex-direction: row;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        /* Input and Graph Sections Styling */
        .input-section, .graph-section {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        /* Specific Styling for Input and Graph Sections */
        .input-section {
            flex: 1 1 400px;
            max-width: 400px;
        }

        .graph-section {
            flex: 2 1 600px;
            min-width: 300px;
        }

        /* Center-aligned Section Headers with Light Grey Background */
        .input-section h2, .graph-section h2 {
            text-align: center;
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        /* Prompt Above the Data Table */
        .table-prompt {
            font-size: 14px;
            color: #555;
            text-align: center;
            margin-bottom: 10px;
        }

        /* Scrollable Table Container */
        .table-container {
            max-height: 300px; /* Adjust as needed */
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* Data Table Styling */
        .data-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            table-layout: fixed; /* Fixed table layout for better control */
        }

        .data-table th, .data-table td {
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
        }

        /* Input Fields in Table Headers */
        .data-table th input {
            width: 90%;
            border: none;
            outline: none;
            font-size: 16px;
            text-align: center;
            background-color: transparent;
            font-weight: bold;
            padding: 4px;
            /* Removed text-transform to allow uppercase letters */
        }

        .data-table th input:focus {
            border-bottom: 2px solid #007bff;
        }

        /* LaTeX Display Below Headers */
        .data-table .latex-display {
            margin-top: 4px;
            font-size: 14px;
            color: #333;
            background-color: #e9ecef;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            word-wrap: break-word;
            display: inline-block;
        }

        /* Input Fields in Data Rows */
        .data-table td input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 14px;
            text-align: center;
            background-color: transparent;
            padding: 4px;
        }

        .data-table td input:focus {
            outline: 1px solid #007bff;
        }

        /* Alternating Row Colors for Better Readability */
        .data-table tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #ffffff;
        }

        /* Button Styling */
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        /* Button Container Styling */
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .button-row {
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        /* Fit Method Section Styling */
        .fit-method-section {
            margin-top: 20px;
        }

        /* Result Section Styling */
        .result {
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }

        .result h3 {
            margin-top: 0;
        }

        .result p {
            margin: 10px 0; /* Reduced margin for better spacing */
            font-size: 16px;
        }

        /* Graph Labels Section Styling */
        .labels {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .labels h2 {
            text-align: center;
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .label-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .label-item label {
            font-size: 14px;
            font-weight: bold;
            flex: 1;
            /* Removed text-transform to allow uppercase letters */
        }

        .label-item input {
            flex: 2;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            font-size: 14px;
        }

        .label-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .label-item .latex-display {
            font-size: 14px;
            color: #333;
            background-color: #e9ecef;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            word-wrap: break-word;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }

        /* Plot Area Styling */
        #plot {
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        /* Responsive Design for Smaller Screens */
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .input-section, .graph-section {
                max-width: 100%;
                flex: none;
            }

            .label-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .label-item .latex-display {
                width: 100%;
            }

            /* Align uncertainty toggles and dropdowns vertically on small screens */
            .uncertainty-controls {
                flex-direction: column;
                align-items: center;
            }
        }

        /* Uncertainty Toggles and Dropdowns Alignment */
        .uncertainty-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .uncertainty-controls > div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .uncertainty-controls label {
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 5px;
            /* Removed text-transform to allow uppercase letters */
        }

        .uncertainty-controls select {
            width: 120px;
            padding: 4px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* Global Uncertainty Styling */
        .global-uncertainty {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .global-uncertainty h3 {
            margin-bottom: 10px;
            text-align: center;
        }

        .global-uncertainty-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px; /* Added gap for better spacing */
        }

        /* Removed label styling as labels are no longer present */
        .global-uncertainty-item label {
            /* Removed */
        }

        .global-uncertainty-item input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            /* Removed margin-right: 10px; as labels are removed */
        }

        .global-uncertainty-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .apply-button-container {
            display: flex;
            flex-direction: row;
            gap: 10px;
            justify-content: flex-end;
        }

        .apply-button-container button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Banner -->
    <div class="banner">
        Curve Fitting
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Input Section -->
        <div class="input-section">
            <h2>Data Input</h2>
            <p class="table-prompt">Enter your data below. Use the toggles to add uncertainty.</p>

            <!-- Uncertainty Toggles and Error Type Selectors -->
            <div class="uncertainty-controls">
                <!-- x Uncertainty Toggle and Selector -->
                <div>
                    <label>
                        <input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
                        x uncertainty
                    </label>
                    <select id="x-error-type" onchange="updateErrorType('x')">
                        <option value="absolute">absolute</option>
                        <option value="percentage">%</option>
                    </select>
                </div>
                <!-- y Uncertainty Toggle and Selector -->
                <div>
                    <label>
                        <input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
                        y uncertainty
                    </label>
                    <select id="y-error-type" onchange="updateErrorType('y')">
                        <option value="absolute">absolute</option>
                        <option value="percentage">%</option>
                    </select>
                </div>
            </div>

            <!-- Scrollable Table Container -->
            <div class="table-container">
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <!-- x Column Header -->
                            <th>
                                <input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
                                <div id="x-column-latex" class="latex-display">\( x \)</div>
                            </th>
                            <!-- y Column Header -->
                            <th>
                                <input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
                                <div id="y-column-latex" class="latex-display">\( y \)</div>
                            </th>
                            <!-- x Uncertainty Column Header (Hidden by Default) -->
                            <th class="error-column" id="x-error-header" style="display: none;">
                                <div id="x-error-header-latex" class="latex-display">\( \Delta x \)</div>
                            </th>
                            <!-- y Uncertainty Column Header (Hidden by Default) -->
                            <th class="error-column" id="y-error-header" style="display: none;">
                                <div id="y-error-header-latex" class="latex-display">\( \Delta y \)</div>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Initialize with 7 empty data rows -->
                        <!-- Each row will have x-input, y-input, x-error-input, y-error-input -->
                        <!-- Error inputs are hidden by default -->
                        <!-- Row Template -->
                        <!-- Here, manually adding 7 rows for simplicity -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <!-- Repeat the above row 6 more times -->
                        <!-- Row 2 -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <!-- Row 3 -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <!-- Row 4 -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <!-- Row 5 -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <!-- Row 6 -->
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Button Container: 2x2 Grid -->
            <div class="button-container">
                <!-- Top Row: Add Row and Clear All -->
                <div class="button-row">
                    <button onclick="addRow()">Add Row</button>
                    <button onclick="clearRows()">Clear All</button>
                </div>
                <!-- Bottom Row: Import CSV and Export CSV -->
                <div class="button-row">
                    <button onclick="document.getElementById('csv-file-input').click()">Import CSV</button>
                    <button onclick="exportCSV()">Export CSV</button>
                </div>
            </div>
            <!-- Hidden File Input for CSV Upload -->
            <input type="file" id="csv-file-input" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />

            <!-- Global Uncertainty Inputs -->
            <div class="global-uncertainty">
                <h3>Uniform Uncertainty</h3>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-x-uncertainty" placeholder="Enter x uncertainty" />
                    <button onclick="applyGlobalXUncertainties()">Apply Δx</button>
                </div>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-y-uncertainty" placeholder="Enter y uncertainty" />
                    <button onclick="applyGlobalYUncertainties()">Apply Δy</button>
                </div>
            </div>

            <!-- Fit Method Section -->
            <div class="fit-method-section">
                <h2>Fit Method</h2>
                <label for="fit-method">Choose Method:</label>
                <select id="fit-method">
                    <option value="Linear">Linear</option>
                    <option value="Polynomial-2">Polynomial (2nd Degree)</option>
                    <option value="Polynomial-3">Polynomial (3rd Degree)</option>
                    <option value="Polynomial-4">Polynomial (4th Degree)</option>
                    <option value="Exponential">Exponential</option> <!-- Renamed to "Exponential" -->
                    <option value="Power">Power</option> <!-- Modified to include offset -->
                    <!-- Future Extensions: Gaussian, Lorentzian, User-Defined -->
                </select>
                <button style="margin-top: 10px;" onclick="fitCurve()">Fit Curve</button>
            </div>
        </div>

        <!-- Graph Section -->
        <div class="graph-section">
            <h2>Graph</h2>
            <div id="plot"></div>

            <!-- Result Section -->
            <div class="result">
                <h3>Result</h3>
                <p id="fit-equation" style="display: none;"></p>
                <p id="r-squared-container" style="display: none;"></p>
            </div>

            <!-- Graph Labels Section -->
            <div class="labels">
                <h2>Graph Labels</h2>
                <div class="label-item">
                    <label for="graph-title">Title:</label>
                    <input type="text" id="graph-title" placeholder="Enter graph title" oninput="debouncedUpdatePlotAndRenderLatex()" value="Title">
                    <div id="graph-title-latex" class="latex-display">\( \text{Title} \)</div>
                </div>
                <div class="label-item">
                    <label for="x-axis-label">x-axis label:</label>
                    <input type="text" id="x-axis-label" value="x" oninput="debouncedUpdatePlotAndRenderLatex()">
                    <div id="x-axis-label-latex" class="latex-display">\( x \)</div>
                </div>
                <div class="label-item">
                    <label for="y-axis-label">y-axis label:</label>
                    <input type="text" id="y-axis-label" value="y" oninput="debouncedUpdatePlotAndRenderLatex()">
                    <div id="y-axis-label-latex" class="latex-display">\( y \)</div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Functions -->
    <script>
        let rawData = [];
        let isSyncing = false; // Flag to prevent infinite loops during syncing

        // Debounce function to limit the rate of function execution
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Debounced version of updatePlotAndRenderLatex with 300ms delay
        const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 300);

        // Initialize the table with initial rows
        function initializeTable(initialRows = 7) {
            try {
                // If the table already has rows, do not add more
                const existingRows = document.querySelectorAll('#data-table tbody tr').length;
                for (let i = existingRows; i < initialRows; i++) {
                    addRow();
                }
                updateData();
            } catch (error) {
                console.error('Error initializing table:', error);
            }
        }

        // Add a new row to the data table
        function addRow() {
            try {
                const tableBody = document.querySelector('#data-table tbody');
                const newRow = tableBody.insertRow();

                // x Input Cell
                const xCell = newRow.insertCell(0);
                xCell.innerHTML = `<input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">`;

                // y Input Cell
                const yCell = newRow.insertCell(1);
                yCell.innerHTML = `<input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">`;

                // x Uncertainty Cell (Hidden by Default)
                const xErrorCell = newRow.insertCell(2);
                xErrorCell.className = 'error-column';
                xErrorCell.style.display = document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none';
                xErrorCell.innerHTML = `<input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />`;

                // y Uncertainty Cell (Hidden by Default)
                const yErrorCell = newRow.insertCell(3);
                yErrorCell.className = 'error-column';
                yErrorCell.style.display = document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none';
                yErrorCell.innerHTML = `<input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />`;

                updateData();
            } catch (error) {
                console.error('Error adding row:', error);
            }
        }

        /**
         * Clears all data rows in the table.
         * @param {boolean} resetHeaders - Determines whether to reset the headers to default values.
         */
        function clearRows(resetHeaders = true) {
            try {
                const tableBody = document.querySelector('#data-table tbody');
                tableBody.innerHTML = ''; // Remove all existing rows

                if (resetHeaders) {
                    // Reset header input fields to default values
                    isSyncing = true; // Prevent recursive updates
                    document.getElementById('x-column-name').value = 'x';
                    document.getElementById('y-column-name').value = 'y';
                    renderLatex('#x-column-latex', 'x');
                    renderLatex('#y-column-latex', 'y');
                    document.getElementById('x-axis-label').value = 'x';
                    document.getElementById('y-axis-label').value = 'y';
                    renderLatex('#x-axis-label-latex', 'x');
                    renderLatex('#y-axis-label-latex', 'y');
                    isSyncing = false;
                }

                // Re-initialize with initial rows (e.g., 7)
                initializeTable();

                // Reapply the visibility based on the current toggle states
                toggleErrorColumn('x');
                toggleErrorColumn('y');
            } catch (error) {
                console.error('Error clearing rows:', error);
            }
        }

        // Navigate between input fields using Enter and Tab keys
        function navigateTable(event) {
            try {
                const inputs = Array.from(document.querySelectorAll('#data-table input'));
                const currentInput = event.target;
                const index = inputs.indexOf(currentInput);

                if (event.key === 'Enter') {
                    // Prevent form submission or other default behaviors
                    event.preventDefault();

                    // Determine the column of the current input
                    const currentCell = currentInput.parentElement;
                    const currentRow = currentCell.parentElement;
                    const cells = Array.from(currentRow.children);
                    const currentColumnIndex = cells.indexOf(currentCell);

                    // Determine the next row's input in the same column
                    const nextRow = currentRow.nextElementSibling;
                    if (nextRow) {
                        const nextInput = nextRow.children[currentColumnIndex].querySelector('input');
                        if (nextInput) {
                            nextInput.focus();
                        }
                    } else {
                        // Optionally, add a new row if at the end
                        addRow();
                        const addedRow = currentRow.nextElementSibling;
                        const addedInput = addedRow.children[currentColumnIndex].querySelector('input');
                        if (addedInput) {
                            addedInput.focus();
                        }
                    }
                } else if (event.key === 'Tab') {
                    // Allow default Tab behavior
                }
            } catch (error) {
                console.error('Error navigating table:', error);
            }
        }

        /**
         * Toggles the visibility of uncertainty columns based on user selection.
         * @param {string} axis - The axis identifier ('x' or 'y').
         */
        function toggleErrorColumn(axis) {
            try {
                const errorHeader = document.getElementById(`${axis}-error-header`);
                const checkBox = document.getElementById(`toggle-${axis}-error`);
                const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

                if (checkBox.checked) {
                    errorHeader.style.display = 'table-cell';
                    // Update uncertainty headers with \Delta labels
                    updateUncertaintyHeaders(axis);

                    // Show all corresponding error cells
                    errorInputs.forEach((input) => {
                        const errorCell = input.parentElement; // Parent 'td'
                        if (errorCell) {
                            errorCell.style.display = 'table-cell';
                        }
                    });
                } else {
                    errorHeader.style.display = 'none';
                    // Hide all corresponding error cells and clear their values
                    errorInputs.forEach((input) => {
                        const errorCell = input.parentElement; // Parent 'td'
                        if (errorCell) {
                            errorCell.style.display = 'none';
                            input.value = ''; // Clear the input
                        }
                    });
                }

                updateData();
            } catch (error) {
                console.error(`Error toggling error column for ${axis}:`, error);
            }
        }

        /**
         * Updates uncertainty headers with \Delta labels based on the current column name and error type.
         * @param {string} axis - The axis identifier ('x' or 'y').
         */
        function updateUncertaintyHeaders(axis) {
            try {
                const columnName = document.getElementById(`${axis}-column-name`).value;
                const errorType = document.getElementById(`${axis}-error-type`).value;
                let headerLatex = `\\( \\Delta ${columnName} \\)`;

                if (errorType === 'percentage') {
                    // Place the percent symbol outside math mode without escaping
                    headerLatex += ' (%)';
                }

                const headerElement = document.getElementById(`${axis}-error-header-latex`);
                headerElement.innerHTML = headerLatex;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
            } catch (error) {
                console.error(`Error updating uncertainty headers for ${axis}:`, error);
            }
        }

        /**
         * Updates the error type selection and adjusts headers accordingly.
         * @param {string} axis - The axis identifier ('x' or 'y').
         */
        function updateErrorType(axis) {
            try {
                const errorType = document.getElementById(`${axis}-error-type`).value;
                console.log(`Error type for ${axis}: ${errorType}`);
                // Update uncertainty headers based on the new error type
                if (document.getElementById(`toggle-${axis}-error`).checked) {
                    updateUncertaintyHeaders(axis);
                }
                // Re-render LaTeX in headers
                // Not necessary here since updateUncertaintyHeaders handles it
                updateData();
            } catch (error) {
                console.error(`Error updating error type for ${axis}:`, error);
            }
        }

        /**
         * Handles CSV file uploads and initiates parsing.
         * @param {Event} event - The file input change event.
         */
        function handleCSVUpload(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    parseCSV(text);
                };
                reader.onerror = function() {
                    alert('Error reading the file!');
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error handling CSV upload:', error);
            }
        }

        /**
         * Parses CSV content and populates the data table.
         * @param {string} csvText - The raw CSV text.
         */
        function parseCSV(csvText) {
            try {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    alert('CSV file must contain at least two rows (headers and one data row).');
                    return;
                }

                // Split the first line for headers
                const headers = parseCSVLine(lines[0]);
                if (headers.length < 2) {
                    alert('CSV file must have at least two columns.');
                    return;
                }

                // Determine if CSV includes uncertainty columns
                const hasXError = headers.length >= 3;
                const hasYError = headers.length >= 4;

                // Update column headers
                isSyncing = true; // Prevent recursive updates
                document.getElementById('x-column-name').value = headers[0];
                document.getElementById('y-column-name').value = headers[1];
                renderLatex('#x-column-latex', headers[0]);
                renderLatex('#y-column-latex', headers[1]);
                document.getElementById('x-axis-label').value = headers[0];
                document.getElementById('y-axis-label').value = headers[1];
                renderLatex('#x-axis-label-latex', headers[0]);
                renderLatex('#y-axis-label-latex', headers[1]);
                isSyncing = false;

                // Clear existing data rows without resetting headers
                clearRows(false);

                // If CSV has uncertainty columns, toggle them on using toggleErrorColumn
                if (hasXError) {
                    document.getElementById('toggle-x-error').checked = true;
                    toggleErrorColumn('x');
                }
                if (hasYError) {
                    document.getElementById('toggle-y-error').checked = true;
                    toggleErrorColumn('y');
                }

                // Determine the number of data rows to import
                const dataRows = lines.slice(1); // Get all data rows
                const tableBody = document.querySelector('#data-table tbody');

                // Add necessary rows
                for (let i = 0; i < dataRows.length; i++) {
                    if (i >= tableBody.rows.length) {
                        addRow();
                    }
                    const rowData = parseCSVLine(dataRows[i]);
                    const row = tableBody.rows[i];

                    const xInput = row.querySelector('.x-input');
                    const yInput = row.querySelector('.y-input');
                    xInput.value = rowData[0] || '';
                    yInput.value = rowData[1] || '';

                    if (hasXError && rowData.length >= 3) {
                        const xErrorInput = row.querySelector('.x-error-input');
                        xErrorInput.value = rowData[2] || '';
                    }

                    if (hasYError && rowData.length >= 4) {
                        const yErrorInput = row.querySelector('.y-error-input');
                        yErrorInput.value = rowData[3] || '';
                    }
                }

                // Clear any extra rows beyond the imported data
                const totalRows = tableBody.rows.length;
                if (dataRows.length < totalRows) {
                    for (let i = dataRows.length; i < totalRows; i++) {
                        const row = tableBody.rows[i];
                        row.querySelector('.x-input').value = '';
                        row.querySelector('.y-input').value = '';
                        if (hasXError) {
                            const xErrorInput = row.querySelector('.x-error-input');
                            xErrorInput.value = '';
                        }
                        if (hasYError) {
                            const yErrorInput = row.querySelector('.y-error-input');
                            yErrorInput.value = '';
                        }
                    }
                }

                // Update rawData and plot
                updateData();
                // Update plot and LaTeX after import
                updatePlotAndRenderLatex();
            } catch (error) {
                console.error('Error parsing CSV:', error);
                alert('An error occurred while parsing the CSV. Please check the console for details.');
            }
        }

        /**
         * Parses a single CSV line, handling quoted fields and commas within quotes.
         * @param {string} line - A single line from the CSV file.
         * @returns {Array<string>} - An array of parsed fields.
         */
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        /**
         * Updates LaTeX labels based on user input from the table headers.
         * @param {string} type - The type of label ('x' or 'y').
         */
        function updateLabels(type) {
            try {
                if (isSyncing) return; // Prevent recursive updates
                isSyncing = true;

                const value = document.getElementById(`${type}-column-name`).value;
                renderLatex(`#${type}-column-latex`, value);

                if (type === 'x') {
                    document.getElementById('x-axis-label').value = value;
                    renderLatex('#x-axis-label-latex', value);
                } else if (type === 'y') {
                    document.getElementById('y-axis-label').value = value;
                    renderLatex('#y-axis-label-latex', value);
                }

                // Update uncertainty headers if toggles are active
                if (document.getElementById(`toggle-${type}-error`).checked) {
                    updateUncertaintyHeaders(type);
                }

                debouncedUpdatePlotAndRenderLatex();
                isSyncing = false;
            } catch (error) {
                console.error(`Error updating labels for ${type}:`, error);
            }
        }

        /**
         * Renders LaTeX expressions using MathJax.
         * @param {string} elementId - The CSS selector for the target element.
         * @param {string} latexString - The LaTeX string to render.
         */
        function renderLatex(elementId, latexString) {
            try {
                const element = document.querySelector(elementId);
                element.innerHTML = `\\(${latexString}\\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            } catch (error) {
                console.error(`Error rendering LaTeX for ${elementId}:`, error);
            }
        }

        /**
         * Updates the plot and LaTeX labels based on user input.
         */
        function updatePlotAndRenderLatex() {
            try {
                if (isSyncing) return; // Prevent recursive updates
                isSyncing = true;

                plotData();
                ['graph-title', 'x-axis-label', 'y-axis-label'].forEach(id => {
                    const latexValue = document.getElementById(id).value;
                    renderLatex(`#${id}-latex`, latexValue);

                    // Sync back to the column headings if applicable
                    if (id === 'x-axis-label') {
                        document.getElementById('x-column-name').value = latexValue;
                        renderLatex('#x-column-latex', latexValue);
                    } else if (id === 'y-axis-label') {
                        document.getElementById('y-column-name').value = latexValue;
                        renderLatex('#y-column-latex', latexValue);
                    }
                });

                isSyncing = false;
            } catch (error) {
                console.error('Error updating plot and LaTeX:', error);
            }
        }

        /**
         * Performs curve fitting based on the selected method.
         */
        function fitCurve() {
            try {
                if (rawData.length < 2) {
                    alert('Please enter at least two data points.');
                    return;
                }

                const x = rawData.map(point => point.x);
                const y = rawData.map(point => point.y);
                const fitMethod = document.getElementById('fit-method').value;

                if (fitMethod === 'Linear') {
                    performLinearFit(x, y);
                } else if (fitMethod.startsWith('Polynomial')) {
                    const degree = parseInt(fitMethod.split('-')[1]);
                    performPolynomialFit(x, y, degree);
                } else if (fitMethod === 'Exponential') { // Modified Exponential Fit
                    performExponentialFit(x, y);
                } else if (fitMethod === 'Power') { // Modified Power Fit
                    performPowerFit(x, y);
                }
                // Future Extensions: Gaussian, Lorentzian, User-Defined
            } catch (error) {
                console.error('Error in fitCurve function:', error);
                alert('An error occurred while fitting the curve. Please check the console for details.');
            }
        }

        /**
         * Performs a linear fit and updates the results.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         */
        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                // Standard y = mx + c format, handling negative intercept
                let equation = `y = ${slope.toFixed(2)}x`;
                if (intercept >= 0) {
                    equation += ` + ${intercept.toFixed(2)}`;
                } else {
                    equation += ` - ${Math.abs(intercept).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'linear fit');
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        /**
         * Performs a polynomial fit and updates the results.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         * @param {number} degree - The degree of the polynomial.
         */
        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + (i / 99) * (Math.max(...x) - Math.min(...x)));
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                // Build the equation string with proper signs
                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return; // Skip zero coefficients

                    const absC = Math.abs(c).toFixed(2);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, `polynomial (${degree} degree)`);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        /**
         * Performs an exponential fit and updates the results.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         */
        function performExponentialFit(x, y) {
            try {
                // Estimate offset c as slightly less than the minimum y-value
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1; // 10% of |minY| plus 0.1
                const c = minY - delta;

                // Adjust y-values by subtracting c
                const adjustedY = y.map(val => val - c);

                // Ensure all adjusted y-values are positive
                if (adjustedY.some(val => val <= 0)) {
                    alert('After subtracting offset, all y values must be positive for exponential fitting.');
                    return;
                }

                // Perform linear fit on adjusted y-values
                const logAdjustedY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(x, logAdjustedY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.exp(b * xi) + c);

                const fitFunction = xi => a * Math.exp(b * xi) + c;

                // Construct the fit equation with proper sign for c
                let equation = `y = ${a.toFixed(2)} e^{${b.toFixed(2)}x}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }
                // If c is approximately 0, omit it
                else {
                    // Do nothing; equation remains without the offset
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'exponential fit');
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        /**
         * Performs a power fit and updates the results.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         */
        function performPowerFit(x, y) {
            try {
                // Estimate offset c as slightly less than the minimum y-value
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1; // 10% of |minY| plus 0.1
                const c = minY - delta;

                // Adjust y-values by subtracting c
                const adjustedY = y.map(val => val - c);

                // Ensure all adjusted y-values are positive
                if (adjustedY.some(val => val <= 0)) {
                    alert('After subtracting offset, all y values must be positive for power fitting.');
                    return;
                }

                // Perform linear fit on log-log transformed data
                const logX = x.map(val => Math.log(val));
                const logY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(logX, logY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.pow(xi, b) + c);

                const fitFunction = xi => a * Math.pow(xi, b) + c;

                // Construct the fit equation with proper sign for c
                let equation = `y = ${a.toFixed(2)}x^{${b.toFixed(2)}}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }
                // If c is approximately 0, omit it
                else {
                    // Do nothing; equation remains without the offset
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'power fit');
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }

        /**
         * Computes a linear fit using least squares.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         * @returns {Object} - An object containing the slope and intercept.
         */
        function computeLinearFit(x, y) {
            try {
                const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
                const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

                let numerator = 0, denominator = 0;
                for (let i = 0; i < x.length; i++) {
                    numerator += (x[i] - xMean) * (y[i] - yMean);
                    denominator += (x[i] - xMean) ** 2;
                }

                const slope = numerator / denominator;
                const intercept = yMean - slope * xMean;

                return { slope, intercept };
            } catch (error) {
                console.error('Error computing linear fit:', error);
                throw error;
            }
        }

        /**
         * Updates the Result Section with the fit equation and R-squared value.
         * @param {string} equation - The fitted equation in LaTeX format.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         * @param {Function} fitFunction - The function representing the fitted curve.
         */
        function updateResults(equation, x, y, fitFunction) {
            try {
                const yPredicted = x.map(point => fitFunction(point));
                const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

                let ssTotal = 0, ssResidual = 0;
                for (let i = 0; i < y.length; i++) {
                    ssTotal += (y[i] - meanY) ** 2;
                    ssResidual += (y[i] - yPredicted[i]) ** 2;
                }

                const rSquared = 1 - ssResidual / ssTotal;

                // Update and show fit equation
                const fitEquationElement = document.getElementById('fit-equation');
                fitEquationElement.innerHTML = `\\(${equation}\\)`;
                fitEquationElement.style.display = 'block';

                // Update and show R^2
                const rSquaredContainer = document.getElementById('r-squared-container');
                rSquaredContainer.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
                rSquaredContainer.style.display = 'block';

                // Queue MathJax typesetting for both elements
                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    fitEquationElement
                ]);
                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    rSquaredContainer
                ]);
            } catch (error) {
                console.error('Error updating results:', error);
            }
        }

        /**
         * Performs polynomial fitting using Math.js and returns the coefficients.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         * @param {number} degree - The degree of the polynomial.
         * @returns {Array<number>} - The coefficients of the polynomial.
         */
        function polyfit(x, y, degree) {
            try {
                const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
                const Xt = math.transpose(X);
                const XtX = math.multiply(Xt, X);
                const XtY = math.multiply(Xt, y);
                const coefficients = math.lusolve(XtX, XtY).flat();
                return coefficients;
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                throw error;
            }
        }

        /**
         * Evaluates a polynomial at a given x-value.
         * @param {Array<number>} coefficients - The coefficients of the polynomial.
         * @param {number} x - The x-value.
         * @returns {number} - The evaluated y-value.
         */
        function polyEval(coefficients, x) {
            try {
                return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
            } catch (error) {
                console.error('Error evaluating polynomial:', error);
                throw error;
            }
        }

        /**
         * Plots the data points using Plotly.js.
         */
        function plotData() {
            try {
                const x = rawData.map(point => point.x);
                const y = rawData.map(point => point.y);
                const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
                const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                // Convert percentage errors to absolute if needed
                const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
                const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

                const trace = {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Input Data',
                    marker: { color: 'red' }, // Data points in red
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal', // Error bars in teal
                        thickness: 1.5, // Thinner error bars
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal', // Error bars in teal
                        thickness: 1.5, // Thinner error bars
                        width: 2
                    }
                };

                const layout = {
                    title: processLabel(document.getElementById('graph-title')?.value || 'Title'),
                    xaxis: { title: processLabel(document.getElementById('x-axis-label')?.value || 'x') },
                    yaxis: { title: processLabel(document.getElementById('y-axis-label')?.value || 'y') }
                };

                // Check if plot already exists
                if (document.getElementById('plot').data) {
                    // Update the existing plot
                    Plotly.react('plot', [trace], layout);
                } else {
                    // Create a new plot
                    Plotly.newPlot('plot', [trace], layout);
                }
            } catch (error) {
                console.error('Error plotting data:', error);
                alert('An error occurred while plotting the data. Please check the console for details.');
            }
        }

        /**
         * Processes labels for LaTeX rendering in Plotly.
         * @param {string} label - The label text.
         * @returns {string} - The processed label wrapped in dollar signs for LaTeX.
         */
        function processLabel(label) {
            return `$${label}$`;
        }

        /**
         * Plots the fitted curve along with the input data using Plotly.react for better performance.
         * @param {Array<number>} x - The x-values.
         * @param {Array<number>} y - The y-values.
         * @param {Array<number>} xFit - The x-values for the fitted curve.
         * @param {Array<number>} yFit - The y-values for the fitted curve.
         * @param {string} title - The title of the fitted curve.
         */
        function plotFittedCurve(x, y, xFit, yFit, title) {
            try {
                const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
                const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                // Convert percentage errors to absolute if needed
                const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
                const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

                const inputTrace = {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Input Data',
                    marker: { color: 'red' }, // Data points in red
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal', // Error bars in teal
                        thickness: 1.5, // Thinner error bars
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal', // Error bars in teal
                        thickness: 1.5, // Thinner error bars
                        width: 2
                    }
                };
                const fittedTrace = {
                    x: xFit,
                    y: yFit,
                    mode: 'lines',
                    name: 'Fit',
                    line: { color: 'blue' }
                };

                const layout = {
                    title: processLabel(document.getElementById('graph-title')?.value || 'Title'),
                    xaxis: { title: processLabel(document.getElementById('x-axis-label')?.value || 'x') },
                    yaxis: { title: processLabel(document.getElementById('y-axis-label')?.value || 'y') }
                };

                // Update the existing plot with new traces
                Plotly.react('plot', [inputTrace, fittedTrace], layout);
            } catch (error) {
                console.error('Error plotting fitted curve:', error);
                alert('An error occurred while plotting the fitted curve. Please check the console for details.');
            }
        }

        /**
         * Gathers data from the table and updates the plot.
         */
        function updateData() {
            try {
                const xInputs = document.querySelectorAll('.x-input');
                const yInputs = document.querySelectorAll('.y-input');
                const xErrorInputs = document.querySelectorAll('.x-error-input');
                const yErrorInputs = document.querySelectorAll('.y-error-input');
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                rawData = [];
                for (let i = 0; i < xInputs.length; i++) {
                    const x = parseFloat(xInputs[i].value);
                    const y = parseFloat(yInputs[i].value);
                    const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
                    const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

                    if (!isNaN(x) && !isNaN(y)) {
                        rawData.push({
                            x: x,
                            y: y,
                            xErrorRaw: xErrorRaw,
                            yErrorRaw: yErrorRaw
                        });
                    }
                }

                plotData();
            } catch (error) {
                console.error('Error updating data:', error);
            }
        }

        /**
         * Initializes the table and renders initial LaTeX labels upon window load.
         */
        window.onload = function() {
            try {
                initializeTable();
                ['graph-title', 'x-axis-label', 'y-axis-label'].forEach(id => {
                    renderLatex(`#${id}-latex`, document.getElementById(id).value);
                });
                ['x', 'y'].forEach(type => {
                    renderLatex(`#${type}-column-latex`, document.getElementById(`${type}-column-name`).value);
                });
            } catch (error) {
                console.error('Error during window onload:', error);
            }
        };

        /**
         * Exports the table data as a CSV file.
         */
        function exportCSV() {
            try {
                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tr');
                let csvContent = '';

                // Extract headers from the first row's input fields
                const headerRow = rows[0];
                const headerCells = headerRow.querySelectorAll('th');
                let headers = [];

                // x and y headers
                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
                headers.push(xHeader, yHeader);

                // x_error and y_error headers if toggles are active
                if (document.getElementById('toggle-x-error').checked) {
                    const xErrorType = document.getElementById('x-error-type').value;
                    // Replace \Delta with "delta" for CSV compatibility
                    const xErrorHeader = `delta ${xHeader}${xErrorType === 'percentage' ? ' (%)' : ''}`;
                    headers.push(xErrorHeader);
                }

                if (document.getElementById('toggle-y-error').checked) {
                    const yErrorType = document.getElementById('y-error-type').value;
                    // Replace \Delta with "delta" for CSV compatibility
                    const yErrorHeader = `delta ${yHeader}${yErrorType === 'percentage' ? ' (%)' : ''}`;
                    headers.push(yErrorHeader);
                }

                // Join headers with commas and add a newline
                csvContent += headers.join(',') + '\n';

                // Extract data from each row
                for (let i = 1; i < rows.length; i++) { // Start from 1 to skip header row
                    const x = rows[i].querySelector('.x-input').value.trim();
                    const y = rows[i].querySelector('.y-input').value.trim();
                    let row = [x, y];

                    // Only include uncertainties if both x and y are present
                    if (document.getElementById('toggle-x-error').checked) {
                        if (x !== '' && y !== '') {
                            const xError = rows[i].querySelector('.x-error-input').value.trim();
                            row.push(xError !== '' ? xError : '');
                        } else {
                            row.push(''); // Empty cell if x or y is missing
                        }
                    }

                    if (document.getElementById('toggle-y-error').checked) {
                        if (x !== '' && y !== '') {
                            const yError = rows[i].querySelector('.y-error-input').value.trim();
                            row.push(yError !== '' ? yError : '');
                        } else {
                            row.push(''); // Empty cell if x or y is missing
                        }
                    }

                    // Join row data with commas and add a newline
                    csvContent += row.join(',') + '\n';
                }

                // Create a downloadable Blob from the CSV content
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'curve_fitting_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click(); // Trigger the download
                document.body.removeChild(link); // Clean up
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('An error occurred while exporting the CSV. Please check the console for details.');
            }
        }

        /**
         * Applies uniform x uncertainties based on the global x input.
         */
        function applyGlobalXUncertainties() {
            try {
                const globalX = document.getElementById('global-x-uncertainty').value.trim();

                // Determine error type for x
                const xErrorType = document.getElementById('x-error-type').value;

                // Select all data rows
                const tableBody = document.querySelector('#data-table tbody');
                const rows = tableBody.querySelectorAll('tr');

                rows.forEach((row) => {
                    const xInput = row.querySelector('.x-input').value.trim();
                    const yInput = row.querySelector('.y-input').value.trim();

                    // Only apply uncertainties if both x and y data are present
                    if (xInput !== '' && yInput !== '') {
                        const xErrorInput = row.querySelector('.x-error-input');

                        // Apply uniform x uncertainty
                        if (document.getElementById('toggle-x-error').checked && xErrorInput) {
                            xErrorInput.value = globalX !== '' ? globalX : '';
                        }
                    }
                });

                // Update data and re-plot
                updateData();

                // Optionally, clear global x uncertainty input field after applying
                document.getElementById('global-x-uncertainty').value = '';
            } catch (error) {
                console.error('Error applying global x uncertainties:', error);
                alert('An error occurred while applying global x uncertainties. Please check the console for details.');
            }
        }

        /**
         * Applies uniform y uncertainties based on the global y input.
         */
        function applyGlobalYUncertainties() {
            try {
                const globalY = document.getElementById('global-y-uncertainty').value.trim();

                // Determine error type for y
                const yErrorType = document.getElementById('y-error-type').value;

                // Select all data rows
                const tableBody = document.querySelector('#data-table tbody');
                const rows = tableBody.querySelectorAll('tr');

                rows.forEach((row) => {
                    const xInput = row.querySelector('.x-input').value.trim();
                    const yInput = row.querySelector('.y-input').value.trim();

                    // Only apply uncertainties if both x and y data are present
                    if (xInput !== '' && yInput !== '') {
                        const yErrorInput = row.querySelector('.y-error-input');

                        // Apply uniform y uncertainty
                        if (document.getElementById('toggle-y-error').checked && yErrorInput) {
                            yErrorInput.value = globalY !== '' ? globalY : '';
                        }
                    }
                });

                // Update data and re-plot
                updateData();

                // Optionally, clear global y uncertainty input field after applying
                document.getElementById('global-y-uncertainty').value = '';
            } catch (error) {
                console.error('Error applying global y uncertainties:', error);
                alert('An error occurred while applying global y uncertainties. Please check the console for details.');
            }
        }
    </script>
</body>
</html>
