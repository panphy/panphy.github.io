<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Plotting & Curve Fitting</title>
    <!-- Plotly.js for graphing -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Math.js for mathematical computations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <!-- MathJax v2 for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .banner {
            background-color: #333;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        .reminder {
            color: #999999;
            margin: 5px;
            font-size: 14px;
            text-align: center;
        }

        .container {
            display: flex;
            flex-direction: row;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .input-section, .graph-section {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        .input-section {
            flex: 1 1 400px;
            max-width: 400px;
        }

        .graph-section {
            flex: 2 1 600px;
            min-width: 300px;
        }

        .input-section h2, .graph-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .table-prompt {
            font-size: 14px;
            color: #555;
            text-align: center;
            margin-bottom: 10px;
        }

        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .data-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            table-layout: auto;
        }

        .data-table th, .data-table td {
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
            vertical-align: middle;
            white-space: normal;
        }

        .data-table th input {
            width: 90%;
            border: none;
            outline: none;
            font-size: 16px;
            text-align: center;
            background-color: transparent;
            font-weight: normal;
            padding: 4px;
        }

        .data-table th input:focus {
            border-bottom: 2px solid #007bff;
        }

        .data-table .latex-display {
            margin-top: 4px;
            background-color: #f0f8ff;
            border: 1px solid #add8e6;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            margin-top: 4px;
            max-width: 100%;
            word-wrap: break-word;
        }

        .data-table td input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 14px;
            text-align: center;
            background-color: transparent;
            padding: 4px;
        }

        .data-table td input:focus {
            outline: 1px solid #007bff;
        }

        .data-table tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #ffffff;
        }

        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            flex: 1;
        }

        button:hover {
            background-color: #0056b3;
        }

        .fit-button {
            background-color: #17a2b8;
            width: 100%;
            height: 40px;
            padding: 0;
            margin: 0;
            flex: 1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .fit-button:hover {
            background-color: #138496;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .button-row {
            display: flex;
            flex-direction: row;
            gap: 10px;
            width: 100%;
        }

        .button-container .button-row button {
            width: 100%;
            height: 40px;
            padding: 0;
            background-color: #6aa84f;
            margin: 0;
            flex: 1;
    	    font-size: 16px;
        }

        .button-container .button-row button:hover {
            background-color: #218838;
        }

	.global-uncertainty {
    	    margin-top: 20px;
    	    padding: 10px;
    	    border-top: 1px solid #ccc;
	    border-bottom: 1px solid #ccc;
	    margin-bottom: 20px;
	}

	.global-uncertainty h3 {
    	    margin-bottom: 10px;
    	    text-align: center;
	}

	.global-uncertainty-item {
    	    display: flex;
    	    align-items: center;
    	    margin-bottom: 0px;
      	    gap: 10px;
	}

	.global-uncertainty-item input {
    	    flex: 1;
    	    padding: 8px;
    	    font-size: 14px;
    	    border: 1px solid #ccc;
    	    border-radius: 4px;
	}

	.global-uncertainty-item input:focus {
    	    border-color: #007bff;
    	    outline: none;
	}

	.global-uncertainty-item button {
    	    background-color: #6fa8dc;
    	    color: #ffffff;
    	    border: none;
    	    padding: 8px 12px;
    	    border-radius: 4px;
    	    font-size: 14px;
    	    cursor: pointer;
    	    transition: background-color 0.3s;
	}

	.global-uncertainty-item button:hover {
    	    background-color: #0b5394;
	}

        .apply-button-container {
            display: flex;
            flex-direction: row;
            gap: 10px;
            justify-content: flex-end;
        }

        .apply-button-container button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }

        .advanced-fit-section {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .advanced-fit-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .advanced-fit-section select, 
        .advanced-fit-section .fit-method-select {
            
    	    width: auto;
    	    min-width: 150px;
    	    max-width: 300px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 15px;
        }

	.advanced-fit-item {
	    display: flex;
	    align-items: center;
	    justify-content: flex-start;
	    gap: 10px;
	    margin-bottom: 10px;
	}

	.advanced-fit-item label {
	    flex: none;
	    text-align: left;
	    white-space: nowrap;
	}

	.advanced-fit-item input {
	    flex: none;
	    width: auto;
	    max-width: 200px;
	    padding: 5px;
	    border: 1px solid #ccc;
	    border-radius: 4px;
	}

        .advanced-fit-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .advanced-fit-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .advanced-fit-buttons button {
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 12px;
        }

        .advanced-fit-buttons button:hover {
            background-color: #138496;
        }

        .parameter-section {
            display: none;
        }

        .parameter-section.active {
            display: block;
        }

        .general-equation {
            margin-top: 10px;
            background-color: #e9ecef;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
	    margin-bottom: 10px;
        }

	.tabs {
    	    display: flex; /* Arrange children side by side */
    	    justify-content: flex-start; /* Align tabs to the left */
    	    border-radius: 4px;
    	    margin-bottom: 15px;
	}


	.tabs button {
    	    background-color: #f3f3f3;
    	    float: left;
    	    border: none;
    	    outline: none;
    	    cursor: pointer;
    	    padding: 14px 16px;
    	    transition: background-color 0.3s;
    	    font-size: 16px;
    	    border-radius: 4px;
    	    color: #999999;
    	    width: 50%;
	}


        .tabs button:hover {
            background-color: #edc7c7;
        }

        .tabs button.active {
            background-color: #f08080;
            color: white;
        }

        .tab-content {
            display: none;
            padding: 10px 0;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .result {
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }

        .result h3 {
            margin-top: 0;
        }

        .result p {
            margin: 10px 0;
            font-size: 16px;
        }

        .labels {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .labels h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .label-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .label-item label {
            font-size: 14px;
            font-weight: bold;
            flex: 1;
        }

        .label-item input {
            flex: 2;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            font-size: 14px;
        }

        .label-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .label-item .latex-display {
            font-size: 14px;
            color: #333;
            background-color: #e9ecef;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            word-wrap: break-word;
            flex: 1;
            min-width: 100px;
            text-align: center;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        #plot {
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .input-section, .graph-section {
                max-width: 100%;
                flex: none;
            }

            .label-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .label-item .latex-display {
                width: 100%;
            }

            .uncertainty-controls {
                flex-direction: column;
                align-items: center;
            }
        }

        .uncertainty-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .uncertainty-controls > div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .uncertainty-controls label {
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .uncertainty-controls select {
            width: 120px;
            padding: 4px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="banner">
        Graph Plotting & Curve Fitting
    </div>

    <div class="reminder">
        <p align="center">
            Note: All headings, labels, and titles accept LaTeX input only. Use <b><code>\space</code></b> or <b><code>\quad</code></b> to include spaces in your expressions.
        </p>
    </div>

    <div class="container">
        <div class="input-section">
            <h2>Data Input</h2>

            <div class="table-container">
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <th>
                                <input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
                                <div id="x-column-latex" class="latex-display">\( x \)</div>
                            </th>
                            <th>
                                <input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
                                <div id="y-column-latex" class="latex-display">\( y \)</div>
                            </th>
                            <th class="error-column" id="x-error-header" style="display: none;">
                                <div id="x-error-header-latex" class="latex-display">\( \Delta x \)</div>
                            </th>
                            <th class="error-column" id="y-error-header" style="display: none;">
                                <div id="y-error-header-latex" class="latex-display">\( \Delta y \)</div>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                        <tr>
                            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                            <td class="error-column" style="display: none;">
                                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="button-container">
                <div class="button-row">
                    <button onclick="addRow()">Add Row</button>
                    <button onclick="clearRows()">Clear All</button>
                </div>
                <div class="button-row">
                    <button onclick="document.getElementById('csv-file-input').click()">Import CSV</button>
                    <button onclick="exportCSV()">Export CSV</button>
                </div>
            </div>
            <input type="file" id="csv-file-input" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />

            
            <div class="global-uncertainty">
	    <h2>Uncertainties</h2>


            <div class="uncertainty-controls">
                <div>
                    <label>
                        <input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
                        Δx
                    </label>
                    <select id="x-error-type" onchange="updateErrorType('x')">
                        <option value="absolute">absolute</option>
                        <option value="percentage">%</option>
                    </select>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
                        Δy
                    </label>
                    <select id="y-error-type" onchange="updateErrorType('y')">
                        <option value="absolute">absolute</option>
                        <option value="percentage">%</option>
                    </select>
                </div>
            </div>

                <h3>Apply Consistent Uncertainty</h3>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
                    <button onclick="applyGlobalXUncertainties()">Apply Δx</button>
                </div>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
                    <button onclick="applyGlobalYUncertainties()">Apply Δy</button>
                </div>
            </div>

            <div class="fit-method-section">
                <h2>Curve Fitting</h2>
                <div class="tabs">
                    <button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
                    <button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
                </div>

                <div id="BasicFit" class="tab-content active">
                    <label for="fit-method">Fit Method:</label>
                    <select id="fit-method" onchange="updateBasicFitEquation()">
                        <option value="Linear">Linear</option>
                        <option value="Polynomial-2">Polynomial (2nd Degree)</option>
                        <option value="Polynomial-3">Polynomial (3rd Degree)</option>
                        <option value="Polynomial-4">Polynomial (4th Degree)</option>
                        <option value="Exponential">Exponential</option>
                        <option value="Power">Power</option>
                    </select>
                    <div id="basic-fit-equation" class="general-equation">
                        \( y = mx + c \)
                    </div>
                    <button class="fit-button" onclick="fitCurve()">Fit Curve</button>
                </div>

                <div id="AdvancedFit" class="tab-content">
                    <label for="advanced-fit-method">Advanced Fit Method:</label>
                    <select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
                        <option value="Sinusoidal">Sinusoidal</option>
                        <option value="Gaussian">Gaussian</option>
                        <option value="Lorentzian">Lorentzian</option>
                    </select>
                    <div id="advanced-fit-general-equation" class="general-equation">
                        \( y = A e^{bx} \sin(kx - \phi) + c \)
                    </div>
                    <p class="table-prompt">Enter initial fitting parameters below.</p><br>
                    
                    <div id="Sinusoidal-parameters" class="parameter-section active">
                        <div class="advanced-fit-item">
                            <label for="initial-A">A:</label>
                            <input type="number" id="initial-A" placeholder="Enter initial A" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b">b:</label>
                            <input type="number" id="initial-b" placeholder="Enter initial b" value="0">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-k">k:</label>
                            <input type="number" id="initial-k" placeholder="Enter initial k" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-phi">φ:</label>
                            <input type="number" id="initial-phi" placeholder="Enter initial φ" value="0">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c">c:</label>
                            <input type="number" id="initial-c" placeholder="Enter initial c" value="0">
                        </div>
                    </div>

                    <div id="Gaussian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-gaussian">A:</label>
                            <input type="number" id="initial-A-gaussian" placeholder="Enter initial A" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-mu">μ:</label>
                            <input type="number" id="initial-mu" placeholder="Enter initial μ" value="0">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-sigma">σ:</label>
                            <input type="number" id="initial-sigma" placeholder="Enter initial σ" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-gaussian">c:</label>
                            <input type="number" id="initial-c-gaussian" placeholder="Enter initial c" value="0">
                        </div>
                    </div>

                    <div id="Lorentzian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-lorentzian">A:</label>
                            <input type="number" id="initial-A-lorentzian" placeholder="Enter initial A" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-x0">x₀:</label>
                            <input type="number" id="initial-x0" placeholder="Enter initial x₀" value="0">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-gamma">γ:</label>
                            <input type="number" id="initial-gamma" placeholder="Enter initial γ" value="1">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-lorentzian">c:</label>
                            <input type="number" id="initial-c-lorentzian" placeholder="Enter initial c" value="0">
                        </div>
                    </div>

                    <div class="advanced-fit-buttons">
                        <button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="graph-section">
            <h2>Graph</h2>
            <div id="plot"></div>

            <div class="result">
                <h3>Result</h3>
                <p id="fit-equation" style="display: none;"></p>
                <p id="r-squared-container" style="display: none;"></p>
            </div>

            <div class="labels">
                <h2>Graph Labels</h2>
                <div class="label-item">
                    <label for="graph-title">Title:</label>
                    <input type="text" id="graph-title" placeholder="Enter graph title" oninput="debouncedUpdatePlotAndRenderLatex()" value="Title">
                    <div id="graph-title-latex" class="latex-display">\( \text{Title} \)</div>
                </div>
                <div class="label-item">
                    <label for="x-axis-label">x-axis label:</label>
                    <input type="text" id="x-axis-label" value="x" oninput="debouncedUpdatePlotAndRenderLatex()">
                    <div id="x-axis-label-latex" class="latex-display">\( x \)</div>
                </div>
                <div class="label-item">
                    <label for="y-axis-label">y-axis label:</label>
                    <input type="text" id="y-axis-label" value="y" oninput="debouncedUpdatePlotAndRenderLatex()">
                    <div id="y-axis-label-latex" class="latex-display">\( y \)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let isSyncing = false;

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);

        function initializeTable(initialRows = 7) {
            try {
                const existingRows = document.querySelectorAll('#data-table tbody tr').length;
                for (let i = existingRows; i < initialRows; i++) {
                    addRow();
                }
                updateData();
            } catch (error) {
                console.error('Error initializing table:', error);
            }
        }

        function addRow() {
            try {
                const tableBody = document.querySelector('#data-table tbody');
                const newRow = tableBody.insertRow();

                const xCell = newRow.insertCell(0);
                xCell.innerHTML = `<input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">`;

                const yCell = newRow.insertCell(1);
                yCell.innerHTML = `<input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">`;

                const xErrorCell = newRow.insertCell(2);
                xErrorCell.className = 'error-column';
                xErrorCell.style.display = document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none';
                xErrorCell.innerHTML = `<input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />`;

                const yErrorCell = newRow.insertCell(3);
                yErrorCell.className = 'error-column';
                yErrorCell.style.display = document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none';
                yErrorCell.innerHTML = `<input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />`;

                updateData();
            } catch (error) {
                console.error('Error adding row:', error);
            }
        }

        function clearRows(resetHeaders = true) {
            try {
                const tableBody = document.querySelector('#data-table tbody');
                tableBody.innerHTML = '';

                if (resetHeaders) {
                    isSyncing = true;
                    document.getElementById('x-column-name').value = 'x';
                    document.getElementById('y-column-name').value = 'y';
                    renderLatex('#x-column-latex', 'x');
                    renderLatex('#y-column-latex', 'y');
                    document.getElementById('x-axis-label').value = 'x';
                    document.getElementById('y-axis-label').value = 'y';
                    renderLatex('#x-axis-label-latex', 'x');
                    renderLatex('#y-axis-label-latex', 'y');
                    isSyncing = false;
                }

                initializeTable();
                toggleErrorColumn('x');
                toggleErrorColumn('y');
            } catch (error) {
                console.error('Error clearing rows:', error);
            }
        }

        function navigateTable(event) {
            try {
                const key = event.key;
                const currentInput = event.target;

                const currentCell = currentInput.parentElement;
                const currentRow = currentCell.parentElement;
                const table = currentRow.parentElement.parentElement;
                const rows = Array.from(table.querySelectorAll('tbody tr'));
                const rowIndex = rows.indexOf(currentRow);
                const cells = Array.from(currentRow.children);
                const colIndex = cells.indexOf(currentCell);

                let targetRow = rowIndex;
                let targetCol = colIndex;

                switch (key) {
                    case 'Enter':
                        event.preventDefault();
                        targetRow = rowIndex + 1;
                        targetCol = colIndex;
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        targetCol = colIndex + 1;
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        targetCol = colIndex - 1;
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        targetRow = rowIndex + 1;
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        targetRow = rowIndex - 1;
                        break;
                    default:
                        return;
                }

                if (targetRow < 0) targetRow = 0;
                if (targetRow >= rows.length) targetRow = rows.length - 1;
                if (targetCol < 0) targetCol = 0;
                if (targetCol >= cells.length) targetCol = cells.length - 1;

                const targetCell = rows[targetRow].children[targetCol];
                const targetInput = targetCell.querySelector('input');

                if (targetInput && targetInput.offsetParent !== null) {
                    targetInput.focus();
                }
            } catch (error) {
                console.error('Error navigating table:', error);
            }
        }

        function toggleErrorColumn(axis) {
            try {
                const errorHeader = document.getElementById(`${axis}-error-header`);
                const checkBox = document.getElementById(`toggle-${axis}-error`);
                const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

                if (checkBox.checked) {
                    errorHeader.style.display = 'table-cell';
                    updateUncertaintyHeaders(axis);

                    errorInputs.forEach((input) => {
                        const errorCell = input.parentElement;
                        if (errorCell) {
                            errorCell.style.display = 'table-cell';
                        }
                    });
                } else {
                    errorHeader.style.display = 'none';
                    errorInputs.forEach((input) => {
                        const errorCell = input.parentElement;
                        if (errorCell) {
                            errorCell.style.display = 'none';
                            input.value = '';
                        }
                    });
                }

                updateData();
            } catch (error) {
                console.error(`Error toggling error column for ${axis}:`, error);
            }
        }

        function updateUncertaintyHeaders(axis) {
            try {
                const columnName = document.getElementById(`${axis}-column-name`).value;
                const errorType = document.getElementById(`${axis}-error-type`).value;
                let headerLatex = `\\( \\Delta ${columnName} \\)`;

                if (errorType === 'percentage') {
                    headerLatex += ' (%)';
                }

                const headerElement = document.getElementById(`${axis}-error-header-latex`);
                headerElement.innerHTML = headerLatex;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
            } catch (error) {
                console.error(`Error updating uncertainty headers for ${axis}:`, error);
            }
        }

        function updateErrorType(axis) {
            try {
                const errorType = document.getElementById(`${axis}-error-type`).value;
                if (document.getElementById(`toggle-${axis}-error`).checked) {
                    updateUncertaintyHeaders(axis);
                }
                updateData();
            } catch (error) {
                console.error(`Error updating error type for ${axis}:`, error);
            }
        }

        function handleCSVUpload(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    parseCSV(text);
                };
                reader.onerror = function() {
                    alert('Error reading the file!');
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error handling CSV upload:', error);
            }
        }

        function parseCSV(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                alert('CSV file must contain at least two rows (headers and one data row).');
                return;
            }

            const headers = parseCSVLine(lines[0]);
            if (headers.length < 2) {
                alert('CSV file must have at least two columns.');
                return;
            }

            const hasXError = headers.length >= 3;
            const hasYError = headers.length >= 4;

            isSyncing = true;
            document.getElementById('x-column-name').value = headers[0];
            document.getElementById('y-column-name').value = headers[1];
            renderLatex('#x-column-latex', headers[0]);
            renderLatex('#y-column-latex', headers[1]);
            document.getElementById('x-axis-label').value = headers[0];
            document.getElementById('y-axis-label').value = headers[1];
            renderLatex('#x-axis-label-latex', headers[0]);
            renderLatex('#y-axis-label-latex', headers[1]);
            isSyncing = false;

            clearRows(false);

            if (hasXError) {
                document.getElementById('toggle-x-error').checked = true;
                toggleErrorColumn('x');
            }
            if (hasYError) {
                document.getElementById('toggle-y-error').checked = true;
                toggleErrorColumn('y');
            }

            const dataRows = lines.slice(1);
            const tableBody = document.querySelector('#data-table tbody');

            for (let i = 0; i < dataRows.length; i++) {
                if (i >= tableBody.rows.length) {
                    addRow();
                }
                const rowData = parseCSVLine(dataRows[i]);
                const row = tableBody.rows[i];

                const xInput = row.querySelector('.x-input');
                const yInput = row.querySelector('.y-input');
                xInput.value = rowData[0] || '';
                yInput.value = rowData[1] || '';

                if (hasXError && rowData.length >= 3) {
                    const xErrorInput = row.querySelector('.x-error-input');
                    xErrorInput.value = rowData[2] || '';
                }

                if (hasYError && rowData.length >= 4) {
                    const yErrorInput = row.querySelector('.y-error-input');
                    yErrorInput.value = rowData[3] || '';
                }
            }

            const totalRows = tableBody.rows.length;
            if (dataRows.length < totalRows) {
                for (let i = dataRows.length; i < totalRows; i++) {
                    const row = tableBody.rows[i];
                    row.querySelector('.x-input').value = '';
                    row.querySelector('.y-input').value = '';
                    if (hasXError) {
                        const xErrorInput = row.querySelector('.x-error-input');
                        xErrorInput.value = '';
                    }
                    if (hasYError) {
                        const yErrorInput = row.querySelector('.y-error-input');
                        yErrorInput.value = '';
                    }
                }
            }

            updateData();
            updatePlotAndRenderLatex();
        }

        function updateLabels(type) {
            try {
                if (isSyncing) return;
                isSyncing = true;

                const value = document.getElementById(`${type}-column-name`).value;
                renderLatex(`#${type}-column-latex`, value);

                if (type === 'x') {
                    document.getElementById('x-axis-label').value = value;
                    renderLatex('#x-axis-label-latex', value);
                } else if (type === 'y') {
                    document.getElementById('y-axis-label').value = value;
                    renderLatex('#y-axis-label-latex', value);
                }

                if (document.getElementById(`toggle-${type}-error`).checked) {
                    updateUncertaintyHeaders(type);
                }

                debouncedUpdatePlotAndRenderLatex();
                isSyncing = false;
            } catch (error) {
                console.error(`Error updating labels for ${type}:`, error);
            }
        }

        function renderLatex(elementId, latexString) {
            try {
                const element = document.querySelector(elementId);
                element.innerHTML = `\\(${latexString}\\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            } catch (error) {
                console.error(`Error rendering LaTeX for ${elementId}:`, error);
            }
        }

        function updatePlotAndRenderLatex() {
            try {
                if (isSyncing) return;
                isSyncing = true;

                plotData();
                ['graph-title', 'x-axis-label', 'y-axis-label'].forEach(id => {
                    const latexValue = document.getElementById(id).value;
                    renderLatex(`#${id}-latex`, latexValue);

                    if (id === 'x-axis-label') {
                        document.getElementById('x-column-name').value = latexValue;
                        renderLatex('#x-column-latex', latexValue);
                    } else if (id === 'y-axis-label') {
                        document.getElementById('y-column-name').value = latexValue;
                        renderLatex('#y-column-latex', latexValue);
                    }
                });

                isSyncing = false;
            } catch (error) {
                console.error('Error updating plot and LaTeX:', error);
            }
        }

        function openTab(evt, tabName) {
            try {
                const tablinks = document.getElementsByClassName("tablink");
                const tabContents = document.getElementsByClassName("tab-content");

                for (let i = 0; i < tablinks.length; i++) {
                    tablinks[i].classList.remove("active");
                }

                for (let i = 0; i < tabContents.length; i++) {
                    tabContents[i].classList.remove("active");
                }

                document.getElementById(tabName).classList.add("active");
                evt.currentTarget.classList.add("active");

                if (tabName === 'BasicFit') {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
                } else if (tabName === 'AdvancedFit') {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
                }
            } catch (error) {
                console.error(`Error opening tab ${tabName}:`, error);
            }
        }

        function fitCurve() {
            try {
                if (rawData.length < 2) {
                    alert('Please enter at least two data points.');
                    return;
                }

                const x = rawData.map(point => point.x);
                const y = rawData.map(point => point.y);
                const fitMethod = document.getElementById('fit-method').value;

                if (fitMethod === 'Linear') {
                    performLinearFit(x, y);
                } else if (fitMethod.startsWith('Polynomial')) {
                    const degree = parseInt(fitMethod.split('-')[1]);
                    performPolynomialFit(x, y, degree);
                } else if (fitMethod === 'Exponential') {
                    performExponentialFit(x, y);
                } else if (fitMethod === 'Power') {
                    performPowerFit(x, y);
                }
            } catch (error) {
                console.error('Error in fitCurve function:', error);
                alert('An error occurred while fitting the curve. Please check the console for details.');
            }
        }

        function updateBasicFitEquation() {
            try {
                const fitMethod = document.getElementById('fit-method').value;
                let equation = '';

                if (fitMethod === 'Linear') {
                    equation = 'y = mx + c';
                } else if (fitMethod.startsWith('Polynomial')) {
                    const degree = parseInt(fitMethod.split('-')[1]);
                    let terms = [];
                    for (let i = degree; i >= 0; i--) {
                        terms.push(`a_${i}x^{${i}}`);
                    }
                    equation = 'y = ' + terms.join(' + ');
                } else if (fitMethod === 'Exponential') {
                    equation = 'y = A e^{bx} + c';
                } else if (fitMethod === 'Power') {
                    equation = 'y = A x^{b} + c';
                }

                document.getElementById('basic-fit-equation').innerHTML = `\\( ${equation} \\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
            } catch (error) {
                console.error('Error updating Basic Fit equation:', error);
            }
        }

        function changeAdvancedFitMethod() {
            try {
                const selectedMethod = document.getElementById('advanced-fit-method').value;
                const methods = ['Sinusoidal', 'Gaussian', 'Lorentzian'];

                methods.forEach(method => {
                    const section = document.getElementById(`${method}-parameters`);
                    if (method === selectedMethod) {
                        section.classList.add('active');
                    } else {
                        section.classList.remove('active');
                    }
                });

                updateAdvancedFitEquation(selectedMethod);
            } catch (error) {
                console.error('Error changing advanced fit method:', error);
            }
        }

        function updateAdvancedFitEquation(method) {
            try {
                let equation = '';

                if (method === 'Sinusoidal') {
                    equation = 'y = A e^{bx} \\sin(kx - \\phi) + c';
                } else if (method === 'Gaussian') {
                    equation = 'y = A e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}} + c';
                } else if (method === 'Lorentzian') {
                    equation = 'y = A \\frac{\\gamma^2}{(x - x_0)^2 + \\gamma^2} + c';
                }

                document.getElementById('advanced-fit-general-equation').innerHTML = `\\( ${equation} \\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
            } catch (error) {
                console.error('Error updating Advanced Fit equation:', error);
            }
        }

        function performSinusoidalFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A').value);
                let b = parseFloat(document.getElementById('initial-b').value);
                let k = parseFloat(document.getElementById('initial-k').value);
                let phi = parseFloat(document.getElementById('initial-phi').value);
                let c = parseFloat(document.getElementById('initial-c').value);

                if (isNaN(A) || isNaN(b) || isNaN(k) || isNaN(phi) || isNaN(c)) {
                    alert('Please provide valid initial parameters for sinusoidal fit.');
                    return;
                }

                const params = { A: A, b: b, k: k, phi: phi, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterations = 0;

                while (iterations < maxIterations) {
                    const predictions = rawData.map(point => params.A * Math.exp(params.b * point.x) * Math.sin(params.k * point.x - params.phi) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err * err, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, db = 0, dk = 0, dphi = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const sinTerm = Math.sin(params.k * xi - params.phi);
                        const cosTerm = Math.cos(params.k * xi - params.phi);
                        const expTerm = Math.exp(params.b * xi);

                        const prediction = params.A * expTerm * sinTerm + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * expTerm * sinTerm;
                        db += -2 * error * params.A * xi * expTerm * sinTerm;
                        dk += -2 * error * params.A * expTerm * xi * cosTerm;
                        dphi += 2 * error * params.A * expTerm * cosTerm;
                        dc += -2 * error;
                    }

                    params.A -= learningRate * dA;
                    params.b -= learningRate * db;
                    params.k -= learningRate * dk;
                    params.phi -= learningRate * dphi;
                    params.c -= learningRate * dc;

                    iterations++;
                }

                if (iterations === maxIterations) {
                    alert('Sinusoidal fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c);

                const fitFunction = xi => params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c;

                let equation = 'y = ';
                if (params.A < 0) {
                    equation += `-${Math.abs(params.A).toFixed(2)} e^{${params.b.toFixed(2)}x} \\sin(${params.k.toFixed(2)}x`;
                } else {
                    equation += `${params.A.toFixed(2)} e^{${params.b.toFixed(2)}x} \\sin(${params.k.toFixed(2)}x`;
                }

                if (params.phi > 0) {
                    equation += ` - ${params.phi.toFixed(2)}`;
                } else if (params.phi < 0) {
                    equation += ` + ${Math.abs(params.phi).toFixed(2)}`;
                }
                equation += ')';

                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotFittedCurve(rawData.map(p => p.x), rawData.map(p => p.y), xFit, yFit, 'sinusoidal fit');
            } catch (error) {
                console.error('Error performing sinusoidal fit:', error);
                alert('An error occurred during sinusoidal fitting. Please check the console for details.');
            }
        }

        function performGaussianFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A-gaussian').value);
                let mu = parseFloat(document.getElementById('initial-mu').value);
                let sigma = parseFloat(document.getElementById('initial-sigma').value);
                let c = parseFloat(document.getElementById('initial-c-gaussian').value);

                if (isNaN(A) || isNaN(mu) || isNaN(sigma) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Gaussian fit.');
                    return;
                }

                const params = { A: A, mu: mu, sigma: sigma, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterations = 0;

                while (iterations < maxIterations) {
                    const predictions = rawData.map(point => params.A * Math.exp(-((point.x - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err * err, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, dmu = 0, dsigma = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const expTerm = Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2));

                        const prediction = params.A * expTerm + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * expTerm;
                        dmu += -2 * error * params.A * expTerm * ((xi - params.mu) / (params.sigma ** 2));
                        dsigma += -2 * error * params.A * expTerm * ((xi - params.mu) ** 2) / (params.sigma ** 3);
                        dc += -2 * error;
                    }

                    params.A -= learningRate * dA;
                    params.mu -= learningRate * dmu;
                    params.sigma -= learningRate * dsigma;
                    params.c -= learningRate * dc;

                    iterations++;
                }

                if (iterations === maxIterations) {
                    alert('Gaussian fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c);

                const fitFunction = xi => params.A * Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c;

                let equation = `y = ${params.A.toFixed(2)} e^{-\\frac{(x - ${params.mu.toFixed(2)})^2}{2(${params.sigma.toFixed(2)})^2}}`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotFittedCurve(rawData.map(p => p.x), rawData.map(p => p.y), xFit, yFit, 'Gaussian fit');
            } catch (error) {
                console.error('Error performing Gaussian fit:', error);
                alert('An error occurred during Gaussian fitting. Please check the console for details.');
            }
        }

        function performLorentzianFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A-lorentzian').value);
                let x0 = parseFloat(document.getElementById('initial-x0').value);
                let gamma = parseFloat(document.getElementById('initial-gamma').value);
                let c = parseFloat(document.getElementById('initial-c-lorentzian').value);

                if (isNaN(A) || isNaN(x0) || isNaN(gamma) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Lorentzian fit.');
                    return;
                }

                const params = { A: A, x0: x0, gamma: gamma, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterations = 0;

                while (iterations < maxIterations) {
                    const predictions = rawData.map(point => params.A * (params.gamma ** 2) / ((point.x - params.x0) ** 2 + params.gamma ** 2) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err * err, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, dx0 = 0, dgamma = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const denominator = ((xi - params.x0) ** 2 + params.gamma ** 2);
                        const lorentzian = (params.gamma ** 2) / denominator;

                        const prediction = params.A * lorentzian + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * lorentzian;
                        dx0 += -2 * error * params.A * (-2 * (xi - params.x0) * params.gamma ** 2) / (denominator ** 2);
                        dgamma += -2 * error * params.A * (2 * params.gamma * denominator - 2 * (xi - params.x0) ** 2 * params.gamma) / (denominator ** 2);
                        dc += -2 * error;
                    }

                    params.A -= learningRate * dA;
                    params.x0 -= learningRate * dx0;
                    params.gamma -= learningRate * dgamma;
                    params.c -= learningRate * dc;

                    iterations++;
                }

                if (iterations === maxIterations) {
                    alert('Lorentzian fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * (params.gamma ** 2) / ((xi - params.x0) ** 2 + params.gamma ** 2) + params.c);

                const fitFunction = xi => params.A * (params.gamma ** 2) / ((xi - params.x0) ** 2 + params.gamma ** 2) + params.c;

                let equation = `y = ${params.A.toFixed(2)} \\frac{(${params.gamma.toFixed(2)})^2}{(x - ${params.x0.toFixed(2)})^2 + (${params.gamma.toFixed(2)})^2}`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotFittedCurve(rawData.map(p => p.x), rawData.map(p => p.y), xFit, yFit, 'Lorentzian fit');
            } catch (error) {
                console.error('Error performing Lorentzian fit:', error);
                alert('An error occurred during Lorentzian fitting. Please check the console for details.');
            }
        }

        function computeLinearFit(x, y) {
            try {
                const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
                const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

                let numerator = 0, denominator = 0;
                for (let i = 0; i < x.length; i++) {
                    numerator += (x[i] - xMean) * (y[i] - yMean);
                    denominator += (x[i] - xMean) ** 2;
                }

                const slope = numerator / denominator;
                const intercept = yMean - slope * xMean;

                return { slope, intercept };
            } catch (error) {
                console.error('Error computing linear fit:', error);
                throw error;
            }
        }

        function updateResults(equation, x, y, fitFunction) {
            try {
                const yPredicted = x.map(point => fitFunction(point));
                const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

                let ssTotal = 0, ssResidual = 0;
                for (let i = 0; i < y.length; i++) {
                    ssTotal += (y[i] - meanY) ** 2;
                    ssResidual += (y[i] - yPredicted[i]) ** 2;
                }

                const rSquared = 1 - ssResidual / ssTotal;

                const fitEquationElement = document.getElementById('fit-equation');
                fitEquationElement.innerHTML = `\\(${equation}\\)`;
                fitEquationElement.style.display = 'block';

                const rSquaredContainer = document.getElementById('r-squared-container');
                rSquaredContainer.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
                rSquaredContainer.style.display = 'block';

                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    fitEquationElement
                ]);
                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    rSquaredContainer
                ]);
            } catch (error) {
                console.error('Error updating results:', error);
            }
        }

        function polyfit(x, y, degree) {
            try {
                const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
                const Xt = math.transpose(X);
                const XtX = math.multiply(Xt, X);
                const XtY = math.multiply(Xt, y);
                const coefficients = math.lusolve(XtX, XtY).flat();
                return coefficients;
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                throw error;
            }
        }

        function polyEval(coefficients, x) {
            try {
                return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
            } catch (error) {
                console.error('Error evaluating polynomial:', error);
                throw error;
            }
        }

        function plotData() {
            try {
                const x = rawData.map(point => point.x);
                const y = rawData.map(point => point.y);
                const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
                const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
                const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

                const trace = {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Input Data',
                    marker: { color: '#f37070' },
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    }
                };

                const layout = {
                    title: processLabel(document.getElementById('graph-title')?.value || 'Title'),
                    xaxis: { title: processLabel(document.getElementById('x-axis-label')?.value || 'x') },
                    yaxis: { title: processLabel(document.getElementById('y-axis-label')?.value || 'y') }
                };

                if (document.getElementById('plot').data) {
                    Plotly.react('plot', [trace], layout);
                } else {
                    Plotly.newPlot('plot', [trace], layout);
                }
            } catch (error) {
                console.error('Error plotting data:', error);
                alert('An error occurred while plotting the data. Please check the console for details.');
            }
        }

        function processLabel(label) {
            return `$${label}$`;
        }

        function plotFittedCurve(x, y, xFit, yFit, title) {
            try {
                const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
                const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
                const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

                const inputTrace = {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Input Data',
                    marker: { color: 'red' },
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    }
                };
                const fittedTrace = {
                    x: xFit,
                    y: yFit,
                    mode: 'lines',
                    name: 'Fit',
                    line: { color: '#4595dd' }
                };

                const layout = {
                    title: processLabel(document.getElementById('graph-title')?.value || 'Title'),
                    xaxis: { title: processLabel(document.getElementById('x-axis-label')?.value || 'x') },
                    yaxis: { title: processLabel(document.getElementById('y-axis-label')?.value || 'y') }
                };

                Plotly.react('plot', [inputTrace, fittedTrace], layout);
            } catch (error) {
                console.error('Error plotting fitted curve:', error);
                alert('An error occurred while plotting the fitted curve. Please check the console for details.');
            }
        }

        function updateData() {
            try {
                const xInputs = document.querySelectorAll('.x-input');
                const yInputs = document.querySelectorAll('.y-input');
                const xErrorInputs = document.querySelectorAll('.x-error-input');
                const yErrorInputs = document.querySelectorAll('.y-error-input');
                const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
                const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

                rawData = [];
                for (let i = 0; i < xInputs.length; i++) {
                    const x = parseFloat(xInputs[i].value);
                    const y = parseFloat(yInputs[i].value);
		    const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
		    const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;




                    if (!isNaN(x) && !isNaN(y)) {
                        rawData.push({
                            x: x,
                            y: y,
                            xErrorRaw: xErrorRaw,
                            yErrorRaw: yErrorRaw
                        });
                    }
                }

                plotData();
            } catch (error) {
                console.error('Error updating data:', error);
            }
        }

        window.onload = function() {
            try {
                initializeTable();
                ['graph-title', 'x-axis-label', 'y-axis-label'].forEach(id => {
                    renderLatex(`#${id}-latex`, document.getElementById(id).value);
                });
                ['x', 'y'].forEach(type => {
                    renderLatex(`#${type}-column-latex`, document.getElementById(`${type}-column-name`).value);
                });

                updateBasicFitEquation();

                const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
                updateAdvancedFitEquation(initialAdvancedFitMethod);
            } catch (error) {
                console.error('Error during window onload:', error);
            }
        };


        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                let equation = `y = ${slope.toFixed(2)}x`;
                if (intercept >= 0) {
                    equation += ` + ${intercept.toFixed(2)}`;
                } else {
                    equation += ` - ${Math.abs(intercept).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'linear fit');
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return;

                    const absC = Math.abs(c).toFixed(2);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, `polynomial (${degree} degree)`);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        function performExponentialFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logAdjustedY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(x, logAdjustedY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.exp(b * xi) + c);

                const fitFunction = xi => a * Math.exp(b * xi) + c;

                let equation = `y = ${a.toFixed(2)} e^{${b.toFixed(2)}x}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'exponential fit');
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        function performPowerFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logX = x.map(val => Math.log(val));
                const logY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(logX, logY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.pow(xi, b) + c);

                const fitFunction = xi => a * Math.pow(xi, b) + c;

                let equation = `y = ${a.toFixed(2)}x^{${b.toFixed(2)}}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'power fit');
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }


        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                let equation = `y = ${slope.toFixed(2)}x`;
                if (intercept >= 0) {
                    equation += ` + ${intercept.toFixed(2)}`;
                } else {
                    equation += ` - ${Math.abs(intercept).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'linear fit');
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return;

                    const absC = Math.abs(c).toFixed(2);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, `polynomial (${degree} degree)`);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        function performExponentialFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logAdjustedY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(x, logAdjustedY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.exp(b * xi) + c);

                const fitFunction = xi => a * Math.exp(b * xi) + c;

                let equation = `y = ${a.toFixed(2)} e^{${b.toFixed(2)}x}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'exponential fit');
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        function performPowerFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logX = x.map(val => Math.log(val));
                const logY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(logX, logY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.pow(xi, b) + c);

                const fitFunction = xi => a * Math.pow(xi, b) + c;

                let equation = `y = ${a.toFixed(2)}x^{${b.toFixed(2)}}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'power fit');
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }


        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                let equation = `y = ${slope.toFixed(2)}x`;
                if (intercept >= 0) {
                    equation += ` + ${intercept.toFixed(2)}`;
                } else {
                    equation += ` - ${Math.abs(intercept).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'linear fit');
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return;

                    const absC = Math.abs(c).toFixed(2);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, `polynomial (${degree} degree)`);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        function performExponentialFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logAdjustedY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(x, logAdjustedY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.exp(b * xi) + c);

                const fitFunction = xi => a * Math.exp(b * xi) + c;

                let equation = `y = ${a.toFixed(2)} e^{${b.toFixed(2)}x}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'exponential fit');
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        function performPowerFit(x, y) {
            try {
                const minY = Math.min(...y);
                const delta = Math.abs(minY) * 0.1 + 0.1;
                const c = minY - delta;

                const adjustedY = y.map(val => val - c);

                const logX = x.map(val => Math.log(val));
                const logY = adjustedY.map(val => Math.log(val));
                const { slope: b, intercept: lnA } = computeLinearFit(logX, logY);
                const a = Math.exp(lnA);

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => a * Math.pow(xi, b) + c);

                const fitFunction = xi => a * Math.pow(xi, b) + c;

                let equation = `y = ${a.toFixed(2)}x^{${b.toFixed(2)}}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotFittedCurve(x, y, xFit, yFit, 'power fit');
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }


        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }


        function exportCSV() {
            try {
                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tr');
                let csvContent = '';

                const headers = [];
                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
                headers.push(xHeader, yHeader);

                if (document.getElementById('toggle-x-error').checked) {
                    const xErrorType = document.getElementById('x-error-type').value;
                    const xErrorHeader = `delta ${xHeader}${xErrorType === 'percentage' ? ' (%)' : ''}`;
                    headers.push(xErrorHeader);
                }

                if (document.getElementById('toggle-y-error').checked) {
                    const yErrorType = document.getElementById('y-error-type').value;
                    const yErrorHeader = `delta ${yHeader}${yErrorType === 'percentage' ? ' (%)' : ''}`;
                    headers.push(yErrorHeader);
                }

                csvContent += headers.join(',') + '\n';

                for (let i = 1; i < rows.length; i++) {
                    const x = rows[i].querySelector('.x-input').value.trim();
                    const y = rows[i].querySelector('.y-input').value.trim();
                    let row = [x, y];

                    if (document.getElementById('toggle-x-error').checked) {
                        if (x !== '' && y !== '') {
                            const xError = rows[i].querySelector('.x-error-input').value.trim();
                            row.push(xError !== '' ? xError : '');
                        } else {
                            row.push('');
                        }
                    }

                    if (document.getElementById('toggle-y-error').checked) {
                        if (x !== '' && y !== '') {
                            const yError = rows[i].querySelector('.y-error-input').value.trim();
                            row.push(yError !== '' ? yError : '');
                        } else {
                            row.push('');
                        }
                    }

                    csvContent += row.join(',') + '\n';
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'curve_fitting_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('An error occurred while exporting the CSV. Please check the console for details.');
            }
        }

        function applyGlobalXUncertainties() {
            try {
                const globalX = document.getElementById('global-x-uncertainty').value.trim();
                const xErrorType = document.getElementById('x-error-type').value;

                const tableBody = document.querySelector('#data-table tbody');
                const rows = tableBody.querySelectorAll('tr');

                rows.forEach((row) => {
                    const xInput = row.querySelector('.x-input').value.trim();
                    const yInput = row.querySelector('.y-input').value.trim();

                    if (xInput !== '' && yInput !== '') {
                        const xErrorInput = row.querySelector('.x-error-input');
                        if (document.getElementById('toggle-x-error').checked && xErrorInput) {
                            xErrorInput.value = globalX !== '' ? globalX : '';
                        }
                    }
                });

                updateData();
                document.getElementById('global-x-uncertainty').value = '';
            } catch (error) {
                console.error('Error applying global x uncertainties:', error);
                alert('An error occurred while applying global x uncertainties. Please check the console for details.');
            }
        }

        function applyGlobalYUncertainties() {
            try {
                const globalY = document.getElementById('global-y-uncertainty').value.trim();
                const yErrorType = document.getElementById('y-error-type').value;

                const tableBody = document.querySelector('#data-table tbody');
                const rows = tableBody.querySelectorAll('tr');

                rows.forEach((row) => {
                    const xInput = row.querySelector('.x-input').value.trim();
                    const yInput = row.querySelector('.y-input').value.trim();

                    if (xInput !== '' && yInput !== '') {
                        const yErrorInput = row.querySelector('.y-error-input');
                        if (document.getElementById('toggle-y-error').checked && yErrorInput) {
                            yErrorInput.value = globalY !== '' ? globalY : '';
                        }
                    }
                });

                updateData();
                document.getElementById('global-y-uncertainty').value = '';
            } catch (error) {
                console.error('Error applying global y uncertainties:', error);
                alert('An error occurred while applying global y uncertainties. Please check the console for details.');
            }
        }

        function fitAdvancedCurve() {
            try {
                if (rawData.length < 4) {
                    alert('Please enter at least four data points for advanced fitting.');
                    return;
                }

                const fitMethod = document.getElementById('advanced-fit-method').value;

                if (fitMethod === 'Sinusoidal') {
                    performSinusoidalFit();
                } else if (fitMethod === 'Gaussian') {
                    performGaussianFit();
                } else if (fitMethod === 'Lorentzian') {
                    performLorentzianFit();
                }
            } catch (error) {
                console.error('Error in fitAdvancedCurve function:', error);
                alert('An error occurred while performing advanced fitting. Please check the console for details.');
            }
        }
    </script>
</body>
</html>
