<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph Plotting & Curve Fitting</title>
    <link rel="icon" type="image/png" href="/favicon.png" />
    <!-- Plotly.js for graphing -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Math.js for computations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <!-- MathJax v2 for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>

    <style>
        :root {
            --add-row-btn-color: #6aa84f;
            --clear-all-btn-color: #e06666;
            --import-csv-btn-color: #45818e;
            --export-csv-btn-color: #7f7f7f;
            --export-md-btn-color: #7f7f7f;
            --tab-bg-color: #f3f3f3;
            --tab-active-bg-color: #ffd966;
            --tab-border-color: #ccc;
            --tab-close-color: #999;
            --tab-close-hover-color: #e06666;
        }

        body {
            font-family: Helvetica, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .banner {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #333;
            color: white;
            padding: 8px;
            font-size: 22px;
            font-weight: bold;
            position: relative;
        }

        .banner-left {
            width: 120px;
            /* Spacer for centering */
        }

        .banner-title {
            flex: 1;
            text-align: center;
        }

        .banner-buttons {
            display: flex;
            gap: 0px;
            width: 110px;
            /* Fixed width to match banner-left */
        }

        .banner-button {
            background: none;
            border: none;
            color: grey;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            padding: 0px 0px;
            transition: color 0.3s;
        }

        .banner-button:hover {
            color: #ddd;
        }

        .reminder {
            color: #999999;
            margin: 3px 0;
            font-size: 12px;
            text-align: center;
        }

        /* Dataset Tabs Bar */
        .dataset-tabs-bar {
            display: flex;
            align-items: center;
            padding: 0 10px;
            background-color: #f4f4f4;
            gap: 0;
            flex-wrap: nowrap;
            /* Don't wrap tabs; keep them in one row */
            overflow-x: auto;
            /* Enable horizontal scrolling if necessary */
            -webkit-overflow-scrolling: touch;
            /* For smoother scrolling on touch devices */
            scrollbar-width: thin;
            /* For Firefox (optional) */
        }

        /* Optional: Customize scrollbar for WebKit browsers */
        .dataset-tabs-bar::-webkit-scrollbar {
            height: 6px;
        }

        .dataset-tabs-bar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .dataset-tabs-bar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .dataset-tabs-bar::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .dataset-tab {
            position: relative;
            padding: 8px 16px;
            background-color: #ddd;
            border: 1px solid transparent;
            border-bottom: none;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            margin-right: 2px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: #333;
        }

        .dataset-tab:hover {
            background-color: #ccc;
        }

        /* Active tab is highlighted and appears attached to the content below */
        .dataset-tab.active {
            background-color: #ffba3b;
            border-color: #aaa;
            border-bottom: 1px solid #ffba3b;
            /* Hide the border on the bottom so it appears attached */
            font-weight: bold;
        }

        /* Tab label and close button styling */
        .dataset-tab .tab-label {
            margin-right: 5px;
            white-space: nowrap;
        }

        .dataset-tab .tab-close {
            font-weight: bold;
            color: #888;
            cursor: pointer;
            padding-left: 4px;
            user-select: none;
        }

        .dataset-tab .tab-close:hover {
            color: #e06666;
        }

        /* "Add Dataset" button styled as a tab */
        .add-dataset-btn {
            flex: 0 0 auto;
            padding: 8px 16px;
            background-color: #16537e;
            border: 1px solid transparent;
            border-bottom: none;
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            margin-right: 2px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            font-size: 14px;
            color: #fff;
        }

        /* Hover state for the Add button */
        .add-dataset-btn:hover {
            background-color: #113d5c;
        }

        .container {
            display: flex;
            flex-direction: row;
            padding: 0px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .input-section,
        .graph-section {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
            height: 80vh;
            /* fixed height for scrolling */
            overflow-y: auto;
            /* adds vertical scroll when needed */
        }

        .input-section {
            flex: 1 1 400px;
            max-width: 400px;
        }

        .graph-section {
            flex: 2 1 600px;
            min-width: 300px;
        }

        .input-section h2,
        .graph-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .data-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            table-layout: auto;
        }

        .data-table th,
        .data-table td {
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
            vertical-align: middle;
            white-space: normal;
        }

        .data-table th input {
            width: 90%;
            border: none;
            outline: none;
            font-size: 16px;
            text-align: center;
            background-color: transparent;
            font-weight: normal;
            padding: 4px;
        }

        .data-table th input:focus {
            border-bottom: 2px solid #007bff;
        }

        .data-table .latex-display {
            margin-top: 4px;
            background-color: #f0f8ff;
            border: 1px solid #add8e6;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            max-width: 100%;
            word-wrap: break-word;
        }

        .data-table td input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 14px;
            text-align: center;
            background-color: transparent;
            padding: 4px;
        }

        .data-table td input:focus {
            outline: 1px solid #007bff;
        }

        .data-table tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #ffffff;
        }

        button {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
            flex: 1;
            transition: background-color 0.3s, filter 0.3s;
        }

        button:hover {
            filter: brightness(90%);
        }

        .btn-add-row {
            background-color: var(--add-row-btn-color);
        }

        .btn-clear-all {
            background-color: var(--clear-all-btn-color);
        }

        .btn-import-csv {
            background-color: var(--import-csv-btn-color);
        }

        .btn-export-csv {
            background-color: var(--export-csv-btn-color);
        }

        .btn-export-md {
            background-color: var(--export-md-btn-color);
        }

        .fit-button {
            background-color: #17a2b8;
            width: 100%;
            height: 40px;
            padding: 0;
            margin: 0;
            flex: 1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .fit-button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .button-row {
            display: flex;
            flex-direction: row;
            gap: 2px;
            width: 100%;
        }

        .global-uncertainty {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .global-uncertainty h2 {
            margin-bottom: 10px;
            text-align: center;
        }

        .uncertainty-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 20px;
        }

        .uncertainty-controls div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .global-uncertainty-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .global-uncertainty-item input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .global-uncertainty-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .global-uncertainty-item button {
            background-color: #6fa8dc;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s, filter 0.3s;
        }

        .global-uncertainty-item button:hover {
            background-color: #6fa8dc;
            filter: brightness(90%);
        }

        .advanced-fit-section {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .advanced-fit-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .advanced-fit-section select,
        .advanced-fit-section .fit-method-select {
            width: auto;
            min-width: 150px;
            max-width: 300px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .advanced-fit-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            margin-bottom: 10px;
        }

        .advanced-fit-item label {
            flex: none;
            text-align: left;
            white-space: nowrap;
        }

        .advanced-fit-item input {
            flex: none;
            width: auto;
            max-width: 200px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .advanced-fit-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .advanced-fit-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .advanced-fit-buttons button {
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 12px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .advanced-fit-buttons button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .parameter-section {
            display: none;
        }

        .parameter-section.active {
            display: block;
        }

        .general-equation {
            margin-top: 20px;
            background-color: #e9ecef;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            justify-content: flex-start;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .tabs button {
            background-color: #f3f3f3;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: background-color 0.3s, filter 0.3s;
            font-size: 16px;
            border-radius: 4px;
            color: #999999;
            width: 50%;
        }

        .tabs button:hover {
            background-color: #eeeeee;
            filter: brightness(95%);
        }

        .tabs button.active {
            background-color: #ffd966;
            color: black;
        }

        .tab-content {
            display: none;
            padding: 15px 1px;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .result {
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }

        .result h3 {
            margin-top: 0;
        }

        .result p {
            margin: 10px 0;
            font-size: 16px;
        }

        #plot {
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        .plot-all-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        .plot-all-btn {
            padding: 8px 16px;
            background-color: #a64d79;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .plot-all-btn:hover {
            background-color: #741b47;
            filter: brightness(90%);
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .input-section,
            .graph-section {
                max-width: 100%;
                flex: none;
            }

            .banner-left,
            .banner-buttons {
                width: auto;
            }
        }

        .graph-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .graph-title-container label {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }

        .graph-title-container input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .graph-title-container input:focus {
            border-color: #007bff;
            outline: none;
        }

        /* Full-screen overlay container */
        #popup-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;

            /* Center the content using flexbox */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
        }

        #popup-content {
            background: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            width: 60%;
            /* Set the popup width to 60% of the viewport */
            max-width: 1200px;
            /* Optionally set a maximum width */
            height: auto;
            /* Height auto */
            max-height: 90vh;
            /* Limit height so it doesn’t overflow the viewport */
            overflow: auto;
            /* Scroll if content overflows */
            position: relative;
            /* Ensure normal positioning so flex-centering applies */
        }

        /* Popup title area */
        #popup-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 3px;
            text-align: center;
        }

        /* Container for the Plotly graph */
        #popup-plot {
            width: auto;
            height: auto;
            min-width: 600px;
            min-height: 400px;
            margin-top: 5px;
            /* Add a top margin to separate from the title */
        }

        /* Close button for the popup */
        #popup-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e06666;
            color: #fff;
            border: none;
            border-radius: 2px;
            padding: 4px 8px;
            cursor: pointer;
        }

        #popup-close:hover {
            background: #cc5555;
        }

        /* Container for the combined plot controls */
        .combined-plot-controls {
            margin-top: 10px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            /* Stack rows vertically */
            gap: 10px;
            /* Space between each row */
        }

        /* Each row for label and input arranged horizontally */
        .control-row-horizontal {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Label styling */
        .control-row-horizontal label {
            width: 120px;
            font-weight: bold;
        }

        /* Input styling */
        .control-row-horizontal input[type="text"] {
            padding: 5px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 3px;
            flex-grow: 1;
            box-sizing: border-box;
        }

        #popup-plot-container {
            margin-top: 15px;
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #f4f4f4;
            color: #555;
            margin: 10px auto 0;
            margin-bottom: 10px;
            width: 100%;
        }

        footer a {
            color: #ff5f1f;
        }
    </style>
</head>

<body>
    <div class="banner">
        <div class="banner-left"></div> <!-- Spacer for centering -->
        <div class="banner-title">Graph Plotting & Curve Fitting</div>
        <div class="banner-buttons">
            <a href="/curve_fitting_manual.html" class="banner-button">Manual</a>
        </div>
    </div>

    <div class="reminder">
        <p align="center">
            Note: Headings and Title accept LaTeX input.
        </p>
    </div>

    <div class="dataset-tabs-bar">
        <div class="dataset-tab active">
            <span class="tab-label">Dataset 1</span>
            <span class="tab-close" title="Remove dataset">×</span>
        </div>
        <button class="add-dataset-btn">Add Dataset</button>
    </div>

    <div class="container">
        <!-- Input section -->
        <div class="input-section">
            <h2>Data</h2>
            <div class="table-container">
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <th>
                                <input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
                                <div id="x-column-latex" class="latex-display">\( x \)</div>
                            </th>
                            <th>
                                <input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
                                <div id="y-column-latex" class="latex-display">\( y \)</div>
                            </th>
                            <th class="error-column" id="x-error-header" style="display: none;">
                                <div id="x-error-header-latex" class="latex-display">\( \pm \Delta x \)</div>
                            </th>
                            <th class="error-column" id="y-error-header" style="display: none;">
                                <div id="y-error-header-latex" class="latex-display">\( \pm \Delta y \)</div>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rows initialized in JS -->
                    </tbody>
                </table>
            </div>

            <div class="button-container">
                <div class="button-row">
                    <button class="btn-add-row" onclick="addRow()">Add Row</button>
                    <button class="btn-clear-all" onclick="clearRows()">Clear All</button>
                </div>
                <div class="button-row">
                    <button class="btn-import-csv" onclick="document.getElementById('csv-file-input').click()">Import
                        .csv</button>
                    <button class="btn-export-csv" onclick="exportCSV()">Export .csv</button>
                    <button class="btn-export-md" onclick="exportPlainText()">Export .md</button>
                </div>
            </div>
            <input type="file" id="csv-file-input" accept=".csv" style="display: none;"
                onchange="handleCSVUpload(event)" />

            <div class="global-uncertainty">
                <h2>Uncertainties</h2>
                <div class="uncertainty-controls">
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
                            Δx
                        </label>
                        <select id="x-error-type" onchange="updateErrorType('x')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
                            Δy
                        </label>
                        <select id="y-error-type" onchange="updateErrorType('y')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                </div>

                <h3>Apply Global Uncertainty</h3>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
                    <button onclick="applyGlobalUncertainties('x')">Apply Δx</button>
                </div>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
                    <button onclick="applyGlobalUncertainties('y')">Apply Δy</button>
                </div>
            </div>

            <div class="fit-method-section">
                <h2>Best Fit Line</h2>
                <div class="tabs">
                    <button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
                    <button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
                </div>

                <div id="BasicFit" class="tab-content active">
                    <label for="fit-method">Fit Method:</label>
                    <select id="fit-method" onchange="updateBasicFitEquation()">
                        <option value="Linear">Linear</option>
                        <option value="Polynomial-2">Polynomial (2nd Degree)</option>
                        <option value="Polynomial-3">Polynomial (3rd Degree)</option>
                        <option value="Polynomial-4">Polynomial (4th Degree)</option>
                        <option value="Exponential">Exponential</option>
                        <option value="Power">Power</option>
                    </select>
                    <div id="basic-fit-equation" class="general-equation">
                        \( y = mx + c \)
                    </div>
                    <button class="fit-button" onclick="fitCurve()">Fit Curve</button>
                </div>

                <div id="AdvancedFit" class="tab-content">
                    <label for="advanced-fit-method">Advanced Fit Method:</label>
                    <select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
                        <option value="Sinusoidal">Sinusoidal</option>
                        <option value="Gaussian">Gaussian</option>
                    </select>
                    <div id="advanced-fit-general-equation" class="general-equation">
                        \( y = A e^{bx} \sin(kx - \phi) + c \)
                    </div>
                    <p class="table-prompt">Enter initial fitting parameters below.</p><br>

                    <!-- Sinusoidal Parameters -->
                    <div id="Sinusoidal-parameters" class="parameter-section active">
                        <div class="advanced-fit-item">
                            <label for="initial-A">A:</label>
                            <input type="number" id="initial-A" value="1" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b">b:</label>
                            <input type="number" id="initial-b" value="0" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-k">k:</label>
                            <input type="number" id="initial-k" value="1" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-phi">φ:</label>
                            <input type="number" id="initial-phi" value="0" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c">c:</label>
                            <input type="number" id="initial-c" value="0" step="any" />
                        </div>
                    </div>

                    <!-- Gaussian Parameters -->
                    <div id="Gaussian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-gaussian">A:</label>
                            <input type="number" id="initial-A-gaussian" value="1" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-mu">μ:</label>
                            <input type="number" id="initial-mu" value="0" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-sigma">σ:</label>
                            <input type="number" id="initial-sigma" value="1" step="any" />
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-gaussian">c:</label>
                            <input type="number" id="initial-c-gaussian" value="0" step="any" />
                        </div>
                    </div>

                    <div class="advanced-fit-buttons">
                        <button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Graph section -->
        <div class="graph-section">
            <h2>Graph</h2>
            <div class="graph-title-container">
                <label for="graph-title">Title:</label>
                <input type="text" id="graph-title" placeholder="Enter graph title"
                    oninput="debouncedUpdatePlotAndRenderLatex()">
            </div>
            <div id="plot"></div>

            <div class="result">
                <h3>Fitting Result</h3>
                <p id="fit-equation" style="display: none;"></p>
                <p id="r-squared-container" style="display: none;"></p>
            </div>

            <div class="plot-all-container">
                <button class="plot-all-btn" onclick="plotAllDatasets()">Plot ALL Datasets</button>
            </div>
        </div>

        <div id="popup-container" style="display: none;">
            <div id="popup-content" style="max-height: 90vh; overflow-y: auto; padding: 20px;">
                <button id="popup-close" onclick="closePopup()">Close</button>
                <div id="popup-title">Combined Plot of All Datasets</div>
                <!-- Wrap the Plotly div in its own container -->
                <div id="popup-plot-container">
                    <div id="popup-plot"></div>
                </div>
                <!-- Container for input boxes arranged in separate rows -->
                <div id="combined-plot-controls" class="combined-plot-controls">
                    <div class="control-row-horizontal">
                        <label for="combined-title">Title:</label>
                        <input type="text" id="combined-title" placeholder="Combined Plot Title" />
                    </div>
                    <div class="control-row-horizontal">
                        <label for="combined-x-label">x-axis Label:</label>
                        <input type="text" id="combined-x-label" placeholder="x-axis Label" />
                    </div>
                    <div class="control-row-horizontal">
                        <label for="combined-y-label">y-axis Label:</label>
                        <input type="text" id="combined-y-label" placeholder="y-axis Label" />
                    </div>
                </div>

            </div>
        </div>

    </div>

    <footer>
        &copy; 2025 <a href="https://panphy.github.io/">PanPhy</a> | <a href="https://buymeacoffee.com/panphy">Support
            My Projects</a>
    </footer>
</body>

<script>
    let rawData = [];  // Each element will be an array of data points
    let activeSet = 0;  // Index of the current active dataset
    let datasetHeaders = {};  // Object to store headers per dataset, e.g. {0: {x: 'x', y: 'y'}, 1: {x: 'Time', y: 'Distance'}}
    let datasetToggles = {};  // Global object to hold fitted curves by dataset index.
    let datasetErrorTypes = {}; // stores the error type per axis per dataset, e.g. { 0: { x: 'absolute', y: 'absolute' }, 1: { x: 'percentage', y: 'percentage' } }
    let fittedCurves = {};
    let datasetFitResults = {};  // e.g. { 0: { equation: "...", rSquared: "..." }, 1: { ... } }

    let lastPlotState = {
        data: null,
        layout: null
    };

    rawData.push([]);
    datasetHeaders[0] = { x: 'x', y: 'y' };  // At initialization, for dataset 0:
    datasetToggles[0] = { x: false, y: false };
    datasetErrorTypes[0] = { x: 'absolute', y: 'absolute' };

    let isSyncing = false;

    function debounce(func, wait) {
        let timeout;
        return function (...args) {
            const later = () => {
                clearTimeout(timeout);
                func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);

    function processLabel(label) {
        return label ? `$${formatLabelForLatex(label)}$` : '';
    }

    function initializeTable(initialRows = 7) {
        const tableBody = document.querySelector('#data-table tbody');
        // Create the default empty rows
        for (let i = 0; i < initialRows; i++) {
            const newRow = tableBody.insertRow();
            newRow.innerHTML = `
            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
            <td class="error-column" style="display: none;">
                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
            </td>
            <td class="error-column" style="display: none;">
                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
            </td>
        `;
        }
        // Update the active dataset with the new (empty) rows.
        updateData();
    }

    // Function to update the tabs bar UI
    function updateDatasetTabsBar() {
        const tabsBar = document.querySelector('.dataset-tabs-bar');
        if (!tabsBar) return;

        // Clear all tabs except the Add Dataset button.
        const existingTabs = Array.from(tabsBar.querySelectorAll('.dataset-tab'));
        existingTabs.forEach(tab => tab.remove());

        // For each dataset, create a tab element.
        rawData.forEach((dataset, index) => {
            const tab = document.createElement('div');
            tab.classList.add('dataset-tab');
            if (index === activeSet) {
                tab.classList.add('active');
            }
            // Create a span for the label (e.g., "Dataset 1")
            const labelSpan = document.createElement('span');
            labelSpan.classList.add('tab-label');
            labelSpan.textContent = `Dataset ${index + 1}`;
            tab.appendChild(labelSpan);

            // Create the close button. (Do not add a close icon if there is only one dataset.)
            if (rawData.length > 1) {
                const closeSpan = document.createElement('span');
                closeSpan.classList.add('tab-close');
                closeSpan.textContent = '×';
                // When the close button is clicked, remove this dataset.
                closeSpan.addEventListener('click', function (e) {
                    // prevent the click from also firing the tab-switch event
                    e.stopPropagation();
                    removeDataset(index);
                });
                tab.appendChild(closeSpan);
            }

            // Clicking on a tab should switch to that dataset.
            tab.addEventListener('click', function () {
                switchDataset(index);
            });

            // Insert the new tab before the Add Dataset button.
            // (We assume the Add Dataset button remains as the last element.)
            const addBtn = tabsBar.querySelector('.add-dataset-btn');
            tabsBar.insertBefore(tab, addBtn);
        });
    }

    function switchDataset(index) {
        if (index < 0 || index >= rawData.length) {
            console.error("Invalid dataset index.");
            return;
        }
        activeSet = index;
        updateDatasetTabsBar();

        // Repopulate the table UI with data from the active dataset.
        populateTableFromActiveDataset();

        // Load header values for this dataset.
        loadHeaders();

        // Restore uncertainty toggle state.
        loadToggles();

        // Restore error type settings.
        loadErrorTypes();

        // Update the graph and LaTeX-rendered labels.
        updatePlotAndRenderLatex();
        updateLabels('x');
        updateLabels('y');

        // Update the combined plot input boxes with the active dataset’s header values.
        updateCombinedPlotInputsToActive();

        // Restore or clear the fitting result for the current dataset.
        const fitEquationElement = document.getElementById('fit-equation');
        const rSquaredElement = document.getElementById('r-squared-container');
        if (datasetFitResults.hasOwnProperty(activeSet)) {
            const result = datasetFitResults[activeSet];
            fitEquationElement.innerHTML = `\\(${result.equation}\\)`;
            fitEquationElement.style.display = 'block';
            rSquaredElement.innerHTML = `\\( R^2 = ${result.rSquared} \\)`;
            rSquaredElement.style.display = 'block';
            if (typeof MathJax !== 'undefined') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, fitEquationElement]);
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, rSquaredElement]);
            }
        } else {
            fitEquationElement.style.display = 'none';
            fitEquationElement.innerHTML = '';
            rSquaredElement.style.display = 'none';
            rSquaredElement.innerHTML = '';
        }
    }

    function updateCombinedPlotInputsToActive() {
        const title = document.getElementById('graph-title').value || 'y vs x';
        const xLabel = processLabel(document.getElementById('x-column-name').value || 'x');
        const yLabel = processLabel(document.getElementById('y-column-name').value || 'y');

        const titleInput = document.getElementById('combined-title');
        const xLabelInput = document.getElementById('combined-x-label');
        const yLabelInput = document.getElementById('combined-y-label');

        if (titleInput) {
            titleInput.value = title;
        }
        if (xLabelInput) {
            xLabelInput.value = xLabel;
        }
        if (yLabelInput) {
            yLabelInput.value = yLabel;
        }
    }

    function populateTableFromActiveDataset() {
        const tableBody = document.querySelector('#data-table tbody');
        tableBody.innerHTML = ''; // Clear current table

        const dataset = rawData[activeSet] || [];
        if (dataset.length > 0) {
            dataset.forEach(point => {
                const newRow = tableBody.insertRow();
                newRow.innerHTML = `
                <td>
                    <input type="text" class="x-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="${point.x}">
                </td>
                <td>
                    <input type="text" class="y-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="${point.y}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="x-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="${point.xErrorRaw || ''}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="y-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="${point.yErrorRaw || ''}">
                </td>
            `;
            });
        } else {
            // If there is no data in the active dataset, initialize default rows.
            initializeTable();
        }
    }

    // Function to add a new dataset
    function addDataset() {
        // Add a new empty dataset to rawData.
        rawData.push([]);

        // Then switch to the newly added dataset.
        activeSet = rawData.length - 1;
        updateDatasetTabsBar();

        // Now clear the UI for the active dataset 
        // (clearRows() will create new empty rows since rawData[activeSet] is empty)
        clearRows();

        // Update the rest of the UI to reflect the new active dataset.
        updateData();
        updatePlotAndRenderLatex();
    }

    // Function to remove an existing dataset given its index
    function removeDataset(index) {
        if (rawData.length <= 1) {
            alert("You must keep at least one dataset.");
            return;
        }

        // Remove the dataset from rawData.
        rawData.splice(index, 1);

        // Adjust activeSet: if we removed an earlier dataset or the active set was the last one, update accordingly.
        if (activeSet >= rawData.length) {
            activeSet = rawData.length - 1;
        }

        updateDatasetTabsBar();

        // Refresh UI based on the new active dataset.
        updateData();
        updatePlotAndRenderLatex();
    }

    // Attach the Add Dataset button click event
    function initializeDatasetTabsBar() {
        const addBtn = document.querySelector('.add-dataset-btn');
        if (addBtn) {
            addBtn.addEventListener('click', addDataset);
        }
        // Build the initial tabs UI.
        updateDatasetTabsBar();
    }

    function addRow() {
        const tableBody = document.querySelector('#data-table tbody');
        const newRow = tableBody.insertRow();
        newRow.innerHTML = `
                <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
            `;
        updateData();
    }

    function clearRows(resetHeaders = true) {
        const tableBody = document.querySelector('#data-table tbody');
        tableBody.innerHTML = '';

        if (resetHeaders) {
            isSyncing = true;
            // Reset header inputs to defaults.
            document.getElementById('x-column-name').value = 'x';
            document.getElementById('y-column-name').value = 'y';
            document.getElementById('graph-title').value = 'y vs x';
            renderLatex('#x-column-latex', formatLabelForLatex('x'));
            renderLatex('#y-column-latex', formatLabelForLatex('y'));
            updateGraphTitle();
            isSyncing = false;
        }

        initializeTable();

        // Uncheck uncertainty toggles and hide error columns.
        document.getElementById('toggle-x-error').checked = false;
        toggleErrorColumn('x');
        document.getElementById('toggle-y-error').checked = false;
        toggleErrorColumn('y');

        // Reset fitting parameters.
        setInitialParameters(getCurrentAdvancedFitMethod());

        // Clear the fitting result from the UI.
        const fitEquationElement = document.getElementById('fit-equation');
        const rSquaredElement = document.getElementById('r-squared-container');
        if (fitEquationElement) {
            fitEquationElement.style.display = 'none';
            fitEquationElement.innerHTML = '';
        }
        if (rSquaredElement) {
            rSquaredElement.style.display = 'none';
            rSquaredElement.innerHTML = '';
        }

        // Also clear the stored fitting result for the current dataset.
        if (datasetFitResults.hasOwnProperty(activeSet)) {
            delete datasetFitResults[activeSet];
        }

        // Update the combined plot input boxes to reflect default header values.
        updateCombinedPlotInputsToActive();
    }

    function updateCombinedPlotInputsToActive() {
        const title = document.getElementById('graph-title').value || 'y vs x';
        const xLabel = processLabel(document.getElementById('x-column-name').value || 'x');
        const yLabel = processLabel(document.getElementById('y-column-name').value || 'y');

        const titleInput = document.getElementById('combined-title');
        const xLabelInput = document.getElementById('combined-x-label');
        const yLabelInput = document.getElementById('combined-y-label');

        if (titleInput) {
            titleInput.value = title;
        }
        if (xLabelInput) {
            xLabelInput.value = xLabel;
        }
        if (yLabelInput) {
            yLabelInput.value = yLabel;
        }
    }

    function navigateTable(event) {
        const key = event.key;
        const currentInput = event.target;

        const currentCell = currentInput.parentElement;
        const currentRow = currentCell.parentElement;
        const table = currentRow.parentElement.parentElement;
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        const rowIndex = rows.indexOf(currentRow);
        const cells = Array.from(currentRow.children);
        const colIndex = cells.indexOf(currentCell);

        let targetRow = rowIndex;
        let targetCol = colIndex;

        switch (key) {
            case 'Enter':
                event.preventDefault();
                targetRow = rowIndex + 1;
                targetCol = colIndex;
                break;
            case 'ArrowRight':
                event.preventDefault();
                targetCol = colIndex + 1;
                break;
            case 'ArrowLeft':
                event.preventDefault();
                targetCol = colIndex - 1;
                break;
            case 'ArrowDown':
                event.preventDefault();
                targetRow = rowIndex + 1;
                break;
            case 'ArrowUp':
                event.preventDefault();
                targetRow = rowIndex - 1;
                break;
            default:
                return;
        }

        if (targetRow < 0) targetRow = 0;
        if (targetRow >= rows.length) targetRow = rows.length - 1;
        if (targetCol < 0) targetCol = 0;
        if (targetCol >= cells.length) targetCol = cells.length - 1;

        const targetCell = rows[targetRow].children[targetCol];
        const targetInput = targetCell.querySelector('input');

        if (targetInput && targetInput.offsetParent !== null) {
            targetInput.focus();
        }
    }

    function toggleErrorColumn(axis) {
        // Get the checkbox element and its state.
        const checkBox = document.getElementById(`toggle-${axis}-error`);
        const state = checkBox.checked;

        // Ensure the toggles object exists for the current dataset.
        if (!datasetToggles[activeSet]) {
            datasetToggles[activeSet] = { x: false, y: false };
        }
        datasetToggles[activeSet][axis] = state;

        // Update the UI for the active dataset.
        const errorHeader = document.getElementById(`${axis}-error-header`);
        const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

        if (state) {
            errorHeader.style.display = 'table-cell';
            updateUncertaintyHeaders(axis);
            errorInputs.forEach((input) => {
                const errorCell = input.parentElement;
                if (errorCell) {
                    errorCell.style.display = 'table-cell';
                }
            });
        } else {
            errorHeader.style.display = 'none';
            errorInputs.forEach((input) => {
                const errorCell = input.parentElement;
                if (errorCell) {
                    errorCell.style.display = 'none';
                    input.value = '';
                }
            });
        }

        updateData();
        setInitialParameters(getCurrentAdvancedFitMethod());
    }

    function loadToggles() {
        const toggles = datasetToggles[activeSet] || { x: false, y: false };

        document.getElementById('toggle-x-error').checked = toggles.x;
        document.getElementById('toggle-y-error').checked = toggles.y;

        // Update x error column:
        const xErrorHeader = document.getElementById('x-error-header');
        const xErrorInputs = document.querySelectorAll('.x-error-input');
        if (toggles.x) {
            xErrorHeader.style.display = 'table-cell';
            xErrorInputs.forEach(input => {
                const cell = input.parentElement;
                if (cell) {
                    cell.style.display = 'table-cell';
                }
            });
        } else {
            xErrorHeader.style.display = 'none';
            xErrorInputs.forEach(input => {
                const cell = input.parentElement;
                if (cell) {
                    cell.style.display = 'none';
                }
            });
        }

        // Update y error column:
        const yErrorHeader = document.getElementById('y-error-header');
        const yErrorInputs = document.querySelectorAll('.y-error-input');
        if (toggles.y) {
            yErrorHeader.style.display = 'table-cell';
            yErrorInputs.forEach(input => {
                const cell = input.parentElement;
                if (cell) {
                    cell.style.display = 'table-cell';
                }
            });
        } else {
            yErrorHeader.style.display = 'none';
            yErrorInputs.forEach(input => {
                const cell = input.parentElement;
                if (cell) {
                    cell.style.display = 'none';
                }
            });
        }
    }

    // Function to reindex all dataset-specific objects to match the new ordering in rawData.
    function reindexDatasets() {
        const newHeaders = {};
        const newToggles = {};
        const newErrorTypes = {};
        const newFitResults = {};

        // rawData is assumed to be an array. Loop over it and assign new keys (0, 1, 2, ...).
        rawData.forEach((data, newIndex) => {
            // If a header exists for this newIndex (it might have shifted from its old key), copy it.
            // Otherwise, set a default.
            newHeaders[newIndex] = datasetHeaders[newIndex] || { x: 'x', y: 'y' };
            newToggles[newIndex] = datasetToggles[newIndex] || { x: false, y: false };
            newErrorTypes[newIndex] = datasetErrorTypes[newIndex] || { x: 'absolute', y: 'absolute' };
            if (datasetFitResults[newIndex]) {
                newFitResults[newIndex] = datasetFitResults[newIndex];
            }
        });

        // Replace the original objects with the re-indexed ones.
        datasetHeaders = newHeaders;
        datasetToggles = newToggles;
        datasetErrorTypes = newErrorTypes;
        datasetFitResults = newFitResults;
    }

    // Helper function to reindex dataset-specific global objects.
    function reindexDatasets() {
        const newHeaders = {};
        const newToggles = {};
        const newErrorTypes = {};
        const newFitResults = {};

        rawData.forEach((data, newIndex) => {
            // Use existing values if available; otherwise, set defaults.
            newHeaders[newIndex] = datasetHeaders[newIndex] || { x: 'x', y: 'y' };
            newToggles[newIndex] = datasetToggles[newIndex] || { x: false, y: false };
            newErrorTypes[newIndex] = datasetErrorTypes[newIndex] || { x: 'absolute', y: 'absolute' };
            if (datasetFitResults[newIndex]) {
                newFitResults[newIndex] = datasetFitResults[newIndex];
            }
        });

        datasetHeaders = newHeaders;
        datasetToggles = newToggles;
        datasetErrorTypes = newErrorTypes;
        datasetFitResults = newFitResults;
    }

    // Updated removeDataset function.
    function removeDataset(index) {
        if (rawData.length <= 1) {
            alert("You must keep at least one dataset.");
            return;
        }

        // Remove the dataset from rawData.
        rawData.splice(index, 1);

        // Reindex the global objects so that keys match rawData order.
        reindexDatasets();

        // Adjust activeSet if needed.
        if (activeSet >= rawData.length) {
            activeSet = rawData.length - 1;
        }

        updateDatasetTabsBar();

        // Refresh UI using the data from the new active dataset.
        updateData();
        updatePlotAndRenderLatex();
    }

    // Attach the Add Dataset button click event.
    function initializeDatasetTabsBar() {
        const addBtn = document.querySelector('.add-dataset-btn');
        if (addBtn) {
            addBtn.addEventListener('click', addDataset);
        }
        // Build the initial tabs UI.
        updateDatasetTabsBar();
    }

    function updateUncertaintyHeaders(axis) {
        const columnName = document.getElementById(`${axis}-column-name`).value.trim() || (axis === 'x' ? 'x' : 'y');
        const errorType = document.getElementById(`${axis}-error-type`).value;
        let headerLatex = `\\pm \\Delta ${formatLabelForLatex(columnName)}`;
        let headerFull = `\\( ${headerLatex} \\)`;
        if (errorType === 'percentage') {
            headerFull += ' (%)';
        }

        const headerElement = document.getElementById(`${axis}-error-header-latex`);
        if (headerElement) {
            headerElement.innerHTML = headerFull;
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
        }
    }

    function updateErrorType(axis) {
        // Get the selected error type from the dropdown.
        const errorType = document.getElementById(`${axis}-error-type`).value;

        // Ensure the error type object exists for the current dataset.
        if (!datasetErrorTypes[activeSet]) {
            datasetErrorTypes[activeSet] = { x: 'absolute', y: 'absolute' };
        }
        datasetErrorTypes[activeSet][axis] = errorType;

        // If uncertainty is enabled for this axis, update the uncertainty header.
        if (document.getElementById(`toggle-${axis}-error`).checked) {
            updateUncertaintyHeaders(axis);
        }

        updateData();
        setInitialParameters(getCurrentAdvancedFitMethod());
    }

    function loadErrorTypes() {
        const xErrorTypeElement = document.getElementById('x-error-type');
        const yErrorTypeElement = document.getElementById('y-error-type');

        // Use stored error types or fallback to 'absolute'
        const currentXErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].x) || 'absolute';
        const currentYErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].y) || 'absolute';

        if (xErrorTypeElement) {
            xErrorTypeElement.value = currentXErrorType;
        }
        if (yErrorTypeElement) {
            yErrorTypeElement.value = currentYErrorType;
        }

        // Ensure the uncertainty header is updated accordingly.
        updateUncertaintyHeaders('x');
        updateUncertaintyHeaders('y');
    }

    function isPlotStateEqual(newData, newLayout) {
        // Simple approach: compare JSON strings.
        // Note: This works fine for small to moderate data sets.
        const currentDataStr = JSON.stringify(lastPlotState.data);
        const newDataStr = JSON.stringify(newData);
        const currentLayoutStr = JSON.stringify(lastPlotState.layout);
        const newLayoutStr = JSON.stringify(newLayout);
        return currentDataStr === newDataStr && currentLayoutStr === newLayoutStr;
    }

    function updatePlotEfficiently() {
        // Build the new data and layout from your current rawData, settings, etc.
        const newData = buildPlotData();   // Your function that returns an array of traces.
        const newLayout = buildPlotLayout(); // Your function that returns the layout object.

        // Check if the new state is different from what was last plotted.
        if (isPlotStateEqual(newData, newLayout)) {
            // No changes: skip replotting.
            console.log("No changes in plot state; skipping update.");
            return;
        }

        // Otherwise, perform an efficient update with Plotly.react.
        Plotly.react('plot', newData, newLayout, {
            toImageButtonOptions: {
                format: 'svg',
                filename: 'data_plot',
                scale: 1
            }
        });

        // Update the cache.
        lastPlotState.data = newData;
        lastPlotState.layout = newLayout;
    }

    function handleCSVUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const text = e.target.result;
            // Pass the CSV text to the parser so that it writes data into rawData[activeSet]
            parseCSV(text);
        };
        reader.onerror = function () {
            alert('Error reading the file!');
        };
        reader.readAsText(file);
    }

    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    }

    function parseCSV(text) {
        const lines = text.trim().split('\n');
        if (lines.length < 2) {
            alert('CSV file must contain at least two rows (headers and one data row).');
            return;
        }

        // 1) Parse headers
        const headers = parseCSVLine(lines[0]);
        if (headers.length < 2) {
            alert('CSV file must have at least two columns.');
            return;
        }
        // Determine if the CSV initially has X and Y errors
        const hasXError = headers.length >= 3;
        const hasYError = headers.length >= 4;

        // 2) Store headers for the active dataset and update the UI via loadHeaders()
        isSyncing = true;
        datasetHeaders[activeSet] = {
            x: headers[0],
            y: headers[1]
        };
        loadHeaders();  // This function sets the header input values and renders LaTeX.
        isSyncing = false;

        // Clear existing rows for this dataset without resetting headers
        clearRows(false);

        // Set the uncertainty toggles to match the CSV's columns
        document.getElementById('toggle-x-error').checked = hasXError;
        document.getElementById('toggle-y-error').checked = hasYError;

        // 3) Build the new rows in memory based on the CSV data.
        const dataRows = lines.slice(1);
        const tableBody = document.querySelector('#data-table tbody');
        const fragment = document.createDocumentFragment();

        for (let i = 0; i < dataRows.length; i++) {
            const rowData = parseCSVLine(dataRows[i]);
            const tr = document.createElement('tr');

            // x cell
            const tdX = document.createElement('td');
            tdX.innerHTML = `
            <input type="text" class="x-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[0] || ''}">
        `;
            tr.appendChild(tdX);

            // y cell
            const tdY = document.createElement('td');
            tdY.innerHTML = `
            <input type="text" class="y-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[1] || ''}">
        `;
            tr.appendChild(tdY);

            // X-error cell
            const tdXErr = document.createElement('td');
            tdXErr.className = 'error-column x-error-td';
            tdXErr.innerHTML = `
            <input type="text" class="x-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[2] || ''}">
        `;
            if (!hasXError) tdXErr.style.display = 'none';
            tr.appendChild(tdXErr);

            // Y-error cell
            const tdYErr = document.createElement('td');
            tdYErr.className = 'error-column y-error-td';
            tdYErr.innerHTML = `
            <input type="text" class="y-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[3] || ''}">
        `;
            if (!hasYError) tdYErr.style.display = 'none';
            tr.appendChild(tdYErr);

            fragment.appendChild(tr);
        }

        // 4) Replace the old table rows with our newly built fragment
        tableBody.innerHTML = '';
        tableBody.appendChild(fragment);

        // 5) Update data in the active dataset, re-plot, etc.
        updateData();
        updatePlotAndRenderLatex();
        setInitialParameters(getCurrentAdvancedFitMethod());

        // Re-apply uncertainty toggle display logic.
        toggleErrorColumn('x');
        toggleErrorColumn('y');
    }

    function loadHeaders() {
        // Use stored headers for the active dataset if available;
        // otherwise, use defaults.
        const headers = datasetHeaders[activeSet] || { x: 'x', y: 'y' };

        document.getElementById('x-column-name').value = headers.x;
        document.getElementById('y-column-name').value = headers.y;
        renderLatex('#x-column-latex', formatLabelForLatex(headers.x));
        renderLatex('#y-column-latex', formatLabelForLatex(headers.y));
        updateGraphTitle();
    }

    function updateLabels(type) {
        if (isSyncing) return;
        isSyncing = true;
        const value = document.getElementById(`${type}-column-name`).value;
        renderLatex(`#${type}-column-latex`, formatLabelForLatex(value));

        if (document.getElementById(`toggle-${type}-error`).checked) {
            updateUncertaintyHeaders(type);
        }

        debouncedUpdatePlotAndRenderLatex();
        isSyncing = false;

        // Update the graph title dynamically based on both headers
        const xColumn = document.getElementById('x-column-name').value || 'x';
        const yColumn = document.getElementById('y-column-name').value || 'y';
        document.getElementById('graph-title').value = `${yColumn} \\space \\text{vs} \\space ${xColumn}`;

        // Update initial parameters based on the selected advanced fit method
        setInitialParameters(getCurrentAdvancedFitMethod());
    }

    function renderLatex(elementId, latexString) {
        const element = document.querySelector(elementId);
        if (!element) return;
        element.innerHTML = `\\(${latexString}\\)`;
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
    }

    function updatePlotAndRenderLatex() {
        if (isSyncing) return;
        isSyncing = true;

        // Assumes plotGraph() uses rawData[activeSet] internally.
        plotGraph();

        const xColumnName = document.getElementById('x-column-name').value || 'x';
        renderLatex('#x-column-latex', formatLabelForLatex(xColumnName));

        const yColumnName = document.getElementById('y-column-name').value || 'y';
        renderLatex('#y-column-latex', formatLabelForLatex(yColumnName));

        isSyncing = false;
    }

    function openTab(evt, tabName) {
        const tablinks = document.getElementsByClassName("tablink");
        const tabContents = document.getElementsByClassName("tab-content");

        for (let i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }

        for (let i = 0; i < tabContents.length; i++) {
            tabContents[i].classList.remove("active");
        }

        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");

        if (tabName === 'BasicFit') {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
        } else if (tabName === 'AdvancedFit') {
            changeAdvancedFitMethod();
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
        }
    }

    function updateGraphTitle() {
        const xColumn = document.getElementById('x-column-name').value || 'x';
        const yColumn = document.getElementById('y-column-name').value || 'y';
        // Set the title as "y vs x"
        document.getElementById('graph-title').value = `${yColumn} \\space \\text{vs} \\space ${xColumn}`;
    }

    function plotGraph(fittedX = null, fittedY = null) {
        // If fitted data is not provided and a fit exists, use that.
        if ((fittedX === null || fittedY === null) && fittedCurves.hasOwnProperty(activeSet)) {
            fittedX = fittedCurves[activeSet].x;
            fittedY = fittedCurves[activeSet].y;
        }

        // Build data arrays based on the active dataset.
        const x = rawData[activeSet].map(point => point.x);
        const y = rawData[activeSet].map(point => point.y);
        const xErrorRaw = rawData[activeSet].map(point => point.xErrorRaw || 0);
        const yErrorRaw = rawData[activeSet].map(point => point.yErrorRaw || 0);
        const xErrorType = document.getElementById('toggle-x-error').checked
            ? document.getElementById('x-error-type').value
            : 'absolute';
        const yErrorType = document.getElementById('toggle-y-error').checked
            ? document.getElementById('y-error-type').value
            : 'absolute';

        // Convert error values if using percentage uncertainties.
        const convertedXError = x.map((xi, idx) =>
            xErrorType === 'percentage' ? (xErrorRaw[idx] / 100) * (xi || 0) : xErrorRaw[idx]
        );
        const convertedYError = y.map((yi, idx) =>
            yErrorType === 'percentage' ? (yErrorRaw[idx] / 100) * (yi || 0) : yErrorRaw[idx]
        );

        // Build the trace array.
        const data = [
            {
                x: x,
                y: y,
                mode: 'markers',
                name: 'Data',
                marker: { color: '#ff6c61' },
                error_x: {
                    type: 'data',
                    array: convertedXError,
                    visible: document.getElementById('toggle-x-error').checked,
                    color: 'teal',
                    thickness: 0.5,
                    width: 2
                },
                error_y: {
                    type: 'data',
                    array: convertedYError,
                    visible: document.getElementById('toggle-y-error').checked,
                    color: 'teal',
                    thickness: 0.5,
                    width: 2
                }
            }
        ];

        // If fitted data is available, add its trace.
        if (fittedX && fittedY) {
            data.push({
                x: fittedX,
                y: fittedY,
                mode: 'lines',
                name: 'Fit',
                line: { color: '#4595dd' }
            });
        }

        // Build the layout using the active dataset's header values.
        const layout = {
            xaxis: {
                title: processLabel(document.getElementById('x-column-name').value || 'x')
            },
            yaxis: {
                title: {
                    text: processLabel(document.getElementById('y-column-name').value || 'y'),
                    standoff: 20 // Increase space between y-axis label and values
                },
                titlefont: { size: 14 },
                automargin: true
            },
            title: processLabel(document.getElementById('graph-title').value ||
                `${document.getElementById('y-column-name').value || 'y'} \\space \\text{vs} \\space ${document.getElementById('x-column-name').value || 'x'}`),
            margin: {
                t: 100,
                b: 80,
                l: 85,  // increased left margin for extra spacing
                r: 30
            }
        };

        // Only replot if the new state is different.
        if (isPlotStateEqual(data, layout)) {
            console.log("No changes in plot state; skipping update.");
            return;
        }

        // Update the plot using Plotly.react.
        Plotly.react('plot', data, layout, {
            toImageButtonOptions: {
                format: 'svg',
                filename: 'data_plot',
                scale: 1
            }
        });

        // Update the global cache.
        lastPlotState.data = data;
        lastPlotState.layout = layout;
    }

    function plotAllDatasets() {
        const traces = [];
        // Define an array of colors for fitted curves.
        const fitColors = ['#e06666', '#f6b26b', '#ffd966', '#93c47d', '#6fa8dc', '#8e7cc3'];

        // Process each dataset.
        rawData.forEach((dataset, index) => {
            const x = dataset.map(point => point.x);
            const y = dataset.map(point => point.y);
            const xErrorsRaw = dataset.map(point => point.xErrorRaw || 0);
            const yErrorsRaw = dataset.map(point => point.yErrorRaw || 0);

            // Get the error types for this dataset (default to absolute if not set).
            const currentErrorTypes = datasetErrorTypes[index] || { x: 'absolute', y: 'absolute' };
            const xErrors = x.map((xi, idx) =>
                currentErrorTypes.x === 'percentage' ? (xErrorsRaw[idx] / 100) * (xi || 0) : xErrorsRaw[idx]
            );
            const yErrors = y.map((yi, idx) =>
                currentErrorTypes.y === 'percentage' ? (yErrorsRaw[idx] / 100) * (yi || 0) : yErrorsRaw[idx]
            );

            // Add the data trace for this dataset.
            traces.push({
                x: x,
                y: y,
                mode: 'markers',
                name: `Dataset ${index + 1}`,
                marker: { size: 8 },
                error_x: {
                    type: 'data',
                    array: xErrors,
                    visible: true,
                    color: 'teal',
                    thickness: 0.5,
                    width: 2
                },
                error_y: {
                    type: 'data',
                    array: yErrors,
                    visible: true,
                    color: 'teal',
                    thickness: 0.5,
                    width: 2
                }
            });

            // If a fitted curve exists for this dataset, add it.
            if (fittedCurves.hasOwnProperty(index)) {
                const color = fitColors[index % fitColors.length];
                traces.push({
                    x: fittedCurves[index].x,
                    y: fittedCurves[index].y,
                    mode: 'lines',
                    name: `Fit ${index + 1}`,
                    line: { color: color }
                });
            }
        });

        // Retrieve header settings from the combined plot input boxes
        let titleValue = document.getElementById('combined-title')
            ? document.getElementById('combined-title').value
            : null;
        let xLabelValue = document.getElementById('combined-x-label')
            ? document.getElementById('combined-x-label').value
            : null;
        let yLabelValue = document.getElementById('combined-y-label')
            ? document.getElementById('combined-y-label').value
            : null;

        // Wrap the title in $ signs to enable LaTeX rendering.
        titleValue = '$' + titleValue + '$';

        const layout = {
            title: { text: titleValue, font: { size: 16 } },
            xaxis: { title: xLabelValue },
            yaxis: {
                title: {
                    text: yLabelValue,
                    standoff: 20 // Increase spacing between y-axis label and values
                }
            },
            margin: { t: 100, b: 70, l: 85, r: 30 }
        };

        // Only update if there's a change.
        if (isPlotStateEqual(traces, layout)) {
            console.log("No changes detected in combined plot; skipping update.");
            return;
        }

        Plotly.newPlot('popup-plot', traces, layout, {
            toImageButtonOptions: {
                format: 'svg',
                filename: 'combined_plot',
                scale: 1
            }
        });

        // Update the global cache.
        lastPlotState.data = traces;
        lastPlotState.layout = layout;

        showPopup();

        if (typeof MathJax !== 'undefined') {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('popup-plot')]);
        }
    }

    // Function to initialize the combined plot input boxes.
    function initCombinedPlotInputs() {
        // Assume there is a container element in your HTML with id "combined-plot-controls"
        // If it doesn't exist yet, create and append it below the combined plot container.
        let controlsContainer = document.getElementById('combined-plot-controls');
        if (!controlsContainer) {
            controlsContainer = document.createElement('div');
            controlsContainer.id = 'combined-plot-controls';
            // Optionally style the container here.
            document.body.appendChild(controlsContainer);
        }

        // Create or select the title input.
        let titleInput = document.getElementById('combined-title');
        if (!titleInput) {
            titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.id = 'combined-title';
            titleInput.placeholder = 'Title';
            controlsContainer.appendChild(titleInput);
        }

        // Create or select the x-axis label input.
        let xLabelInput = document.getElementById('combined-x-label');
        if (!xLabelInput) {
            xLabelInput = document.createElement('input');
            xLabelInput.type = 'text';
            xLabelInput.id = 'combined-x-label';
            xLabelInput.placeholder = 'x-axis Label';
            controlsContainer.appendChild(xLabelInput);
        }

        // Create or select the y-axis label input.
        let yLabelInput = document.getElementById('combined-y-label');
        if (!yLabelInput) {
            yLabelInput = document.createElement('input');
            yLabelInput.type = 'text';
            yLabelInput.id = 'combined-y-label';
            yLabelInput.placeholder = 'y-axis Label';
            controlsContainer.appendChild(yLabelInput);
        }

        // Initialize the input boxes with the active dataset’s labels.
        // For title, take the value from the active graph title input.
        titleInput.value = document.getElementById('graph-title').value || `${document.getElementById('y-column-name').value || 'y'} \\space \\text{vs} \\space ${document.getElementById('x-column-name').value || 'x'}`;
        xLabelInput.value = processLabel(document.getElementById('x-column-name').value || 'x');
        yLabelInput.value = processLabel(document.getElementById('y-column-name').value || 'y');

        // Add event listeners: whenever any input value changes, update the combined plot.
        titleInput.addEventListener('input', updateCombinedPlotFromInputs);
        xLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
        yLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
    }

    // Function to update the combined plot using the values from the new input boxes.
    function updateCombinedPlotFromInputs() {
        // Simply call plotAllDatasets; the updated version will check the input box values.
        plotAllDatasets();
    }

    // This function makes the popup visible.
    function showPopup() {
        const popup = document.getElementById('popup-container');
        if (popup) {
            popup.style.display = 'block';
        }
    }

    // This function hides the popup.
    function closePopup() {
        const popup = document.getElementById('popup-container');
        if (popup) {
            popup.style.display = 'none';
        }
    }

    function fitCurve() {
        // Ensure there are at least two data points in the active dataset.
        if (rawData[activeSet].length < 2) {
            alert('Please enter at least two data points.');
            return;
        }

        const fitMethod = document.getElementById('fit-method').value;

        // For fitting methods where you need x and y arrays,
        // we are mapping rawData[activeSet] to extract the x and y values.
        if (fitMethod === 'Linear') {
            performLinearFit(rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y));
        } else if (fitMethod.startsWith('Polynomial')) {
            const degree = parseInt(fitMethod.split('-')[1]);
            performPolynomialFit(rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y), degree);
        } else if (fitMethod === 'Exponential') {
            performExponentialFit();
        } else if (fitMethod === 'Power') {
            performPowerFit();
        }
    }

    function updateBasicFitEquation() {
        const fitMethod = document.getElementById('fit-method').value;
        let equation = '';

        if (fitMethod === 'Linear') {
            equation = 'y = mx + c';
        } else if (fitMethod.startsWith('Polynomial')) {
            const degree = parseInt(fitMethod.split('-')[1]);
            let terms = [];
            for (let i = degree; i >= 0; i--) {
                terms.push(`a_${i}x^{${i}}`);
            }
            equation = 'y = ' + terms.join(' + ');
        } else if (fitMethod === 'Exponential') {
            equation = 'y = A e^{bx}';
        } else if (fitMethod === 'Power') {
            equation = 'y = A x^{b}';
        }

        const equationElement = document.getElementById('basic-fit-equation');
        if (equationElement) {
            equationElement.innerHTML = `\\( ${equation} \\)`;
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
        }
    }

    function changeAdvancedFitMethod() {
        const selectedMethod = document.getElementById('advanced-fit-method').value;
        const methods = ['Sinusoidal', 'Gaussian'];

        methods.forEach(method => {
            const section = document.getElementById(`${method}-parameters`);
            if (method === selectedMethod) {
                section.classList.add('active');
            } else {
                section.classList.remove('active');
            }
        });

        updateAdvancedFitEquation(selectedMethod);
        setInitialParameters(selectedMethod);
    }

    function updateAdvancedFitEquation(selectedMethod) {
        let equation = '';
        if (selectedMethod === 'Sinusoidal') {
            equation = 'y = A e^{bx} \\sin(kx - \\phi) + c';
        } else if (selectedMethod === 'Gaussian') {
            equation = 'y = A e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}} + c';
        }

        const equationElement = document.getElementById('advanced-fit-general-equation');
        if (equationElement) {
            equationElement.innerHTML = `\\(${equation}\\)`;
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
        }
    }

    // Helper function to calculate FWHM for Gaussian Fit (optional, not used here)
    function calculateFWHM(x, y, maxY) {
        const halfMax = maxY / 2;
        let left = null, right = null;

        // Sort data by x
        const sortedData = rawData[activeSet].slice().sort((a, b) => a.x - b.x);

        // Find left crossing
        for (let i = 1; i < sortedData.length; i++) {
            if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                const x1 = sortedData[i - 1].x;
                const y1 = sortedData[i - 1].y;
                const x2 = sortedData[i].x;
                const y2 = sortedData[i].y;
                left = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                break;
            }
        }

        // Find right crossing
        for (let i = sortedData.length - 1; i > 0; i--) {
            if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                const x1 = sortedData[i - 1].x;
                const y1 = sortedData[i - 1].y;
                const x2 = sortedData[i].x;
                const y2 = sortedData[i].y;
                right = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                break;
            }
        }

        if (left !== null && right !== null && right > left) {
            return right - left;
        } else {
            const minX = Math.min(...x);
            const maxX = Math.max(...x);
            return (maxX - minX) / 4;
        }
    }

    // Function to set initial parameters based on selected method and data
    function setInitialParameters(method) {
        if (!method) return; // If method is undefined, do nothing

        if (rawData[activeSet].length === 0) return;

        const x = rawData[activeSet].map(p => p.x);
        const y = rawData[activeSet].map(p => p.y);
        const meanX = x.reduce((sum, val) => sum + val, 0) / x.length;
        const stdX = Math.sqrt(x.reduce((sum, val) => sum + Math.pow(val - meanX, 2), 0) / x.length);
        const maxY = Math.max(...y);
        const FWHM = calculateFWHM(x, y, maxY);

        if (method === 'Gaussian') {
            document.getElementById('initial-A-gaussian').value = maxY.toFixed(3);
            document.getElementById('initial-mu').value = meanX.toFixed(3);
            document.getElementById('initial-sigma').value = (FWHM / (2 * Math.sqrt(2 * Math.log(2)))).toFixed(3);
            document.getElementById('initial-c-gaussian').value = '0';
        } else if (method === 'Sinusoidal') {
            // Set A to maxY, b to slope from linear fit, phi to 0, c to meanY
            const meanY = y.reduce((sum, val) => sum + val, 0) / y.length;
            const linearFit = computeLinearFit(x, y);
            const A = maxY - meanY;
            const b = linearFit.slope;
            const phi = 0;
            const c = meanY;

            // Estimate k from data and set it
            const estimatedK = estimateKFromData();
            if (estimatedK !== null) {
                document.getElementById('initial-k').value = estimatedK.toFixed(3);
            } else {
                document.getElementById('initial-k').value = '1'; // Default value if estimation fails
            }

            document.getElementById('initial-A').value = A.toFixed(3);
            document.getElementById('initial-b').value = b.toFixed(3);
            document.getElementById('initial-phi').value = phi.toFixed(3);
            document.getElementById('initial-c').value = c.toFixed(3);
        }
    }

    function getCurrentAdvancedFitMethod() {
        return document.getElementById('advanced-fit-method').value;
    }

    function computeLinearFit(x, y) {
        try {
            const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
            const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

            let numerator = 0, denominator = 0;
            for (let i = 0; i < x.length; i++) {
                numerator += (x[i] - xMean) * (y[i] - yMean);
                denominator += (x[i] - xMean) ** 2;
            }

            const slope = numerator / denominator;
            const intercept = yMean - slope * xMean;

            return { slope, intercept };
        } catch (error) {
            console.error('Error computing linear fit:', error);
            throw error;
        }
    }

    function updateResults(equation, x, y, fitFunction) {
        try {
            const yPredicted = x.map(point => fitFunction(point));
            const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

            let ssTotal = 0, ssResidual = 0;
            for (let i = 0; i < y.length; i++) {
                ssTotal += Math.pow(y[i] - meanY, 2);
                ssResidual += Math.pow(y[i] - yPredicted[i], 2);
            }

            const rSquared = 1 - ssResidual / ssTotal;

            // Update the UI (fitting result container)
            const fitEquationElement = document.getElementById('fit-equation');
            if (fitEquationElement) {
                fitEquationElement.innerHTML = `\\(${equation}\\)`;
                fitEquationElement.style.display = 'block';
            }

            const rSquaredElement = document.getElementById('r-squared-container');
            if (rSquaredElement) {
                rSquaredElement.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
                rSquaredElement.style.display = 'block';
            }

            // Trigger MathJax typesetting if available.
            if (typeof MathJax !== 'undefined') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, fitEquationElement]);
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, rSquaredElement]);
            }

            // Store this result for the current dataset.
            datasetFitResults[activeSet] = {
                equation: equation,
                rSquared: rSquared.toFixed(5)
            };
        } catch (error) {
            console.error('Error updating results:', error);
        }
    }

    function polyfit(x, y, degree) {
        try {
            const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtY = math.multiply(Xt, y);
            const coefficients = math.lusolve(XtX, XtY).flat();
            return coefficients;
        } catch (error) {
            console.error('Error performing polynomial fit:', error);
            throw error;
        }
    }

    function polyEval(coefficients, x) {
        try {
            return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
        } catch (error) {
            console.error('Error evaluating polynomial:', error);
            throw error;
        }
    }

    function updateData() {
        try {
            const xInputs = document.querySelectorAll('.x-input');
            const yInputs = document.querySelectorAll('.y-input');
            const xErrorInputs = document.querySelectorAll('.x-error-input');
            const yErrorInputs = document.querySelectorAll('.y-error-input');

            // Clear the current active dataset and repopulate it from the table inputs.
            rawData[activeSet] = [];
            for (let i = 0; i < xInputs.length; i++) {
                const x = parseFloat(xInputs[i].value);
                const y = parseFloat(yInputs[i].value);
                const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
                const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

                if (!isNaN(x) && !isNaN(y)) {
                    rawData[activeSet].push({
                        x: x,
                        y: y,
                        xErrorRaw: xErrorRaw,
                        yErrorRaw: yErrorRaw
                    });
                }
            }

            // Update the plot using only the active dataset.
            plotGraph();
        } catch (error) {
            console.error('Error updating data:', error);
        }
    }

    function formatDataForExport(valueStr, errorStr, errorEnabled, errorType, val, rowVal, rowErr) {
        if (!errorEnabled) {
            return valueStr;
        }

        if (isNaN(rowErr)) return valueStr;

        if (errorType === 'absolute') {
            const dp = countDecimalPlaces(errorStr);
            return val.toFixed(dp);
        } else if (errorType === 'percentage') {
            const perc = parseFloat(errorStr);
            if (isNaN(perc)) {
                return valueStr;
            }

            // Use 1 significant figure if percentage uncertainty is >= 50%
            let sigFigs;
            if (perc >= 50) {
                sigFigs = 1;
            } else if (perc <= 10) {
                sigFigs = 3;
            } else {
                sigFigs = 2;
            }

            const sfVal = toSigFigs(val, sigFigs);
            return sfVal;
        } else {
            return valueStr;
        }
    }

    /**
     * Formats labels for LaTeX by replacing spaces with \space.
     * @param {string} label - The label to format.
     * @returns {string} - The LaTeX-formatted label.
     */
    function formatLabelForLatex(label) {
        return label ? label.replace(/ /g, '\\space ') : '';
    }

    /**
     * Counts the number of decimal places in a number string.
     * @param {string} numStr - The number as a string.
     * @returns {number} - The number of decimal places.
     */
    function countDecimalPlaces(numStr) {
        if (!numStr.includes('.')) return 0;
        return numStr.length - numStr.indexOf('.') - 1;
    }

    /**
     * Formats a number to the specified number of significant figures without using scientific notation.
     * Preserves trailing zeros by returning a string.
     * @param {number} num - The number to format.
     * @param {number} sigFigs - The number of significant figures.
     * @returns {string} - The formatted number as a string.
     */
    function toSigFigs(num, sigFigs) {
        if (num === 0) return '0';

        if (sigFigs === 1) {
            const order = Math.floor(Math.log10(Math.abs(num)));
            const factor = Math.pow(10, order);
            const rounded = Math.floor(num / factor) * factor;
            return order >= 0 ? rounded.toString() : rounded.toFixed(Math.abs(order));
        }

        let numStr = num.toPrecision(sigFigs);
        if (numStr.includes('e') || numStr.includes('E')) {
            const [mantissa, exponent] = numStr.split(/e/i);
            const exponentVal = parseInt(exponent, 10);
            let fixedNum = parseFloat(mantissa) * Math.pow(10, exponentVal);
            const decimalPlaces = sigFigs - 1 - Math.floor(Math.log10(Math.abs(num)));
            return fixedNum.toFixed(decimalPlaces > 0 ? decimalPlaces : 0);
        }
        return numStr;
    }

    /**
     * Formats a number into scientific notation for LaTeX with specified significant figures.
     * @param {number} num - The number to format.
     * @param {number} sigFigs - The number of significant figures.
     * @returns {string} - The LaTeX-formatted scientific notation string.
     */
    function formatScientificNotation(num, sigFigs) {
        if (sigFigs === 1) {
            return toSigFigs(num, sigFigs);
        }
        let numStr = num.toExponential(sigFigs - 1);
        return numStr;
    }

    /**
     * Formats data values based on the uncertainty type.
     *
     * For 'absolute' uncertainty:
     *   - If the absolute uncertainty is ≥ 1, the data value is rounded down (via Math.floor)
     *     to the nearest multiple determined by the order of magnitude of the uncertainty.
     *     For example, 1455 with an uncertainty of 40 becomes 1450.
     *   - If the absolute uncertainty is < 1, the data value is formatted to the same number of
     *     decimal places as the uncertainty (preserving trailing zeros).
     *
     * For 'percentage' uncertainty:
     *   - When the percentage uncertainty is greater than or equal to 50%, the data value is formatted
     *     to 1 significant figure.
     *   - Otherwise, the data value is formatted to a fixed number of significant figures:
     *       * 3 significant figures if the uncertainty is less than 10,
     *       * 2 significant figures otherwise.
     *   - Scientific notation is applied if indicated.
     *
     * If no uncertainty is provided, the data value is simply returned as a string.
     *
     * @param {number} dataVal - The data value.
     * @param {number} uncertaintyVal - The uncertainty value.
     * @param {string} uncertaintyType - The type of uncertainty ('absolute' or 'percentage').
     * @param {boolean} useSciNotation - Whether to apply scientific notation.
     * @returns {string} - The formatted data value.
     */
    function formatDataValue(dataVal, uncertaintyVal, uncertaintyType, useSciNotation) {
        if (uncertaintyType === 'absolute') {
            if (Math.abs(uncertaintyVal) >= 1) {
                const order = Math.floor(Math.log10(Math.abs(uncertaintyVal)));
                const factor = Math.pow(10, order);
                const roundedValue = Math.floor(dataVal / factor) * factor;
                return roundedValue.toFixed(0);
            } else {
                const dp = countDecimalPlaces(uncertaintyVal.toString());
                // Simply return the data value formatted with 'dp' decimal places,
                // preserving all trailing zeros.
                return dataVal.toFixed(dp);
            }
        } else if (uncertaintyType === 'percentage') {
            const perc = parseFloat(uncertaintyVal);
            if (isNaN(perc)) return dataVal.toString();
            // Use 1 s.f. if percentage uncertainty is >= 50, else use 3 s.f. if error < 10, otherwise 2 s.f.
            const sigFigs = perc >= 50 ? 1 : (perc < 10 ? 3 : 2);
            if (useSciNotation) {
                return formatScientificNotation(dataVal, sigFigs);
            } else {
                return toSigFigs(dataVal, sigFigs);
            }
        } else {
            return dataVal.toString();
        }
    }

    /**
     * Formats uncertainties based on their type.
     * - For percentage uncertainties: preserves the exact input (optionally add '\\%' if needed).
     * - For absolute uncertainties: preserves trailing zeros based on the number of decimal places.
     * @param {string} errStr - The uncertainty value as a string.
     * @param {string} errorType - The type of uncertainty ('absolute' or 'percentage').
     * @returns {string} - The formatted uncertainty string.
     */
    function formatUncertainty(errStr, errorType) {
        if (errorType === 'percentage') {
            return errStr; // Optionally: return errStr + '\\%' if desired.
        } else if (errorType === 'absolute') {
            const dp = countDecimalPlaces(errStr);
            const errVal = parseFloat(errStr);
            if (isNaN(errVal)) return errStr;
            return errVal.toFixed(dp);
        } else {
            return errStr;
        }
    }

    /**
     * Exports the data as a Markdown (.md) file with LaTeX formatting.
     */
    function exportPlainText() {
        try {
            // Retrieve axis headings
            const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
            const yHeader = document.getElementById('y-column-name').value.trim() || 'y';

            // Check if uncertainties are enabled
            const xErrorEnabled = document.getElementById('toggle-x-error').checked;
            const yErrorEnabled = document.getElementById('toggle-y-error').checked;

            // Get uncertainty types
            const xErrorType = document.getElementById('x-error-type').value;
            const yErrorType = document.getElementById('y-error-type').value;

            // Get all rows from the data table's tbody
            const table = document.getElementById('data-table');
            const rows = table.querySelectorAll('tbody tr');

            // Initialize arrays to collect all x and y values
            let xValues = [];
            let yValues = [];

            // Collect all x and y values for notation decision
            rows.forEach(row => {
                const xInputElem = row.querySelector('.x-input');
                const yInputElem = row.querySelector('.y-input');

                if (!xInputElem || !yInputElem) return;

                const xValStr = xInputElem.value.trim();
                const yValStr = yInputElem.value.trim();

                if (xValStr !== '') {
                    const xVal = parseFloat(xValStr);
                    if (!isNaN(xVal)) xValues.push(xVal);
                }
                if (yValStr !== '') {
                    const yVal = parseFloat(yValStr);
                    if (!isNaN(yVal)) yValues.push(yVal);
                }
            });

            // Determine if scientific notation is needed for x and y
            const xUseSciNotation = xErrorEnabled && xErrorType === 'percentage' &&
                xValues.some(val => val < -10000 || val > 10000);
            const yUseSciNotation = yErrorEnabled && yErrorType === 'percentage' &&
                yValues.some(val => val < -10000 || val > 10000);

            // Initialize headers with LaTeX formatting
            let headers = [
                `$${formatLabelForLatex(xHeader)}$`,
                `$${formatLabelForLatex(yHeader)}$`
            ];

            if (xErrorEnabled) {
                let xUncHeading = `\\pm \\Delta ${formatLabelForLatex(xHeader)}`;
                if (xErrorType === 'percentage') xUncHeading += ' \\space (\\%)';
                headers.push(`$${xUncHeading}$`);
            }
            if (yErrorEnabled) {
                let yUncHeading = `\\pm \\Delta ${formatLabelForLatex(yHeader)}`;
                if (yErrorType === 'percentage') yUncHeading += ' \\space (\\%)';
                headers.push(`$${yUncHeading}$`);
            }

            let markdown = `| ${headers.join(' | ')} |\n`;
            markdown += `|${headers.map(() => ':---:').join('|')}|\n`;

            // Process each row
            rows.forEach(row => {
                const xInputElem = row.querySelector('.x-input');
                const yInputElem = row.querySelector('.y-input');
                if (!xInputElem || !yInputElem) return;

                const xValStr = xInputElem.value.trim();
                const yValStr = yInputElem.value.trim();
                if (xValStr === '' && yValStr === '') return;

                const xVal = parseFloat(xValStr);
                const yVal = parseFloat(yValStr);

                const xErrInput = row.querySelector('.x-error-input');
                const yErrInput = row.querySelector('.y-error-input');
                const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                const xErrVal = parseFloat(xErrStr);
                const yErrVal = parseFloat(yErrStr);
                const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                let rowData = [];

                // Format X value
                let xFormatted = xValStr;
                if (!isNaN(xVal)) {
                    if (xUseSciNotation && xErrorEnabledThisRow && xErrorType === 'percentage') {
                        const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
                        const sciFormatted = formatScientificNotation(xVal, sigFigs);
                        xFormatted = `$${sciFormatted}$`;
                    } else if (xErrorEnabledThisRow && xErrorType === 'percentage') {
                        const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
                        const sigFormatted = toSigFigs(xVal, sigFigs);
                        xFormatted = `$${sigFormatted}$`;
                    } else if (xErrorEnabledThisRow && xErrorType === 'absolute') {
                        const formattedData = formatDataValue(xVal, xErrVal, 'absolute', false);
                        xFormatted = `$${formattedData}$`;
                    } else {
                        xFormatted = `$${xValStr}$`;
                    }
                }

                // Format Y value
                let yFormatted = yValStr;
                if (!isNaN(yVal)) {
                    if (yUseSciNotation && yErrorEnabledThisRow && yErrorType === 'percentage') {
                        const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
                        const sciFormatted = formatScientificNotation(yVal, sigFigs);
                        yFormatted = `$${sciFormatted}$`;
                    } else if (yErrorEnabledThisRow && yErrorType === 'percentage') {
                        const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
                        const sigFormatted = toSigFigs(yVal, sigFigs);
                        yFormatted = `$${sigFormatted}$`;
                    } else if (yErrorEnabledThisRow && yErrorType === 'absolute') {
                        const formattedData = formatDataValue(yVal, yErrVal, 'absolute', false);
                        yFormatted = `$${formattedData}$`;
                    } else {
                        yFormatted = `$${yValStr}$`;
                    }
                }

                rowData.push(xFormatted);
                rowData.push(yFormatted);
                if (xErrorEnabled) {
                    let xErrorFormatted = xErrorEnabledThisRow ? formatUncertainty(xErrStr, xErrorType) : '';
                    if (xErrorFormatted !== '') xErrorFormatted = `$${xErrorFormatted}$`;
                    rowData.push(xErrorFormatted);
                }
                if (yErrorEnabled) {
                    let yErrorFormatted = yErrorEnabledThisRow ? formatUncertainty(yErrStr, yErrorType) : '';
                    if (yErrorFormatted !== '') yErrorFormatted = `$${yErrorFormatted}$`;
                    rowData.push(yErrorFormatted);
                }
                markdown += `| ${rowData.join(' | ')} |\n`;
            });

            console.log("Final Markdown Content:\n", markdown);
            const blob = new Blob([markdown], { type: 'text/plain;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'data.md');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('Error exporting plain text:', error);
            alert('An error occurred while exporting the Markdown file. Please check the console for details.');
        }
    }

    function exportCSV() {
        try {
            const table = document.getElementById('data-table');
            const rows = table.querySelectorAll('tr');
            let csvContent = '';

            const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
            const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
            const xErrorEnabled = document.getElementById('toggle-x-error').checked;
            const yErrorEnabled = document.getElementById('toggle-y-error').checked;

            const headers = [xHeader, yHeader];
            if (xErrorEnabled) {
                const xErrorType = document.getElementById('x-error-type').value;
                const xErrorHead = xErrorType === 'percentage' ? `delta ${xHeader} (%)` : `delta ${xHeader}`;
                headers.push(xErrorHead);
            }
            if (yErrorEnabled) {
                const yErrorType = document.getElementById('y-error-type').value;
                const yErrorHead = yErrorType === 'percentage' ? `delta ${yHeader} (%)` : `delta ${yHeader}`;
                headers.push(yErrorHead);
            }

            csvContent += headers.join(',') + '\n';

            const dataRows = table.querySelectorAll('tbody tr');

            for (let i = 0; i < dataRows.length; i++) {
                const xValStr = dataRows[i].querySelector('.x-input')?.value.trim() || '';
                const yValStr = dataRows[i].querySelector('.y-input')?.value.trim() || '';
                if (xValStr === '' && yValStr === '') continue;

                let xVal = parseFloat(xValStr);
                let yVal = parseFloat(yValStr);

                const xErrInput = dataRows[i].querySelector('.x-error-input');
                const yErrInput = dataRows[i].querySelector('.y-error-input');

                const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                const xErrVal = parseFloat(xErrStr);
                const yErrVal = parseFloat(yErrStr);

                const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                const xErrorType = document.getElementById('x-error-type').value;
                const yErrorType = document.getElementById('y-error-type').value;

                let rowData = [];

                let xFormatted = xValStr;
                if (!isNaN(xVal)) {
                    xFormatted = formatDataForExport(
                        xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
                    );
                }

                let yFormatted = yValStr;
                if (!isNaN(yVal)) {
                    yFormatted = formatDataForExport(
                        yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
                    );
                }

                rowData.push(xFormatted);
                rowData.push(yFormatted);

                if (xErrorEnabled) {
                    rowData.push(xErrorEnabledThisRow ? xErrStr : '');
                }

                if (yErrorEnabled) {
                    rowData.push(yErrorEnabledThisRow ? yErrStr : '');
                }

                csvContent += rowData.join(',') + '\n';
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'data.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('Error exporting CSV:', error);
            alert('An error occurred while exporting the CSV. Please check the console for details.');
        }
    }

    function applyGlobalUncertainties(axis) {
        const globalVal = document.getElementById(`global-${axis}-uncertainty`).value.trim();
        const tableBody = document.querySelector('#data-table tbody');
        const rows = tableBody.querySelectorAll('tr');

        rows.forEach((row) => {
            const xInput = row.querySelector('.x-input').value.trim();
            const yInput = row.querySelector('.y-input').value.trim();

            if (xInput !== '' && yInput !== '') {
                const errorInput = row.querySelector(`.${axis}-error-input`);
                if (document.getElementById(`toggle-${axis}-error`).checked && errorInput) {
                    errorInput.value = globalVal !== '' ? globalVal : '';
                }
            }
        });

        updateData();
        document.getElementById(`global-${axis}-uncertainty`).value = '';

        // Update initial parameters based on the selected advanced fit method
        setInitialParameters(getCurrentAdvancedFitMethod());
    }

    function fitAdvancedCurve() {
        if (rawData[activeSet].length < 4) { // Increased to 4 for more complex fits
            alert('Please enter at least four data points for advanced fitting.');
            return;
        }

        const fitMethod = document.getElementById('advanced-fit-method').value;

        if (fitMethod === 'Sinusoidal') {
            performSinusoidalFit();
        } else if (fitMethod === 'Gaussian') {
            performGaussianFit();
        }
    }

    function performLinearFit(x, y) {
        try {
            const { slope, intercept } = computeLinearFit(x, y);

            const xFit = [Math.min(...x), Math.max(...x)];
            const yFit = xFit.map(xi => slope * xi + intercept);

            const fitFunction = xi => slope * xi + intercept;

            let equation = `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
            if (intercept < 0) {
                equation = `y = ${slope.toFixed(3)}x - ${Math.abs(intercept).toFixed(3)}`;
            }

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

            updateResults(equation, x, y, fitFunction);
            plotGraph(xFit, yFit);
        } catch (error) {
            console.error('Error performing linear fit:', error);
            alert('An error occurred during linear fitting. Please check the console for details.');
        }
    }

    function performPolynomialFit(x, y, degree) {
        try {
            const coefficients = polyfit(x, y, degree);
            const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
            const yFit = xFit.map(xi => polyEval(coefficients, xi));

            const fitFunction = xi => polyEval(coefficients, xi);

            let equation = 'y = ';
            coefficients.forEach((c, i) => {
                const power = degree - i;
                if (c === 0) return;

                const absC = Math.abs(c).toFixed(3);
                const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                let term = '';
                if (power === 0) {
                    term = `${absC}`;
                } else if (power === 1) {
                    term = `${absC}x`;
                } else {
                    term = `${absC}x^{${power}}`;
                }

                equation += `${sign}${term}`;
            });

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

            updateResults(equation, x, y, fitFunction);
            plotGraph(xFit, yFit);
        } catch (error) {
            console.error('Error performing polynomial fit:', error);
            alert('An error occurred during polynomial fitting. Please check the console for details.');
        }
    }

    function performExponentialFit() {
        try {
            // Ensure all y values are positive
            const validData = rawData[activeSet].filter(point => point.y > 0);
            if (validData.length < 2) {
                alert('Exponential fit requires all y values to be positive.');
                return;
            }

            const x = validData.map(p => p.x);
            const y = validData.map(p => Math.log(p.y));

            const { slope, intercept } = computeLinearFit(x, y);

            const b = slope;
            const A = Math.exp(intercept);

            const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
            const yFit = xFit.map(xi => A * Math.exp(b * xi));

            const fitFunction = xi => A * Math.exp(b * xi);

            let equation = `y = ${A.toFixed(3)} e^{${b.toFixed(3)}x}`;

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

            updateResults(equation, x, validData.map(p => p.y), fitFunction);
            plotGraph(xFit, yFit);
        } catch (error) {
            console.error('Error performing exponential fit:', error);
            alert('An error occurred during exponential fitting. Please check the console for details.');
        }
    }

    function performPowerFit() {
        try {
            // Ensure all y and x values are positive
            const validData = rawData[activeSet].filter(point => point.y > 0 && point.x > 0);
            if (validData.length < 2) {
                alert('Power fit requires all x and y values to be positive.');
                return;
            }

            const x = validData.map(p => Math.log(p.x));
            const y = validData.map(p => Math.log(p.y));

            const { slope, intercept } = computeLinearFit(x, y);

            const b = slope;
            const A = Math.exp(intercept);

            const xOriginal = validData.map(p => p.x);
            const xFitOriginal = Array.from({ length: 100 }, (_, i) => Math.min(...xOriginal) + i * (Math.max(...xOriginal) - Math.min(...xOriginal)) / 99);
            const yFit = xFitOriginal.map(xi => A * Math.pow(xi, b));

            const fitFunction = xi => A * Math.pow(xi, b);

            let equation = `y = ${A.toFixed(3)} x^{${b.toFixed(3)}}`;

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFitOriginal, y: yFit, equation: equation };

            updateResults(equation, validData.map(p => p.x), validData.map(p => p.y), fitFunction);
            plotGraph(xFitOriginal, yFit);
        } catch (error) {
            console.error('Error performing power fit:', error);
            alert('An error occurred during power fitting. Please check the console for details.');
        }
    }

    function estimateKFromData() {
        if (!rawData[activeSet] || rawData[activeSet].length < 4) {
            console.warn("Not enough data points to estimate k.");
            return null;
        }

        // === 1. Sort & detrend ===
        const sortedData = [...rawData[activeSet]].sort((a, b) => a.x - b.x);
        const x = sortedData.map(p => p.x);
        const y = sortedData.map(p => p.y);

        const N = x.length;
        const xMin = x[0];
        const xMax = x[N - 1];
        const dataSpan = xMax - xMin;
        if (dataSpan <= 0) {
            console.warn("Degenerate or invalid X range.");
            return null;
        }

        // Mean of y for detrending
        const meanY = y.reduce((acc, val) => acc + val, 0) / N;
        const yDetrended = y.map(val => val - meanY);

        // We'll also need an approximate sampling step to gauge a "Nyquist" limit
        //   (roughly valid if data is close to uniform in x).
        const avgDx = dataSpan / (N - 1);
        // A naive Nyquist frequency ~ π / avgDx
        const nyquist = Math.PI / avgDx;

        // === 2. Optional: Peak-detection for rough kGuess ===
        let peaks = [];
        for (let i = 1; i < N - 1; i++) {
            if (y[i] > y[i - 1] && y[i] > y[i + 1]) {
                peaks.push(x[i]);
            }
        }
        let kGuess = null;
        if (peaks.length >= 2) {
            const intervals = [];
            for (let i = 1; i < peaks.length; i++) {
                intervals.push(peaks[i] - peaks[i - 1]);
            }
            const avgPeriod = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            kGuess = (2 * Math.PI) / avgPeriod;
            console.log(
                `Peak-detect guess => period ~ ${avgPeriod.toFixed(4)}, kGuess ~ ${kGuess.toFixed(4)}`
            );
        } else {
            console.log("Not enough peaks for a peak-based guess.");
        }

        // === 3. Define an initial log-spaced frequency range ===
        // We'll define a broad range, but not infinite.
        // Lower bound: say 2π / (5 * dataSpan) => up to ~5 cycles across the entire domain
        // or 1e-3 if that is bigger, just to avoid going too close to zero.
        const minCandidate = Math.max(1e-3, (2 * Math.PI) / (5 * dataSpan));

        // Upper bound: let's pick something around 5 × the naive Nyquist as a default
        // (i.e. 5 × π / avgDx), but not less than, say, 10 if the data is extremely well-sampled.
        let maxCandidate = Math.max(10, nyquist * 5);

        // If we do have a kGuess, ensure that we include it by possibly expanding the range:
        if (kGuess && Number.isFinite(kGuess) && kGuess > 0) {
            if (kGuess < minCandidate) {
                // expand downward
                console.log(
                    `kGuess < minCandidate => adjusting minCandidate from ${minCandidate.toFixed(4)} to ~${kGuess / 5}`
                );
                minCandidate <= 1e-7
                    ? (minCandidate = 1e-7)
                    : (minCandidate = Math.max(1e-7, kGuess / 5));
            }
            if (kGuess > maxCandidate) {
                console.log(
                    `kGuess > maxCandidate => adjusting maxCandidate from ${maxCandidate.toFixed(4)} to ~${kGuess * 5}`
                );
                maxCandidate = kGuess * 5;
            }
        }

        console.log(
            `Log-search range: [${minCandidate.toFixed(4)}, ${maxCandidate.toFixed(4)}]`
        );

        // === 4. Coarse search in log space ===
        // We'll sample frequencies log-spaced from minCandidate to maxCandidate
        const numLogSamples = 200; // ~200 log steps
        const logMin = Math.log(minCandidate);
        const logMax = Math.log(maxCandidate);

        let bestCoarseOmega = 0;
        let bestCoarseScore = -Infinity;

        for (let i = 0; i < numLogSamples; i++) {
            // Log spacing
            const frac = i / (numLogSamples - 1);
            const omega = Math.exp(logMin + frac * (logMax - logMin));

            let sumSin = 0;
            let sumCos = 0;
            for (let j = 0; j < N; j++) {
                const val = yDetrended[j];
                const phase = omega * x[j];
                sumSin += val * Math.sin(phase);
                sumCos += val * Math.cos(phase);
            }
            const score = sumSin * sumSin + sumCos * sumCos;
            if (score > bestCoarseScore) {
                bestCoarseScore = score;
                bestCoarseOmega = omega;
            }
        }
        console.log(
            `Log-coarse best => omega = ${bestCoarseOmega.toFixed(4)}, score = ${bestCoarseScore.toExponential(3)}`
        );

        // === 5. Fine local linear search around bestCoarseOmega ===
        // We'll do ± 30% in linear space (adjust as desired)
        const fineFactor = 0.3;
        const fineMin = Math.max(minCandidate, bestCoarseOmega * (1 - fineFactor));
        const fineMax = Math.min(maxCandidate, bestCoarseOmega * (1 + fineFactor));

        let bestFineOmega = bestCoarseOmega;
        let bestFineScore = bestCoarseScore;

        if (fineMax <= fineMin) {
            console.warn(
                `Fine search range is degenerate => [${fineMin}, ${fineMax}]. Returning coarse result.`
            );
            return bestCoarseOmega;
        }

        const numFine = 3000; // ~3k linear steps
        const step = (fineMax - fineMin) / (numFine - 1);

        for (let i = 0; i < numFine; i++) {
            const omega = fineMin + i * step;
            let sumSin = 0;
            let sumCos = 0;
            for (let j = 0; j < N; j++) {
                const val = yDetrended[j];
                const phase = omega * x[j];
                sumSin += val * Math.sin(phase);
                sumCos += val * Math.cos(phase);
            }
            const score = sumSin * sumSin + sumCos * sumCos;
            if (score > bestFineScore) {
                bestFineScore = score;
                bestFineOmega = omega;
            }
        }
        console.log(
            `Fine search best => omega = ${bestFineOmega.toFixed(4)}, score = ${bestFineScore.toExponential(3)}`
        );

        // === 6. Final sanity check vs. Nyquist? ===
        if (bestFineOmega > 2 * nyquist) {
            console.warn(
                `Warning: best freq = ${bestFineOmega.toFixed(4)} is > 2 × Nyquist (~${(2 * nyquist).toFixed(4)}). Data may be under-sampled.`
            );
        }

        console.log(
            `Final estimated k = ${bestFineOmega.toFixed(4)}`
        );
        return bestFineOmega;
    }

    function performSinusoidalFit() {
        try {
            let A = parseFloat(document.getElementById('initial-A').value);
            let b = parseFloat(document.getElementById('initial-b').value);
            let k = parseFloat(document.getElementById('initial-k').value);
            let phi = parseFloat(document.getElementById('initial-phi').value);
            let c = parseFloat(document.getElementById('initial-c').value);

            if (isNaN(k) || k <= 0) {
                const estimatedK = estimateKFromData();
                if (estimatedK !== null) {
                    k = estimatedK;
                    console.log(`Using estimated k: ${k}`);
                    document.getElementById('initial-k').value = k.toFixed(3);
                } else {
                    alert('Failed to estimate k. Please provide an initial value.');
                    return;
                }
            }

            if (isNaN(A) || isNaN(b) || isNaN(phi) || isNaN(c)) {
                alert('Please provide valid initial parameters for Sinusoidal fit.');
                return;
            }

            let params = { A: A, b: b, k: k, phi: phi, c: c };

            let learningRate = 1e-5;
            const maxIterations = 100000;
            const tolerance = 1e-6;
            let previousError = Infinity;
            let iterationsCount = 0;

            const decayRate = 0.99995;
            const delta = 1.0;

            while (iterationsCount < maxIterations) {
                let totalLoss = 0;
                let dA = 0, db = 0, dk = 0, dphi = 0, dc = 0;

                for (let i = 0; i < rawData[activeSet].length; i++) {
                    const xi = rawData[activeSet][i].x;
                    const yi = rawData[activeSet][i].y;

                    const expTerm = Math.exp(params.b * xi);
                    const sinTerm = Math.sin(params.k * xi - params.phi);
                    const cosTerm = Math.cos(params.k * xi - params.phi);

                    const prediction = params.A * expTerm * sinTerm + params.c;
                    const error = yi - prediction;

                    let huberGrad;
                    if (Math.abs(error) <= delta) {
                        totalLoss += error ** 2;
                        huberGrad = 2 * error;
                    } else {
                        totalLoss += 2 * delta * Math.abs(error) - delta ** 2;
                        huberGrad = 2 * delta * Math.sign(error);
                    }

                    dA += -huberGrad * expTerm * sinTerm;
                    db += -huberGrad * params.A * xi * expTerm * sinTerm;
                    dk += -huberGrad * params.A * expTerm * xi * cosTerm;
                    dphi += huberGrad * params.A * expTerm * cosTerm;
                    dc += -huberGrad;
                }

                const mse = totalLoss / rawData[activeSet].length;
                if (Math.abs(previousError - mse) < tolerance) {
                    console.log(`Convergence reached after ${iterationsCount} iterations.`);
                    break;
                }
                previousError = mse;

                params.A -= learningRate * dA;
                params.b -= learningRate * db;
                params.k -= learningRate * dk;
                params.phi -= learningRate * dphi;
                params.c -= learningRate * dc;
                learningRate *= decayRate;
                iterationsCount++;
            }

            if (iterationsCount === maxIterations) {
                alert('Sinusoidal fitting did not converge. Please try different initial parameters.');
                return;
            }

            const xMin = Math.min(...rawData[activeSet].map(p => p.x));
            const xMax = Math.max(...rawData[activeSet].map(p => p.x));
            const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
            const yFit = xFit.map(xi =>
                params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c
            );

            const fitFunction = xi =>
                params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c;

            let equation = `y = ${params.A.toFixed(3)} e^{${params.b.toFixed(3)}x} \\sin(${params.k.toFixed(3)}x`;
            if (params.phi > 0) {
                equation += ` - ${params.phi.toFixed(3)}`;
            } else if (params.phi < 0) {
                equation += ` + ${Math.abs(params.phi).toFixed(3)}`;
            }
            equation += `)`;
            if (params.c > 0) {
                equation += ` + ${params.c.toFixed(3)}`;
            } else if (params.c < 0) {
                equation += ` - ${Math.abs(params.c).toFixed(3)}`;
            }

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

            updateResults(equation, rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y), fitFunction);
            plotGraph(xFit, yFit);
        } catch (error) {
            console.error('Error performing sinusoidal fit:', error);
            alert('An error occurred during sinusoidal fitting. Please check the console for details.');
        }
    }

    function performGaussianFit() {
        try {
            let A = parseFloat(document.getElementById('initial-A-gaussian').value);
            let mu = parseFloat(document.getElementById('initial-mu').value);
            let sigma = parseFloat(document.getElementById('initial-sigma').value);
            let c = parseFloat(document.getElementById('initial-c-gaussian').value);

            if (isNaN(A) || isNaN(mu) || isNaN(sigma) || isNaN(c)) {
                alert('Please provide valid initial parameters for Gaussian fit.');
                return;
            }

            const params = { A, mu, sigma, c };

            const learningRateA = 1e-7;
            const learningRateMu = 1e-7;
            const learningRateSigma = 1e-7;
            const learningRateC = 1e-7;

            const maxIterations = 50000;
            const tolerance = 1e-8;

            function gaussian(x, p) {
                return p.A * Math.exp(-((x - p.mu) ** 2) / (2 * p.sigma ** 2)) + p.c;
            }

            function computeMSE(p) {
                let mseSum = 0;
                for (let i = 0; i < rawData[activeSet].length; i++) {
                    const { x, y } = rawData[activeSet][i];
                    const prediction = gaussian(x, p);
                    const error = y - prediction;
                    mseSum += error * error;
                }
                return mseSum / rawData[activeSet].length;
            }

            let previousError = computeMSE(params);

            for (let iteration = 0; iteration < maxIterations; iteration++) {
                let dA = 0, dMu = 0, dSigma = 0, dC = 0;

                for (let i = 0; i < rawData[activeSet].length; i++) {
                    const { x, y } = rawData[activeSet][i];
                    const expTerm = Math.exp(-((x - params.mu) ** 2) / (2 * params.sigma ** 2));
                    const prediction = params.A * expTerm + params.c;
                    const error = y - prediction;

                    dA += error * expTerm;
                    dMu += error * params.A * expTerm * ((x - params.mu) / (params.sigma ** 2));
                    dSigma += error * params.A * expTerm * ((x - params.mu) ** 2) / (params.sigma ** 3);
                    dC += error;
                }

                const N = rawData[activeSet].length;
                dA = -2 * dA / N;
                dMu = -2 * dMu / N;
                dSigma = -2 * dSigma / N;
                dC = -2 * dC / N;

                params.A -= learningRateA * dA;
                params.mu -= learningRateMu * dMu;
                params.sigma -= learningRateSigma * dSigma;
                params.c -= learningRateC * dC;

                if (params.sigma <= 0) {
                    params.sigma = Math.abs(params.sigma) || 1e-6;
                }

                const currentError = computeMSE(params);
                if (Math.abs(previousError - currentError) < tolerance) {
                    break;
                }
                previousError = currentError;
            }

            const xValues = rawData[activeSet].map(p => p.x);
            const yValues = rawData[activeSet].map(p => p.y);
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
            const yFit = xFit.map(xi => gaussian(xi, params));

            let muTerm;
            if (params.mu < 0) {
                muTerm = `(x + ${Math.abs(params.mu).toFixed(3)})`;
            } else {
                muTerm = `(x - ${params.mu.toFixed(3)})`;
            }
            let equation = `y = ${params.A.toFixed(3)} \\; e^{-\\frac{${muTerm}^2}{2 \\; (${params.sigma.toFixed(3)})^2}}`;
            if (params.c > 0) {
                equation += ` \\; + \\; ${params.c.toFixed(3)}`;
            } else if (params.c < 0) {
                equation += ` \\; - \\; ${Math.abs(params.c).toFixed(3)}`;
            };

            const fitFunction = xi => gaussian(xi, params);

            // Store the fitted curve for this dataset.
            fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

            updateResults(equation, xValues, yValues, fitFunction);
            plotGraph(xFit, yFit);
        } catch (error) {
            console.error('Error performing Gaussian fit:', error);
            alert('An error occurred during Gaussian fitting. Please check the console for details.');
        }
    }

    function initCombinedPlotInputs() {
        // Select the input elements by their IDs.
        const titleInput = document.getElementById('combined-title');
        const xLabelInput = document.getElementById('combined-x-label');
        const yLabelInput = document.getElementById('combined-y-label');

        if (!titleInput || !xLabelInput || !yLabelInput) {
            console.error('Combined plot input elements not found.');
            return;
        }

        // Set initial values.
        // For the title, we use the value from the active dataset's 'graph-title' input.
        titleInput.value = document.getElementById('graph-title').value ||
            `${document.getElementById('y-column-name').value || 'y'} \\space \\text{vs} \\space ${document.getElementById('x-column-name').value || 'x'}`;
        // For the axis labels, we use the processed values from the active dataset’s inputs.
        xLabelInput.value = processLabel(document.getElementById('x-column-name').value || 'x');
        yLabelInput.value = processLabel(document.getElementById('y-column-name').value || 'y');

        // Attach event listeners so that when the user changes any value, the combined plot is updated.
        titleInput.addEventListener('input', updateCombinedPlotFromInputs);
        xLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
        yLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
    }

    function updateCombinedPlotFromInputs() {
        // Call the function that re-plots the combined plot using these new values.
        plotAllDatasets();
    }

    window.onload = function () {
        initializeTable();
        ['x-column-name', 'y-column-name'].forEach(id => {
            const value = document.getElementById(id).value;
            renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
        });

        clearRows();

        // Update the graph title based on the current column headings:
        updateGraphTitle();

        // Trigger typesetting for the new graph title if necessary.
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);

        updateBasicFitEquation();
        const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
        changeAdvancedFitMethod();
    };

    document.addEventListener("DOMContentLoaded", function () {
        // Render LaTeX for column headings.
        ['x-column-name', 'y-column-name'].forEach(id => {
            const value = document.getElementById(id).value;
            renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
        });

        // Update the graph title based on the current column headings.
        updateGraphTitle();

        // Trigger MathJax typesetting for the graph title.
        if (typeof MathJax !== 'undefined') {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);
        }

        // Update the basic fit equation and advanced fit method.
        updateBasicFitEquation();
        const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
        changeAdvancedFitMethod();

        // Initialize the dataset tabs bar.
        initializeDatasetTabsBar();

        // Initialize the combined plot inputs.
        initCombinedPlotInputs();
    });

</script>

</html>