<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Plotting & Curve Fitting</title>
    <!-- Plotly.js for graphing -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Math.js for computations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <!-- MathJax v2 for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>
    <style>
        :root {
            --add-row-btn-color: #6aa84f;
            --clear-all-btn-color: #e06666;
            --import-csv-btn-color: #45818e;
            --export-csv-btn-color: #7f7f7f;
            --export-md-btn-color: #7f7f7f;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .banner {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #333;
            color: white;
            padding: 20px;
            font-size: 24px;
            font-weight: bold;
            position: relative;
        }

        .banner-left {
            width: 120px; /* Adjust to match the combined width of banner-buttons */
        }

        .banner-title {
            flex: 1;
            text-align: center;
        }

        .banner-buttons {
            display: flex;
            gap: 0px;
            width: 110px; /* Fixed width to match banner-left */
        }

        .banner-button {
            background: none;
            border: none;
            color: grey;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            padding: 5px 10px;
            transition: color 0.3s;
        }

        .banner-button:hover {
            color: #ddd;
        }

        .reminder {
            color: #999999;
            margin: 5px;
            font-size: 14px;
            text-align: center;
        }

        .container {
            display: flex;
            flex-direction: row;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .input-section, .graph-section {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        .input-section {
            flex: 1 1 400px;
            max-width: 400px;
        }

        .graph-section {
            flex: 2 1 600px;
            min-width: 300px;
        }

        .input-section h2, .graph-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .data-table {
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            table-layout: auto;
        }

        .data-table th, .data-table td {
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
            vertical-align: middle;
            white-space: normal;
        }

        .data-table th input {
            width: 90%;
            border: none;
            outline: none;
            font-size: 16px;
            text-align: center;
            background-color: transparent;
            font-weight: normal;
            padding: 4px;
        }

        .data-table th input:focus {
            border-bottom: 2px solid #007bff;
        }

        .data-table .latex-display {
            margin-top: 4px;
            background-color: #f0f8ff;
            border: 1px solid #add8e6;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
            max-width: 100%;
            word-wrap: break-word;
        }

        .data-table td input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 14px;
            text-align: center;
            background-color: transparent;
            padding: 4px;
        }

        .data-table td input:focus {
            outline: 1px solid #007bff;
        }

        .data-table tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #ffffff;
        }

        button {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
            flex: 1;
            transition: background-color 0.3s, filter 0.3s;
        }

        button:hover {
            filter: brightness(90%);
        }

        .btn-add-row {
            background-color: var(--add-row-btn-color);
        }

        .btn-clear-all {
            background-color: var(--clear-all-btn-color);
        }

        .btn-import-csv {
            background-color: var(--import-csv-btn-color);
        }

        .btn-export-csv {
            background-color: var(--export-csv-btn-color);
        }

        .btn-export-md {
            background-color: var(--export-md-btn-color);
        }

        .fit-button {
            background-color: #17a2b8;
            width: 100%;
            height: 40px;
            padding: 0;
            margin: 0;
            flex: 1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .fit-button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .button-row {
            display: flex;
            flex-direction: row;
            gap: 2px;
            width: 100%;
        }

        .global-uncertainty {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .global-uncertainty h2 {
            margin-bottom: 10px;
            text-align: center;
        }

        .uncertainty-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 20px;
        }

        .uncertainty-controls div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .global-uncertainty-item {
            display: flex;
            align-items: center;
            margin-bottom: 0px;
            gap: 10px;
        }

        .global-uncertainty-item input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .global-uncertainty-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .global-uncertainty-item button {
            background-color: #6fa8dc;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s, filter 0.3s;
        }

        .global-uncertainty-item button:hover {
            background-color: #6fa8dc;
            filter: brightness(90%);
        }

        .advanced-fit-section {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .advanced-fit-section h2 {
            text-align: center;
            background-color: #fff2cc;
            padding: 10px;
            border-radius: 4px;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .advanced-fit-section select, 
        .advanced-fit-section .fit-method-select {  
            width: auto;
            min-width: 150px;
            max-width: 300px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .advanced-fit-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            margin-bottom: 10px;
        }

        .advanced-fit-item label {
            flex: none;
            text-align: left;
            white-space: nowrap;
        }

        .advanced-fit-item input {
            flex: none;
            width: auto;
            max-width: 200px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .advanced-fit-item input:focus {
            border-color: #007bff;
            outline: none;
        }

        .advanced-fit-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .advanced-fit-buttons button {
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 12px;
            transition: background-color 0.3s, filter 0.3s;
        }

        .advanced-fit-buttons button:hover {
            background-color: #138496;
            filter: brightness(90%);
        }

        .parameter-section {
            display: none;
        }

        .parameter-section.active {
            display: block;
        }

        .general-equation {
            margin-top: 10px;
            background-color: #e9ecef;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex; 
            justify-content: flex-start; 
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .tabs button {
            background-color: #f3f3f3;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: background-color 0.3s, filter 0.3s;
            font-size: 16px;
            border-radius: 4px;
            color: #999999;
            width: 50%;
        }

        .tabs button:hover {
            background-color: #eeeeee;
            filter: brightness(95%);
        }

        .tabs button.active {
            background-color: #ffd966;
            color: black;
        }

        .tab-content {
            display: none;
            padding: 10px 0;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .result {
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }

        .result h3 {
            margin-top: 0;
        }

        .result p {
            margin: 10px 0;
            font-size: 16px;
        }

        #plot {
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }

            .input-section, .graph-section {
                max-width: 100%;
                flex: none;
            }

            .banner-left, .banner-buttons {
                width: auto;
            }
        }

        .graph-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .graph-title-container label {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }

        .graph-title-container input {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .graph-title-container input:focus {
            border-color: #007bff;
            outline: none;
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #f4f4f4;
            color: #555;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="banner">
        <div class="banner-left"></div> <!-- Added spacer div for centering -->
        <div class="banner-title">Graph Plotting & Curve Fitting</div>
        <div class="banner-buttons">
            <a href="/curve_fitting_manual.html" class="banner-button">Manual</a>
            <a href="/curve_fitting_math.html" class="banner-button">Math</a>
        </div>
    </div>

    <div class="reminder">
        <p align="center">
            Note: Headings and Title accept LaTeX input.
        </p>
    </div>

    <div class="container">
        <!-- Input section -->
        <div class="input-section">
            <h2>Data Input</h2>

            <div class="table-container">
                <table class="data-table" id="data-table">
                    <thead>
                        <tr>
                            <th>
                                <input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
                                <div id="x-column-latex" class="latex-display">\( x \)</div>
                            </th>
                            <th>
                                <input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
                                <div id="y-column-latex" class="latex-display">\( y \)</div>
                            </th>
                            <th class="error-column" id="x-error-header" style="display: none;">
                                <div id="x-error-header-latex" class="latex-display">\( \pm \Delta x \)</div>
                            </th>
                            <th class="error-column" id="y-error-header" style="display: none;">
                                <div id="y-error-header-latex" class="latex-display">\( \pm \Delta y \)</div>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rows initialized in JS -->
                    </tbody>
                </table>
            </div>

            <div class="button-container">
                <div class="button-row">
                    <button class="btn-add-row" onclick="addRow()">Add Row</button>
                    <button class="btn-clear-all" onclick="clearRows()">Clear All</button>
                </div>
                <div class="button-row">
                    <button class="btn-import-csv" onclick="document.getElementById('csv-file-input').click()">Import .csv</button>
                    <button class="btn-export-csv" onclick="exportCSV()">Export .csv</button>
                    <button class="btn-export-md" onclick="exportPlainText()">Export .md</button>
                </div>
            </div>
            <input type="file" id="csv-file-input" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />

            <div class="global-uncertainty">
                <h2>Uncertainties</h2>

                <div class="uncertainty-controls">
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
                            Δx
                        </label>
                        <select id="x-error-type" onchange="updateErrorType('x')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                    <div>
                        <label>
                            <input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
                            Δy
                        </label>
                        <select id="y-error-type" onchange="updateErrorType('y')">
                            <option value="absolute">absolute</option>
                            <option value="percentage">%</option>
                        </select>
                    </div>
                </div>

                <h3>Apply Global Uncertainty</h3>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
                    <button onclick="applyGlobalUncertainties('x')">Apply Δx</button>
                </div>
                <div class="global-uncertainty-item">
                    <input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
                    <button onclick="applyGlobalUncertainties('y')">Apply Δy</button>
                </div>
            </div>

            <div class="fit-method-section">
                <h2>Curve Fitting</h2>
                <div class="tabs">
                    <button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
                    <button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
                </div>

                <div id="BasicFit" class="tab-content active">
                    <label for="fit-method">Fit Method:</label>
                    <select id="fit-method" onchange="updateBasicFitEquation()">
                        <option value="Linear">Linear</option>
                        <option value="Polynomial-2">Polynomial (2nd Degree)</option>
                        <option value="Polynomial-3">Polynomial (3rd Degree)</option>
                        <option value="Polynomial-4">Polynomial (4th Degree)</option>
                    </select>
                    <div id="basic-fit-equation" class="general-equation">
                        \( y = mx + c \)
                    </div>
                    <button class="fit-button" onclick="fitCurve()">Fit Curve</button>
                </div>

                <div id="AdvancedFit" class="tab-content">
                    <label for="advanced-fit-method">Advanced Fit Method:</label>
                    <select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
                        <option value="Exponential">Exponential</option>
                        <option value="Power">Power</option>
                        <option value="Sinusoidal">Sinusoidal</option>
                        <option value="Gaussian">Gaussian</option>
                        <option value="Lorentzian">Lorentzian</option>
                    </select>
                    <div id="advanced-fit-general-equation" class="general-equation">
                        \( y = A e^{bx} + c \)
                    </div>
                    <p class="table-prompt">Enter initial fitting parameters below.</p><br>
                    
                    <!-- Exponential Parameters -->
                    <div id="Exponential-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-exponential">A:</label>
                            <input type="number" id="initial-A-exponential" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b-exponential">b:</label>
                            <input type="number" id="initial-b-exponential" value="0.2" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-exponential">c:</label>
                            <input type="number" id="initial-c-exponential" value="0" step="any">
                        </div>
                    </div>

                    <!-- Power Parameters -->
                    <div id="Power-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-power">A:</label>
                            <input type="number" id="initial-A-power" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b-power">b:</label>
                            <input type="number" id="initial-b-power" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-power">c:</label>
                            <input type="number" id="initial-c-power" value="0" step="any">
                        </div>
                    </div>

                    <!-- Sinusoidal Parameters -->
                    <div id="Sinusoidal-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A">A:</label>
                            <input type="number" id="initial-A" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-b">b:</label>
                            <input type="number" id="initial-b" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-k">k:</label>
                            <input type="number" id="initial-k" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-phi">φ:</label>
                            <input type="number" id="initial-phi" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c">c:</label>
                            <input type="number" id="initial-c" value="0" step="any">
                        </div>
                    </div>

                    <!-- Gaussian Parameters -->
                    <div id="Gaussian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-gaussian">A:</label>
                            <input type="number" id="initial-A-gaussian" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-mu">μ:</label>
                            <input type="number" id="initial-mu" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-sigma">σ:</label>
                            <input type="number" id="initial-sigma" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-gaussian">c:</label>
                            <input type="number" id="initial-c-gaussian" value="0" step="any">
                        </div>
                    </div>

                    <!-- Lorentzian Parameters -->
                    <div id="Lorentzian-parameters" class="parameter-section">
                        <div class="advanced-fit-item">
                            <label for="initial-A-lorentzian">A:</label>
                            <input type="number" id="initial-A-lorentzian" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-x0">x₀:</label>
                            <input type="number" id="initial-x0" value="0" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-gamma">γ:</label>
                            <input type="number" id="initial-gamma" value="1" step="any">
                        </div>
                        <div class="advanced-fit-item">
                            <label for="initial-c-lorentzian">c:</label>
                            <input type="number" id="initial-c-lorentzian" value="0" step="any">
                        </div>
                    </div>

                    <div class="advanced-fit-buttons">
                        <button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Graph section -->
        <div class="graph-section">
            <h2>Graph</h2>
            <div class="graph-title-container">
                <label for="graph-title">Title:</label>
                <input type="text" id="graph-title" placeholder="Enter graph title" oninput="debouncedUpdatePlotAndRenderLatex()" value="Title">
            </div>
            <div id="plot"></div>

            <div class="result">
                <h3>Fitting Result</h3>
                <p id="fit-equation" style="display: none;"></p>
                <p id="r-squared-container" style="display: none;"></p>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let isSyncing = false;

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func.apply(this, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);

        function formatLabelForLatex(label) {
            return label ? label.replace(/ /g, '\\space ') : '';
        }

        function processLabel(label) {
            return label ? `$${formatLabelForLatex(label)}$` : '';
        }

        function initializeTable(initialRows = 7) {
            const tableBody = document.querySelector('#data-table tbody');
            for (let i = 0; i < initialRows; i++) {
                const newRow = tableBody.insertRow();
                newRow.innerHTML = `
                    <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                    <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                    <td class="error-column" style="display: none;"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                    <td class="error-column" style="display: none;"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                `;
            }
            updateData();
        }

        function addRow() {
            const tableBody = document.querySelector('#data-table tbody');
            const newRow = tableBody.insertRow();
            newRow.innerHTML = `
                <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
            `;
            updateData();
        }

        function clearRows(resetHeaders = true) {
            const tableBody = document.querySelector('#data-table tbody');
            tableBody.innerHTML = '';

            if (resetHeaders) {
                isSyncing = true;
                document.getElementById('x-column-name').value = 'x';
                document.getElementById('y-column-name').value = 'y';
                renderLatex('#x-column-latex', 'x');
                renderLatex('#y-column-latex', 'y');
                document.getElementById('graph-title').value = 'Title';
                isSyncing = false;
            }

            initializeTable();
            toggleErrorColumn('x');
            toggleErrorColumn('y');
        }

        function navigateTable(event) {
            const key = event.key;
            const currentInput = event.target;

            const currentCell = currentInput.parentElement;
            const currentRow = currentCell.parentElement;
            const table = currentRow.parentElement.parentElement;
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const rowIndex = rows.indexOf(currentRow);
            const cells = Array.from(currentRow.children);
            const colIndex = cells.indexOf(currentCell);

            let targetRow = rowIndex;
            let targetCol = colIndex;

            switch (key) {
                case 'Enter':
                    event.preventDefault();
                    targetRow = rowIndex + 1;
                    targetCol = colIndex;
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    targetCol = colIndex + 1;
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    targetCol = colIndex - 1;
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    targetRow = rowIndex + 1;
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    targetRow = rowIndex - 1;
                    break;
                default:
                    return;
            }

            if (targetRow < 0) targetRow = 0;
            if (targetRow >= rows.length) targetRow = rows.length - 1;
            if (targetCol < 0) targetCol = 0;
            if (targetCol >= cells.length) targetCol = cells.length - 1;

            const targetCell = rows[targetRow].children[targetCol];
            const targetInput = targetCell.querySelector('input');

            if (targetInput && targetInput.offsetParent !== null) {
                targetInput.focus();
            }
        }

        function toggleErrorColumn(axis) {
            const errorHeader = document.getElementById(`${axis}-error-header`);
            const checkBox = document.getElementById(`toggle-${axis}-error`);
            const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

            if (checkBox.checked) {
                errorHeader.style.display = 'table-cell';
                updateUncertaintyHeaders(axis);
                errorInputs.forEach((input) => {
                    const errorCell = input.parentElement;
                    if (errorCell) {
                        errorCell.style.display = 'table-cell';
                    }
                });
            } else {
                errorHeader.style.display = 'none';
                errorInputs.forEach((input) => {
                    const errorCell = input.parentElement;
                    if (errorCell) {
                        errorCell.style.display = 'none';
                        input.value = '';
                    }
                });
            }

            updateData();
        }

        function updateUncertaintyHeaders(axis) {
            const columnName = document.getElementById(`${axis}-column-name`).value.trim() || (axis === 'x' ? 'x' : 'y');
            const errorType = document.getElementById(`${axis}-error-type`).value;
            let headerLatex = `\\pm \\Delta ${formatLabelForLatex(columnName)}`;
            let headerFull = `\\( ${headerLatex} \\)`;
            if (errorType === 'percentage') {
                headerFull += ' (%)';
            }

            const headerElement = document.getElementById(`${axis}-error-header-latex`);
            if (headerElement) {
                headerElement.innerHTML = headerFull;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
            }
        }

        function updateErrorType(axis) {
            if (document.getElementById(`toggle-${axis}-error`).checked) {
                updateUncertaintyHeaders(axis);
            }

            updateData();
        }

        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.onerror = function() {
                alert('Error reading the file!');
            };
            reader.readAsText(file);
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                alert('CSV file must contain at least two rows (headers and one data row).');
                return;
            }

            const headers = parseCSVLine(lines[0]);
            if (headers.length < 2) {
                alert('CSV file must have at least two columns.');
                return;
            }

            const hasXError = headers.length >= 3;
            const hasYError = headers.length >= 4;

            isSyncing = true;
            document.getElementById('x-column-name').value = headers[0];
            document.getElementById('y-column-name').value = headers[1];
            renderLatex('#x-column-latex', formatLabelForLatex(headers[0]));
            renderLatex('#y-column-latex', formatLabelForLatex(headers[1]));
            document.getElementById('graph-title').value = 'Title';
            isSyncing = false;

            clearRows(false);

            if (hasXError) {
                document.getElementById('toggle-x-error').checked = true;
                toggleErrorColumn('x');
            }
            if (hasYError) {
                document.getElementById('toggle-y-error').checked = true;
                toggleErrorColumn('y');
            }

            const dataRows = lines.slice(1);
            const tableBody = document.querySelector('#data-table tbody');

            for (let i = 0; i < dataRows.length; i++) {
                if (i >= tableBody.rows.length) {
                    addRow();
                }
                const rowData = parseCSVLine(dataRows[i]);
                const row = tableBody.rows[i];

                const xInput = row.querySelector('.x-input');
                const yInput = row.querySelector('.y-input');
                if (xInput) xInput.value = rowData[0] || '';
                if (yInput) yInput.value = rowData[1] || '';

                if (hasXError && rowData.length >= 3) {
                    const xErrorInput = row.querySelector('.x-error-input');
                    if (xErrorInput) xErrorInput.value = rowData[2] || '';
                }

                if (hasYError && rowData.length >= 4) {
                    const yErrorInput = row.querySelector('.y-error-input');
                    if (yErrorInput) yErrorInput.value = rowData[3] || '';
                }
            }

            const totalRows = tableBody.rows.length;
            if (dataRows.length < totalRows) {
                for (let i = dataRows.length; i < totalRows; i++) {
                    const row = tableBody.rows[i];
                    if (row.querySelector('.x-input')) row.querySelector('.x-input').value = '';
                    if (row.querySelector('.y-input')) row.querySelector('.y-input').value = '';
                    if (hasXError && row.querySelector('.x-error-input')) row.querySelector('.x-error-input').value = '';
                    if (hasYError && row.querySelector('.y-error-input')) row.querySelector('.y-error-input').value = '';
                }
            }

            updateData();
            updatePlotAndRenderLatex();
        }

        function updateLabels(type) {
            if (isSyncing) return;
            isSyncing = true;
            const value = document.getElementById(`${type}-column-name`).value;
            renderLatex(`#${type}-column-latex`, formatLabelForLatex(value));

            if (document.getElementById(`toggle-${type}-error`).checked) {
                updateUncertaintyHeaders(type);
            }

            debouncedUpdatePlotAndRenderLatex();
            isSyncing = false;
        }

        function renderLatex(elementId, latexString) {
            const element = document.querySelector(elementId);
            if (!element) return; // Safeguard
            element.innerHTML = `\\(${latexString}\\)`;
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        }

        function updatePlotAndRenderLatex() {
            if (isSyncing) return;
            isSyncing = true;

            plotGraph();
            const xColumnName = document.getElementById('x-column-name').value || 'x';
            renderLatex('#x-column-latex', formatLabelForLatex(xColumnName));

            const yColumnName = document.getElementById('y-column-name').value || 'y';
            renderLatex('#y-column-latex', formatLabelForLatex(yColumnName));

            isSyncing = false;
        }

        function openTab(evt, tabName) {
            const tablinks = document.getElementsByClassName("tablink");
            const tabContents = document.getElementsByClassName("tab-content");

            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }

            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove("active");
            }

            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");

            if (tabName === 'BasicFit') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
            } else if (tabName === 'AdvancedFit') {
                // Trigger changeAdvancedFitMethod to display parameter boxes
                changeAdvancedFitMethod();
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
            }
        }

        function plotGraph(fittedX = null, fittedY = null) {
            const x = rawData.map(point => point.x);
            const y = rawData.map(point => point.y);
            const xErrorRaw = rawData.map(point => point.xErrorRaw || 0);
            const yErrorRaw = rawData.map(point => point.yErrorRaw || 0);
            const xErrorType = document.getElementById('toggle-x-error').checked ? document.getElementById('x-error-type').value : 'absolute';
            const yErrorType = document.getElementById('toggle-y-error').checked ? document.getElementById('y-error-type').value : 'absolute';

            const convertedXError = xErrorType === 'percentage' ? x.map((xi, idx) => (xErrorRaw[idx] / 100) * (xi || 0)) : xErrorRaw;
            const convertedYError = yErrorType === 'percentage' ? y.map((yi, idx) => (yErrorRaw[idx] / 100) * (yi || 0)) : yErrorRaw;

            const traces = [
                {
                    x: x,
                    y: y,
                    mode: 'markers',
                    name: 'Input Data',
                    marker: { color: 'red' },
                    error_x: {
                        type: 'data',
                        array: convertedXError,
                        visible: document.getElementById('toggle-x-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    },
                    error_y: {
                        type: 'data',
                        array: convertedYError,
                        visible: document.getElementById('toggle-y-error').checked,
                        color: 'teal',
                        thickness: 1.5,
                        width: 2
                    }
                }
            ];

            if (fittedX && fittedY) {
                traces.push({
                    x: fittedX,
                    y: fittedY,
                    mode: 'lines',
                    name: 'Fit',
                    line: { color: '#4595dd' }
                });
            }

            const layout = {
                title: processLabel(document.getElementById('graph-title').value || 'Title'),
                xaxis: { title: processLabel(document.getElementById('x-column-name').value || 'x') },
                yaxis: { title: processLabel(document.getElementById('y-column-name').value || 'y') }
            };

            Plotly.react('plot', traces, layout, {
                toImageButtonOptions: {
                    format: 'svg', // Choose your desired format
                    filename: 'data_plot',
                    scale: 1 // Adjust scale for higher resolution
                }
            });
        }

        function fitCurve() {
            if (rawData.length < 2) {
                alert('Please enter at least two data points.');
                return;
            }

            const x = rawData.map(point => point.x);
            const y = rawData.map(point => point.y);
            const fitMethod = document.getElementById('fit-method').value;

            if (fitMethod === 'Linear') {
                performLinearFit(x, y);
            } else if (fitMethod.startsWith('Polynomial')) {
                const degree = parseInt(fitMethod.split('-')[1]);
                performPolynomialFit(x, y, degree);
            }
            // Exponential and Power are handled in Advanced Fit
        }

        function updateBasicFitEquation() {
            const fitMethod = document.getElementById('fit-method').value;
            let equation = '';

            if (fitMethod === 'Linear') {
                equation = 'y = mx + c';
            } else if (fitMethod.startsWith('Polynomial')) {
                const degree = parseInt(fitMethod.split('-')[1]);
                let terms = [];
                for (let i = degree; i >= 0; i--) {
                    terms.push(`a_${i}x^{${i}}`);
                }
                equation = 'y = ' + terms.join(' + ');
            }

            const equationElement = document.getElementById('basic-fit-equation');
            if (equationElement) {
                equationElement.innerHTML = `\\( ${equation} \\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
            }
        }

        function changeAdvancedFitMethod() {
            const selectedMethod = document.getElementById('advanced-fit-method').value;
            const methods = ['Exponential', 'Power', 'Sinusoidal', 'Gaussian', 'Lorentzian'];

            methods.forEach(method => {
                const section = document.getElementById(`${method}-parameters`);
                if (method === selectedMethod) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });

            updateAdvancedFitEquation(selectedMethod);
            setInitialParameters(selectedMethod);
        }

        function updateAdvancedFitEquation(selectedMethod) {
            let equation = '';
            if (selectedMethod === 'Sinusoidal') {
                equation = 'y = A e^{bx} \\sin(kx - \\phi) + c';
            } else if (selectedMethod === 'Gaussian') {
                equation = 'y = A e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}} + c';
            } else if (selectedMethod === 'Lorentzian') {
                equation = 'y = A \\frac{\\gamma^2}{(x - x_0)^2 + \\gamma^2} + c';
            } else if (selectedMethod === 'Exponential') {
                equation = 'y = A e^{bx} + c';
            } else if (selectedMethod === 'Power') {
                equation = 'y = A x^{b} + c';
            }

            const equationElement = document.getElementById('advanced-fit-general-equation');
            if (equationElement) {
                equationElement.innerHTML = `\\(${equation}\\)`;
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
            }
        }

        // Helper function to calculate FWHM for Lorentzian Fit
        function calculateFWHM(x, y, maxY) {
            const halfMax = maxY / 2;
            let left = null, right = null;

            // Sort data by x
            const sortedData = rawData.slice().sort((a, b) => a.x - b.x);

            // Find left crossing
            for (let i = 1; i < sortedData.length; i++) {
                if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                    // Linear interpolation
                    const x1 = sortedData[i - 1].x;
                    const y1 = sortedData[i - 1].y;
                    const x2 = sortedData[i].x;
                    const y2 = sortedData[i].y;
                    left = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                    break;
                }
            }

            // Find right crossing
            for (let i = sortedData.length - 1; i > 0; i--) {
                if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
                    // Linear interpolation
                    const x1 = sortedData[i - 1].x;
                    const y1 = sortedData[i - 1].y;
                    const x2 = sortedData[i].x;
                    const y2 = sortedData[i].y;
                    right = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
                    break;
                }
            }

            if (left !== null && right !== null && right > left) {
                return right - left;
            } else {
                // Fallback to range x /4
                const minX = Math.min(...x);
                const maxX = Math.max(...x);
                return (maxX - minX) / 4;
            }
        }

        // Function to set initial parameters based on selected method and data
        function setInitialParameters(method) {
            if (rawData.length === 0) return;

            const x = rawData.map(p => p.x);
            const y = rawData.map(p => p.y);
            const meanX = x.reduce((sum, val) => sum + val, 0) / x.length;
            const stdX = Math.sqrt(x.reduce((sum, val) => sum + Math.pow(val - meanX, 2), 0) / x.length);
            const maxY = Math.max(...y);
            const rangeX = Math.max(...x) - Math.min(...x);
            const FWHM = calculateFWHM(x, y, maxY);

            if (method === 'Gaussian') {
                document.getElementById('initial-A-gaussian').value = maxY.toFixed(2);
                document.getElementById('initial-mu').value = meanX.toFixed(2);
                document.getElementById('initial-sigma').value = stdX.toFixed(2);
                document.getElementById('initial-c-gaussian').value = '0';
            } else if (method === 'Lorentzian') {
                document.getElementById('initial-A-lorentzian').value = maxY.toFixed(2);
                document.getElementById('initial-x0').value = meanX.toFixed(2);
                document.getElementById('initial-gamma').value = FWHM.toFixed(2);
                document.getElementById('initial-c-lorentzian').value = '0';
            }
        }

        function computeLinearFit(x, y) {
            try {
                const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
                const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

                let numerator = 0, denominator = 0;
                for (let i = 0; i < x.length; i++) {
                    numerator += (x[i] - xMean) * (y[i] - yMean);
                    denominator += (x[i] - xMean) ** 2;
                }

                const slope = numerator / denominator;
                const intercept = yMean - slope * xMean;

                return { slope, intercept };
            } catch (error) {
                console.error('Error computing linear fit:', error);
                throw error;
            }
        }

        function updateResults(equation, x, y, fitFunction) {
            try {
                const yPredicted = x.map(point => fitFunction(point));
                const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

                let ssTotal = 0, ssResidual = 0;
                for (let i = 0; i < y.length; i++) {
                    ssTotal += (y[i] - meanY) ** 2;
                    ssResidual += (y[i] - yPredicted[i]) ** 2;
                }

                const rSquared = 1 - ssResidual / ssTotal;

                const fitEquationElement = document.getElementById('fit-equation');
                if (fitEquationElement) {
                    fitEquationElement.innerHTML = `\\(${equation}\\)`;
                    fitEquationElement.style.display = 'block';
                }

                const rSquaredContainer = document.getElementById('r-squared-container');
                if (rSquaredContainer) {
                    rSquaredContainer.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
                    rSquaredContainer.style.display = 'block';
                }

                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    fitEquationElement
                ]);
                MathJax.Hub.Queue([
                    "Typeset",
                    MathJax.Hub,
                    rSquaredContainer
                ]);
            } catch (error) {
                console.error('Error updating results:', error);
            }
        }

        function polyfit(x, y, degree) {
            try {
                const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
                const Xt = math.transpose(X);
                const XtX = math.multiply(Xt, X);
                const XtY = math.multiply(Xt, y);
                const coefficients = math.lusolve(XtX, XtY).flat();
                return coefficients;
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                throw error;
            }
        }

        function polyEval(coefficients, x) {
            try {
                return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
            } catch (error) {
                console.error('Error evaluating polynomial:', error);
                throw error;
            }
        }

        function updateData() {
            try {
                const xInputs = document.querySelectorAll('.x-input');
                const yInputs = document.querySelectorAll('.y-input');
                const xErrorInputs = document.querySelectorAll('.x-error-input');
                const yErrorInputs = document.querySelectorAll('.y-error-input');

                rawData = [];
                for (let i = 0; i < xInputs.length; i++) {
                    const x = parseFloat(xInputs[i].value);
                    const y = parseFloat(yInputs[i].value);
                    const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
                    const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

                    if (!isNaN(x) && !isNaN(y)) {
                        rawData.push({
                            x: x,
                            y: y,
                            xErrorRaw: xErrorRaw,
                            yErrorRaw: yErrorRaw
                        });
                    }
                }

                plotGraph();
            } catch (error) {
                console.error('Error updating data:', error);
            }
        }

        window.onload = function() {
            initializeTable();
            ['x-column-name', 'y-column-name'].forEach(id => {
                const value = document.getElementById(id).value;
                renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
            });

            updateBasicFitEquation();
            const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
            changeAdvancedFitMethod();
        };

        // Helper function to count decimal places in absolute uncertainty
        function countDecimalPlaces(numStr) {
            if (!numStr.includes('.')) return 0;
            return numStr.length - numStr.indexOf('.') - 1;
        }

        // Convert to significant figures
        // Updated toSigFigs function to preserve trailing zeros
        function toSigFigs(num, sigFigs) {
            return num.toPrecision(sigFigs);
        }

        function formatDataForExport(valueStr, errorStr, errorEnabled, errorType, val, rowVal, rowErr) {
            if (!errorEnabled) {
                // No uncertainty toggled for this axis => return raw input
                return valueStr;
            }

            // If uncertainty is toggled but no valid uncertainty provided
            if (isNaN(rowErr)) return valueStr;

            if (errorType === 'absolute') {
                // Absolute uncertainty: match decimal places to uncertainty's decimal places
                const dp = countDecimalPlaces(errorStr);
                return val.toFixed(dp);
            } else if (errorType === 'percentage') {
                // Percentage uncertainty
                const perc = parseFloat(errorStr);
                if (isNaN(perc) || rowVal === 0) {
                    // If can't parse percentage or val=0, fallback to raw input
                    return valueStr;
                }

                // If percentage ≤ 10%, 3 s.f. else 2 s.f.
                const sigFigs = (perc <= 10) ? 3 : 2;
                const sfVal = toSigFigs(val, sigFigs);
                return sfVal; // Return as string to preserve trailing zeros
            } else {
                // Fallback to raw input
                return valueStr;
            }
        }

        function exportPlainText() {
            try {
                // Retrieve column headers
                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';

                const xErrorEnabled = document.getElementById('toggle-x-error').checked;
                const yErrorEnabled = document.getElementById('toggle-y-error').checked;

                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tr');

                // Build headers with LaTeX formatting
                let headers = [`$${xHeader}$`, `$${yHeader}$`];
                if (xErrorEnabled) {
                    const xErrorType = document.getElementById('x-error-type').value;
                    let xUncHeading = `$\\pm \\Delta ${formatLabelForLatex(xHeader)}$`;
                    if (xErrorType === 'percentage') xUncHeading += ' (%)';
                    headers.push(xUncHeading);
                }
                if (yErrorEnabled) {
                    const yErrorType = document.getElementById('y-error-type').value;
                    let yUncHeading = `$\\pm \\Delta ${formatLabelForLatex(yHeader)}$`;
                    if (yErrorType === 'percentage') yUncHeading += ' (%)';
                    headers.push(yUncHeading);
                }

                // Start building markdown with headers
                let markdown = `| ${headers.join(' | ')} |\n`;
                // Use ':---:' for center alignment
                markdown += `|${headers.map(() => ':---:').join('|')}|\n`;

                // Iterate through data rows
                for (let i = 1; i < rows.length; i++) { // Start from 1 to skip header row
                    const row = rows[i];
                    if (!row) continue; // Safeguard

                    const xInputElem = row.querySelector('.x-input');
                    const yInputElem = row.querySelector('.y-input');

                    if (!xInputElem || !yInputElem) continue; // Safeguard

                    const xValStr = xInputElem.value.trim();
                    const yValStr = yInputElem.value.trim();

                    if (xValStr === '' && yValStr === '') continue;

                    let xVal = parseFloat(xValStr);
                    let yVal = parseFloat(yValStr);

                    const xErrInput = row.querySelector('.x-error-input');
                    const yErrInput = row.querySelector('.y-error-input');

                    const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                    const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                    const xErrVal = parseFloat(xErrStr);
                    const yErrVal = parseFloat(yErrStr);

                    const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                    const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                    const xErrorType = document.getElementById('x-error-type').value;
                    const yErrorType = document.getElementById('y-error-type').value;

                    let rowData = [];
                    // Format x according to rules
                    let xFormatted = xValStr;
                    if (!isNaN(xVal)) {
                        xFormatted = formatDataForExport(
                            xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
                        );
                    }

                    // Format y according to rules
                    let yFormatted = yValStr;
                    if (!isNaN(yVal)) {
                        yFormatted = formatDataForExport(
                            yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
                        );
                    }

                    rowData.push(xFormatted);
                    rowData.push(yFormatted);

                    if (xErrorEnabled) {
                        rowData.push(xErrorEnabledThisRow ? xErrStr : '');
                    }

                    if (yErrorEnabled) {
                        rowData.push(yErrorEnabledThisRow ? yErrStr : '');
                    }

                    markdown += `| ${rowData.join(' | ')} |\n`;
                }

                // Create a Blob from the markdown string
                const blob = new Blob([markdown], { type: 'text/plain;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'curve_fitting_data.md');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting plain text:', error);
                alert('An error occurred while exporting the Markdown file. Please check the console for details.');
            }
        }

        function exportCSV() {
            try {
                const table = document.getElementById('data-table');
                const rows = table.querySelectorAll('tr');
                let csvContent = '';

                const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
                const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
                const xErrorEnabled = document.getElementById('toggle-x-error').checked;
                const yErrorEnabled = document.getElementById('toggle-y-error').checked;

                const headers = [xHeader, yHeader];
                if (xErrorEnabled) {
                    const xErrorType = document.getElementById('x-error-type').value;
                    const xErrorHead = xErrorType === 'percentage' ? `delta ${xHeader} (%)` : `delta ${xHeader}`;
                    headers.push(xErrorHead);
                }
                if (yErrorEnabled) {
                    const yErrorType = document.getElementById('y-error-type').value;
                    const yErrorHead = yErrorType === 'percentage' ? `delta ${yHeader} (%)` : `delta ${yHeader}`;
                    headers.push(yErrorHead);
                }

                csvContent += headers.join(',') + '\n';

                const dataRows = table.querySelectorAll('tbody tr');

                for (let i = 0; i < dataRows.length; i++) {
                    const xValStr = dataRows[i].querySelector('.x-input')?.value.trim() || '';
                    const yValStr = dataRows[i].querySelector('.y-input')?.value.trim() || '';
                    if (xValStr === '' && yValStr === '') continue;

                    let xVal = parseFloat(xValStr);
                    let yVal = parseFloat(yValStr);

                    const xErrInput = dataRows[i].querySelector('.x-error-input');
                    const yErrInput = dataRows[i].querySelector('.y-error-input');

                    const xErrStr = xErrInput ? xErrInput.value.trim() : '';
                    const yErrStr = yErrInput ? yErrInput.value.trim() : '';
                    const xErrVal = parseFloat(xErrStr);
                    const yErrVal = parseFloat(yErrStr);

                    const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
                    const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

                    const xErrorType = document.getElementById('x-error-type').value;
                    const yErrorType = document.getElementById('y-error-type').value;

                    let rowData = [];

                    let xFormatted = xValStr;
                    if (!isNaN(xVal)) {
                        xFormatted = formatDataForExport(
                            xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
                        );
                    }

                    let yFormatted = yValStr;
                    if (!isNaN(yVal)) {
                        yFormatted = formatDataForExport(
                            yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
                        );
                    }

                    rowData.push(xFormatted);
                    rowData.push(yFormatted);

                    if (xErrorEnabled) {
                        rowData.push(xErrorEnabledThisRow ? xErrStr : '');
                    }

                    if (yErrorEnabled) {
                        rowData.push(yErrorEnabledThisRow ? yErrStr : '');
                    }

                    csvContent += rowData.join(',') + '\n';
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'curve_fitting_data.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('An error occurred while exporting the CSV. Please check the console for details.');
            }
        }

        function applyGlobalUncertainties(axis) {
            const globalVal = document.getElementById(`global-${axis}-uncertainty`).value.trim();
            const tableBody = document.querySelector('#data-table tbody');
            const rows = tableBody.querySelectorAll('tr');

            rows.forEach((row) => {
                const xInput = row.querySelector('.x-input').value.trim();
                const yInput = row.querySelector('.y-input').value.trim();

                if (xInput !== '' && yInput !== '') {
                    const errorInput = row.querySelector(`.${axis}-error-input`);
                    if (document.getElementById(`toggle-${axis}-error`).checked && errorInput) {
                        errorInput.value = globalVal !== '' ? globalVal : '';
                    }
                }
            });

            updateData();
            document.getElementById(`global-${axis}-uncertainty`).value = '';
        }

        function fitAdvancedCurve() {
            if (rawData.length < 4) { // Increased to 4 for more complex fits
                alert('Please enter at least four data points for advanced fitting.');
                return;
            }

            const fitMethod = document.getElementById('advanced-fit-method').value;

            if (fitMethod === 'Exponential') {
                performExponentialFitAdvanced();
            } else if (fitMethod === 'Power') {
                performPowerFitAdvanced();
            } else if (fitMethod === 'Sinusoidal') {
                performSinusoidalFit();
            } else if (fitMethod === 'Gaussian') {
                performGaussianFit();
            } else if (fitMethod === 'Lorentzian') {
                performLorentzianFit();
            }
        }

        function performLinearFit(x, y) {
            try {
                const { slope, intercept } = computeLinearFit(x, y);

                const xFit = [Math.min(...x), Math.max(...x)];
                const yFit = xFit.map(xi => slope * xi + intercept);

                const fitFunction = xi => slope * xi + intercept;

                let equation = `y = ${slope.toFixed(2)}x`;
                if (intercept >= 0) {
                    equation += ` + ${intercept.toFixed(2)}`;
                } else {
                    equation += ` - ${Math.abs(intercept).toFixed(2)}`;
                }

                updateResults(equation, x, y, fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing linear fit:', error);
                alert('An error occurred during linear fitting. Please check the console for details.');
            }
        }

        function performPolynomialFit(x, y, degree) {
            try {
                const coefficients = polyfit(x, y, degree);
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
                const yFit = xFit.map(xi => polyEval(coefficients, xi));

                const fitFunction = xi => polyEval(coefficients, xi);

                let equation = 'y = ';
                coefficients.forEach((c, i) => {
                    const power = degree - i;
                    if (c === 0) return;

                    const absC = Math.abs(c).toFixed(2);
                    const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

                    let term = '';
                    if (power === 0) {
                        term = `${absC}`;
                    } else if (power === 1) {
                        term = `${absC}x`;
                    } else {
                        term = `${absC}x^{${power}}`;
                    }

                    equation += `${sign}${term}`;
                });

                updateResults(equation, x, y, fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing polynomial fit:', error);
                alert('An error occurred during polynomial fitting. Please check the console for details.');
            }
        }

        function performExponentialFitAdvanced() {
            try {
                // Retrieve initial parameters from Advanced Fit section
                let A = parseFloat(document.getElementById('initial-A-exponential').value);
                let b = parseFloat(document.getElementById('initial-b-exponential').value);
                let c = parseFloat(document.getElementById('initial-c-exponential').value);

                if (isNaN(A) || isNaN(b) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Exponential fit.');
                    return;
                }

                const learningRate = 1e-3;
                const maxIterations = 10000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterations = 0;

                while (iterations < maxIterations) {
                    const predictions = rawData.map(point => A * Math.exp(b * point.x) + c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err ** 2, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) break;

                    previousError = mse;

                    let dA = 0, db = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const expTerm = Math.exp(b * xi);
                        const error = errors[i];

                        dA += -2 * error * expTerm;
                        db += -2 * error * A * xi * expTerm;
                        dc += -2 * error;
                    }

                    // Update parameters
                    A -= learningRate * dA;
                    b -= learningRate * db;
                    c -= learningRate * dc;

                    iterations++;
                }

                if (iterations === maxIterations) {
                    alert("Exponential fitting did not converge. Try different initial guesses.");
                    return;
                }

                // Generate fitted curve
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => A * Math.exp(b * xi) + c);

                const fitFunction = xi => A * Math.exp(b * xi) + c;

                // Equation string
                let equation = `y = ${A.toFixed(2)} e^{${b.toFixed(2)}x}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing exponential fit:', error);
                alert('An error occurred during exponential fitting. Please check the console for details.');
            }
        }

        function performPowerFitAdvanced() {
            try {
                // Retrieve initial parameters from Advanced Fit section
                let A = parseFloat(document.getElementById('initial-A-power').value);
                let b = parseFloat(document.getElementById('initial-b-power').value);
                let c = parseFloat(document.getElementById('initial-c-power').value);

                if (isNaN(A) || isNaN(b) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Power fit.');
                    return;
                }

                const learningRate = 1e-3;
                const maxIterations = 10000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterations = 0;

                while (iterations < maxIterations) {
                    const predictions = rawData.map(point => A * Math.pow(point.x, b) + c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err ** 2, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) break;

                    previousError = mse;

                    let dA = 0, db = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        if (xi === 0 && b <= 0) continue; // Avoid division by zero or log(0)
                        const powerTerm = Math.pow(xi, b);
                        const error = errors[i];

                        dA += -2 * error * powerTerm;
                        db += -2 * error * A * Math.log(xi) * powerTerm;
                        dc += -2 * error;
                    }

                // Update parameters
                    A -= learningRate * dA;
                    b -= learningRate * db;
                    c -= learningRate * dc;

                    iterations++;
                }

                if (iterations === maxIterations) {
                    alert("Power fitting did not converge. Try different initial guesses.");
                    return;
                }

                // Generate fitted curve
                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => A * Math.pow(xi, b) + c);

                const fitFunction = xi => A * Math.pow(xi, b) + c;

                // Equation string
                let equation = `y = ${A.toFixed(2)}x^{${b.toFixed(2)}}`;
                if (c > 0) {
                    equation += ` + ${c.toFixed(2)}`;
                } else if (c < 0) {
                    equation += ` - ${Math.abs(c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing power fit:', error);
                alert('An error occurred during power fitting. Please check the console for details.');
            }
        }

        function performSinusoidalFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A').value);
                let b = parseFloat(document.getElementById('initial-b').value);
                let k = parseFloat(document.getElementById('initial-k').value);
                let phi = parseFloat(document.getElementById('initial-phi').value);
                let c = parseFloat(document.getElementById('initial-c').value);

                if (isNaN(A) || isNaN(b) || isNaN(k) || isNaN(phi) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Sinusoidal fit.');
                    return;
                }

                const params = { A: A, b: b, k: k, phi: phi, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterationsCount = 0;

                while (iterationsCount < maxIterations) {
                    const predictions = rawData.map(point => params.A * Math.exp(params.b * point.x) * Math.sin(params.k * point.x - params.phi) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err * err, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, db = 0, dk = 0, dphi = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const sinTerm = Math.sin(params.k * xi - params.phi);
                        const cosTerm = Math.cos(params.k * xi - params.phi);
                        const expTerm = Math.exp(params.b * xi);

                        const prediction = params.A * expTerm * sinTerm + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * expTerm * sinTerm;
                        db += -2 * error * params.A * xi * expTerm * sinTerm;
                        dk += -2 * error * params.A * expTerm * xi * cosTerm;
                        dphi += 2 * error * params.A * expTerm * cosTerm;
                        dc += -2 * error;
                    }

                // Update parameters
                    params.A -= learningRate * dA;
                    params.b -= learningRate * db;
                    params.k -= learningRate * dk;
                    params.phi -= learningRate * dphi;
                    params.c -= learningRate * dc;

                    iterationsCount++;
                }

                if (iterationsCount === maxIterations) {
                    alert('Sinusoidal fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c);

                const fitFunction = xi => params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c;

                let equation = `y = ${params.A.toFixed(2)} e^{${params.b.toFixed(2)}x}\\sin(${params.k.toFixed(2)}x`;
                if (params.phi > 0) {
                    equation += ` - ${params.phi.toFixed(2)}`;
                } else if (params.phi < 0) {
                    equation += ` + ${Math.abs(params.phi).toFixed(2)}`;
                }
                equation += `)`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing sinusoidal fit:', error);
                alert('An error occurred during sinusoidal fitting. Please check the console for details.');
            }
        }

        function performGaussianFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A-gaussian').value);
                let mu = parseFloat(document.getElementById('initial-mu').value);
                let sigma = parseFloat(document.getElementById('initial-sigma').value);
                let c = parseFloat(document.getElementById('initial-c-gaussian').value);

                if (isNaN(A) || isNaN(mu) || isNaN(sigma) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Gaussian fit.');
                    return;
                }

                const params = { A: A, mu: mu, sigma: sigma, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterationsCount = 0;

                while (iterationsCount < maxIterations) {
                    const predictions = rawData.map(point => params.A * Math.exp(-((point.x - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err ** 2, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, dmu = 0, dsigma = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const expTerm = Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2));

                        const prediction = params.A * expTerm + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * expTerm;
                        dmu += -2 * error * params.A * expTerm * ((xi - params.mu) / (params.sigma ** 2));
                        dsigma += -2 * error * params.A * expTerm * ((xi - params.mu) ** 2) / (params.sigma ** 3);
                        dc += -2 * error;
                    }

                // Update parameters
                    params.A -= learningRate * dA;
                    params.mu -= learningRate * dmu;
                    params.sigma -= learningRate * dsigma;
                    params.c -= learningRate * dc;

                    iterationsCount++;
                }

                if (iterationsCount === maxIterations) {
                    alert('Gaussian fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c);

                const fitFunction = xi => params.A * Math.exp(-((xi - params.mu) ** 2) / (2 * params.sigma ** 2)) + params.c;

                let equation = `y = ${params.A.toFixed(2)} e^{-\\frac{(x - ${params.mu.toFixed(2)})^2}{2 (${params.sigma.toFixed(2)})^2}}`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing Gaussian fit:', error);
                alert('An error occurred during Gaussian fitting. Please check the console for details.');
            }
        }

        function performLorentzianFit() {
            try {
                let A = parseFloat(document.getElementById('initial-A-lorentzian').value);
                let x0 = parseFloat(document.getElementById('initial-x0').value);
                let gamma = parseFloat(document.getElementById('initial-gamma').value);
                let c = parseFloat(document.getElementById('initial-c-lorentzian').value);

                if (isNaN(A) || isNaN(x0) || isNaN(gamma) || isNaN(c)) {
                    alert('Please provide valid initial parameters for Lorentzian fit.');
                    return;
                }

                const params = { A: A, x0: x0, gamma: gamma, c: c };
                const learningRate = 1e-5;
                const maxIterations = 100000;
                const tolerance = 1e-6;

                let previousError = Infinity;
                let iterationsCount = 0;

                while (iterationsCount < maxIterations) {
                    const predictions = rawData.map(point => params.A * (params.gamma ** 2) / ((point.x - params.x0) ** 2 + params.gamma ** 2) + params.c);
                    const errors = rawData.map((point, idx) => point.y - predictions[idx]);
                    const mse = errors.reduce((sum, err) => sum + err ** 2, 0) / errors.length;

                    if (Math.abs(previousError - mse) < tolerance) {
                        break;
                    }

                    previousError = mse;

                    let dA = 0, dx0 = 0, dgamma = 0, dc = 0;
                    for (let i = 0; i < rawData.length; i++) {
                        const xi = rawData[i].x;
                        const yi = rawData[i].y;
                        const denominator = ((xi - params.x0) ** 2 + params.gamma ** 2);
                        const lorentzian = (params.gamma ** 2) / denominator;

                        const prediction = params.A * lorentzian + params.c;
                        const error = yi - prediction;

                        dA += -2 * error * lorentzian;
                        dx0 += -2 * error * params.A * (-2 * (xi - params.x0) * params.gamma ** 2) / (denominator ** 2);
                        dgamma += -2 * error * params.A * (2 * params.gamma * denominator - 2 * (xi - params.x0) ** 2 * params.gamma) / (denominator ** 2);
                        dc += -2 * error;
                    }

                // Update parameters
                    params.A -= learningRate * dA;
                    params.x0 -= learningRate * dx0;
                    params.gamma -= learningRate * dgamma;
                    params.c -= learningRate * dc;

                    iterationsCount++;
                }

                if (iterationsCount === maxIterations) {
                    alert('Lorentzian fitting did not converge. Please try different initial parameters.');
                    return;
                }

                const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...rawData.map(p => p.x)) + i * (Math.max(...rawData.map(p => p.x)) - Math.min(...rawData.map(p => p.x))) / 99);
                const yFit = xFit.map(xi => params.A * (params.gamma ** 2) / ((xi - params.x0) ** 2 + params.gamma ** 2) + params.c);

                const fitFunction = xi => params.A * (params.gamma ** 2) / ((xi - params.x0) ** 2 + params.gamma ** 2) + params.c;

                let equation = `y = ${params.A.toFixed(2)} \\frac{(${params.gamma.toFixed(2)})^2}{(x - ${params.x0.toFixed(2)})^2 + (${params.gamma.toFixed(2)})^2}`;
                if (params.c > 0) {
                    equation += ` + ${params.c.toFixed(2)}`;
                } else if (params.c < 0) {
                    equation += ` - ${Math.abs(params.c).toFixed(2)}`;
                }

                updateResults(equation, rawData.map(p => p.x), rawData.map(p => p.y), fitFunction);
                plotGraph(xFit, yFit);
            } catch (error) {
                console.error('Error performing Lorentzian fit:', error);
                alert('An error occurred during Lorentzian fitting. Please check the console for details.');
            }
        }
    </script>
</body>

    <footer>
        &copy; 2024 PanPhy. All rights reserved.
    </footer>

</html>
