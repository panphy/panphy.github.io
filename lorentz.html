<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Lorentz Transformation – Interactive Minkowski Diagram</title>
    <style>
        /* 
      Theme Variables:
      Change these values to quickly adjust the color scheme.
    */
        :root {
            /* Page Background and Text */
            --bg-color: #ffffff;
            /* Page background color */
            --primary-text-color: #333333;
            /* Main text color */

            /* Accent Colors */
            --accent-blue: #1E90FF;
            /* Used for moving frame axes and buttons */
            --accent-orange: #FFA500;
            /* (Optional) alternate accent color */
            --accent-green: #008000;
            /* (Optional) alternate accent color */

            /* Canvas and Grid */
            --canvas-border: #cccccc;
            /* Border color for the canvas */
            --grid-color: #dddddd;
            /* Grid line color in the rest frame */
            --moving-grid-color: #800080;
            /* Grid line color in the moving frame */

            /* Axes Colors */
            --rest-axis-color: #333333;
            /* Rest frame axes (dark gray) */
            --moving-axis-color: var(--accent-blue);
            /* Moving frame axes (accent blue) */
            --light-cone-color: #00aaff;
            /* Light cone color (blue) */

            /* Particle Colors */
            --particle-rest-color: #006400;
            /* Rest frame particle (dark green) */
            --particle-moving-color: #c00;
            /* Moving frame particle (red) */

            /* Button and Control Colors */
            --control-bg-color: #f5f5f5;
            /* Background for control container */
            --control-border-color: #cccccc;
            /* Border color for control container elements */
        }

        /* Remove default body margin */
        body {
            margin: 0;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
        }

        /* Header styling using CSS grid */
        header {
            background-color: #333333;
            /* dark grey */
            padding: 5px;
        }

        .header-container {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
        }

        /* Logo in the left column */
        .header-container .logo img {
            height: 30px;
            /* Adjust logo height as needed */
        }

        /* Title in the center column */
        .header-container .title h1 {
            margin: 0;
            text-align: center;
            color: #ffffff;
            font-size: 22px;
            /* Adjust font size as needed */
        }

        /* Empty right column for spacing */
        .header-container .spacer {
            display: block;
            /* Ensures the spacer takes up space */
        }

        /* Wrapper for the main content */
        #contentWrapper {
            padding: 20px;
        }

        /* Main container using CSS grid with fixed widths for a compact layout */
        #mainContainer {
            display: grid;
            grid-template-columns: 800px 250px;
            /* Diagram width 800px, controls 250px */
            grid-gap: 15px;
            /* Gap between containers set to 15px */
            justify-content: center;
        }

        /* Diagram container on the left */
        #diagramContainer {
            width: 800px;
        }

        /* Canvas styling */
        #minkowskiCanvas {
            border: 1px solid var(--canvas-border);
            background-color: var(--bg-color);
            display: block;
            cursor: pointer;
        }

        /* Controls container on the right */
        #controlsContainer {
            width: 250px;
            background-color: var(--control-bg-color);
            border: 1px solid var(--control-border-color);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .controlItem {
            margin-bottom: 10px;
        }

        .controlLabel {
            margin-right: 5px;
        }

        /* Uniform button width */
        button {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--control-border-color);
            border-radius: 3px;
            background-color: var(--accent-blue);
            color: #fff;
            cursor: pointer;
        }

        button:hover {
            background-color: #187bcd;
        }

        /* Particle coordinates moved to the controls container */
        #coordinates {
            margin-top: 10px;
            font-size: 14px;
            overflow-y: auto;
            max-height: 200px;
            border-top: 1px solid var(--control-border-color);
            padding-top: 10px;
        }

        /* Custom context menu styling */
        #contextMenu {
            position: absolute;
            background: var(--bg-color);
            border: 1px solid var(--control-border-color);
            padding: 5px 10px;
            display: none;
            z-index: 1000;
            cursor: pointer;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }

        #contextMenu:hover {
            background: #eeeeee;
        }
    </style>
</head>

<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="https://panphy.github.io/">
                    <img src="/panphy.png" alt="PanPhy Logo">
                </a>
            </div>
            <div class="title">
                <h1>Lorentz Transformation – Interactive Minkowski Diagram</h1>
            </div>
            <div class="spacer"></div>
        </div>
    </header>
    <div id="contentWrapper">
        <div id="mainContainer">
            <!-- Diagram container (left): holds the canvas only -->
            <div id="diagramContainer">
                <canvas id="minkowskiCanvas" width="800" height="600"></canvas>
            </div>
            <!-- Controls container (right): holds all controls and particle coordinates -->
            <div id="controlsContainer">
                <div class="controlItem">
                    <label class="controlLabel" for="speedSlider">Relative Speed (v):</label>
                    <input type="range" id="speedSlider" min="-0.95" max="0.95" step="0.01" value="0">
                    <span id="speedValue">0.00</span>
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="gridToggle">Rest Frame Grid</label>
                    <input type="checkbox" id="gridToggle" checked>
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="movingGridToggle">Moving Frame Grid</label>
                    <input type="checkbox" id="movingGridToggle" checked>
                </div>
                <div class="controlItem">
                    <button id="addParticleBtn">Add Particle</button>
                </div>
                <div class="controlItem">
                    <button id="removeAllParticlesBtn">Remove All Particles</button>
                </div>
                <div class="controlItem">
                    <button id="alignFramesBtn">Align Frames</button>
                </div>
                <!-- Particle coordinates moved here -->
                <div id="coordinates"></div>
            </div>
        </div>
    </div>

    <!-- Custom context menu for particle removal -->
    <div id="contextMenu">Remove Particle</div>

    <script>
        // Get elements from the DOM
        const canvas = document.getElementById("minkowskiCanvas");
        const ctx = canvas.getContext("2d");
        const speedSlider = document.getElementById("speedSlider");
        const speedValueDisplay = document.getElementById("speedValue");
        const gridToggle = document.getElementById("gridToggle");
        const movingGridToggle = document.getElementById("movingGridToggle");
        const addParticleBtn = document.getElementById("addParticleBtn");
        const removeAllParticlesBtn = document.getElementById("removeAllParticlesBtn");
        const alignFramesBtn = document.getElementById("alignFramesBtn");
        const coordinatesDiv = document.getElementById("coordinates");
        const contextMenu = document.getElementById("contextMenu");

        // Coordinate system parameters
        const origin = { x: canvas.width / 2, y: canvas.height / 2 };
        const scale = 80; // pixels per unit (both space and time)

        // Particle data structure: each particle is an object with { label, x, t, radius }
        let particles = [];

        // For labeling particles: use letters.
        // nextParticleLabelCode is used if no recycled labels are available.
        let nextParticleLabelCode = "A".charCodeAt(0);
        // Pool for recycled labels.
        let availableLabels = [];

        // Utility: Get the next label (reusing if available)
        function getNextLabel() {
            if (availableLabels.length > 0) {
                availableLabels.sort();
                return availableLabels.shift();
            } else {
                let label = String.fromCharCode(nextParticleLabelCode);
                nextParticleLabelCode++;
                return label;
            }
        }

        // Add an initial particle.
        particles.push({ label: getNextLabel(), x: 1, t: 2, radius: 8 });

        // Global variables for dragging and context menu.
        let draggingParticle = null;
        let contextParticle = null;

        // Convert Minkowski coordinates (x, t) to canvas pixel coordinates.
        function toCanvasCoords(x, t) {
            return {
                x: origin.x + x * scale,
                y: origin.y - t * scale
            };
        }

        // Convert canvas pixel coordinates back to Minkowski (x, t) coordinates.
        function toMinkowskiCoords(canvasX, canvasY) {
            return {
                x: (canvasX - origin.x) / scale,
                t: (origin.y - canvasY) / scale
            };
        }

        // Lorentz transformation (rest frame to moving frame, c=1)
        function lorentzTransform(pt, v) {
            const gamma = 1 / Math.sqrt(1 - v * v);
            return {
                t: gamma * (pt.t - v * pt.x),
                x: gamma * (pt.x - v * pt.t)
            };
        }

        // Inverse Lorentz transformation (moving frame to rest frame)
        function inverseLorentzTransform(pt, v) {
            const gamma = 1 / Math.sqrt(1 - v * v);
            return {
                t: gamma * (pt.t + v * pt.x),
                x: gamma * (pt.x + v * pt.t)
            };
        }

        // Draw rest frame grid (if enabled)
        function drawGrid() {
            if (!gridToggle.checked) return;
            ctx.strokeStyle = "#dddddd"; // grid color
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            const xMin = -origin.x / scale;
            const xMax = (canvas.width - origin.x) / scale;
            const tMin = -(canvas.height - origin.y) / scale;
            const tMax = origin.y / scale;

            // Vertical grid lines (constant x)
            for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                const start = toCanvasCoords(x, tMin);
                const end = toCanvasCoords(x, tMax);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
            // Horizontal grid lines (constant t)
            for (let t = Math.floor(tMin); t <= Math.ceil(tMax); t++) {
                const start = toCanvasCoords(xMin, t);
                const end = toCanvasCoords(xMax, t);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        // Draw moving frame grid (if enabled)
        function drawMovingFrameGrid(v) {
            if (!movingGridToggle.checked) return;

            const gridSpacing = 1;    // grid spacing in moving frame coordinates
            const paramRange = 10;    // range for grid coverage
            ctx.strokeStyle = "#800080"; // moving grid color (purple)
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 4]);

            // Lines of constant x' (vertical in moving frame)
            for (let xPrime = -paramRange; xPrime <= paramRange; xPrime += gridSpacing) {
                const startMoving = { x: xPrime, t: -paramRange };
                const endMoving = { x: xPrime, t: paramRange };
                const startRest = inverseLorentzTransform(startMoving, v);
                const endRest = inverseLorentzTransform(endMoving, v);
                const startCanvas = toCanvasCoords(startRest.x, startRest.t);
                const endCanvas = toCanvasCoords(endRest.x, endRest.t);
                ctx.beginPath();
                ctx.moveTo(startCanvas.x, startCanvas.y);
                ctx.lineTo(endCanvas.x, endCanvas.y);
                ctx.stroke();
            }

            // Lines of constant t' (horizontal in moving frame)
            for (let tPrime = -paramRange; tPrime <= paramRange; tPrime += gridSpacing) {
                const startMoving = { x: -paramRange, t: tPrime };
                const endMoving = { x: paramRange, t: tPrime };
                const startRest = inverseLorentzTransform(startMoving, v);
                const endRest = inverseLorentzTransform(endMoving, v);
                const startCanvas = toCanvasCoords(startRest.x, startRest.t);
                const endCanvas = toCanvasCoords(endRest.x, endRest.t);
                ctx.beginPath();
                ctx.moveTo(startCanvas.x, startCanvas.y);
                ctx.lineTo(endCanvas.x, endCanvas.y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        // Main draw function to render the diagram.
        function draw() {
            const v = parseFloat(speedSlider.value);
            speedValueDisplay.textContent = v.toFixed(2);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grids
            drawGrid();
            drawMovingFrameGrid(v);

            // --- Draw rest frame axes ---
            ctx.strokeStyle = "#333333"; // rest axis color
            ctx.lineWidth = 2;
            // Draw x-axis
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();
            // Draw t-axis
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, canvas.height);
            ctx.stroke();
            // Label rest frame axes (x and t)
            ctx.fillStyle = "#333333";
            ctx.font = "16px Arial";
            ctx.fillText("x", canvas.width - 20, origin.y - 10);
            ctx.fillText("t", origin.x + 10, 20);

            // --- Draw moving frame axes ---
            ctx.strokeStyle = "#1E90FF"; // moving axis color
            ctx.lineWidth = 1.5;

            // t' axis: defined by x = v*t
            let tMin = -canvas.height / (2 * scale);
            let tMax = canvas.height / (2 * scale);
            let tAxisStart = toCanvasCoords(v * tMin, tMin);
            let tAxisEnd = toCanvasCoords(v * tMax, tMax);
            ctx.beginPath();
            ctx.moveTo(tAxisStart.x, tAxisStart.y);
            ctx.lineTo(tAxisEnd.x, tAxisEnd.y);
            ctx.stroke();

            // x' axis: defined by t = v*x
            let xMin = -canvas.width / (2 * scale);
            let xMax = canvas.width / (2 * scale);
            let xAxisStart = toCanvasCoords(xMin, v * xMin);
            let xAxisEnd = toCanvasCoords(xMax, v * xMax);
            ctx.beginPath();
            ctx.moveTo(xAxisStart.x, xAxisStart.y);
            ctx.lineTo(xAxisEnd.x, xAxisEnd.y);
            ctx.stroke();

            // Label moving frame axes.
            if (Math.abs(v) < 0.001) {
                ctx.fillStyle = "#1E90FF";
                ctx.font = "16px Arial";
                ctx.fillText("t'", origin.x + 10, 20);
                ctx.fillText("x'", canvas.width - 20, origin.y - 10);
            } else {
                let tLabelOffsetX = 10;
                let tLabelOffsetY = 20;
                let xLabelOffsetX = -30;
                let xLabelOffsetY = -5;
                ctx.fillStyle = "#1E90FF";
                ctx.font = "16px Arial";
                ctx.fillText("t'", tAxisEnd.x + tLabelOffsetX, tAxisEnd.y + tLabelOffsetY);
                ctx.fillText("x'", xAxisEnd.x + xLabelOffsetX, xAxisEnd.y + xLabelOffsetY);
            }

            // --- Draw light cone (blue dashed lines) ---
            ctx.strokeStyle = "#00aaff"; // light cone color
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            let lcStart = toCanvasCoords(-canvas.width / (2 * scale), -canvas.width / (2 * scale));
            let lcEnd = toCanvasCoords(canvas.width / (2 * scale), canvas.width / (2 * scale));
            ctx.moveTo(lcStart.x, lcStart.y);
            ctx.lineTo(lcEnd.x, lcEnd.y);
            lcStart = toCanvasCoords(-canvas.width / (2 * scale), canvas.width / (2 * scale));
            lcEnd = toCanvasCoords(canvas.width / (2 * scale), -canvas.width / (2 * scale));
            ctx.moveTo(lcStart.x, lcStart.y);
            ctx.lineTo(lcEnd.x, lcEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // --- Draw particles (rest frame and moving frame positions) ---
            particles.forEach(particle => {
                const canvasPos = toCanvasCoords(particle.x, particle.t);
                ctx.fillStyle = "#006400";
                ctx.beginPath();
                ctx.arc(canvasPos.x, canvasPos.y, particle.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#000";
                ctx.stroke();
                ctx.fillStyle = "#333333";
                ctx.font = "14px Arial";
                ctx.fillText(particle.label, canvasPos.x + particle.radius + 2, canvasPos.y - particle.radius - 2);

                const transformed = lorentzTransform(particle, v);
                const canvasPosTrans = toCanvasCoords(transformed.x, transformed.t);
                ctx.fillStyle = "#c00";
                ctx.beginPath();
                ctx.arc(canvasPosTrans.x, canvasPosTrans.y, particle.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.fillText(particle.label + "'", canvasPosTrans.x + particle.radius + 2, canvasPosTrans.y - particle.radius - 2);
            });

            // --- Update particle coordinates in the controls container ---
            let coordsHTML = "<h3>Particle Coordinates</h3><ul>";
            particles.forEach(particle => {
                const transformed = lorentzTransform(particle, v);
                coordsHTML += `<li>${particle.label} (rest): x = ${particle.x.toFixed(2)}, t = ${particle.t.toFixed(2)}; `;
                coordsHTML += `${particle.label}' (moving): x' = ${transformed.x.toFixed(2)}, t' = ${transformed.t.toFixed(2)}</li>`;
            });
            coordsHTML += "</ul>";
            coordinatesDiv.innerHTML = coordsHTML;
        }

        // --- Dragging functionality (left-click) ---
        canvas.addEventListener("mousedown", function (e) {
            if (e.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                const canvasPos = toCanvasCoords(particle.x, particle.t);
                const dx = mouseX - canvasPos.x;
                const dy = mouseY - canvasPos.y;
                if (Math.sqrt(dx * dx + dy * dy) < particle.radius + 5) {
                    draggingParticle = particle;
                    break;
                }
            }
        });

        canvas.addEventListener("mousemove", function (e) {
            if (draggingParticle) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const minkowskiCoords = toMinkowskiCoords(mouseX, mouseY);
                draggingParticle.x = minkowskiCoords.x;
                draggingParticle.t = minkowskiCoords.t;
                draw();
            }
        });

        canvas.addEventListener("mouseup", function () {
            draggingParticle = null;
        });
        canvas.addEventListener("mouseleave", function () {
            draggingParticle = null;
        });

        // --- Custom Context Menu for Particle Removal ---
        canvas.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            let found = false;
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                const canvasPos = toCanvasCoords(particle.x, particle.t);
                const dx = mouseX - canvasPos.x;
                const dy = mouseY - canvasPos.y;
                if (Math.sqrt(dx * dx + dy * dy) < particle.radius + 5) {
                    found = true;
                    contextParticle = particle;
                    break;
                }
            }
            if (found && contextParticle) {
                contextMenu.style.display = "block";
                contextMenu.style.left = e.pageX + "px";
                contextMenu.style.top = e.pageY + "px";
            } else {
                contextMenu.style.display = "none";
            }
        });

        contextMenu.addEventListener("click", function (e) {
            if (contextParticle) {
                const index = particles.indexOf(contextParticle);
                if (index !== -1) {
                    availableLabels.push(contextParticle.label);
                    particles.splice(index, 1);
                }
                contextParticle = null;
                contextMenu.style.display = "none";
                draw();
            }
        });

        document.addEventListener("click", function (e) {
            if (e.target !== contextMenu) {
                contextMenu.style.display = "none";
            }
        });

        // --- Add Particle Button ---
        addParticleBtn.addEventListener("click", function () {
            const newX = (Math.random() * 6) - 3;
            const newT = (Math.random() * 6) - 3;
            const newParticle = { label: getNextLabel(), x: newX, t: newT, radius: 8 };
            particles.push(newParticle);
            draw();
        });

        // --- Remove All Particles Button ---
        removeAllParticlesBtn.addEventListener("click", function () {
            particles.forEach(particle => {
                availableLabels.push(particle.label);
            });
            particles = [];
            draw();
        });

        // --- Align Frames Button (resets speed to zero) ---
        alignFramesBtn.addEventListener("click", function () {
            speedSlider.value = 0;
            draw();
        });

        speedSlider.addEventListener("input", draw);
        gridToggle.addEventListener("change", draw);
        movingGridToggle.addEventListener("change", draw);

        // Initial drawing.
        draw();
    </script>
</body>

</html>