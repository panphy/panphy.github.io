<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Lorentz Transformation – Interactive Minkowski Diagram</title>
    <style>
        /* Define color and layout variables for easy theme management */
        :root {
            --bg-color: #ffffff;
            --primary-text-color: #333333;
            --accent-blue: #1E90FF;
            --accent-orange: #FFA500;
            --canvas-border: #cccccc;
            --grid-color: #dddddd;
            --moving-grid-color: #800080;
            --rest-axis-color: #333333;
            --moving-axis-color: var(--accent-blue);
            --light-cone-color: #00aaff;
            --particle-rest-color: #006400;
            --particle-moving-color: #c00;
            --control-bg-color: #f5f5f5;
            --control-border-color: #cccccc;
        }

        body {
            margin: 0;
            font-family: sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
        }

        header {
            background-color: #333333;
            padding: 5px;
        }

        .header-container {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
        }

        .header-container .logo img {
            height: 30px;
            margin: 10px;
        }

        .header-container .title h1 {
            margin: 0;
            text-align: center;
            color: #ffffff;
            font-size: 22px;
        }

        #contentWrapper {
            padding: 20px;
        }

        /* Main container: Minkowski Diagram (canvas) plus the control panel */
        #mainContainer {
            display: grid;
            grid-template-columns: 800px 250px;
            grid-gap: 15px;
            justify-content: center;
        }

        #diagramContainer {
            width: 800px;
        }

        #minkowskiCanvas {
            border: 1px solid var(--canvas-border);
            background-color: var(--bg-color);
            display: block;
            cursor: pointer;
        }

        /* Control panel styling */
        #controlsContainer {
            width: 250px;
            background-color: var(--control-bg-color);
            border: 1px solid var(--control-border-color);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .controlItem {
            margin-bottom: 5px;
        }

        .controlLabel {
            margin-right: 5px;
        }

        button {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--control-border-color);
            border-radius: 3px;
            background-color: var(--accent-blue);
            color: #fff;
            font-size: 15px;
            cursor: pointer;
        }

        button:hover {
            background-color: #187bcd;
        }

        #coordinates {
            margin-top: 10px;
            font-size: 14px;
            overflow-y: auto;
            max-height: 200px;
            border-top: 1px solid var(--control-border-color);
            padding-top: 10px;
        }

        /* Context menu for removing a particle */
        #contextMenu {
            position: absolute;
            background: var(--bg-color);
            border: 1px solid var(--control-border-color);
            padding: 5px 10px;
            display: none;
            z-index: 1000;
            cursor: pointer;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }

        #contextMenu:hover {
            background: #eeeeee;
        }
    </style>
</head>

<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="https://panphy.github.io/">
                    <img src="/panphy.png" alt="PanPhy Logo">
                </a>
            </div>
            <div class="title">
                <h1>Lorentz Transformation – Interactive Minkowski Diagram</h1>
            </div>
            <div class="spacer"></div>
        </div>
    </header>
    <div id="contentWrapper">
        <div id="mainContainer">
            <!-- The Minkowski Diagram Canvas -->
            <div id="diagramContainer">
                <canvas id="minkowskiCanvas" width="800" height="600"></canvas>
            </div>

            <!-- The control panel on the right -->
            <div id="controlsContainer">
                <div class="controlItem">
                    <label class="controlLabel" for="speedSlider">Relative Speed (c):</label>
                    <input type="range" id="speedSlider" min="-0.95" max="0.95" step="0.01" value="0">
                    <span id="speedValue">0.00</span>
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="gridToggle">Rest Frame Grid</label>
                    <input type="checkbox" id="gridToggle" checked>
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="movingGridToggle">Moving Frame Grid</label>
                    <input type="checkbox" id="movingGridToggle" checked>
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="velocityToggle">Show Velocity Line</label>
                    <input type="checkbox" id="velocityToggle">
                </div>
                <div class="controlItem">
                    <label class="controlLabel" for="velocitySlider">Velocity (v):</label>
                    <input type="range" id="velocitySlider" min="-0.95" max="0.95" step="0.01" value="0.30">
                    <span id="velocityValue">0.30</span>
                </div>
                <div class="controlItem">
                    <button id="addParticleBtn">Add Particle</button>
                </div>
                <div class="controlItem">
                    <button id="removeAllParticlesBtn">Remove All Particles</button>
                </div>
                <div class="controlItem">
                    <button id="alignFramesBtn">Align Frames</button>
                </div>
                <div id="coordinates"></div>
            </div>
        </div>
    </div>

    <!-- Context menu to remove a specific particle -->
    <div id="contextMenu">Remove Particle</div>

    <script>
        window.addEventListener("load", function () {
            const canvas = document.getElementById("minkowskiCanvas");
            const ctx = canvas.getContext("2d");

            // Sliders and toggle elements
            const speedSlider = document.getElementById("speedSlider");
            const speedValueDisplay = document.getElementById("speedValue");
            const gridToggle = document.getElementById("gridToggle");
            const movingGridToggle = document.getElementById("movingGridToggle");
            const velocityToggle = document.getElementById("velocityToggle");
            const velocitySlider = document.getElementById("velocitySlider");
            const velocityValueDisplay = document.getElementById("velocityValue");

            // Buttons
            const addParticleBtn = document.getElementById("addParticleBtn");
            const removeAllParticlesBtn = document.getElementById("removeAllParticlesBtn");
            const alignFramesBtn = document.getElementById("alignFramesBtn");

            // Particle coordinates display
            const coordinatesDiv = document.getElementById("coordinates");
            // Context menu for removing individual particles
            const contextMenu = document.getElementById("contextMenu");

            // Used to detect long-press on touch devices
            let longPressTimeout = null;

            // Origin at the center of the canvas
            const origin = { x: canvas.width / 2, y: canvas.height / 2 };
            // Scale factor (pixels per unit in Minkowski space)
            const scale = 80;

            // Particle storage
            let particles = [];
            // For labeling particles in alphabetical order
            let nextParticleLabelCode = "A".charCodeAt(0);
            // Reusable labels if particles are removed
            let availableLabels = [];

            // Function to fetch the next particle label
            function getNextLabel() {
                if (availableLabels.length > 0) {
                    availableLabels.sort();
                    return availableLabels.shift();
                } else {
                    let label = String.fromCharCode(nextParticleLabelCode);
                    nextParticleLabelCode++;
                    return label;
                }
            }

            // Sample default particle
            particles.push({ label: getNextLabel(), x: 1, t: 2, radius: 8 });

            // Variables used for dragging particles
            let draggingParticle = null;
            let contextParticle = null;

            /**
             * Convert Minkowski coordinates (x, t) to canvas coordinates (pixels).
             */
            function toCanvasCoords(x, t) {
                return {
                    x: origin.x + x * scale,
                    y: origin.y - t * scale
                };
            }

            /**
             * Convert canvas coordinates (pixels) to Minkowski coordinates (x, t).
             */
            function toMinkowskiCoords(cx, cy) {
                return {
                    x: (cx - origin.x) / scale,
                    t: (origin.y - cy) / scale
                };
            }

            /**
             * Perform Lorentz transformation from rest frame to moving frame:
             *  (t', x') = gamma ( t - v x , x - v t ).
             * v is the speed (in units of c).
             */
            function lorentzTransform(pt, v) {
                const gamma = 1 / Math.sqrt(1 - v * v);
                return {
                    t: gamma * (pt.t - v * pt.x),
                    x: gamma * (pt.x - v * pt.t)
                };
            }

            /**
             * Compute endpoints for a line x = v_line * t in Minkowski space, ensuring
             * the line extends across the entire canvas.
             */
            function computeVelocityEndpoints(v_line) {
                const W = canvas.width / (2 * scale);
                const T = canvas.height / (2 * scale);

                // If |v_line| <= W/T, we limit by the t-range; otherwise by the x-range.
                if (Math.abs(v_line) <= W / T) {
                    // x = v_line * t; pick t = ±T
                    return [
                        { x: v_line * T, t: T },
                        { x: v_line * (-T), t: -T }
                    ];
                } else {
                    // Else pick x = ±W, solve for t = x / v_line.
                    return [
                        { x: W, t: W / v_line },
                        { x: -W, t: -W / v_line }
                    ];
                }
            }

            /**
             * Draw two velocity lines if requested: 
             * 1) The green line in the rest frame (x = v_line * t).
             * 2) The orange line corresponding to x' = v_line * t' in the moving frame,
             *    transformed back to the rest frame via the velocity-composition formula:
             *      v_eff = (v_line + relSpeed) / (1 + v_line * relSpeed).
             */
            function drawVelocityLine(v_line, relSpeed) {
                // --- REST FRAME VELOCITY LINE (green) ---
                const endpointsGreen = computeVelocityEndpoints(v_line);

                ctx.strokeStyle = "green";
                ctx.lineWidth = 2;
                ctx.setLineDash([]);

                let cp1 = toCanvasCoords(endpointsGreen[0].x, endpointsGreen[0].t);
                let cp2 = toCanvasCoords(endpointsGreen[1].x, endpointsGreen[1].t);
                ctx.beginPath();
                ctx.moveTo(cp1.x, cp1.y);
                ctx.lineTo(cp2.x, cp2.y);
                ctx.stroke();

                // --- MOVING FRAME LINE (orange) ---
                // We define the "effective speed" in rest frame for the line x' = v_line t':
                //     v_eff = (v_line + relSpeed) / (1 + v_line * relSpeed)
                // Then in the rest frame, the line is simply x = v_eff * t.
                let v_eff = (v_line + relSpeed) / (1 + v_line * relSpeed);
                const endpointsOrange = computeVelocityEndpoints(v_eff);

                ctx.strokeStyle = "orange";
                ctx.lineWidth = 2;
                ctx.beginPath();
                let cp1m = toCanvasCoords(endpointsOrange[0].x, endpointsOrange[0].t);
                let cp2m = toCanvasCoords(endpointsOrange[1].x, endpointsOrange[1].t);
                ctx.moveTo(cp1m.x, cp1m.y);
                ctx.lineTo(cp2m.x, cp2m.y);
                ctx.stroke();
            }

            /**
             * Main draw function: Clears canvas, draws grids, axes, light cone, particles, etc.
             */
            function draw() {
                const relSpeed = parseFloat(speedSlider.value);
                speedValueDisplay.textContent = relSpeed.toFixed(2);

                // The "velocity line" v_line is separate from the relative speed between frames
                const v_line = parseFloat(velocitySlider.value);
                velocityValueDisplay.textContent = v_line.toFixed(2);

                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Decide how many grid lines to draw based on scale
                const xMinVal = -origin.x / scale, xMaxVal = (canvas.width - origin.x) / scale;
                const tMinVal = -(canvas.height - origin.y) / scale, tMaxVal = origin.y / scale;

                // --- DRAW GRID (rest frame) if toggled ---
                if (gridToggle.checked) {
                    ctx.strokeStyle = "#dddddd";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);

                    // Vertical lines in rest frame
                    for (let x = Math.floor(xMinVal); x <= Math.ceil(xMaxVal); x++) {
                        let s = toCanvasCoords(x, tMinVal);
                        let e = toCanvasCoords(x, tMaxVal);
                        ctx.beginPath();
                        ctx.moveTo(s.x, s.y);
                        ctx.lineTo(e.x, e.y);
                        ctx.stroke();
                    }
                    // Horizontal lines in rest frame
                    for (let t = Math.floor(tMinVal); t <= Math.ceil(tMaxVal); t++) {
                        let s = toCanvasCoords(xMinVal, t);
                        let e = toCanvasCoords(xMaxVal, t);
                        ctx.beginPath();
                        ctx.moveTo(s.x, s.y);
                        ctx.lineTo(e.x, e.y);
                        ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }

                // --- DRAW REST FRAME AXES (x, t) ---
                ctx.strokeStyle = "#333333";
                ctx.lineWidth = 2;
                // x-axis
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(canvas.width, origin.y);
                ctx.stroke();

                // t-axis
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, canvas.height);
                ctx.stroke();

                // Axis labels in rest frame
                ctx.fillStyle = "#333333";
                ctx.font = "16px Arial";
                ctx.fillText("x", canvas.width - 20, origin.y - 10);
                ctx.fillText("t", origin.x + 10, 20);

                // --- DRAW MOVING FRAME AXES (x', t') if toggled ---
                if (movingGridToggle.checked) {
                    // You can implement a similar "moving grid" if desired.
                    // For now, we only draw the main x' and t' axes.
                }

                // Moving frame axes in blue
                ctx.strokeStyle = "#1E90FF";
                ctx.lineWidth = 1.5;

                // t' axis
                let tA = toCanvasCoords(relSpeed * tMinVal, tMinVal);
                let tB = toCanvasCoords(relSpeed * tMaxVal, tMaxVal);
                ctx.beginPath();
                ctx.moveTo(tA.x, tA.y);
                ctx.lineTo(tB.x, tB.y);
                ctx.stroke();

                // x' axis
                let xA = toCanvasCoords(xMinVal, relSpeed * xMinVal);
                let xB = toCanvasCoords(xMaxVal, relSpeed * xMaxVal);
                ctx.beginPath();
                ctx.moveTo(xA.x, xA.y);
                ctx.lineTo(xB.x, xB.y);
                ctx.stroke();

                // Label the moving axes
                ctx.fillStyle = "#1E90FF";
                ctx.font = "16px Arial";
                if (Math.abs(relSpeed) < 0.001) {
                    // If speed ~ 0, overlap with rest frame
                    ctx.fillText("t'", origin.x + 10, 20);
                    ctx.fillText("x'", canvas.width - 20, origin.y - 10);
                } else {
                    ctx.fillText("t'", tB.x + 10, tB.y + 20);
                    ctx.fillText("x'", xB.x - 30, xB.y - 5);
                }

                // --- DRAW VELOCITY LINES (green & orange) if toggled ---
                if (velocityToggle.checked) {
                    drawVelocityLine(v_line, relSpeed);
                }

                // --- DRAW LIGHT CONE (45-degree lines) ---
                ctx.strokeStyle = "#00aaff";
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                let lcS = toCanvasCoords(-canvas.width / (2 * scale), -canvas.width / (2 * scale));
                let lcE = toCanvasCoords(canvas.width / (2 * scale), canvas.width / (2 * scale));
                ctx.moveTo(lcS.x, lcS.y);
                ctx.lineTo(lcE.x, lcE.y);
                lcS = toCanvasCoords(-canvas.width / (2 * scale), canvas.width / (2 * scale));
                lcE = toCanvasCoords(canvas.width / (2 * scale), -canvas.width / (2 * scale));
                ctx.moveTo(lcS.x, lcS.y);
                ctx.lineTo(lcE.x, lcE.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // --- DRAW PARTICLES ---
                particles.forEach(particle => {
                    // Draw particle in rest frame (green)
                    let cp = toCanvasCoords(particle.x, particle.t);
                    ctx.fillStyle = "#006400";
                    ctx.beginPath();
                    ctx.arc(cp.x, cp.y, particle.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "#000";
                    ctx.stroke();

                    // Label the particle in rest frame
                    ctx.fillStyle = "#333333";
                    ctx.font = "14px Arial";
                    ctx.fillText(particle.label, cp.x + particle.radius + 2, cp.y - particle.radius - 2);

                    // Draw the same particle in the moving frame (red circle)
                    let trans = lorentzTransform(particle, relSpeed);
                    let cpT = toCanvasCoords(trans.x, trans.t);
                    ctx.fillStyle = "#c00";
                    ctx.beginPath();
                    ctx.arc(cpT.x, cpT.y, particle.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillText(particle.label + "'", cpT.x + particle.radius + 2, cpT.y - particle.radius - 2);
                });

                // --- UPDATE PARTICLE COORDINATES DISPLAY ---
                let html = "<h3>Particle Coordinates</h3><ul>";
                particles.forEach(particle => {
                    let trans = lorentzTransform(particle, relSpeed);
                    html += `<li>${particle.label} (rest): x = ${particle.x.toFixed(2)}, t = ${particle.t.toFixed(2)}; `;
                    html += `${particle.label}' (moving): x' = ${trans.x.toFixed(2)}, t' = ${trans.t.toFixed(2)}</li>`;
                });
                html += "</ul>";
                coordinatesDiv.innerHTML = html;
            }

            // --- MOUSE EVENTS FOR DRAGGING PARTICLES ---
            canvas.addEventListener("mousedown", function (e) {
                // Only handle left-click
                if (e.button !== 0) return;
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left, my = e.clientY - r.top;

                // Check if mouse is near any particle
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const cp = toCanvasCoords(p.x, p.t);
                    if (Math.sqrt((mx - cp.x) ** 2 + (my - cp.y) ** 2) < p.radius + 5) {
                        draggingParticle = p;
                        break;
                    }
                }
            });

            canvas.addEventListener("mousemove", function (e) {
                if (draggingParticle) {
                    const r = canvas.getBoundingClientRect();
                    const mx = e.clientX - r.left, my = e.clientY - r.top;
                    const coords = toMinkowskiCoords(mx, my);

                    // Update the particle's position
                    draggingParticle.x = coords.x;
                    draggingParticle.t = coords.t;
                    draw();
                }
            });

            canvas.addEventListener("mouseup", function () {
                draggingParticle = null;
            });

            canvas.addEventListener("mouseleave", function () {
                draggingParticle = null;
            });

            // --- TOUCH EVENTS FOR DRAGGING & LONG-PRESS CONTEXT MENU ---
            canvas.addEventListener("touchstart", function (e) {
                e.preventDefault();
                const t = e.touches[0];
                const r = canvas.getBoundingClientRect();
                const tx = t.clientX - r.left, ty = t.clientY - r.top;

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const cp = toCanvasCoords(p.x, p.t);
                    if (Math.sqrt((tx - cp.x) ** 2 + (ty - cp.y) ** 2) < p.radius + 5) {
                        draggingParticle = p;
                        // Set a long-press timeout to show context menu
                        longPressTimeout = setTimeout(() => {
                            contextParticle = p;
                            contextMenu.style.display = "block";
                            contextMenu.style.left = t.pageX + "px";
                            contextMenu.style.top = t.pageY + "px";
                        }, 800);
                        break;
                    }
                }
            });

            canvas.addEventListener("touchmove", function (e) {
                e.preventDefault();
                if (draggingParticle) {
                    if (longPressTimeout) clearTimeout(longPressTimeout);
                    const t = e.touches[0];
                    const r = canvas.getBoundingClientRect();
                    const tx = t.clientX - r.left, ty = t.clientY - r.top;
                    const coords = toMinkowskiCoords(tx, ty);

                    draggingParticle.x = coords.x;
                    draggingParticle.t = coords.t;
                    draw();
                }
            });

            canvas.addEventListener("touchend", function () {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                draggingParticle = null;
            });

            canvas.addEventListener("touchcancel", function () {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                draggingParticle = null;
            });

            // --- RIGHT-CLICK CONTEXT MENU (Remove Particle) ---
            canvas.addEventListener("contextmenu", function (e) {
                e.preventDefault();
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left, my = e.clientY - r.top;
                let found = false;

                // Check if user right-clicked on a particle
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const cp = toCanvasCoords(p.x, p.t);
                    if (Math.sqrt((mx - cp.x) ** 2 + (my - cp.y) ** 2) < p.radius + 5) {
                        found = true;
                        contextParticle = p;
                        break;
                    }
                }

                // Show the context menu if on a particle, else hide
                if (found && contextParticle) {
                    contextMenu.style.display = "block";
                    contextMenu.style.left = e.pageX + "px";
                    contextMenu.style.top = e.pageY + "px";
                } else {
                    contextMenu.style.display = "none";
                }
            });

            // When user clicks "Remove Particle" in the context menu
            contextMenu.addEventListener("click", function () {
                if (contextParticle) {
                    const idx = particles.indexOf(contextParticle);
                    if (idx !== -1) {
                        // Reuse the label
                        availableLabels.push(contextParticle.label);
                        particles.splice(idx, 1);
                    }
                    contextParticle = null;
                    contextMenu.style.display = "none";
                    draw();
                }
            });

            // Hide context menu when clicking elsewhere
            document.addEventListener("click", function (e) {
                if (e.target !== contextMenu) {
                    contextMenu.style.display = "none";
                }
            });

            // --- BUTTONS ---
            addParticleBtn.addEventListener("click", function () {
                // Add a particle at a random (x, t) for demonstration
                const newX = (Math.random() * 6) - 3;
                const newT = (Math.random() * 6) - 3;
                particles.push({ label: getNextLabel(), x: newX, t: newT, radius: 8 });
                draw();
            });

            removeAllParticlesBtn.addEventListener("click", function () {
                // Return all labels to the pool
                particles.forEach(p => availableLabels.push(p.label));
                particles = [];
                draw();
            });

            alignFramesBtn.addEventListener("click", function () {
                // Reset the relative speed to 0
                speedSlider.value = 0;
                draw();
            });

            // --- SLIDER & TOGGLE EVENTS ---
            speedSlider.addEventListener("input", draw);
            gridToggle.addEventListener("change", draw);
            movingGridToggle.addEventListener("change", draw);
            velocitySlider.addEventListener("input", draw);
            velocityToggle.addEventListener("change", draw);

            // Initial draw
            draw();
        });
    </script>
</body>

</html>