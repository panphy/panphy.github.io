<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="robots" content="noindex, nofollow">

	<title>Physics Club — Sim Showcase</title>
	<link rel="icon" type="image/png" href="/assets/favicon.png">
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

		:root {
			--bg: #0a0d12;
			--fg: #e7f0ff;
			--accent: #58e1ff;
			--accent2: #a0ff6a;
			--accent3: #ff7ad9;
		}

		html,
		body {
			height: 100%;
			margin: 0;
			background: #0a0d12;
			color: var(--fg);
			font-family: 'Inter', sans-serif;
			overflow: hidden
		}

		#wrap {
			position: fixed;
			inset: 0;
			display: flex;
			flex-direction: column
		}

		#stage {
			flex: 1;
			position: relative
		}

		canvas {
			position: absolute;
			inset: 0;
			width: 100%;
			height: 100%
		}

		#hud {
			position: absolute;
			right: 12px;
			top: 12px;
			font-size: 12px;
			opacity: .85;
			padding: 6px 8px;
			border-radius: 8px;
			background: rgba(10, 13, 18, .45);
			backdrop-filter: blur(8px);
			border: 1px solid rgba(255, 255, 255, .08);
			text-align: right;
		}

		#sceneName {
			font-weight: 700;
			color: #d7f9ff
		}

		#timer {
			font-variant-numeric: tabular-nums;
			opacity: .85
		}

		#controls {
			height: 56px;
			display: flex;
			gap: 10px;
			align-items: center;
			justify-content: center;
			border-top: 1px solid rgba(255, 255, 255, .05);
			background: linear-gradient(to top, rgba(10, 13, 18, .7), rgba(10, 13, 18, .35));
			backdrop-filter: blur(6px)
		}

		button {
			appearance: none;
			border: 1px solid rgba(255, 255, 255, .12);
			background: rgba(255, 255, 255, .06);
			backdrop-filter: blur(4px);
			color: var(--fg);
			padding: 10px 14px;
			border-radius: 10px;
			font-weight: 700;
			letter-spacing: .04em;
			cursor: pointer;
			transition: all .25s ease
		}

		button:hover {
			border-color: rgba(88, 225, 255, .45);
			background: rgba(88, 225, 255, .1);
			box-shadow: 0 0 14px rgba(88, 225, 255, .25)
		}

		.pill {
			font-size: 12px;
			padding: 6px 10px;
			opacity: .9
		}

		.scene-dots {
			display: flex;
			gap: 6px;
			align-items: center;
			margin: 0 10px
		}

		.scene-dots .dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: rgba(255, 255, 255, .18);
			transition: all .3s ease
		}

		.scene-dots .dot.active {
			background: var(--accent);
			box-shadow: 0 0 8px var(--accent)
		}

		#hint {
			position: absolute;
			left: 12px;
			bottom: 62px;
			font-size: 12px;
			opacity: .6;
			animation: hintFade 5s forwards
		}

		@keyframes hintFade {

			0%,
			60% {
				opacity: .6
			}

			100% {
				opacity: 0
			}
		}
	</style>
</head>

<body>
	<div id="wrap">
		<div id="stage">
			<canvas id="simCanvas"></canvas>
			<canvas id="titleCanvas"></canvas>
			<div id="hud">
				<div id="sceneName">Loading…</div>
				<div id="timer">00:00</div>
			</div>
			<div id="hint">Tap / Space: Pause · Swipe / Arrows: Prev / Next · F: Fullscreen</div>
		</div>
		<div id="controls">
			<button id="prev">◀ Prev</button>
			<button id="toggle">Pause ⏸</button>
			<button id="next">Next ▶</button>
			<div class="scene-dots" id="sceneDots"></div>
			<button id="fs" class="pill">Fullscreen ⛶</button>
		</div>
	</div>

	<script>
		(() => {
			/* ===== Elements ===== */
			const sim = document.getElementById('simCanvas');
			const sctx = sim.getContext('2d');
			const tit = document.getElementById('titleCanvas');
			const tctx = tit.getContext('2d');
			const hudName = document.getElementById('sceneName');
			const timerEl = document.getElementById('timer');
			const btnPrev = document.getElementById('prev');
			const btnNext = document.getElementById('next');
			const btnToggle = document.getElementById('toggle');
			const btnFS = document.getElementById('fs');
			const stage = document.getElementById('stage');
			const dotsEl = document.getElementById('sceneDots');

			let W = 0, H = 0, D = 1;

			function resize() {
				D = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
				W = stage.clientWidth;
				H = stage.clientHeight;
				for (const c of [sim, tit]) {
					c.width = Math.floor(W * D);
					c.height = Math.floor(H * D);
					c.style.width = W + 'px';
					c.style.height = H + 'px';
				}
				sctx.setTransform(D, 0, 0, D, 0, 0);
				tctx.setTransform(D, 0, 0, D, 0, 0);
				current?.onResize?.(W, H, D);
			}
			addEventListener('resize', resize, { passive: true });

			/* ===== Timing ===== */
			const dwellSeconds = 12;
			const interstitialSeconds = 2.5;
			let interstitialUntil = 0;
			let inInterstitial = false;
			let lastSwitch = 0;
			let playing = true;
			let startBase = performance.now() / 1000;
			let elapsed = 0;

			/* ===== Interactions ===== */
			let touchStartX = null;
			sim.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].clientX; }, { passive: true });
			sim.addEventListener('touchend', e => {
				if (touchStartX == null) return;
				const dx = e.changedTouches[0].clientX - touchStartX;
				if (Math.abs(dx) > 50) { dx < 0 ? nextScene() : prevScene(); } else togglePlay();
				touchStartX = null;
			}, { passive: true });
			sim.addEventListener('click', togglePlay);
			btnPrev.onclick = prevScene;
			btnNext.onclick = nextScene;
			btnToggle.onclick = togglePlay;
			btnFS.onclick = () => {
				if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
				else document.exitFullscreen?.();
			};
			document.addEventListener('keydown', e => {
				if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); togglePlay(); }
				else if (e.key === 'ArrowRight') nextScene();
				else if (e.key === 'ArrowLeft') prevScene();
				else if (e.key === 'f' || e.key === 'F') {
					if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
					else document.exitFullscreen?.();
				}
			});

			function togglePlay() {
				playing = !playing;
				btnToggle.textContent = playing ? 'Pause ⏸' : 'Play ▶';
				if (playing) startBase = performance.now() / 1000 - elapsed;
			}

			/* ===== Helpers ===== */
			const TAU = Math.PI * 2;
			const now = () => performance.now() / 1000;

			function drawGrid(ctx, step = 28, alpha = 0.22) {
				ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
				ctx.lineWidth = 1;
				ctx.beginPath();
				for (let x = 0; x < W; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
				for (let y = 0; y < H; y += step) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
				ctx.stroke();
			}

			function glowCircle(ctx, x, y, r, color) {
				const g = ctx.createRadialGradient(x, y, 0, x, y, r * 1.6);
				g.addColorStop(0, color);
				g.addColorStop(1, 'rgba(0,0,0,0)');
				ctx.fillStyle = g;
				ctx.beginPath();
				ctx.arc(x, y, r * 1.6, 0, TAU);
				ctx.fill();
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.arc(x, y, r, 0, TAU);
				ctx.fill();
			}

			function drawArrow(ctx, x1, y1, x2, y2, color) {
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				const a = Math.atan2(y2 - y1, x2 - x1), ah = 8;
				ctx.beginPath();
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - ah * Math.cos(a - 0.45), y2 - ah * Math.sin(a - 0.45));
				ctx.lineTo(x2 - ah * Math.cos(a + 0.45), y2 - ah * Math.sin(a + 0.45));
				ctx.closePath();
				ctx.fill();
			}

			function spring(ctx, x1, y1, x2, y2, coils = 14, amp = 10, color = '#58e1ff') {
				ctx.strokeStyle = color;
				ctx.lineWidth = 2;
				const dx = x2 - x1, dy = y2 - y1, len = Math.hypot(dx, dy);
				const nx = dx / len, ny = dy / len, px = -ny, py = nx, seg = (len - 30) / coils;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x1 + nx * 10, y1 + ny * 10);
				let cx = x1 + nx * 10, cy = y1 + ny * 10;
				for (let i = 0; i < coils; i++) {
					const dir = (i % 2 ? -1 : 1), ox = px * amp * dir, oy = py * amp * dir;
					cx += nx * seg; cy += ny * seg;
					ctx.lineTo(cx + ox, cy + oy);
				}
				ctx.lineTo(x2, y2);
				ctx.stroke();
			}

			/* ===== Interstitial ===== */
			const eqTexts = ['E = mc²', 'F = ma', 'v = λf', 'E = hf', 'p = mv', 'V = IR', 'PV = nRT', 'F = qvB', 'a = v²/r', 'λ = h/p', 'ΔE = qΔV', 'W = Fd'];

			function startInterstitial() {
				inInterstitial = true;
				interstitialUntil = now() + interstitialSeconds;
				sctx.clearRect(0, 0, W, H);
			}

			function endInterstitial() {
				inInterstitial = false;
				tctx.clearRect(0, 0, W, H);
			}

			function drawInterstitial(t) {
				tctx.clearRect(0, 0, W, H);

				/* Background */
				const bg = tctx.createRadialGradient(W * 0.5, H * 0.45, 0, W * 0.5, H * 0.45, Math.max(W, H) * 0.9);
				bg.addColorStop(0, '#0b1220');
				bg.addColorStop(1, '#070a12');
				tctx.fillStyle = bg;
				tctx.fillRect(0, 0, W, H);

				/* Sparkles */
				const nStar = Math.floor(W * H / 12000);
				for (let i = 0; i < nStar; i++) {
					const sx = (i * 71) % W, sy = (i * 199) % H;
					const tw = 0.35 + 0.65 * Math.abs(Math.sin(t * 3 + i));
					tctx.fillStyle = `rgba(255,255,255,${tw * 0.55})`;
					tctx.fillRect(sx, sy, 1, 1);
				}

				/* Floating equations */
				tctx.font = '14px Inter, sans-serif';
				for (let i = 0; i < eqTexts.length; i++) {
					const ex = ((i * 137 + t * 12) % (W + 120)) - 60;
					const ey = ((i * 199 + t * 6) % (H + 80)) - 40;
					const ea = 0.08 + 0.06 * Math.sin(t * 0.7 + i * 2.5);
					tctx.fillStyle = `rgba(150,220,255,${ea})`;
					tctx.fillText(eqTexts[i], ex, ey);
				}

				/* Radial energy burst */
				for (let i = 0; i < 20; i++) {
					const a = (i / 20) * TAU + t * 0.5;
					const r0 = Math.min(W, H) * 0.07;
					const r1 = Math.min(W, H) * 0.42;
					tctx.strokeStyle = 'rgba(155,234,255,0.06)';
					tctx.lineWidth = 1.5;
					tctx.beginPath();
					tctx.moveTo(W / 2 + Math.cos(a) * r0, H / 2 + Math.sin(a) * r0);
					tctx.lineTo(W / 2 + Math.cos(a) * r1, H / 2 + Math.sin(a) * r1);
					tctx.stroke();
				}

				/* Bohr-model atom orbits */
				const acx = W / 2, acy = H / 2;
				const orbits = [
					{ a: Math.min(W, H) * 0.18, b: Math.min(W, H) * 0.06, tilt: -0.35, speed: 2.2 },
					{ a: Math.min(W, H) * 0.24, b: Math.min(W, H) * 0.07, tilt: 0.7, speed: 1.6 },
					{ a: Math.min(W, H) * 0.30, b: Math.min(W, H) * 0.08, tilt: -1.1, speed: 1.1 }
				];
				for (const orb of orbits) {
					/* Draw orbit ellipse */
					tctx.save();
					tctx.translate(acx, acy);
					tctx.rotate(orb.tilt);
					tctx.strokeStyle = 'rgba(88,225,255,0.18)';
					tctx.lineWidth = 1;
					tctx.beginPath();
					tctx.ellipse(0, 0, orb.a, orb.b, 0, 0, TAU);
					tctx.stroke();
					tctx.restore();

					/* Draw electron */
					const ea = t * orb.speed;
					const elx = orb.a * Math.cos(ea);
					const ely = orb.b * Math.sin(ea);
					const ex = acx + elx * Math.cos(orb.tilt) - ely * Math.sin(orb.tilt);
					const ey = acy + elx * Math.sin(orb.tilt) + ely * Math.cos(orb.tilt);
					glowCircle(tctx, ex, ey, 4, '#58e1ff');
				}

				/* Nucleus glow */
				const ng = tctx.createRadialGradient(acx, acy, 0, acx, acy, 12);
				ng.addColorStop(0, 'rgba(255,160,106,0.8)');
				ng.addColorStop(1, 'rgba(255,160,106,0)');
				tctx.fillStyle = ng;
				tctx.beginPath();
				tctx.arc(acx, acy, 12, 0, TAU);
				tctx.fill();
				tctx.fillStyle = '#ffb87a';
				tctx.beginPath();
				tctx.arc(acx, acy, 4, 0, TAU);
				tctx.fill();

				/* Title — multi-layer neon glow */
				const title = "Physics Club";
				tctx.save();
				tctx.translate(W / 2, H / 2);
				const pulse = 1 + 0.03 * Math.sin(t * 5);
				tctx.scale(pulse, pulse);
				tctx.textAlign = 'center';
				tctx.textBaseline = 'middle';
				const fontSize = Math.floor(Math.min(W, H) * 0.14);
				tctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial Black, sans-serif`;

				const layers = [
					{ blur: 60, color: 'rgba(88,225,255,0.4)' },
					{ blur: 90, color: 'rgba(88,225,255,0.28)' },
					{ blur: 120, color: 'rgba(160,255,106,0.18)' },
					{ blur: 150, color: 'rgba(255,122,217,0.12)' }
				];
				for (const L of layers) {
					tctx.save();
					tctx.shadowColor = L.color;
					tctx.shadowBlur = L.blur;
					tctx.fillStyle = 'rgba(0,0,0,0)';
					tctx.fillText(title, 0, 0);
					tctx.restore();
				}

				tctx.lineWidth = 3;
				tctx.strokeStyle = '#9beaff';
				tctx.strokeText(title, 0, 0);
				tctx.shadowColor = '#9beaff';
				tctx.shadowBlur = 30;
				tctx.fillStyle = '#d0f4ff';
				tctx.fillText(title, 0, 0);
				tctx.shadowBlur = 0;

				/* Subtitle */
				const subSize = Math.floor(fontSize * 0.28);
				tctx.font = `600 ${subSize}px Inter, sans-serif`;
				tctx.fillStyle = 'rgba(200,230,255,0.55)';
				tctx.fillText('Sim Showcase', 0, fontSize * 0.55);

				tctx.restore();

				/* Scene counter */
				const counterSize = Math.floor(Math.min(W, H) * 0.035);
				tctx.font = `600 ${counterSize}px Inter, sans-serif`;
				tctx.textAlign = 'center';
				tctx.fillStyle = 'rgba(200,230,255,0.4)';
				tctx.fillText(`${index + 1} / ${scenes.length}`, W / 2, H - 24);
			}

			/* ===== Scene factory ===== */
			function makeScene(name, init, draw, onResize) { return { name, init, draw, onResize: onResize || null }; }

			/* ========================================
			   SCENE: Double Pendulum — rainbow trail
			   ======================================== */
			const sceneDoublePendulum = makeScene("Chaos — Double Pendulum", function () {
				this.m1 = 1; this.m2 = 1;
				this.L1 = Math.min(W, H) * 0.22;
				this.L2 = Math.min(W, H) * 0.22;
				this.g = 9.8 * 220;
				this.theta1 = Math.PI * 0.6;
				this.theta2 = Math.PI * 0.45;
				this.w1 = 0; this.w2 = 0;
				this.pivot = { x: W * 0.5, y: H * 0.16 };
				this.trail = [];
			}, function (t) {
				const dt = 1 / 60;
				for (let k = 0; k < 2; k++) {
					const { m1, m2, L1, L2, g, theta1, theta2, w1, w2 } = this;
					const d = theta1 - theta2;
					const den = 2 * m1 + m2 - m2 * Math.cos(2 * d);
					const a1 = (-g * (2 * m1 + m2) * Math.sin(theta1) - m2 * g * Math.sin(theta1 - 2 * theta2)
						- 2 * Math.sin(d) * m2 * (w2 * w2 * L2 + w1 * w1 * L1 * Math.cos(d))) / (L1 * den);
					const a2 = (2 * Math.sin(d) * (w1 * w1 * L1 * (m1 + m2) + g * (m1 + m2) * Math.cos(theta1)
						+ w2 * w2 * L2 * m2 * Math.cos(d))) / (L2 * den);
					this.w1 += a1 * dt; this.w2 += a2 * dt;
					this.theta1 += this.w1 * dt; this.theta2 += this.w2 * dt;
				}
				const x1 = this.pivot.x + this.L1 * Math.sin(this.theta1);
				const y1 = this.pivot.y + this.L1 * Math.cos(this.theta1);
				const x2 = x1 + this.L2 * Math.sin(this.theta2);
				const y2 = y1 + this.L2 * Math.cos(this.theta2);

				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 34, 0.14);

				/* Rainbow trail */
				this.trail.push({ x: x2, y: y2 });
				if (this.trail.length > 400) this.trail.shift();
				sctx.lineWidth = 2;
				for (let i = 1; i < this.trail.length; i++) {
					const frac = i / this.trail.length;
					sctx.strokeStyle = `hsla(${frac * 360}, 100%, 60%, ${frac * 0.7})`;
					sctx.beginPath();
					sctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
					sctx.lineTo(this.trail[i].x, this.trail[i].y);
					sctx.stroke();
				}

				/* Rods */
				sctx.strokeStyle = 'rgba(255,255,255,.8)';
				sctx.lineWidth = 2;
				sctx.beginPath();
				sctx.moveTo(this.pivot.x, this.pivot.y);
				sctx.lineTo(x1, y1);
				sctx.lineTo(x2, y2);
				sctx.stroke();
				glowCircle(sctx, this.pivot.x, this.pivot.y, 5, '#58e1ff');
				glowCircle(sctx, x1, y1, 10, '#a0ff6a');
				glowCircle(sctx, x2, y2, 10, '#ff7ad9');
			}, function (w, h) {
				this.L1 = Math.min(w, h) * 0.22; this.L2 = Math.min(w, h) * 0.22;
				this.pivot = { x: w * 0.5, y: h * 0.16 };
			});

			/* ========================================
			   SCENE: Electric Field — Dipole
			   ======================================== */
			const sceneElectricField = makeScene("Electric Field — Dipole", function () {
				this.t0 = now();
				const sep = Math.min(W, H) * 0.3;
				this.qPos = { x: W / 2 - sep / 2, y: H / 2 };
				this.qNeg = { x: W / 2 + sep / 2, y: H / 2 };

				/* Pre-compute field lines */
				this.lines = [];
				const nLines = 14;
				const ds = 4;
				const maxSteps = 250;
				for (let i = 0; i < nLines; i++) {
					const angle = (i / nLines) * TAU;
					let lx = this.qPos.x + 18 * Math.cos(angle);
					let ly = this.qPos.y + 18 * Math.sin(angle);
					const pts = [{ x: lx, y: ly }];
					for (let s = 0; s < maxSteps; s++) {
						let Ex = 0, Ey = 0;
						let ddx = lx - this.qPos.x, ddy = ly - this.qPos.y;
						let r2 = ddx * ddx + ddy * ddy, r = Math.sqrt(r2);
						if (r < 6) break;
						Ex += ddx / (r2 * r); Ey += ddy / (r2 * r);
						ddx = lx - this.qNeg.x; ddy = ly - this.qNeg.y;
						r2 = ddx * ddx + ddy * ddy; r = Math.sqrt(r2);
						if (r < 18) { pts.push({ x: this.qNeg.x, y: this.qNeg.y }); break; }
						Ex -= ddx / (r2 * r); Ey -= ddy / (r2 * r);
						const Em = Math.sqrt(Ex * Ex + Ey * Ey);
						if (Em < 1e-12) break;
						lx += ds * Ex / Em; ly += ds * Ey / Em;
						if (lx < -60 || lx > W + 60 || ly < -60 || ly > H + 60) break;
						pts.push({ x: lx, y: ly });
					}
					if (pts.length > 8) this.lines.push(pts);
				}

				/* Particles flowing along lines */
				this.particles = [];
				for (const line of this.lines) {
					const np = 3;
					for (let j = 0; j < np; j++) {
						this.particles.push({ line, pos: (j / np) * line.length, speed: 50 + Math.random() * 25 });
					}
				}
			}, function (t) {
				sctx.clearRect(0, 0, W, H);
				const bg = sctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
				bg.addColorStop(0, '#0b1220');
				bg.addColorStop(1, '#070a12');
				sctx.fillStyle = bg;
				sctx.fillRect(0, 0, W, H);

				/* Draw field lines */
				for (const line of this.lines) {
					sctx.strokeStyle = 'rgba(88,225,255,0.18)';
					sctx.lineWidth = 1.2;
					sctx.beginPath();
					for (let i = 0; i < line.length; i++) {
						if (i === 0) sctx.moveTo(line[i].x, line[i].y);
						else sctx.lineTo(line[i].x, line[i].y);
					}
					sctx.stroke();
				}

				/* Animate particles */
				const dt = 1 / 60;
				for (const p of this.particles) {
					p.pos += p.speed * dt;
					if (p.pos >= p.line.length) p.pos -= p.line.length;
					const idx = Math.floor(p.pos);
					const frac = p.pos - idx;
					if (idx >= p.line.length - 1) continue;
					const px = p.line[idx].x + (p.line[idx + 1].x - p.line[idx].x) * frac;
					const py = p.line[idx].y + (p.line[idx + 1].y - p.line[idx].y) * frac;
					glowCircle(sctx, px, py, 3, '#58e1ff');
				}

				/* Charges */
				glowCircle(sctx, this.qPos.x, this.qPos.y, 16, '#ff6b6b');
				sctx.fillStyle = '#fff';
				sctx.font = 'bold 18px Inter, sans-serif';
				sctx.textAlign = 'center';
				sctx.textBaseline = 'middle';
				sctx.fillText('+', this.qPos.x, this.qPos.y);

				glowCircle(sctx, this.qNeg.x, this.qNeg.y, 16, '#4dabf7');
				sctx.fillStyle = '#fff';
				sctx.fillText('−', this.qNeg.x, this.qNeg.y);
				sctx.textAlign = 'start';
				sctx.textBaseline = 'alphabetic';

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('E = kQ/r²', 16, 24);
			});

			/* ========================================
			   SCENE: Solar System + Comet (3D)
			   ======================================== */
			const sceneSolar = makeScene("Solar System — 3D Orbits", function () {
				this.cx = W / 2; this.cy = H / 2;
				this.planets = [];
				const baseR = Math.min(W, H) * 0.16;
				const gap = baseR * 0.42;
				const cols = ['#58e1ff', '#a0ff6a', '#ffcc66', '#ff7ad9', '#9bb0ff'];
				// tilt orbits slightly for 3D effect
				for (let i = 0; i < 5; i++) {
					this.planets.push({
						a: baseR + i * gap, // semi-major axis
						b: (baseR + i * gap) * 0.98, // semi-minor (slight eccentricity)
						angle: Math.random() * TAU,
						w: 0.45 / (i + 1),
						color: cols[i],
						size: 8 + i * 2.5,
						inclination: (Math.random() - 0.5) * 0.3 // random orbital tilt
					});
				}
				this.stars = [];
				const n = Math.floor(W * H / 9000);
				for (let i = 0; i < n; i++) {
					this.stars.push({ x: Math.random() * W, y: Math.random() * H, a: 0.2 + Math.random() * 0.6, s: Math.random() < 0.06 ? 2 : 1 });
				}
				/* Comet */
				this.comet = { angle: 0, e: 0.7, a: baseR + 4.5 * gap, inclination: 0.6, trail: [] };

				// Camera / projection params
				this.camTilt = 0.6; // radian tilt of the whole system
				this.perspective = 800;
			}, function (t) {
				const dt = 1 / 60;
				sctx.clearRect(0, 0, W, H);
				sctx.fillStyle = '#070b12';
				sctx.fillRect(0, 0, W, H);

				/* Stars */
				for (const s of this.stars) {
					sctx.globalAlpha = s.a * (0.8 + 0.2 * Math.sin(t * 2 + s.x * 0.01));
					sctx.fillStyle = 'white';
					sctx.fillRect(s.x, s.y, s.s, s.s);
				}
				sctx.globalAlpha = 1;

				// 3D Projection helper
				const project = (x, y, z) => {
					// apply camera tilt (rotate around X axis)
					const ry = y * Math.cos(this.camTilt) - z * Math.sin(this.camTilt);
					const rz = y * Math.sin(this.camTilt) + z * Math.cos(this.camTilt);

					const scale = this.perspective / (this.perspective + rz);
					return {
						px: this.cx + x * scale,
						py: this.cy + ry * scale,
						scale: scale,
						z: rz
					};
				};

				/* Draw orbits */
				sctx.strokeStyle = 'rgba(255,255,255,.08)';
				sctx.lineWidth = 1.5;
				for (const p of this.planets) {
					sctx.beginPath();
					for (let a = 0; a <= TAU; a += 0.1) {
						// Parametric equation of tilted ellipse
						const x = p.a * Math.cos(a);
						const y = p.b * Math.sin(a) * Math.cos(p.inclination);
						const z = p.b * Math.sin(a) * Math.sin(p.inclination);
						const proj = project(x, y, z);
						if (a === 0) sctx.moveTo(proj.px, proj.py);
						else sctx.lineTo(proj.px, proj.py);
					}
					sctx.closePath();
					sctx.stroke();
				}

				/* Calculate Sun projection */
				const sunProj = project(0, 0, 0);

				/* Calculate Comet projection */
				const c = this.comet;
				const cr = c.a * (1 - c.e * c.e) / (1 + c.e * Math.cos(c.angle));
				const cSpeed = 800 / (cr * cr + 1000);
				c.angle += cSpeed * dt;
				const cox = cr * Math.cos(c.angle);
				const coy = cr * Math.sin(c.angle) * Math.cos(c.inclination);
				const coz = cr * Math.sin(c.angle) * Math.sin(c.inclination);
				const cometProj = project(cox, coy, coz);

				// trail needs 3D positions saved for correct projection each frame
				if (!c.trace) c.trace = [];
				c.trace.push({ x: cox, y: coy, z: coz });
				if (c.trace.length > 50) c.trace.shift();

				/* Calculate Planet projections */
				const renderableEntities = [];
				for (const p of this.planets) {
					p.angle += p.w * dt;
					const x = p.a * Math.cos(p.angle);
					const y = p.b * Math.sin(p.angle) * Math.cos(p.inclination);
					const z = p.b * Math.sin(p.angle) * Math.sin(p.inclination);
					const proj = project(x, y, z);
					renderableEntities.push({
						...proj,
						type: 'planet',
						color: p.color,
						size: p.size * proj.scale
					});
				}

				// Add sun & comet to render queue for depth sorting
				renderableEntities.push({
					...sunProj,
					type: 'sun',
					color: '#ffd36b',
					size: 36 * sunProj.scale
				});
				renderableEntities.push({
					...cometProj,
					type: 'comet'
				});

				// Z-sort (painter's algorithm)
				renderableEntities.sort((a, b) => b.z - a.z);

				/* Draw Comet trail (behind all entities that are closer) */
				sctx.beginPath();
				for (let i = 1; i < c.trace.length; i++) {
					const pt = c.trace[i];
					const proj = project(pt.x, pt.y, pt.z);
					const a = i / c.trace.length;
					sctx.strokeStyle = `rgba(180,220,255,${a * 0.5})`;
					sctx.lineWidth = 3 * a * proj.scale;
					if (i === 1) sctx.moveTo(proj.px, proj.py);
					else sctx.lineTo(proj.px, proj.py);
				}
				sctx.stroke();

				/* Draw Renderables back-to-front */
				for (const entity of renderableEntities) {
					if (entity.type === 'sun' || entity.type === 'planet') {
						glowCircle(sctx, entity.px, entity.py, entity.size, entity.color);
					} else if (entity.type === 'comet') {
						glowCircle(sctx, entity.px, entity.py, 4 * entity.scale, '#e0f0ff');
					}
				}

			}, function (w, h) { this.cx = w / 2; this.cy = h / 2; });

			/* ========================================
			   SCENE: Standing Wave — Harmonics
			   ======================================== */
			const sceneStandingWave = makeScene("Standing Wave — Harmonics", function () {
				this.t0 = now();
				this.harmonicDur = 2.5;
				this.maxN = 5;
			}, function (t) {
				const local = t - this.t0;
				const n = (Math.floor(local / this.harmonicDur) % this.maxN) + 1;
				const omega = 5;

				sctx.clearRect(0, 0, W, H);
				sctx.fillStyle = '#070b14';
				sctx.fillRect(0, 0, W, H);

				const margin = W * 0.08;
				const L = W - 2 * margin;
				const cy = H * 0.5;
				const A = H * 0.22;

				/* Fixed ends */
				sctx.fillStyle = 'rgba(255,255,255,.4)';
				sctx.fillRect(margin - 2, cy - A * 1.2, 4, A * 2.4);
				sctx.fillRect(margin + L - 2, cy - A * 1.2, 4, A * 2.4);

				/* Envelope */
				sctx.strokeStyle = 'rgba(88,225,255,.12)';
				sctx.lineWidth = 1;
				for (const sign of [1, -1]) {
					sctx.beginPath();
					for (let px = 0; px <= L; px += 2) {
						const xf = px / L;
						const env = sign * A * Math.sin(n * Math.PI * xf);
						if (px === 0) sctx.moveTo(margin, cy - env);
						else sctx.lineTo(margin + px, cy - env);
					}
					sctx.stroke();
				}

				/* Wave */
				const cosVal = Math.cos(omega * local);
				sctx.strokeStyle = '#58e1ff';
				sctx.lineWidth = 3;
				sctx.shadowColor = '#58e1ff';
				sctx.shadowBlur = 10;
				sctx.beginPath();
				for (let px = 0; px <= L; px += 2) {
					const xf = px / L;
					const yv = A * Math.sin(n * Math.PI * xf) * cosVal;
					if (px === 0) sctx.moveTo(margin, cy - yv);
					else sctx.lineTo(margin + px, cy - yv);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* Nodes */
				for (let k = 0; k <= n; k++) {
					glowCircle(sctx, margin + (k / n) * L, cy, 5, '#ff7ad9');
				}
				/* Antinodes */
				for (let k = 0; k < n; k++) {
					const axf = (k + 0.5) / n;
					const ay = A * Math.sin(n * Math.PI * axf) * cosVal;
					glowCircle(sctx, margin + axf * L, cy - ay, 4, '#a0ff6a');
				}

				/* Labels */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText(`Harmonic n = ${n}`, 16, 24);
				sctx.fillText('y(x,t) = A sin(nπx/L) cos(ωt)', 16, 44);
			});

			/* ========================================
			   SCENE: SHM — Spring + Oscilloscope
			   ======================================== */
			const sceneSpring = makeScene("SHM — Mass on a Spring", function () {
				this.t0 = now();
				this.k = 12; this.m = 1;
				this.A = Math.min(W, H) * 0.18;
				this.omega = Math.sqrt(this.k / this.m);
				this.bobR = 18;
				this.anchor = { x: W * 0.45, y: H * 0.16 };
				this.ucmCenter = { x: W * 0.2, y: H * 0.16 + 120 }; // Aligned with rest position of mass
				this.trace = [];
				this.traceMax = 200;
			}, function (t) {
				const local = t - this.t0;
				const x = this.A * Math.cos(this.omega * local); // Vertical displacement
				const bob = { x: this.anchor.x, y: this.anchor.y + 120 + x };
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 30, 0.16);

				/* Uniform Circular Motion (UCM) */
				const angle = this.omega * local;
				const ucmX = this.ucmCenter.x - this.A * Math.sin(angle);
				const ucmY = this.ucmCenter.y + this.A * Math.cos(angle); // Matches SHM x

				// UCM Circle path
				sctx.strokeStyle = 'rgba(255,255,255,.2)';
				sctx.lineWidth = 1;
				sctx.beginPath();
				sctx.arc(this.ucmCenter.x, this.ucmCenter.y, this.A, 0, TAU);
				sctx.stroke();

				// UCM Axes
				sctx.beginPath();
				sctx.moveTo(this.ucmCenter.x - this.A - 10, this.ucmCenter.y);
				sctx.lineTo(this.ucmCenter.x + this.A + 10, this.ucmCenter.y);
				sctx.moveTo(this.ucmCenter.x, this.ucmCenter.y - this.A - 10);
				sctx.lineTo(this.ucmCenter.x, this.ucmCenter.y + this.A + 10);
				sctx.stroke();

				// UCM Radius vector
				sctx.strokeStyle = 'rgba(255,122,217,.6)';
				sctx.lineWidth = 2;
				sctx.beginPath();
				sctx.moveTo(this.ucmCenter.x, this.ucmCenter.y);
				sctx.lineTo(ucmX, ucmY);
				sctx.stroke();

				// UCM Particle
				glowCircle(sctx, ucmX, ucmY, 8, '#ff7ad9');

				/* Spring & bob */
				spring(sctx, this.anchor.x, this.anchor.y, bob.x, bob.y - this.bobR, 13, 12, '#58e1ff');
				glowCircle(sctx, this.anchor.x, this.anchor.y, 6, '#8fd9ff');
				glowCircle(sctx, bob.x, bob.y, this.bobR, '#a0ff6a');

				/* Oscilloscope trace */
				this.trace.push(x);
				if (this.trace.length > this.traceMax) this.trace.shift();
				const trX = W * 0.6, trW = W * 0.35, trY = this.ucmCenter.y;

				/* Connecting Projection Line (UCM -> Bob -> Trace) */
				sctx.strokeStyle = 'rgba(255,255,255,.4)';
				sctx.setLineDash([5, 5]);
				sctx.lineWidth = 1;
				sctx.beginPath();
				sctx.moveTo(ucmX, ucmY);
				sctx.lineTo(trX, ucmY);
				sctx.stroke();
				sctx.setLineDash([]);

				/* Axis */
				sctx.strokeStyle = 'rgba(255,255,255,.15)';
				sctx.beginPath();
				sctx.moveTo(trX, trY);
				sctx.lineTo(trX + trW, trY);
				sctx.stroke();

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.4)';
				sctx.font = '12px Inter, sans-serif';
				sctx.fillText('y(t)', trX + trW + 6, trY + 4);

				/* Trace curve */
				sctx.strokeStyle = '#a0ff6a';
				sctx.lineWidth = 2;
				sctx.shadowColor = '#a0ff6a';
				sctx.shadowBlur = 6;
				sctx.beginPath();
				const dx = trW / this.traceMax;
				for (let i = 0; i < this.trace.length; i++) {
					// Newest point (i = length - 1) is at trX. Oldest point is at trX + trW.
					const px = trX + (this.trace.length - 1 - i) * dx;
					const py = trY + this.trace[i];
					if (i === 0) sctx.moveTo(px, py);
					else sctx.lineTo(px, py);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('SHM is the 1D projection of Uniform Circular Motion', 16, 24);
			}, function (w, h) {
				this.A = Math.min(w, h) * 0.18;
				this.anchor = { x: w * 0.45, y: h * 0.16 };
				this.ucmCenter = { x: w * 0.2, y: h * 0.16 + 120 };
			});

			/* ========================================
			   SCENE: Spiral Galaxy
			   ======================================== */
			const sceneGalaxy = makeScene("Spiral Galaxy", function () {
				this.cx = W / 2; this.cy = H / 2;
				this.particles = [];
				const nArms = 2;
				for (let i = 0; i < 300; i++) {
					const arm = i % nArms;
					const r = 15 + Math.random() * Math.min(W, H) * 0.38;
					const armA = (arm / nArms) * TAU;
					const spiralA = armA + Math.log(r / 15) * 1.4;
					const spread = (Math.random() - 0.5) * 0.7;
					this.particles.push({
						r, theta: spiralA + spread,
						omega: 0.55 / Math.sqrt(r / 40),
						size: 1 + Math.random() * 1.5,
						bright: 0.3 + Math.random() * 0.7,
						hue: 190 + Math.random() * 70
					});
				}
				this.bgStars = [];
				for (let i = 0; i < 120; i++) {
					this.bgStars.push({ x: Math.random() * W, y: Math.random() * H, a: 0.08 + Math.random() * 0.25 });
				}
				this.firstFrame = true;
			}, function (t) {
				const dt = 1 / 60;

				/* Fade trail */
				if (this.firstFrame) {
					sctx.fillStyle = '#060810';
					sctx.fillRect(0, 0, W, H);
					this.firstFrame = false;
				} else {
					sctx.fillStyle = 'rgba(6,8,16,0.14)';
					sctx.fillRect(0, 0, W, H);
				}

				/* Background stars (subtle) */
				for (const s of this.bgStars) {
					sctx.fillStyle = `rgba(255,255,255,${s.a})`;
					sctx.fillRect(s.x, s.y, 1, 1);
				}

				/* Central glow */
				const cg = sctx.createRadialGradient(this.cx, this.cy, 0, this.cx, this.cy, 28);
				cg.addColorStop(0, 'rgba(255,225,170,0.7)');
				cg.addColorStop(1, 'rgba(255,225,170,0)');
				sctx.fillStyle = cg;
				sctx.beginPath();
				sctx.arc(this.cx, this.cy, 28, 0, TAU);
				sctx.fill();

				/* Particles */
				for (const p of this.particles) {
					p.theta += p.omega * dt;
					const px = this.cx + p.r * Math.cos(p.theta);
					const py = this.cy + p.r * Math.sin(p.theta) * 0.55;
					sctx.fillStyle = `hsla(${p.hue},75%,68%,${p.bright})`;
					sctx.beginPath();
					sctx.arc(px, py, p.size, 0, TAU);
					sctx.fill();
				}

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.7)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('Differential rotation → spiral arms', 16, 24);
			}, function (w, h) { this.cx = w / 2; this.cy = h / 2; });

			/* ========================================
			   SCENE: Doppler Effect
			   ======================================== */
			const sceneDoppler = makeScene("Doppler Effect — Moving Source", function () {
				this.t0 = now();
				this.wave = [];
				this.c = 260; this.v = 160;
				this.y = H * 0.5; this.x = W * 0.15; this.dir = 1;
				this.emitEvery = 0.16; this.lastEmit = 0;
				this.hFront = 190; this.hBack = 340;
			}, function (t) {
				const dt = 1 / 60;
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 32, 0.18);
				this.x += this.v * this.dir * dt;
				if (this.x > W * 0.85) this.dir = -1;
				if (this.x < W * 0.15) this.dir = 1;
				if (t - this.lastEmit > this.emitEvery) { this.wave.push({ x: this.x, y: this.y, t }); this.lastEmit = t; }
				for (let i = this.wave.length - 1; i >= 0; i--) {
					const w = this.wave[i];
					const r = (t - w.t) * this.c;
					if (r > Math.max(W, H)) { this.wave.splice(i, 1); continue; }
					const ahead = (this.dir > 0 && w.x < this.x) || (this.dir < 0 && w.x > this.x);
					sctx.strokeStyle = ahead ? `hsla(${this.hFront},100%,70%,.6)` : `hsla(${this.hBack},100%,70%,.4)`;
					sctx.lineWidth = 1.8;
					sctx.beginPath();
					sctx.arc(w.x, w.y, r, 0, TAU);
					sctx.stroke();
				}
				glowCircle(sctx, this.x, this.y, 12, '#a0ff6a');
				drawArrow(sctx, this.x, this.y, this.x + this.dir * 54, this.y, '#a0ff6a');
			}, function (w, h) { this.y = h * 0.5; });



			/* ========================================
			   SCENE: Quantum Tunneling (Wave Packet)
			   ======================================== */
			const sceneQuantumTunneling = makeScene("Quantum Tunneling — Wave Packet", function () {
				this.t0 = now();
				this.k0 = 12; // central wave number
				this.sigma = W * 0.05; // width of packet
				this.x0 = W * -0.1; // starting position (slightly offscreen left)
				// calculate speed so it traverses screen + margin within dwell time
				this.v_group = (W * 1.2) / dwellSeconds;
				this.barrierX = W * 0.55;
				this.barrierW = W * 0.08;
				this.A_inc = H * 0.15; // incident amplitude
			}, function (t) {
				const local = t - this.t0;
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 32, 0.12);

				const cy = H * 0.5;

				/* Draw Barrier */
				sctx.fillStyle = 'rgba(88,225,255,0.15)';
				sctx.fillRect(this.barrierX, cy - H * 0.3, this.barrierW, H * 0.6);
				sctx.strokeStyle = 'rgba(88,225,255,0.4)';
				sctx.lineWidth = 2;
				sctx.strokeRect(this.barrierX, cy - H * 0.3, this.barrierW, H * 0.6);

				// Label barrier
				sctx.fillStyle = 'rgba(255,255,255,.5)';
				sctx.font = '12px Inter, sans-serif';
				sctx.fillText('Potential Energy Barrier', this.barrierX - 40, cy - H * 0.3 - 10);

				/* Wave packet logic (heuristic for visual effect) */
				const xc = this.x0 + this.v_group * local; // where the center of the incident packet *would* be

				sctx.strokeStyle = '#ff7ad9';
				sctx.lineWidth = 2.5;
				sctx.shadowColor = '#ff7ad9';
				sctx.shadowBlur = 8;
				sctx.beginPath();

				for (let x = 0; x < W; x += 2) {
					// 1. Incident + Reflected Region (Left of barrier)
					if (x < this.barrierX) {
						// Incoming packet
						const envInc = this.A_inc * Math.exp(-Math.pow(x - xc, 2) / (2 * this.sigma * this.sigma));
						const waveInc = envInc * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local);

						// Reflected packet (starts forming as xc crosses barrier)
						let waveRef = 0;
						if (xc > this.barrierX - this.sigma * 2) {
							// packet reflects back at -v_group
							const xc_ref = this.barrierX - (xc - this.barrierX);
							// reflection coefficient heuristic ~ 0.8
							const envRef = 0.8 * this.A_inc * Math.exp(-Math.pow(x - xc_ref, 2) / (2 * this.sigma * this.sigma));
							// phase flip on reflection
							waveRef = -envRef * Math.cos(-this.k0 * x - 2 * this.k0 * this.v_group * local);
						}

						const y = cy - (waveInc + waveRef);
						if (x === 0) sctx.moveTo(x, y);
						else sctx.lineTo(x, y);
					}
					// 2. Tunnelling Region (Inside barrier)
					else if (x >= this.barrierX && x <= this.barrierX + this.barrierW) {
						// Exponential decay
						if (xc > this.barrierX - this.sigma * 2) {
							// Amplitude at front of barrier
							const A_edge = this.A_inc * Math.exp(-Math.pow(this.barrierX - xc, 2) / (2 * this.sigma * this.sigma));
							const decayFactor = Math.exp(-0.06 * (x - this.barrierX)); // decay constant
							const y = cy - (A_edge * decayFactor * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local));
							sctx.lineTo(x, y);
						} else {
							sctx.lineTo(x, cy);
						}
					}
					// 3. Transmitted Region (Right of barrier)
					else {
						if (xc > this.barrierX + this.barrierW / 2) {
							// transmission coefficient heuristic ~ 0.15 (greatly reduced amplitude)
							const A_trans = 0.15 * this.A_inc;
							// center of transmitted packet
							const xc_trans = this.barrierX + this.barrierW + (xc - (this.barrierX + this.barrierW));
							const envTrans = A_trans * Math.exp(-Math.pow(x - xc_trans, 2) / (2 * this.sigma * this.sigma));
							const waveTrans = envTrans * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local);
							const y = cy - waveTrans;
							sctx.lineTo(x, y);
						} else {
							sctx.lineTo(x, cy);
						}
					}
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('|Ψ(x,t)|² > 0 inside and beyond classically forbidden region', 16, 24);
			});

			/* ========================================
			   SCENE: Magnetic Field — Solenoid
			   ======================================== */
			const sceneSolenoid = makeScene("Magnetic Field — Solenoid (3D)", function () {
				this.t0 = now();
				this.cx = W / 2;
				this.cy = H / 2 + 20;
				this.L = W * 0.35; // length of solenoid
				this.R = H * 0.15; // radius of solenoid
				this.perspective = 800;

				// Generate iron filings (particles) in 3D local space
				this.filings = [];
				const nFilings = 4000;
				for (let i = 0; i < nFilings; i++) {
					this.filings.push({
						x: (Math.random() - 0.5) * W * 1.2,
						y: (Math.random() - 0.5) * H * 1.2,
						z: (Math.random() - 0.5) * H * 1.2,
						length: 6 + Math.random() * 8,
						alpha: 0.2 + Math.random() * 0.6
					});
				}

				// Helper to calculate B-field at a point (3D)
				this.getBField = (x, y, z) => {
					const r_cyl = Math.sqrt(y * y + z * z);

					// Inside the solenoid
					if (Math.abs(x) < this.L / 2 && r_cyl < this.R) {
						const axialFalloff = 1 - (r_cyl / this.R) * 0.1;
						const flareX = x / (this.L / 2);
						return { bx: 10 * axialFalloff, by: y * 0.02 * flareX, bz: z * 0.02 * flareX };
					}

					// Outside (dipole approximation)
					const pole1 = { x: -this.L / 2, y: 0, z: 0 };
					const pole2 = { x: this.L / 2, y: 0, z: 0 };

					const rx1 = x - pole1.x, ry1 = y - pole1.y, rz1 = z - pole1.z;
					let r1_3 = Math.pow(rx1 * rx1 + ry1 * ry1 + rz1 * rz1, 1.5);

					const rx2 = x - pole2.x, ry2 = y - pole2.y, rz2 = z - pole2.z;
					let r2_3 = Math.pow(rx2 * rx2 + ry2 * ry2 + rz2 * rz2, 1.5);

					if (r1_3 < 100) r1_3 = 100;
					if (r2_3 < 100) r2_3 = 100;

					const Bx = rx1 / r1_3 - rx2 / r2_3;
					const By = ry1 / r1_3 - ry2 / r2_3;
					const Bz = rz1 / r1_3 - rz2 / r2_3;

					return { bx: Bx * 20000, by: By * 20000, bz: Bz * 20000 };
				};

				// Rotation axis (arbitrary off-axis)
				const ax = 0.5, ay = 0.7, az = -0.3;
				const len = Math.sqrt(ax * ax + ay * ay + az * az);
				this.rotAxis = { x: ax / len, y: ay / len, z: az / len };
				this.rotSpeed = 0.25;
			}, function (t) {
				const local = t - this.t0;
				sctx.clearRect(0, 0, W, H);

				const pulse = 0.5 + 0.5 * Math.sin(local * 3);
				drawGrid(sctx, 40, 0.05 + 0.05 * pulse);

				// Rotation matrix (Rodrigues' formula)
				const angle = local * this.rotSpeed;
				const cA = Math.cos(angle), sA = Math.sin(angle), iA = 1 - cA;
				const kx = this.rotAxis.x, ky = this.rotAxis.y, kz = this.rotAxis.z;

				const r11 = cA + kx * kx * iA, r12 = kx * ky * iA - kz * sA, r13 = kx * kz * iA + ky * sA;
				const r21 = ky * kx * iA + kz * sA, r22 = cA + ky * ky * iA, r23 = ky * kz * iA - kx * sA;
				const r31 = kz * kx * iA - ky * sA, r32 = kz * ky * iA + kx * sA, r33 = cA + kz * kz * iA;

				const rotate3D = (vx, vy, vz) => ({
					x: r11 * vx + r12 * vy + r13 * vz,
					y: r21 * vx + r22 * vy + r23 * vz,
					z: r31 * vx + r32 * vy + r33 * vz
				});

				const project = (px, py, pz) => {
					const scale = this.perspective / (this.perspective + pz + 500); // 500 = distance from camera
					return {
						x: this.cx + px * scale,
						y: this.cy + py * scale,
						scale: scale,
						z: pz
					};
				};

				const renderables = [];

				/* Process Filings */
				for (const f of this.filings) {
					const f_pulse = 0.5 + 0.5 * Math.sin(local * 4 + f.x * 0.1);
					const B = this.getBField(f.x, f.y, f.z);
					const Bmag = Math.sqrt(B.bx * B.bx + B.by * B.by + B.bz * B.bz);

					if (Bmag > 0.1) {
						const nx = B.bx / Bmag, ny = B.by / Bmag, nz = B.bz / Bmag;

						// endpoints in local 3D
						const p1_local = { x: f.x - nx * f.length / 2, y: f.y - ny * f.length / 2, z: f.z - nz * f.length / 2 };
						const p2_local = { x: f.x + nx * f.length / 2, y: f.y + ny * f.length / 2, z: f.z + nz * f.length / 2 };

						// rotate
						const p1_rot = rotate3D(p1_local.x, p1_local.y, p1_local.z);
						const p2_rot = rotate3D(p2_local.x, p2_local.y, p2_local.z);

						// project
						const p1_proj = project(p1_rot.x, p1_rot.y, p1_rot.z);
						const p2_proj = project(p2_rot.x, p2_rot.y, p2_rot.z);

						const intensity = Math.min(1, Bmag * 0.5) * f.alpha * (0.6 + 0.4 * f_pulse);

						renderables.push({
							type: 'line',
							p1: p1_proj, p2: p2_proj,
							z: (p1_proj.z + p2_proj.z) / 2, // Sort by Z
							color: `rgba(160, 255, 106, ${intensity})`,
							w: 2 * p1_proj.scale
						});
					}
				}

				/* Process Solenoid Coils */
				const nCoils = 18;
				const startX = -this.L / 2;
				const coilDx = this.L / nCoils;
				const segments = 24;

				for (let i = 0; i < nCoils; i++) {
					const cx = startX + i * coilDx;
					for (let s = 0; s < segments; s++) {
						const a1 = (s / segments) * Math.PI * 2;
						const a2 = ((s + 1) / segments) * Math.PI * 2;

						const p1_local = { x: cx, y: this.R * Math.cos(a1), z: this.R * Math.sin(a1) };
						const p2_local = { x: cx, y: this.R * Math.cos(a2), z: this.R * Math.sin(a2) };

						const p1_rot = rotate3D(p1_local.x, p1_local.y, p1_local.z);
						const p2_rot = rotate3D(p2_local.x, p2_local.y, p2_local.z);

						const p1_proj = project(p1_rot.x, p1_rot.y, p1_rot.z);
						const p2_proj = project(p2_rot.x, p2_rot.y, p2_rot.z);

						renderables.push({
							type: 'coil',
							p1: p1_proj, p2: p2_proj,
							z: (p1_proj.z + p2_proj.z) / 2,
							isFront: p1_proj.z < 0 // front of coil is physically closer (z is deeper if pos)
						});
					}
				}

				// Z-sort (Painter's algorithm: draw furthest things first, z > 0 is deep)
				renderables.sort((a, b) => b.z - a.z);

				/* Draw Renderables */
				sctx.lineCap = 'round';
				for (const r of renderables) {
					if (r.type === 'line') {
						sctx.lineWidth = r.w;
						sctx.strokeStyle = r.color;
						sctx.beginPath();
						sctx.moveTo(r.p1.x, r.p1.y);
						sctx.lineTo(r.p2.x, r.p2.y);
						sctx.stroke();
					} else if (r.type === 'dot') {
						sctx.fillStyle = r.color;
						sctx.beginPath();
						sctx.arc(r.p.x, r.p.y, r.r, 0, TAU);
						sctx.fill();
					} else if (r.type === 'coil') {
						sctx.lineWidth = 3 * r.p1.scale;
						sctx.strokeStyle = `rgba(88, 225, 255, ${r.isFront ? 0.8 + 0.2 * pulse : 0.4})`;
						sctx.shadowColor = '#58e1ff';
						sctx.shadowBlur = (r.isFront ? 10 * pulse : 0);
						sctx.beginPath();
						sctx.moveTo(r.p1.x, r.p1.y);
						sctx.lineTo(r.p2.x, r.p2.y);
						sctx.stroke();
						sctx.shadowBlur = 0;
					}
				}
				sctx.lineCap = 'butt';

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('3D Rotating Magnetic Field (Current loop approximation)', 16, 24);
			});

			/* ========================================
			   SCENE: Brownian Motion (Thermodynamics)
			   ======================================== */
			const sceneBrownian = makeScene("Brownian Motion", function () {
				this.t0 = now();
				this.cx = W / 2;
				this.cy = H / 2;

				// Large visible grain
				this.grain = {
					x: this.cx, y: this.cy,
					vx: 0, vy: 0,
					r: 32, mass: 100, // Very massive compared to fluid particles
					trail: []
				};

				// Fluid particles
				this.particles = [];
				const nParticles = 400; // Enough for chaos, few enough for performance
				const vBase = 400; // Even higher speed
				for (let i = 0; i < nParticles; i++) {
					const angle = Math.random() * TAU;
					this.particles.push({
						x: Math.random() * W,
						y: Math.random() * H,
						vx: vBase * Math.cos(angle),
						vy: vBase * Math.sin(angle),
						r: 3.5, mass: 1
					});
				}
			}, function (t) {
				const dt = 1 / 60; // Fixed timestep for stability
				const substeps = 4; // Sub-stepping for collision accuracy at high speeds
				const sdt = dt / substeps;

				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 36, 0.1);

				// Physics Engine Loop
				for (let step = 0; step < substeps; step++) {
					// 1. Move fluid particles and check collisions with walls & grain
					for (const p of this.particles) {
						p.x += p.vx * sdt;
						p.y += p.vy * sdt;

						// Wall collisions
						if (p.x < 0) { p.x = 0; p.vx *= -1; }
						if (p.x > W) { p.x = W; p.vx *= -1; }
						if (p.y < 0) { p.y = 0; p.vy *= -1; }
						if (p.y > H) { p.y = H; p.vy *= -1; }

						// Collision with large grain
						const dx = p.x - this.grain.x;
						const dy = p.y - this.grain.y;
						const distSq = dx * dx + dy * dy;
						const minDist = p.r + this.grain.r;

						if (distSq < minDist * minDist) {
							const dist = Math.sqrt(distSq);
							const nx = dx / dist; const ny = dy / dist; // normal

							// relative velocity
							const rvx = p.vx - this.grain.vx;
							const rvy = p.vy - this.grain.vy;
							const velAlongNormal = rvx * nx + rvy * ny;

							if (velAlongNormal > 0) continue; // moving apart

							// Restitution (elastic)
							const e = 1.0;
							const j = -(1 + e) * velAlongNormal / (1 / p.mass + 1 / this.grain.mass); // impulse scalar

							const impulseX = j * nx;
							const impulseY = j * ny;

							p.vx += impulseX / p.mass;
							p.vy += impulseY / p.mass;
							this.grain.vx -= impulseX / this.grain.mass;
							this.grain.vy -= impulseY / this.grain.mass;

							// push apart to prevent overlap
							const overlap = minDist - dist;
							p.x += nx * overlap * 0.5;
							p.y += ny * overlap * 0.5;
						}
					}

					// 2. Move large grain (includes dampening/viscosity)
					this.grain.x += this.grain.vx * sdt;
					this.grain.y += this.grain.vy * sdt;

					// Grain wall boundary
					if (this.grain.x < this.grain.r) { this.grain.x = this.grain.r; this.grain.vx *= -0.5; }
					if (this.grain.x > W - this.grain.r) { this.grain.x = W - this.grain.r; this.grain.vx *= -0.5; }
					if (this.grain.y < this.grain.r) { this.grain.y = this.grain.r; this.grain.vy *= -0.5; }
					if (this.grain.y > H - this.grain.r) { this.grain.y = H - this.grain.r; this.grain.vy *= -0.5; }
				}

				// Record trail (throttle pushing to array based on distance moved to make jagged path obvious)
				if (this.grain.trail.length === 0 ||
					Math.hypot(this.grain.x - this.grain.trail[this.grain.trail.length - 1].x,
						this.grain.y - this.grain.trail[this.grain.trail.length - 1].y) > 2) {
					this.grain.trail.push({ x: this.grain.x, y: this.grain.y });
					if (this.grain.trail.length > 300) this.grain.trail.shift();
				}

				/* Draw Renderables */

				// 1. Trail
				sctx.strokeStyle = 'rgba(255,255,255, 0.5)';
				sctx.lineWidth = 1.5;
				sctx.beginPath();
				for (let i = 0; i < this.grain.trail.length; i++) {
					const pt = this.grain.trail[i];
					if (i === 0) sctx.moveTo(pt.x, pt.y);
					else sctx.lineTo(pt.x, pt.y);
				}
				sctx.stroke();

				// 2. Fluid Particles
				sctx.fillStyle = 'rgba(88,225,255, 0.6)';
				sctx.beginPath();
				for (const p of this.particles) {
					sctx.moveTo(p.x, p.y);
					sctx.arc(p.x, p.y, p.r, 0, TAU);
				}
				sctx.fill();

				// 3. Large Grain
				glowCircle(sctx, this.grain.x, this.grain.y, this.grain.r, '#ffcc66');

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('Random walk emerges from microscopic fluid collisions', 16, 24);
			});

			/* ========================================
			   SCENE: Cyclotron Accelerator
			   ======================================== */
			const sceneCyclotron = makeScene("Cyclotron Accelerator", function () {
				this.t0 = now();
				this.cx = W / 2;
				this.cy = H / 2;

				this.gapW = 20; // Width of the gap between Dees
				this.deeR = Math.min(W, H) * 0.4;

				this.q = 1;     // Charge
				this.m = 1;     // Mass
				this.B = 1.2;   // Magnetic field strength (uniform everywhere)

				// Cyclotron Frequency (omega = qB/m)
				this.omega_c = (this.q * this.B) / this.m;
				// Electric field magnitude in the gap
				this.E_mag = 400; // Lower E_mag so it gains less speed per crossing

				this.p = {
					x: this.cx, y: this.cy + 2, // Start slightly off-center to kickstart spiral
					vx: 0, vy: 30, // Low initial speed for tight inner orbits
					trail: []
				};
			}, function (t) {
				const dt = 1 / 60;
				const substeps = 10; // high precision for circular orbit Integration
				const sdt = dt / substeps;

				const local = t - this.t0;

				sctx.clearRect(0, 0, W, H);

				// Background grid
				drawGrid(sctx, 30, 0.1);

				// Determine alternating E-field direction based on Cyclotron Frequency
				// The E field should switch signs every half-period T/2 = PI / omega_c
				const period = TAU / this.omega_c;
				const phase = (local % period) / period;
				// +1 if phase < 0.5 (left to right), -1 if phase >= 0.5 (right to left)
				const E_dir = (phase < 0.5) ? 1 : -1;
				const E_current = this.E_mag * E_dir;

				// Integration Loop
				for (let step = 0; step < substeps; step++) {
					// Is particle in the gap?
					const inGap = Math.abs(this.p.x - this.cx) < (this.gapW / 2);

					let fx = 0, fy = 0;

					if (inGap) {
						// Electric force F = qE
						fx += this.q * E_current;
					} else {
						// Magnetic force F = qv x B. B is out of page (z). 
						// v x B = (vy*Bz, -vx*Bz)
						fx += this.q * this.p.vy * this.B;
						fy += -this.q * this.p.vx * this.B;
					}

					// Update velocity
					this.p.vx += (fx / this.m) * sdt;
					this.p.vy += (fy / this.m) * sdt;
					// Update position
					this.p.x += this.p.vx * sdt;
					this.p.y += this.p.vy * sdt;

					// Save trail if still inside bounds
					const distFromCenter = Math.hypot(this.p.x - this.cx, this.p.y - this.cy);
					if (distFromCenter < this.deeR * 1.5 && (step === 0)) {
						this.p.trail.push({ x: this.p.x, y: this.p.y });
						if (this.p.trail.length > 600) this.p.trail.shift();
					}
				}

				/* Draw Renderables */

				// 1. Draw "Dees" (Electrodes)
				sctx.lineWidth = 4;
				sctx.strokeStyle = '#58e1ff';
				sctx.fillStyle = 'rgba(88,225,255, 0.05)';
				sctx.shadowColor = '#58e1ff';
				sctx.shadowBlur = 10;

				// Left Dee
				sctx.beginPath();
				sctx.arc(this.cx - this.gapW / 2, this.cy, this.deeR, Math.PI / 2, -Math.PI / 2);
				sctx.closePath();
				sctx.stroke(); sctx.fill();

				// Right Dee
				sctx.beginPath();
				sctx.arc(this.cx + this.gapW / 2, this.cy, this.deeR, -Math.PI / 2, Math.PI / 2);
				sctx.closePath();
				sctx.stroke(); sctx.fill();

				sctx.shadowBlur = 0;

				// 2. Draw Alternating Electric Field in Gap
				sctx.strokeStyle = `rgba(255,122,217, ${0.4 + 0.4 * Math.abs(Math.sin(local * this.omega_c))})`;
				sctx.lineWidth = 2;
				const nArrows = 7;
				for (let i = 0; i < nArrows; i++) {
					const yStart = this.cy - this.deeR * 0.8 + (i / (nArrows - 1)) * this.deeR * 1.6;
					if (E_dir > 0) {
						drawArrow(sctx, this.cx - this.gapW / 2 + 2, yStart, this.cx + this.gapW / 2 - 2, yStart, sctx.strokeStyle);
					} else {
						drawArrow(sctx, this.cx + this.gapW / 2 - 2, yStart, this.cx - this.gapW / 2 + 2, yStart, sctx.strokeStyle);
					}
				}

				// 3. Draw B-field indicators (uniform dots/crosses)
				sctx.fillStyle = 'rgba(160, 255, 106, 0.3)';
				const dotSpacing = 40;
				for (let x = this.cx - this.deeR; x <= this.cx + this.deeR; x += dotSpacing) {
					for (let y = this.cy - this.deeR; y <= this.cy + this.deeR; y += dotSpacing) {
						if (Math.hypot(x - this.cx, y - this.cy) < this.deeR - 10 && Math.abs(x - this.cx) > this.gapW / 2) {
							// Draw an "out of page" dot vector
							sctx.beginPath(); sctx.arc(x, y, 2, 0, TAU); sctx.fill();
							sctx.beginPath(); sctx.arc(x, y, 5, 0, TAU); sctx.stroke();
						}
					}
				}

				// 4. Draw Particle Trail
				sctx.strokeStyle = 'rgba(255, 204, 102, 0.8)';
				sctx.lineWidth = 2;
				sctx.beginPath();
				for (let i = 0; i < this.p.trail.length; i++) {
					const pt = this.p.trail[i];
					if (i === 0) sctx.moveTo(pt.x, pt.y);
					else sctx.lineTo(pt.x, pt.y);
				}
				sctx.stroke();

				// 5. Draw Particle
				glowCircle(sctx, this.p.x, this.p.y, 6, '#ffcc66');

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('v = qrB/m  (Alternating E-field accelerates, B-field steers)', 16, 24);
			});

			/* ===== Scene list (curated order) ===== */
			const scenes = [
				sceneDoublePendulum,  // 1 — chaotic rainbow eye-catcher
				sceneQuantumTunneling,// 2 — wave packet encountering barrier
				sceneStandingWave,    // 3 — harmonics
				sceneSolenoid,        // 4 — iron filings magnetic field
				sceneSpring,          // 5 — classic + trace
				sceneCyclotron,       // 6 — spiral accelerator
				sceneBrownian,        // 7 — thermodynamics collisions
				sceneGalaxy,          // 8 — spiral particles
				sceneDoppler          // 9 — wavefronts
			];

			let index = 0, current = null;

			/* Scene indicator dots */
			for (let i = 0; i < scenes.length; i++) {
				const d = document.createElement('div');
				d.className = 'dot';
				dotsEl.appendChild(d);
			}
			function updateDots() {
				const dots = dotsEl.children;
				for (let i = 0; i < dots.length; i++) dots[i].classList.toggle('active', i === index);
			}

			function setScene(i, showTitle = true) {
				index = (i + scenes.length) % scenes.length;
				current = scenes[index];
				hudName.textContent = current.name;
				current.init();
				lastSwitch = now();
				updateDots();
				if (showTitle) startInterstitial();
			}

			function nextScene() { setScene(index + 1); }
			function prevScene() { setScene(index - 1); }

			/* ===== Main loop ===== */
			function loop() {
				const t = now();
				if (playing) {
					elapsed = t - startBase;
					const age = t - lastSwitch;

					if (inInterstitial) {
						drawInterstitial(t);
						if (t >= interstitialUntil) endInterstitial();
					} else {
						current?.draw(t);
					}

					if (age > dwellSeconds) {
						setScene(index + 1);
					}

					const secs = Math.floor(age);
					timerEl.textContent = `${String(Math.floor(secs / 60)).padStart(2, '0')}:${String(secs % 60).padStart(2, '0')}`;
				}
				requestAnimationFrame(loop);
			}

			/* ===== Init ===== */
			resize();
			setScene(0, true);
			startBase = now();
			requestAnimationFrame(loop);
		})();
	</script>
</body>

</html>