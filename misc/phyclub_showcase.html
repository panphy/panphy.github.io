<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="robots" content="noindex, nofollow">

	<title>Physics Club — Sim Showcase</title>
	<link rel="icon" type="image/png" href="/assets/favicon.png">
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

		:root {
			--bg: #0a0d12;
			--fg: #e7f0ff;
			--accent: #58e1ff;
			--accent2: #a0ff6a;
			--accent3: #ff7ad9;
		}

		html,
		body {
			height: 100%;
			margin: 0;
			background: #0a0d12;
			color: var(--fg);
			font-family: 'Inter', sans-serif;
			overflow: hidden
		}

		#wrap {
			position: fixed;
			inset: 0;
			display: flex;
			flex-direction: column
		}

		#stage {
			flex: 1;
			position: relative
		}

		canvas {
			position: absolute;
			inset: 0;
			width: 100%;
			height: 100%
		}

		#hud {
			position: absolute;
			right: 12px;
			top: 12px;
			font-size: 12px;
			opacity: .85;
			padding: 6px 8px;
			border-radius: 8px;
			background: rgba(10, 13, 18, .45);
			backdrop-filter: blur(8px);
			border: 1px solid rgba(255, 255, 255, .08);
			text-align: right;
		}

		#sceneName {
			font-weight: 700;
			color: #d7f9ff
		}

		#timer {
			font-variant-numeric: tabular-nums;
			opacity: .85
		}

		#controls {
			height: 56px;
			display: flex;
			gap: 10px;
			align-items: center;
			justify-content: center;
			border-top: 1px solid rgba(255, 255, 255, .05);
			background: linear-gradient(to top, rgba(10, 13, 18, .7), rgba(10, 13, 18, .35));
			backdrop-filter: blur(6px)
		}

		button {
			appearance: none;
			border: 1px solid rgba(255, 255, 255, .12);
			background: rgba(255, 255, 255, .06);
			backdrop-filter: blur(4px);
			color: var(--fg);
			padding: 10px 14px;
			border-radius: 10px;
			font-weight: 700;
			letter-spacing: .04em;
			cursor: pointer;
			transition: all .25s ease
		}

		button:hover {
			border-color: rgba(88, 225, 255, .45);
			background: rgba(88, 225, 255, .1);
			box-shadow: 0 0 14px rgba(88, 225, 255, .25)
		}

		.pill {
			font-size: 12px;
			padding: 6px 10px;
			opacity: .9
		}

		.scene-dots {
			display: flex;
			gap: 6px;
			align-items: center;
			margin: 0 10px
		}

		.scene-dots .dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: rgba(255, 255, 255, .18);
			transition: all .3s ease
		}

		.scene-dots .dot.active {
			background: var(--accent);
			box-shadow: 0 0 8px var(--accent)
		}

		#hint {
			position: absolute;
			left: 12px;
			bottom: 62px;
			font-size: 12px;
			opacity: .6;
			animation: hintFade 5s forwards
		}

		@keyframes hintFade {

			0%,
			60% {
				opacity: .6
			}

			100% {
				opacity: 0
			}
		}
	</style>
</head>

<body>
	<div id="wrap">
		<div id="stage">
			<canvas id="simCanvas"></canvas>
			<canvas id="titleCanvas"></canvas>
			<div id="hud">
				<div id="sceneName">Loading…</div>
				<div id="timer">00:00</div>
			</div>
			<div id="hint">Tap / Space: Pause · Swipe / Arrows: Prev / Next · F: Fullscreen</div>
		</div>
		<div id="controls">
			<button id="prev">◀ Prev</button>
			<button id="toggle">Pause ⏸</button>
			<button id="next">Next ▶</button>
			<div class="scene-dots" id="sceneDots"></div>
			<button id="fs" class="pill">Fullscreen ⛶</button>
		</div>
	</div>

	<script>
		(() => {
			/* ===== Elements ===== */
			const sim = document.getElementById('simCanvas');
			const sctx = sim.getContext('2d');
			const tit = document.getElementById('titleCanvas');
			const tctx = tit.getContext('2d');
			const hudName = document.getElementById('sceneName');
			const timerEl = document.getElementById('timer');
			const btnPrev = document.getElementById('prev');
			const btnNext = document.getElementById('next');
			const btnToggle = document.getElementById('toggle');
			const btnFS = document.getElementById('fs');
			const stage = document.getElementById('stage');
			const dotsEl = document.getElementById('sceneDots');

			let W = 0, H = 0, D = 1;

			function resize() {
				D = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
				W = stage.clientWidth;
				H = stage.clientHeight;
				for (const c of [sim, tit]) {
					c.width = Math.floor(W * D);
					c.height = Math.floor(H * D);
					c.style.width = W + 'px';
					c.style.height = H + 'px';
				}
				sctx.setTransform(D, 0, 0, D, 0, 0);
				tctx.setTransform(D, 0, 0, D, 0, 0);
				current?.onResize?.(W, H, D);
			}
			addEventListener('resize', resize, { passive: true });

			/* ===== Timing ===== */
			const dwellSeconds = 12;
			const interstitialSeconds = 2.5;
			let interstitialUntil = 0;
			let inInterstitial = false;
			let lastSwitch = 0;
			let playing = true;
			let startBase = performance.now() / 1000;
			let elapsed = 0;

			/* ===== Interactions ===== */
			let touchStartX = null;
			sim.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].clientX; }, { passive: true });
			sim.addEventListener('touchend', e => {
				if (touchStartX == null) return;
				const dx = e.changedTouches[0].clientX - touchStartX;
				if (Math.abs(dx) > 50) { dx < 0 ? nextScene() : prevScene(); } else togglePlay();
				touchStartX = null;
			}, { passive: true });
			sim.addEventListener('click', togglePlay);
			btnPrev.onclick = prevScene;
			btnNext.onclick = nextScene;
			btnToggle.onclick = togglePlay;
			btnFS.onclick = () => {
				if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
				else document.exitFullscreen?.();
			};
			document.addEventListener('keydown', e => {
				if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); togglePlay(); }
				else if (e.key === 'ArrowRight') nextScene();
				else if (e.key === 'ArrowLeft') prevScene();
				else if (e.key === 'f' || e.key === 'F') {
					if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
					else document.exitFullscreen?.();
				}
			});

			function togglePlay() {
				playing = !playing;
				btnToggle.textContent = playing ? 'Pause ⏸' : 'Play ▶';
				if (playing) startBase = performance.now() / 1000 - elapsed;
			}

			/* ===== Helpers ===== */
			const TAU = Math.PI * 2;
			const now = () => performance.now() / 1000;

			function drawGrid(ctx, step = 28, alpha = 0.22) {
				ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
				ctx.lineWidth = 1;
				ctx.beginPath();
				for (let x = 0; x < W; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
				for (let y = 0; y < H; y += step) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
				ctx.stroke();
			}

			function glowCircle(ctx, x, y, r, color) {
				const g = ctx.createRadialGradient(x, y, 0, x, y, r * 1.6);
				g.addColorStop(0, color);
				g.addColorStop(1, 'rgba(0,0,0,0)');
				ctx.fillStyle = g;
				ctx.beginPath();
				ctx.arc(x, y, r * 1.6, 0, TAU);
				ctx.fill();
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.arc(x, y, r, 0, TAU);
				ctx.fill();
			}

			function drawArrow(ctx, x1, y1, x2, y2, color) {
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				const a = Math.atan2(y2 - y1, x2 - x1), ah = 8;
				ctx.beginPath();
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - ah * Math.cos(a - 0.45), y2 - ah * Math.sin(a - 0.45));
				ctx.lineTo(x2 - ah * Math.cos(a + 0.45), y2 - ah * Math.sin(a + 0.45));
				ctx.closePath();
				ctx.fill();
			}

			function spring(ctx, x1, y1, x2, y2, coils = 14, amp = 10, color = '#58e1ff') {
				ctx.strokeStyle = color;
				ctx.lineWidth = 2;
				const dx = x2 - x1, dy = y2 - y1, len = Math.hypot(dx, dy);
				const nx = dx / len, ny = dy / len, px = -ny, py = nx, seg = (len - 30) / coils;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x1 + nx * 10, y1 + ny * 10);
				let cx = x1 + nx * 10, cy = y1 + ny * 10;
				for (let i = 0; i < coils; i++) {
					const dir = (i % 2 ? -1 : 1), ox = px * amp * dir, oy = py * amp * dir;
					cx += nx * seg; cy += ny * seg;
					ctx.lineTo(cx + ox, cy + oy);
				}
				ctx.lineTo(x2, y2);
				ctx.stroke();
			}

			/* ===== Interstitial ===== */
			const eqTexts = ['E = mc²', 'F = ma', 'v = λf', 'E = hf', 'p = mv', 'V = IR', 'PV = nRT', 'F = qvB', 'a = v²/r', 'λ = h/p', 'ΔE = qΔV', 'W = Fd'];

			function startInterstitial() {
				inInterstitial = true;
				interstitialUntil = now() + interstitialSeconds;
				sctx.clearRect(0, 0, W, H);
			}

			function endInterstitial() {
				inInterstitial = false;
				tctx.clearRect(0, 0, W, H);
			}

			function drawInterstitial(t) {
				tctx.clearRect(0, 0, W, H);

				/* Background */
				const bg = tctx.createRadialGradient(W * 0.5, H * 0.45, 0, W * 0.5, H * 0.45, Math.max(W, H) * 0.9);
				bg.addColorStop(0, '#0b1220');
				bg.addColorStop(1, '#070a12');
				tctx.fillStyle = bg;
				tctx.fillRect(0, 0, W, H);

				/* Sparkles */
				const nStar = Math.floor(W * H / 12000);
				for (let i = 0; i < nStar; i++) {
					const sx = (i * 71) % W, sy = (i * 199) % H;
					const tw = 0.35 + 0.65 * Math.abs(Math.sin(t * 3 + i));
					tctx.fillStyle = `rgba(255,255,255,${tw * 0.55})`;
					tctx.fillRect(sx, sy, 1, 1);
				}

				/* Floating equations */
				tctx.font = '14px Inter, sans-serif';
				for (let i = 0; i < eqTexts.length; i++) {
					const ex = ((i * 137 + t * 12) % (W + 120)) - 60;
					const ey = ((i * 199 + t * 6) % (H + 80)) - 40;
					const ea = 0.08 + 0.06 * Math.sin(t * 0.7 + i * 2.5);
					tctx.fillStyle = `rgba(150,220,255,${ea})`;
					tctx.fillText(eqTexts[i], ex, ey);
				}

				/* Radial energy burst */
				for (let i = 0; i < 20; i++) {
					const a = (i / 20) * TAU + t * 0.5;
					const r0 = Math.min(W, H) * 0.07;
					const r1 = Math.min(W, H) * 0.42;
					tctx.strokeStyle = 'rgba(155,234,255,0.06)';
					tctx.lineWidth = 1.5;
					tctx.beginPath();
					tctx.moveTo(W / 2 + Math.cos(a) * r0, H / 2 + Math.sin(a) * r0);
					tctx.lineTo(W / 2 + Math.cos(a) * r1, H / 2 + Math.sin(a) * r1);
					tctx.stroke();
				}

				/* Bohr-model atom orbits */
				const acx = W / 2, acy = H / 2;
				const orbits = [
					{ a: Math.min(W, H) * 0.18, b: Math.min(W, H) * 0.06, tilt: -0.35, speed: 2.2 },
					{ a: Math.min(W, H) * 0.24, b: Math.min(W, H) * 0.07, tilt: 0.7, speed: 1.6 },
					{ a: Math.min(W, H) * 0.30, b: Math.min(W, H) * 0.08, tilt: -1.1, speed: 1.1 }
				];
				for (const orb of orbits) {
					/* Draw orbit ellipse */
					tctx.save();
					tctx.translate(acx, acy);
					tctx.rotate(orb.tilt);
					tctx.strokeStyle = 'rgba(88,225,255,0.18)';
					tctx.lineWidth = 1;
					tctx.beginPath();
					tctx.ellipse(0, 0, orb.a, orb.b, 0, 0, TAU);
					tctx.stroke();
					tctx.restore();

					/* Draw electron */
					const ea = t * orb.speed;
					const elx = orb.a * Math.cos(ea);
					const ely = orb.b * Math.sin(ea);
					const ex = acx + elx * Math.cos(orb.tilt) - ely * Math.sin(orb.tilt);
					const ey = acy + elx * Math.sin(orb.tilt) + ely * Math.cos(orb.tilt);
					glowCircle(tctx, ex, ey, 4, '#58e1ff');
				}

				/* Nucleus glow */
				const ng = tctx.createRadialGradient(acx, acy, 0, acx, acy, 12);
				ng.addColorStop(0, 'rgba(255,160,106,0.8)');
				ng.addColorStop(1, 'rgba(255,160,106,0)');
				tctx.fillStyle = ng;
				tctx.beginPath();
				tctx.arc(acx, acy, 12, 0, TAU);
				tctx.fill();
				tctx.fillStyle = '#ffb87a';
				tctx.beginPath();
				tctx.arc(acx, acy, 4, 0, TAU);
				tctx.fill();

				/* Title — multi-layer neon glow */
				const title = "Physics Club";
				tctx.save();
				tctx.translate(W / 2, H / 2);
				const pulse = 1 + 0.03 * Math.sin(t * 5);
				tctx.scale(pulse, pulse);
				tctx.textAlign = 'center';
				tctx.textBaseline = 'middle';
				const fontSize = Math.floor(Math.min(W, H) * 0.14);
				tctx.font = `800 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial Black, sans-serif`;

				const layers = [
					{ blur: 60, color: 'rgba(88,225,255,0.4)' },
					{ blur: 90, color: 'rgba(88,225,255,0.28)' },
					{ blur: 120, color: 'rgba(160,255,106,0.18)' },
					{ blur: 150, color: 'rgba(255,122,217,0.12)' }
				];
				for (const L of layers) {
					tctx.save();
					tctx.shadowColor = L.color;
					tctx.shadowBlur = L.blur;
					tctx.fillStyle = 'rgba(0,0,0,0)';
					tctx.fillText(title, 0, 0);
					tctx.restore();
				}

				tctx.lineWidth = 3;
				tctx.strokeStyle = '#9beaff';
				tctx.strokeText(title, 0, 0);
				tctx.shadowColor = '#9beaff';
				tctx.shadowBlur = 30;
				tctx.fillStyle = '#d0f4ff';
				tctx.fillText(title, 0, 0);
				tctx.shadowBlur = 0;

				/* Subtitle */
				const subSize = Math.floor(fontSize * 0.28);
				tctx.font = `600 ${subSize}px Inter, sans-serif`;
				tctx.fillStyle = 'rgba(200,230,255,0.55)';
				tctx.fillText('Sim Showcase', 0, fontSize * 0.55);

				tctx.restore();

				/* Scene counter */
				const counterSize = Math.floor(Math.min(W, H) * 0.035);
				tctx.font = `600 ${counterSize}px Inter, sans-serif`;
				tctx.textAlign = 'center';
				tctx.fillStyle = 'rgba(200,230,255,0.4)';
				tctx.fillText(`${index + 1} / ${scenes.length}`, W / 2, H - 24);
			}

			/* ===== Scene factory ===== */
			function makeScene(name, init, draw, onResize) { return { name, init, draw, onResize: onResize || null }; }

			/* ========================================
			   SCENE: Double Pendulum — rainbow trail
			   ======================================== */
			const sceneDoublePendulum = makeScene("Chaos — Double Pendulum", function () {
				this.m1 = 1; this.m2 = 1;
				this.L1 = Math.min(W, H) * 0.22;
				this.L2 = Math.min(W, H) * 0.22;
				this.g = 9.8 * 220;
				this.theta1 = Math.PI * 0.6;
				this.theta2 = Math.PI * 0.45;
				this.w1 = 0; this.w2 = 0;
				this.pivot = { x: W * 0.5, y: H * 0.16 };
				this.trail = [];
			}, function (t) {
				const dt = 1 / 60;
				for (let k = 0; k < 2; k++) {
					const { m1, m2, L1, L2, g, theta1, theta2, w1, w2 } = this;
					const d = theta1 - theta2;
					const den = 2 * m1 + m2 - m2 * Math.cos(2 * d);
					const a1 = (-g * (2 * m1 + m2) * Math.sin(theta1) - m2 * g * Math.sin(theta1 - 2 * theta2)
						- 2 * Math.sin(d) * m2 * (w2 * w2 * L2 + w1 * w1 * L1 * Math.cos(d))) / (L1 * den);
					const a2 = (2 * Math.sin(d) * (w1 * w1 * L1 * (m1 + m2) + g * (m1 + m2) * Math.cos(theta1)
						+ w2 * w2 * L2 * m2 * Math.cos(d))) / (L2 * den);
					this.w1 += a1 * dt; this.w2 += a2 * dt;
					this.theta1 += this.w1 * dt; this.theta2 += this.w2 * dt;
				}
				const x1 = this.pivot.x + this.L1 * Math.sin(this.theta1);
				const y1 = this.pivot.y + this.L1 * Math.cos(this.theta1);
				const x2 = x1 + this.L2 * Math.sin(this.theta2);
				const y2 = y1 + this.L2 * Math.cos(this.theta2);

				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 34, 0.14);

				/* Rainbow trail */
				this.trail.push({ x: x2, y: y2 });
				if (this.trail.length > 400) this.trail.shift();
				sctx.lineWidth = 2;
				for (let i = 1; i < this.trail.length; i++) {
					const frac = i / this.trail.length;
					sctx.strokeStyle = `hsla(${frac * 360}, 100%, 60%, ${frac * 0.7})`;
					sctx.beginPath();
					sctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
					sctx.lineTo(this.trail[i].x, this.trail[i].y);
					sctx.stroke();
				}

				/* Rods */
				sctx.strokeStyle = 'rgba(255,255,255,.8)';
				sctx.lineWidth = 2;
				sctx.beginPath();
				sctx.moveTo(this.pivot.x, this.pivot.y);
				sctx.lineTo(x1, y1);
				sctx.lineTo(x2, y2);
				sctx.stroke();
				glowCircle(sctx, this.pivot.x, this.pivot.y, 5, '#58e1ff');
				glowCircle(sctx, x1, y1, 10, '#a0ff6a');
				glowCircle(sctx, x2, y2, 10, '#ff7ad9');
			}, function (w, h) {
				this.L1 = Math.min(w, h) * 0.22; this.L2 = Math.min(w, h) * 0.22;
				this.pivot = { x: w * 0.5, y: h * 0.16 };
			});

			/* ========================================
			   SCENE: Electric Field — Dipole
			   ======================================== */
			const sceneElectricField = makeScene("Electric Field — Dipole", function () {
				this.t0 = now();
				const sep = Math.min(W, H) * 0.3;
				this.qPos = { x: W / 2 - sep / 2, y: H / 2 };
				this.qNeg = { x: W / 2 + sep / 2, y: H / 2 };

				/* Pre-compute field lines */
				this.lines = [];
				const nLines = 14;
				const ds = 4;
				const maxSteps = 250;
				for (let i = 0; i < nLines; i++) {
					const angle = (i / nLines) * TAU;
					let lx = this.qPos.x + 18 * Math.cos(angle);
					let ly = this.qPos.y + 18 * Math.sin(angle);
					const pts = [{ x: lx, y: ly }];
					for (let s = 0; s < maxSteps; s++) {
						let Ex = 0, Ey = 0;
						let ddx = lx - this.qPos.x, ddy = ly - this.qPos.y;
						let r2 = ddx * ddx + ddy * ddy, r = Math.sqrt(r2);
						if (r < 6) break;
						Ex += ddx / (r2 * r); Ey += ddy / (r2 * r);
						ddx = lx - this.qNeg.x; ddy = ly - this.qNeg.y;
						r2 = ddx * ddx + ddy * ddy; r = Math.sqrt(r2);
						if (r < 18) { pts.push({ x: this.qNeg.x, y: this.qNeg.y }); break; }
						Ex -= ddx / (r2 * r); Ey -= ddy / (r2 * r);
						const Em = Math.sqrt(Ex * Ex + Ey * Ey);
						if (Em < 1e-12) break;
						lx += ds * Ex / Em; ly += ds * Ey / Em;
						if (lx < -60 || lx > W + 60 || ly < -60 || ly > H + 60) break;
						pts.push({ x: lx, y: ly });
					}
					if (pts.length > 8) this.lines.push(pts);
				}

				/* Particles flowing along lines */
				this.particles = [];
				for (const line of this.lines) {
					const np = 3;
					for (let j = 0; j < np; j++) {
						this.particles.push({ line, pos: (j / np) * line.length, speed: 50 + Math.random() * 25 });
					}
				}
			}, function (t) {
				sctx.clearRect(0, 0, W, H);
				const bg = sctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
				bg.addColorStop(0, '#0b1220');
				bg.addColorStop(1, '#070a12');
				sctx.fillStyle = bg;
				sctx.fillRect(0, 0, W, H);

				/* Draw field lines */
				for (const line of this.lines) {
					sctx.strokeStyle = 'rgba(88,225,255,0.18)';
					sctx.lineWidth = 1.2;
					sctx.beginPath();
					for (let i = 0; i < line.length; i++) {
						if (i === 0) sctx.moveTo(line[i].x, line[i].y);
						else sctx.lineTo(line[i].x, line[i].y);
					}
					sctx.stroke();
				}

				/* Animate particles */
				const dt = 1 / 60;
				for (const p of this.particles) {
					p.pos += p.speed * dt;
					if (p.pos >= p.line.length) p.pos -= p.line.length;
					const idx = Math.floor(p.pos);
					const frac = p.pos - idx;
					if (idx >= p.line.length - 1) continue;
					const px = p.line[idx].x + (p.line[idx + 1].x - p.line[idx].x) * frac;
					const py = p.line[idx].y + (p.line[idx + 1].y - p.line[idx].y) * frac;
					glowCircle(sctx, px, py, 3, '#58e1ff');
				}

				/* Charges */
				glowCircle(sctx, this.qPos.x, this.qPos.y, 16, '#ff6b6b');
				sctx.fillStyle = '#fff';
				sctx.font = 'bold 18px Inter, sans-serif';
				sctx.textAlign = 'center';
				sctx.textBaseline = 'middle';
				sctx.fillText('+', this.qPos.x, this.qPos.y);

				glowCircle(sctx, this.qNeg.x, this.qNeg.y, 16, '#4dabf7');
				sctx.fillStyle = '#fff';
				sctx.fillText('−', this.qNeg.x, this.qNeg.y);
				sctx.textAlign = 'start';
				sctx.textBaseline = 'alphabetic';

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('E = kQ/r²', 16, 24);
			});

			/* ========================================
			   SCENE: Solar System + Comet (3D)
			   ======================================== */
			const sceneSolar = makeScene("Solar System — 3D Orbits", function () {
				this.cx = W / 2; this.cy = H / 2;
				this.planets = [];
				const baseR = Math.min(W, H) * 0.16;
				const gap = baseR * 0.42;
				const cols = ['#58e1ff', '#a0ff6a', '#ffcc66', '#ff7ad9', '#9bb0ff'];
				// tilt orbits slightly for 3D effect
				for (let i = 0; i < 5; i++) {
					this.planets.push({
						a: baseR + i * gap, // semi-major axis
						b: (baseR + i * gap) * 0.98, // semi-minor (slight eccentricity)
						angle: Math.random() * TAU,
						w: 0.45 / (i + 1),
						color: cols[i],
						size: 8 + i * 2.5,
						inclination: (Math.random() - 0.5) * 0.3 // random orbital tilt
					});
				}
				this.stars = [];
				const n = Math.floor(W * H / 9000);
				for (let i = 0; i < n; i++) {
					this.stars.push({ x: Math.random() * W, y: Math.random() * H, a: 0.2 + Math.random() * 0.6, s: Math.random() < 0.06 ? 2 : 1 });
				}
				/* Comet */
				this.comet = { angle: 0, e: 0.7, a: baseR + 4.5 * gap, inclination: 0.6, trail: [] };

				// Camera / projection params
				this.camTilt = 0.6; // radian tilt of the whole system
				this.perspective = 800;
			}, function (t) {
				const dt = 1 / 60;
				sctx.clearRect(0, 0, W, H);
				sctx.fillStyle = '#070b12';
				sctx.fillRect(0, 0, W, H);

				/* Stars */
				for (const s of this.stars) {
					sctx.globalAlpha = s.a * (0.8 + 0.2 * Math.sin(t * 2 + s.x * 0.01));
					sctx.fillStyle = 'white';
					sctx.fillRect(s.x, s.y, s.s, s.s);
				}
				sctx.globalAlpha = 1;

				// 3D Projection helper
				const project = (x, y, z) => {
					// apply camera tilt (rotate around X axis)
					const ry = y * Math.cos(this.camTilt) - z * Math.sin(this.camTilt);
					const rz = y * Math.sin(this.camTilt) + z * Math.cos(this.camTilt);

					const scale = this.perspective / (this.perspective + rz);
					return {
						px: this.cx + x * scale,
						py: this.cy + ry * scale,
						scale: scale,
						z: rz
					};
				};

				/* Draw orbits */
				sctx.strokeStyle = 'rgba(255,255,255,.08)';
				sctx.lineWidth = 1.5;
				for (const p of this.planets) {
					sctx.beginPath();
					for (let a = 0; a <= TAU; a += 0.1) {
						// Parametric equation of tilted ellipse
						const x = p.a * Math.cos(a);
						const y = p.b * Math.sin(a) * Math.cos(p.inclination);
						const z = p.b * Math.sin(a) * Math.sin(p.inclination);
						const proj = project(x, y, z);
						if (a === 0) sctx.moveTo(proj.px, proj.py);
						else sctx.lineTo(proj.px, proj.py);
					}
					sctx.closePath();
					sctx.stroke();
				}

				/* Calculate Sun projection */
				const sunProj = project(0, 0, 0);

				/* Calculate Comet projection */
				const c = this.comet;
				const cr = c.a * (1 - c.e * c.e) / (1 + c.e * Math.cos(c.angle));
				const cSpeed = 800 / (cr * cr + 1000);
				c.angle += cSpeed * dt;
				const cox = cr * Math.cos(c.angle);
				const coy = cr * Math.sin(c.angle) * Math.cos(c.inclination);
				const coz = cr * Math.sin(c.angle) * Math.sin(c.inclination);
				const cometProj = project(cox, coy, coz);

				// trail needs 3D positions saved for correct projection each frame
				if (!c.trace) c.trace = [];
				c.trace.push({ x: cox, y: coy, z: coz });
				if (c.trace.length > 50) c.trace.shift();

				/* Calculate Planet projections */
				const renderableEntities = [];
				for (const p of this.planets) {
					p.angle += p.w * dt;
					const x = p.a * Math.cos(p.angle);
					const y = p.b * Math.sin(p.angle) * Math.cos(p.inclination);
					const z = p.b * Math.sin(p.angle) * Math.sin(p.inclination);
					const proj = project(x, y, z);
					renderableEntities.push({
						...proj,
						type: 'planet',
						color: p.color,
						size: p.size * proj.scale
					});
				}

				// Add sun & comet to render queue for depth sorting
				renderableEntities.push({
					...sunProj,
					type: 'sun',
					color: '#ffd36b',
					size: 36 * sunProj.scale
				});
				renderableEntities.push({
					...cometProj,
					type: 'comet'
				});

				// Z-sort (painter's algorithm)
				renderableEntities.sort((a, b) => b.z - a.z);

				/* Draw Comet trail (behind all entities that are closer) */
				sctx.beginPath();
				for (let i = 1; i < c.trace.length; i++) {
					const pt = c.trace[i];
					const proj = project(pt.x, pt.y, pt.z);
					const a = i / c.trace.length;
					sctx.strokeStyle = `rgba(180,220,255,${a * 0.5})`;
					sctx.lineWidth = 3 * a * proj.scale;
					if (i === 1) sctx.moveTo(proj.px, proj.py);
					else sctx.lineTo(proj.px, proj.py);
				}
				sctx.stroke();

				/* Draw Renderables back-to-front */
				for (const entity of renderableEntities) {
					if (entity.type === 'sun' || entity.type === 'planet') {
						glowCircle(sctx, entity.px, entity.py, entity.size, entity.color);
					} else if (entity.type === 'comet') {
						glowCircle(sctx, entity.px, entity.py, 4 * entity.scale, '#e0f0ff');
					}
				}

			}, function (w, h) { this.cx = w / 2; this.cy = h / 2; });

			/* ========================================
			   SCENE: Standing Wave — Harmonics
			   ======================================== */
			const sceneStandingWave = makeScene("Standing Wave — Harmonics", function () {
				this.t0 = now();
				this.harmonicDur = 2.5;
				this.maxN = 5;
			}, function (t) {
				const local = t - this.t0;
				const n = (Math.floor(local / this.harmonicDur) % this.maxN) + 1;
				const omega = 5;

				sctx.clearRect(0, 0, W, H);
				sctx.fillStyle = '#070b14';
				sctx.fillRect(0, 0, W, H);

				const margin = W * 0.08;
				const L = W - 2 * margin;
				const cy = H * 0.5;
				const A = H * 0.22;

				/* Fixed ends */
				sctx.fillStyle = 'rgba(255,255,255,.4)';
				sctx.fillRect(margin - 2, cy - A * 1.2, 4, A * 2.4);
				sctx.fillRect(margin + L - 2, cy - A * 1.2, 4, A * 2.4);

				/* Envelope */
				sctx.strokeStyle = 'rgba(88,225,255,.12)';
				sctx.lineWidth = 1;
				for (const sign of [1, -1]) {
					sctx.beginPath();
					for (let px = 0; px <= L; px += 2) {
						const xf = px / L;
						const env = sign * A * Math.sin(n * Math.PI * xf);
						if (px === 0) sctx.moveTo(margin, cy - env);
						else sctx.lineTo(margin + px, cy - env);
					}
					sctx.stroke();
				}

				/* Wave */
				const cosVal = Math.cos(omega * local);
				sctx.strokeStyle = '#58e1ff';
				sctx.lineWidth = 3;
				sctx.shadowColor = '#58e1ff';
				sctx.shadowBlur = 10;
				sctx.beginPath();
				for (let px = 0; px <= L; px += 2) {
					const xf = px / L;
					const yv = A * Math.sin(n * Math.PI * xf) * cosVal;
					if (px === 0) sctx.moveTo(margin, cy - yv);
					else sctx.lineTo(margin + px, cy - yv);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* Nodes */
				for (let k = 0; k <= n; k++) {
					glowCircle(sctx, margin + (k / n) * L, cy, 5, '#ff7ad9');
				}
				/* Antinodes */
				for (let k = 0; k < n; k++) {
					const axf = (k + 0.5) / n;
					const ay = A * Math.sin(n * Math.PI * axf) * cosVal;
					glowCircle(sctx, margin + axf * L, cy - ay, 4, '#a0ff6a');
				}

				/* Labels */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText(`Harmonic n = ${n}`, 16, 24);
				sctx.fillText('y(x,t) = A sin(nπx/L) cos(ωt)', 16, 44);
			});

			/* ========================================
			   SCENE: EM Wave — 3D perspective
			   ======================================== */
			const sceneEMWave = makeScene("Electromagnetic Wave", function () {
				this.t0 = now();
			}, function (t) {
				const local = t - this.t0;
				sctx.clearRect(0, 0, W, H);
				sctx.fillStyle = '#070b14';
				sctx.fillRect(0, 0, W, H);

				const cx = W * 0.5, cy = H * 0.5;
				const span = Math.min(W, H) * 0.85;
				const amp = Math.min(W, H) * 0.18;
				const numPts = 120;
				const omega = 3;
				const zDx = 0.5, zDy = 0.3; // z-axis projection

				/* Propagation axis */
				sctx.strokeStyle = 'rgba(255,255,255,.2)';
				sctx.lineWidth = 1;
				sctx.beginPath();
				sctx.moveTo(cx - span * 0.45, cy);
				sctx.lineTo(cx + span * 0.45, cy);
				sctx.stroke();

				/* E field wave (vertical) */
				sctx.strokeStyle = '#58e1ff';
				sctx.lineWidth = 2.5;
				sctx.shadowColor = '#58e1ff';
				sctx.shadowBlur = 8;
				sctx.beginPath();
				for (let i = 0; i <= numPts; i++) {
					const f = i / numPts;
					const px = cx - span * 0.42 + f * span * 0.84;
					const phase = f * TAU * 2.5 - omega * local;
					const ey = amp * Math.sin(phase);
					if (i === 0) sctx.moveTo(px, cy - ey);
					else sctx.lineTo(px, cy - ey);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* E field arrows */
				const arrInt = Math.floor(numPts / 14);
				for (let i = 0; i <= numPts; i += arrInt) {
					const f = i / numPts;
					const px = cx - span * 0.42 + f * span * 0.84;
					const phase = f * TAU * 2.5 - omega * local;
					const ey = amp * Math.sin(phase);
					sctx.strokeStyle = 'rgba(88,225,255,.3)';
					sctx.lineWidth = 1;
					sctx.beginPath();
					sctx.moveTo(px, cy);
					sctx.lineTo(px, cy - ey);
					sctx.stroke();
				}

				/* B field wave (z projection) */
				sctx.strokeStyle = '#a0ff6a';
				sctx.lineWidth = 2.5;
				sctx.shadowColor = '#a0ff6a';
				sctx.shadowBlur = 8;
				sctx.beginPath();
				for (let i = 0; i <= numPts; i++) {
					const f = i / numPts;
					const px = cx - span * 0.42 + f * span * 0.84;
					const phase = f * TAU * 2.5 - omega * local;
					const bz = amp * 0.7 * Math.sin(phase);
					if (i === 0) sctx.moveTo(px + zDx * bz, cy + zDy * bz);
					else sctx.lineTo(px + zDx * bz, cy + zDy * bz);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* B arrows */
				for (let i = 0; i <= numPts; i += arrInt) {
					const f = i / numPts;
					const px = cx - span * 0.42 + f * span * 0.84;
					const phase = f * TAU * 2.5 - omega * local;
					const bz = amp * 0.7 * Math.sin(phase);
					sctx.strokeStyle = 'rgba(160,255,106,.3)';
					sctx.lineWidth = 1;
					sctx.beginPath();
					sctx.moveTo(px, cy);
					sctx.lineTo(px + zDx * bz, cy + zDy * bz);
					sctx.stroke();
				}

				/* Axis labels */
				sctx.font = 'bold 16px Inter, sans-serif';
				sctx.textAlign = 'center';
				sctx.fillStyle = '#58e1ff';
				sctx.fillText('E', cx + span * 0.44, cy - amp - 8);
				sctx.fillStyle = '#a0ff6a';
				sctx.fillText('B', cx + span * 0.44 + zDx * amp * 0.7, cy + zDy * amp * 0.7 + 16);
				sctx.fillStyle = 'rgba(255,255,255,.5)';
				sctx.font = '13px Inter, sans-serif';
				sctx.fillText('propagation →', cx + span * 0.32, cy - 6);
				sctx.textAlign = 'start';

				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('E ⊥ B ⊥ propagation direction, c = 3×10⁸ m/s', 16, 24);
			});

			/* ========================================
			   SCENE: SHM — Spring + Oscilloscope
			   ======================================== */
			const sceneSpring = makeScene("SHM — Mass on a Spring", function () {
				this.t0 = now();
				this.k = 12; this.m = 1;
				this.A = Math.min(W, H) * 0.18;
				this.omega = Math.sqrt(this.k / this.m);
				this.bobR = 18;
				this.anchor = { x: W * 0.32, y: H * 0.16 };
				this.trace = [];
				this.traceMax = 200;
			}, function (t) {
				const local = t - this.t0;
				const x = this.A * Math.cos(this.omega * local);
				const v = -this.A * this.omega * Math.sin(this.omega * local);
				const bob = { x: this.anchor.x, y: this.anchor.y + 120 + x };
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 30, 0.16);

				/* Spring & bob */
				spring(sctx, this.anchor.x, this.anchor.y, bob.x, bob.y - this.bobR, 13, 12, '#58e1ff');
				glowCircle(sctx, this.anchor.x, this.anchor.y, 6, '#8fd9ff');
				glowCircle(sctx, bob.x, bob.y, this.bobR, '#a0ff6a');

				/* Oscilloscope trace */
				this.trace.push(x);
				if (this.trace.length > this.traceMax) this.trace.shift();
				const trX = W * 0.52, trW = W * 0.42, trY = H * 0.5;

				/* Axis */
				sctx.strokeStyle = 'rgba(255,255,255,.15)';
				sctx.lineWidth = 1;
				sctx.beginPath();
				sctx.moveTo(trX, trY);
				sctx.lineTo(trX + trW, trY);
				sctx.stroke();

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.4)';
				sctx.font = '12px Inter, sans-serif';
				sctx.fillText('x(t)', trX + trW + 6, trY + 4);

				/* Trace curve */
				sctx.strokeStyle = '#a0ff6a';
				sctx.lineWidth = 2;
				sctx.shadowColor = '#a0ff6a';
				sctx.shadowBlur = 6;
				sctx.beginPath();
				for (let i = 0; i < this.trace.length; i++) {
					const px = trX + (i / this.traceMax) * trW;
					const py = trY - this.trace[i] * 0.9;
					if (i === 0) sctx.moveTo(px, py);
					else sctx.lineTo(px, py);
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('x(t) = A cos(ωt),  ω = √(k/m)', 16, 24);
			}, function (w, h) {
				this.A = Math.min(w, h) * 0.18;
				this.anchor = { x: w * 0.32, y: h * 0.16 };
			});

			/* ========================================
			   SCENE: Spiral Galaxy
			   ======================================== */
			const sceneGalaxy = makeScene("Spiral Galaxy", function () {
				this.cx = W / 2; this.cy = H / 2;
				this.particles = [];
				const nArms = 2;
				for (let i = 0; i < 300; i++) {
					const arm = i % nArms;
					const r = 15 + Math.random() * Math.min(W, H) * 0.38;
					const armA = (arm / nArms) * TAU;
					const spiralA = armA + Math.log(r / 15) * 1.4;
					const spread = (Math.random() - 0.5) * 0.7;
					this.particles.push({
						r, theta: spiralA + spread,
						omega: 0.55 / Math.sqrt(r / 40),
						size: 1 + Math.random() * 1.5,
						bright: 0.3 + Math.random() * 0.7,
						hue: 190 + Math.random() * 70
					});
				}
				this.bgStars = [];
				for (let i = 0; i < 120; i++) {
					this.bgStars.push({ x: Math.random() * W, y: Math.random() * H, a: 0.08 + Math.random() * 0.25 });
				}
				this.firstFrame = true;
			}, function (t) {
				const dt = 1 / 60;

				/* Fade trail */
				if (this.firstFrame) {
					sctx.fillStyle = '#060810';
					sctx.fillRect(0, 0, W, H);
					this.firstFrame = false;
				} else {
					sctx.fillStyle = 'rgba(6,8,16,0.14)';
					sctx.fillRect(0, 0, W, H);
				}

				/* Background stars (subtle) */
				for (const s of this.bgStars) {
					sctx.fillStyle = `rgba(255,255,255,${s.a})`;
					sctx.fillRect(s.x, s.y, 1, 1);
				}

				/* Central glow */
				const cg = sctx.createRadialGradient(this.cx, this.cy, 0, this.cx, this.cy, 28);
				cg.addColorStop(0, 'rgba(255,225,170,0.7)');
				cg.addColorStop(1, 'rgba(255,225,170,0)');
				sctx.fillStyle = cg;
				sctx.beginPath();
				sctx.arc(this.cx, this.cy, 28, 0, TAU);
				sctx.fill();

				/* Particles */
				for (const p of this.particles) {
					p.theta += p.omega * dt;
					const px = this.cx + p.r * Math.cos(p.theta);
					const py = this.cy + p.r * Math.sin(p.theta) * 0.55;
					sctx.fillStyle = `hsla(${p.hue},75%,68%,${p.bright})`;
					sctx.beginPath();
					sctx.arc(px, py, p.size, 0, TAU);
					sctx.fill();
				}

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.7)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('Differential rotation → spiral arms', 16, 24);
			}, function (w, h) { this.cx = w / 2; this.cy = h / 2; });

			/* ========================================
			   SCENE: Doppler Effect
			   ======================================== */
			const sceneDoppler = makeScene("Doppler Effect — Moving Source", function () {
				this.t0 = now();
				this.wave = [];
				this.c = 260; this.v = 160;
				this.y = H * 0.5; this.x = W * 0.15; this.dir = 1;
				this.emitEvery = 0.16; this.lastEmit = 0;
				this.hFront = 190; this.hBack = 340;
			}, function (t) {
				const dt = 1 / 60;
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 32, 0.18);
				this.x += this.v * this.dir * dt;
				if (this.x > W * 0.85) this.dir = -1;
				if (this.x < W * 0.15) this.dir = 1;
				if (t - this.lastEmit > this.emitEvery) { this.wave.push({ x: this.x, y: this.y, t }); this.lastEmit = t; }
				for (let i = this.wave.length - 1; i >= 0; i--) {
					const w = this.wave[i];
					const r = (t - w.t) * this.c;
					if (r > Math.max(W, H)) { this.wave.splice(i, 1); continue; }
					const ahead = (this.dir > 0 && w.x < this.x) || (this.dir < 0 && w.x > this.x);
					sctx.strokeStyle = ahead ? `hsla(${this.hFront},100%,70%,.6)` : `hsla(${this.hBack},100%,70%,.4)`;
					sctx.lineWidth = 1.8;
					sctx.beginPath();
					sctx.arc(w.x, w.y, r, 0, TAU);
					sctx.stroke();
				}
				glowCircle(sctx, this.x, this.y, 12, '#a0ff6a');
				drawArrow(sctx, this.x, this.y, this.x + this.dir * 54, this.y, '#a0ff6a');
			}, function (w, h) { this.y = h * 0.5; });

			/* ========================================
			   SCENE: Pendulum + afterimage trail
			   ======================================== */
			const scenePendulum = makeScene("SHM — Simple Pendulum", function () {
				this.t0 = now();
				this.L = Math.min(W, H) * 0.32;
				this.g = 9.8 * 200;
				this.theta0 = 0.48;
				this.omega = Math.sqrt(this.g / this.L);
				this.pivot = { x: W * 0.5, y: H * 0.18 };
				this.bobR = 16;
				this.trail = [];
				this.trailMax = 18;
			}, function (t) {
				const local = t - this.t0;
				const theta = this.theta0 * Math.cos(this.omega * local);
				const bx = this.pivot.x + this.L * Math.sin(theta);
				const by = this.pivot.y + this.L * Math.cos(theta);

				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 36, 0.16);

				/* Ghost trail */
				this.trail.push({ x: bx, y: by });
				if (this.trail.length > this.trailMax) this.trail.shift();
				for (let i = 0; i < this.trail.length; i++) {
					const a = (i / this.trail.length) * 0.25;
					sctx.globalAlpha = a;
					sctx.fillStyle = '#ff7ad9';
					sctx.beginPath();
					sctx.arc(this.trail[i].x, this.trail[i].y, this.bobR, 0, TAU);
					sctx.fill();
				}
				sctx.globalAlpha = 1;

				/* Rod */
				sctx.strokeStyle = 'rgba(255,255,255,.75)';
				sctx.lineWidth = 1;
				sctx.beginPath();
				sctx.moveTo(this.pivot.x, this.pivot.y);
				sctx.lineTo(bx, by);
				sctx.stroke();
				glowCircle(sctx, this.pivot.x, this.pivot.y, 6, '#58e1ff');
				glowCircle(sctx, bx, by, this.bobR, '#ff7ad9');

				/* Restoring-force arrow */
				const mid = { x: this.pivot.x + this.L * 0.5 * Math.sin(theta), y: this.pivot.y + this.L * 0.5 * Math.cos(theta) };
				drawArrow(sctx, mid.x, mid.y, mid.x - 60 * Math.sin(theta), mid.y + 60 * Math.cos(theta), '#a0ff6a');
			}, function (w, h) {
				this.L = Math.min(w, h) * 0.32;
				this.pivot = { x: w * 0.5, y: h * 0.18 };
			});

			/* ========================================
			   SCENE: Ripple Tank
			   ======================================== */
			const sceneRipple = makeScene("Wave Interference — Ripple Tank", function () {
				this.t0 = now();
				this.c = 220; this.emitEvery = 0.22; this.lastEmit = 0;
				const ccx = W * 0.4, ccy = H * 0.55, sep = Math.min(W, H) * 0.18;
				this.sources = [{ x: ccx - sep / 2, y: ccy }, { x: ccx + sep / 2, y: ccy }];
				this.fronts = [];
			}, function (t) {
				sctx.clearRect(0, 0, W, H);
				const g = sctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
				g.addColorStop(0, '#0b1220');
				g.addColorStop(1, '#070a12');
				sctx.fillStyle = g;
				sctx.fillRect(0, 0, W, H);
				if (t - this.lastEmit > this.emitEvery) {
					for (const s of this.sources) this.fronts.push({ x: s.x, y: s.y, t });
					this.lastEmit = t;
				}
				sctx.lineWidth = 1.2;
				for (let i = this.fronts.length - 1; i >= 0; i--) {
					const f = this.fronts[i];
					const r = (t - f.t) * this.c;
					if (r > Math.max(W, H)) { this.fronts.splice(i, 1); continue; }
					sctx.strokeStyle = 'rgba(88,225,255,.2)';
					sctx.beginPath();
					sctx.arc(f.x, f.y, r, 0, TAU);
					sctx.stroke();
				}
				for (const s of this.sources) glowCircle(sctx, s.x, s.y, 7, '#58e1ff');
			}, function () { });

			/* ========================================
			   SCENE: Quantum Tunneling (Wave Packet)
			   ======================================== */
			const sceneQuantumTunneling = makeScene("Quantum Tunneling — Wave Packet", function () {
				this.t0 = now();
				this.k0 = 12; // central wave number
				this.sigma = W * 0.05; // width of packet
				this.x0 = W * -0.1; // starting position (slightly offscreen left)
				// calculate speed so it traverses screen + margin within dwell time
				this.v_group = (W * 1.2) / dwellSeconds;
				this.barrierX = W * 0.55;
				this.barrierW = W * 0.08;
				this.A_inc = H * 0.15; // incident amplitude
			}, function (t) {
				const local = t - this.t0;
				sctx.clearRect(0, 0, W, H);
				drawGrid(sctx, 32, 0.12);

				const cy = H * 0.5;

				/* Draw Barrier */
				sctx.fillStyle = 'rgba(88,225,255,0.15)';
				sctx.fillRect(this.barrierX, cy - H * 0.3, this.barrierW, H * 0.6);
				sctx.strokeStyle = 'rgba(88,225,255,0.4)';
				sctx.lineWidth = 2;
				sctx.strokeRect(this.barrierX, cy - H * 0.3, this.barrierW, H * 0.6);

				// Label barrier
				sctx.fillStyle = 'rgba(255,255,255,.5)';
				sctx.font = '12px Inter, sans-serif';
				sctx.fillText('Potential Energy Barrier', this.barrierX - 40, cy - H * 0.3 - 10);

				/* Wave packet logic (heuristic for visual effect) */
				const xc = this.x0 + this.v_group * local; // where the center of the incident packet *would* be

				sctx.strokeStyle = '#ff7ad9';
				sctx.lineWidth = 2.5;
				sctx.shadowColor = '#ff7ad9';
				sctx.shadowBlur = 8;
				sctx.beginPath();

				for (let x = 0; x < W; x += 2) {
					// 1. Incident + Reflected Region (Left of barrier)
					if (x < this.barrierX) {
						// Incoming packet
						const envInc = this.A_inc * Math.exp(-Math.pow(x - xc, 2) / (2 * this.sigma * this.sigma));
						const waveInc = envInc * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local);

						// Reflected packet (starts forming as xc crosses barrier)
						let waveRef = 0;
						if (xc > this.barrierX - this.sigma * 2) {
							// packet reflects back at -v_group
							const xc_ref = this.barrierX - (xc - this.barrierX);
							// reflection coefficient heuristic ~ 0.8
							const envRef = 0.8 * this.A_inc * Math.exp(-Math.pow(x - xc_ref, 2) / (2 * this.sigma * this.sigma));
							// phase flip on reflection
							waveRef = -envRef * Math.cos(-this.k0 * x - 2 * this.k0 * this.v_group * local);
						}

						const y = cy - (waveInc + waveRef);
						if (x === 0) sctx.moveTo(x, y);
						else sctx.lineTo(x, y);
					}
					// 2. Tunnelling Region (Inside barrier)
					else if (x >= this.barrierX && x <= this.barrierX + this.barrierW) {
						// Exponential decay
						if (xc > this.barrierX - this.sigma * 2) {
							// Amplitude at front of barrier
							const A_edge = this.A_inc * Math.exp(-Math.pow(this.barrierX - xc, 2) / (2 * this.sigma * this.sigma));
							const decayFactor = Math.exp(-0.06 * (x - this.barrierX)); // decay constant
							const y = cy - (A_edge * decayFactor * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local));
							sctx.lineTo(x, y);
						} else {
							sctx.lineTo(x, cy);
						}
					}
					// 3. Transmitted Region (Right of barrier)
					else {
						if (xc > this.barrierX + this.barrierW / 2) {
							// transmission coefficient heuristic ~ 0.15 (greatly reduced amplitude)
							const A_trans = 0.15 * this.A_inc;
							// center of transmitted packet
							const xc_trans = this.barrierX + this.barrierW + (xc - (this.barrierX + this.barrierW));
							const envTrans = A_trans * Math.exp(-Math.pow(x - xc_trans, 2) / (2 * this.sigma * this.sigma));
							const waveTrans = envTrans * Math.cos(this.k0 * x - 2 * this.k0 * this.v_group * local);
							const y = cy - waveTrans;
							sctx.lineTo(x, y);
						} else {
							sctx.lineTo(x, cy);
						}
					}
				}
				sctx.stroke();
				sctx.shadowBlur = 0;

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('|Ψ(x,t)|² > 0 inside and beyond classically forbidden region', 16, 24);
			});

			/* ========================================
			   SCENE: Magnetic Field — Solenoid
			   ======================================== */
			const sceneSolenoid = makeScene("Magnetic Field — Solenoid", function () {
				this.t0 = now();
				this.cx = W / 2;
				this.cy = H / 2 + 20;
				this.L = W * 0.35; // length of solenoid
				this.R = H * 0.15; // radius of solenoid

				// Generate iron filings (particles)
				this.filings = [];
				const nFilings = 1500;
				for (let i = 0; i < nFilings; i++) {
					this.filings.push({
						x: Math.random() * W,
						y: Math.random() * H,
						length: 6 + Math.random() * 8, // Doubled filing length
						alpha: 0.2 + Math.random() * 0.6 // Increased base alpha for visibility
					});
				}

				// Helper to calculate B-field at a point (simplified Biot-Savart approximation for a finite solenoid)
				this.getBField = (x, y) => {
					// Translate to origin at center of solenoid
					const dx = x - this.cx;
					const dy = y - this.cy;

					// Inside the solenoid, near the center, field is strong and uniform
					if (Math.abs(dx) < this.L / 2 && Math.abs(dy) < this.R) {
						// stronger towards the center axis
						const axialFalloff = 1 - (Math.abs(dy) / this.R) * 0.1;
						return { bx: 10 * axialFalloff, by: dy * 0.02 };
					}

					// Outside, treat as a dipole if far away, or approximate looping field lines
					// We'll use two magnetic monopoles (poles of the solenoid) as a heuristic
					const pole1 = { x: this.cx - this.L / 2, y: this.cy };
					const pole2 = { x: this.cx + this.L / 2, y: this.cy };

					let rx1 = x - pole1.x, ry1 = y - pole1.y;
					let r1_3 = Math.pow(rx1 * rx1 + ry1 * ry1, 1.5);

					let rx2 = x - pole2.x, ry2 = y - pole2.y;
					let r2_3 = Math.pow(rx2 * rx2 + ry2 * ry2, 1.5);

					// Avoid divide by zero near poles
					if (r1_3 < 100) r1_3 = 100;
					if (r2_3 < 100) r2_3 = 100;

					// Pole 1 acts like source (N), Pole 2 acts like sink (S) for mapping lines
					const Bx = rx1 / r1_3 - rx2 / r2_3;
					const By = ry1 / r1_3 - ry2 / r2_3;

					return { bx: Bx * 20000, by: By * 20000 };
				};

			}, function (t) {
				const local = t - this.t0;
				sctx.clearRect(0, 0, W, H);

				// Pulsing background grid
				const pulse = 0.5 + 0.5 * Math.sin(local * 3);
				drawGrid(sctx, 40, 0.05 + 0.05 * pulse);

				/* Draw Filings */
				sctx.lineWidth = 2; // Made lines thicker
				for (const f of this.filings) {
					// Add some per-filing noise to time to make them twinkle
					const f_pulse = 0.5 + 0.5 * Math.sin(local * 4 + f.x * 0.1);

					const B = this.getBField(f.x, f.y);
					const Bmag = Math.sqrt(B.bx * B.bx + B.by * B.by);

					// Only draw clearly if field is strong enough
					if (Bmag > 0.1) {
						// Normalize vector to get direction
						const nx = B.bx / Bmag;
						const ny = B.by / Bmag;

						// Intensity based on field strength and pulse
						const intensity = Math.min(1, Bmag * 0.5) * f.alpha * (0.6 + 0.4 * f_pulse);

						sctx.strokeStyle = `rgba(160, 255, 106, ${intensity})`;
						sctx.beginPath();
						sctx.moveTo(f.x - nx * f.length / 2, f.y - ny * f.length / 2);
						sctx.lineTo(f.x + nx * f.length / 2, f.y + ny * f.length / 2);
						sctx.stroke();
					} else {
						// If field is very weak, just draw a faint dot
						sctx.fillStyle = `rgba(255, 255, 255, ${f.alpha * 0.35})`;
						sctx.fillRect(f.x, f.y, 2, 2); // Bigger faint dots
					}
				}

				/* Draw Solenoid Coils */
				const nCoils = 18;
				sctx.strokeStyle = '#58e1ff';
				sctx.lineWidth = 3;
				sctx.shadowColor = '#58e1ff';

				const startX = this.cx - this.L / 2;
				const coilDx = this.L / nCoils;

				// Draw back halves of coils (dimmer)
				sctx.globalAlpha = 0.3;
				sctx.shadowBlur = 0;
				for (let i = 0; i < nCoils; i++) {
					const x = startX + i * coilDx;
					sctx.beginPath();
					sctx.ellipse(x + coilDx / 2, this.cy, coilDx / 2, this.R, 0, -Math.PI / 2, Math.PI / 2, true);
					sctx.stroke();
				}

				// Draw front halves of coils (brighter, pulsating with current)
				sctx.globalAlpha = 0.8 + 0.2 * pulse;
				sctx.shadowBlur = 10 * pulse;
				for (let i = 0; i < nCoils; i++) {
					const x = startX + i * coilDx;
					sctx.beginPath();
					sctx.ellipse(x + coilDx / 2, this.cy, coilDx / 2, this.R, 0, Math.PI / 2, -Math.PI / 2, true);
					sctx.stroke();

					// Draw current arrows on front coils
					if (i % 3 === 1) {
						const ax = x + coilDx / 2;
						const ay = this.cy + this.R;
						drawArrow(sctx, ax - 5, ay, ax + 5, ay, '#58e1ff');
					}
				}
				sctx.globalAlpha = 1;
				sctx.shadowBlur = 0;

				// Label current
				sctx.fillStyle = 'rgba(88,225,255, 0.8)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('Current I', startX - 40, this.cy + this.R + 20);

				/* Label */
				sctx.fillStyle = 'rgba(255,255,255,.85)';
				sctx.font = '14px Inter, sans-serif';
				sctx.fillText('B = μ₀nI  (Uniform field inside ideal solenoid)', 16, 24);
			});

			/* ===== Scene list (curated order) ===== */
			const scenes = [
				sceneDoublePendulum,  // 1 — chaotic rainbow eye-catcher
				sceneQuantumTunneling,// 2 — wave packet encountering barrier
				sceneStandingWave,    // 3 — harmonics
				sceneEMWave,          // 4 — 3D fields
				sceneSolenoid,        // 5 — iron filings magnetic field
				sceneSpring,          // 6 — classic + trace
				sceneGalaxy,          // 7 — spiral particles
				sceneDoppler,         // 8 — wavefronts
				scenePendulum,        // 9 — swinging trail
				sceneRipple           // 10 — interference
			];

			let index = 0, current = null;

			/* Scene indicator dots */
			for (let i = 0; i < scenes.length; i++) {
				const d = document.createElement('div');
				d.className = 'dot';
				dotsEl.appendChild(d);
			}
			function updateDots() {
				const dots = dotsEl.children;
				for (let i = 0; i < dots.length; i++) dots[i].classList.toggle('active', i === index);
			}

			function setScene(i, showTitle = true) {
				index = (i + scenes.length) % scenes.length;
				current = scenes[index];
				hudName.textContent = current.name;
				current.init();
				lastSwitch = now();
				updateDots();
				if (showTitle) startInterstitial();
			}

			function nextScene() { setScene(index + 1); }
			function prevScene() { setScene(index - 1); }

			/* ===== Main loop ===== */
			function loop() {
				const t = now();
				if (playing) {
					elapsed = t - startBase;
					const age = t - lastSwitch;

					if (inInterstitial) {
						drawInterstitial(t);
						if (t >= interstitialUntil) endInterstitial();
					} else {
						current?.draw(t);
					}

					if (age > dwellSeconds) {
						setScene(index + 1);
					}

					const secs = Math.floor(age);
					timerEl.textContent = `${String(Math.floor(secs / 60)).padStart(2, '0')}:${String(secs % 60).padStart(2, '0')}`;
				}
				requestAnimationFrame(loop);
			}

			/* ===== Init ===== */
			resize();
			setScene(0, true);
			startBase = now();
			requestAnimationFrame(loop);
		})();
	</script>
</body>

</html>