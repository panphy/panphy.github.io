<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Motion Tracker with MediaInfo.js</title>

    <!-- 1) Include Chart.js for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- 2) Include MediaInfo.js (WASM build). 
         This is ~1MB or more, so be aware of loading overhead. 
         For the most up-to-date link, see: https://github.com/MediaArea/MediaInfo.js 
    -->
    <script src="https://unpkg.com/mediainfo.js/dist/MediaInfoModule.js"></script>

    <style>
        :root {
            /* Button Color Variables */
            --btn-upload-color: #0079b1; /* Blue */
            --btn-play-color: #17c5a3; /* Green */
            --btn-calibration-color: #f0bd37; /* Yellow */
            --btn-set-origin-color: #f0bd37; /* Yellow */
            --btn-export-color: #23a5d0; /* Teal */
            --btn-clear-data-color: #ee4c4c; /* Red */
            --btn-clear-calibration-color: #ec7070; /* Red */
            --btn-clear-origin-color: #ec7070; /* Red */
            
            /* Dialog Button Colors */
            --btn-confirm-color: #28a745; /* Green */
            --hover-confirm-color: #1e7e34; /* Darker Green */
            --btn-cancel-color: #dc3545; /* Red */
            --hover-cancel-color: #c82333; /* Darker Red */

            /* Plot Button Color Variables */
            --btn-plot-vx-color: #86b671;
            --btn-plot-vy-color: #86b671;
            --btn-backToPosition-color: #86b671;
        }

        body {
            font-family: 'Arial', sans-serif;
            padding: 0;
            margin: 0;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            text-align: center;
            font-size: 2.2em;
            font-weight: bold;
            margin: 0;
            padding: 10px 0;
            background-color: #333; 
            color: white; 
        }

        #warningBanner {
            background-color: #fff8e3;
            color: #856404;
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #ffeeba;
        }

        #message {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin: 15px auto;
            color: #666;
            max-width: 800px;
            line-height: 1.5;
        }

        /* Top Controls Section */
        #topControls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, auto);
            gap: 10px;
            padding: 20px;
            background-color: #f9f9f9;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Button Styles with CSS Variables */
        .control-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: filter 0.3s ease;
            width: 100%;
        }

        /* Specific Button Classes */
        .btn-upload {
            background-color: var(--btn-upload-color);
        }

        .btn-play {
            background-color: var(--btn-play-color);
        }

        .btn-calibration {
            background-color: var(--btn-calibration-color);
        }

        .btn-set-origin {
            background-color: var(--btn-set-origin-color);
        }

        .btn-export {
            background-color: var(--btn-export-color);
        }

        .btn-clear-data {
            background-color: var(--btn-clear-data-color);
        }

        .btn-clear-calibration {
            background-color: var(--btn-clear-calibration-color);
        }

        .btn-clear-origin {
            background-color: var(--btn-clear-origin-color);
        }

        /* Specific Plot Button Classes */
        .btn-plot-vx {
            background-color: var(--btn-plot-vx-color);
        }

        .btn-plot-vy {
            background-color: var(--btn-plot-vy-color);
        }

        .btn-backToPosition {
            background-color: var(--btn-backToPosition-color);
        }

        /* Hover Effect: Brightness Filter */
        .control-button:hover:not(:disabled) {
            filter: brightness(90%);
        }

        /* Dialog Button Colors */
        #calibrationPrompt button, #exportPrompt button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 48%;
            font-size: 1em;
            color: white;
            transition: filter 0.3s ease;
        }

        #calibrationPrompt #confirmCalibration, #exportPrompt #confirmExport {
            background-color: var(--btn-confirm-color);
        }

        #calibrationPrompt #cancelCalibration, #exportPrompt #cancelExport {
            background-color: var(--btn-cancel-color);
        }

        /* Hover Effect for Dialog Buttons */
        #calibrationPrompt button:hover:not(:disabled), #exportPrompt button:hover:not(:disabled) {
            filter: brightness(90%);
        }

        /* Disabled Buttons */
        .control-button:disabled {
            background-color: #a9a9a9;
            cursor: not-allowed;
        }

        /* Range Slider */
        #slider {
            appearance: none;
            background: #007bff;
            height: 5px;
            border-radius: 5px;
            outline: none;
            margin: 0 10px;
            cursor: pointer;
            width: 100%;
        }

        #slider::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #007bff;
            cursor: pointer;
            margin-top: -5px;
        }

        #slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #007bff;
            cursor: pointer;
        }

        /* Analysis Container */
        #analysisContainer {
            display: flex;
            justify-content: space-evenly;
            align-items: flex-start;
            flex-wrap: wrap;
            margin: 20px auto;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
        }

        /* Video Section */
        #videoSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 48%; 
            max-width: 600px;
            min-width: 300px;
        }

        #videoWrapper {
            position: relative;
            width: 100%;
            min-height: 200px; 
        }

        video, canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 100%;
            background-color: #f5f5f5;
            display: block;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            background-color: transparent;
        }

        #frameCanvas {
            display: none;
        }

        /* Video Control Bar and Frame Rate Message Container */
        #controlsContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            margin-top: 10px;
        }

        /* Video Control Bar */
        #videoControls {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 60%;
        }

        #videoControls .control-button {
            padding: 8px 16px;
            font-size: 0.9em;
            flex: 1; /* Ensure uniform width */
        }

        #videoControls #slider {
            width: 150px;
        }

        /* Plot Section */
        #plotSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 48%;
            min-width: 300px;
            max-width: 600px;
        }

        #chartCanvasContainer {
            width: 100%;
            height: 400px;
        }

        #chartCanvasContainer canvas {
            width: 100%;
            height: 100%;
        }

        /* Plot Buttons */
        #plotButtons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            width: 100%;
        }

        #plotButtons .control-button {
            flex: 1;
        }

        /* Calibration and Export Prompts */
        #calibrationPrompt, #exportPrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid #333;
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 300px;
            box-sizing: border-box;
        }

        #calibrationPrompt h2, #exportPrompt h2 {
            margin-top: 0;
            text-align: center;
        }

        #calibrationPrompt p, #exportPrompt p {
            text-align: center;
        }

        #calibrationPrompt form, #exportPrompt form {
            display: flex;
            flex-direction: column;
        }

        #calibrationPrompt input, #exportPrompt input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            box-sizing: border-box;
        }

        #calibrationPrompt button, #exportPrompt button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 48%;
            font-size: 1em;
            color: white;
            transition: filter 0.3s ease;
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 3;
            display: none;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background-color: red;
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        input:-webkit-autofill,
        input:-webkit-autofill:hover, 
        input:-webkit-autofill:focus, 
        input:-webkit-autofill:active {
            transition: background-color 5000s ease-in-out 0s;
            -webkit-text-fill-color: #000 !important;
            background-color: #fff !important;
        }

        /* Frame Rate Message Styling */
        #frameRateMessage {
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            color: #333;
            width: 35%; /* Adjust width as needed */
        }

        footer {
            text-align: center;
            padding: 10px;
            background: #f9f9f9;
            color: #555;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Motion Tracker</h1>
    
    <div id="warningBanner">
        <strong>Note:</strong> This application is optimized for desktop browsers; using it on iOS devices requires additional steps.
    </div>

    <!-- Top Controls Section -->
    <div id="topControls">
        <button id="uploadVideo" class="control-button btn-upload" aria-label="Upload Video">Upload Video</button>
        <button id="playPause" class="control-button btn-play" disabled>Play</button>
        <button id="calibrate" class="control-button btn-calibration" disabled>Calibration</button>
        <button id="setOrigin" class="control-button btn-set-origin" disabled>Set Origin</button>
        <button id="exportData" class="control-button btn-export" disabled>Export .csv</button>
        <button id="clearDataPoints" class="control-button btn-clear-data" disabled>Clear Data</button>
        <button id="clearCalibration" class="control-button btn-clear-calibration" disabled>Clear Calibration</button>
        <button id="clearOrigin" class="control-button btn-clear-origin" disabled>Clear Origin</button>
        <!-- Hidden Video Upload Input -->
        <input type="file" id="videoUploadInput" accept="video/*" style="display: none;">
    </div>

    <!-- Calibration Prompt -->
    <div id="calibrationPrompt">
        <h2>Calibration</h2>
        <p>Enter the actual length and unit of the drawn line:</p>
        <form autocomplete="off">
            <input type="number" id="actualLength" name="actualLength" placeholder="Actual Length" min="0.0001" step="any" autocomplete="off">
            <input type="text" id="actualUnit" name="actualUnit" placeholder="Unit (e.g., meters, cm)" autocomplete="off">
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button type="button" id="confirmCalibration">Confirm</button>
                <button type="button" id="cancelCalibration">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Export Prompt -->
    <div id="exportPrompt">
        <h2>Export Data</h2>
        <p>Enter the desired filename for the exported data:</p>
        <form autocomplete="off">
            <input type="text" id="exportFilename" name="exportFilename" placeholder="Filename" value="motion_tracker_data" autocomplete="off">
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button type="button" id="confirmExport">Export</button>
                <button type="button" id="cancelExport">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Instruction Message -->
    <div id="message">
        <p>Upload a video to begin analysis.</p>
    </div>

    <!-- Analysis Container -->
    <div id="analysisContainer">
        <!-- Video Section -->
        <div id="videoSection">
            <div id="videoWrapper">
                <canvas id="frameCanvas" style="display: none;"></canvas>
                <canvas id="overlayCanvas"></canvas>
                <div class="crosshair" id="crosshair"></div>
            </div>
            <!-- Controls Container -->
            <div id="controlsContainer">
                <!-- Frame Rate Message -->
                <div id="frameRateMessage"></div>
                <!-- Video Control Bar -->
                <div id="videoControls">
                    <input type="range" id="slider" min="0" max="1" step="0.001" value="0" disabled>
                    <span id="timeDisplay">0:00.000</span>
                </div>
            </div>
        </div>
        <!-- Plot Section -->
        <div id="plotSection">
            <div id="chartCanvasContainer">
                <canvas id="positionChart"></canvas>
            </div>
            <!-- Plot Buttons -->
            <div id="plotButtons">
                <button id="plotVx" class="control-button btn-plot-vx" disabled>vₓ vs t</button>
                <button id="plotVy" class="control-button btn-plot-vy" disabled>vᵧ vs t</button>
                <button id="backToPosition" class="control-button btn-backToPosition" disabled>x-t and y-t</button>
            </div>
        </div>
    </div>

    <script>
        // (A) First, initialize MediaInfo in an async manner:
        let mediaInfoModule = null;  // Will hold the MediaInfo WASM instance
        // We'll do this once the page loads:
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize MediaInfo with 'format: "object"' so it returns data as an object
            mediaInfoModule = await MediaInfo({ format: 'object' });
        });

        // Data Point Colors Configuration
        const dataPointColors = {
            x: '#ae72e6',
            y: '#fcb56a',
            vx: '#549ad9',
            vy: '#f48a8a'
        };

        // Create a hidden video element
        let videoElement = document.createElement('video');
        videoElement.autoplay = false;
        videoElement.controls = true;
        videoElement.muted = true;
        videoElement.playsinline = true;
        videoElement.webkitPlaysinline = true;

        // Get DOM elements
        const uploadVideoButton = document.getElementById('uploadVideo');
        const videoUploadInput = document.getElementById('videoUploadInput');
        const playPauseButton = document.getElementById('playPause');
        const calibrateButton = document.getElementById('calibrate');
        const setOriginButton = document.getElementById('setOrigin');
        const slider = document.getElementById('slider');
        const timeDisplay = document.getElementById('timeDisplay');
        const frameCanvas = document.getElementById('frameCanvas');
        const positionChartCanvas = document.getElementById('positionChart');
        const message = document.getElementById('message');
        const chartCanvasContainer = document.getElementById('chartCanvasContainer');
        const plotVxButton = document.getElementById('plotVx');
        const plotVyButton = document.getElementById('plotVy');
        const backToPositionButton = document.getElementById('backToPosition');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = frameCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');
        const clearDataPointsButton = document.getElementById('clearDataPoints');
        const clearCalibrationButton = document.getElementById('clearCalibration');
        const clearOriginButton = document.getElementById('clearOrigin');
        const exportDataButton = document.getElementById('exportData');
        const calibrationPrompt = document.getElementById('calibrationPrompt');
        const actualLengthInput = document.getElementById('actualLength');
        const actualUnitInput = document.getElementById('actualUnit');
        const confirmCalibrationButton = document.getElementById('confirmCalibration');
        const cancelCalibrationButton = document.getElementById('cancelCalibration');
        const exportPrompt = document.getElementById('exportPrompt');
        const exportFilenameInput = document.getElementById('exportFilename');
        const confirmExportButton = document.getElementById('confirmExport');
        const cancelExportButton = document.getElementById('cancelExport');
        const crosshair = document.getElementById('crosshair');
        const frameRateMessage = document.getElementById('frameRateMessage');

        // Application state variables
        let frameData = [];
        let isPlaying = false;
        let positionChart;
        let skippingFrame = false; 
        let recordedBlob = null;

        let calibrationMode = false;
        let calibrationStart = null;
        let calibrationEnd = null;
        let scaleFactor = 1; 
        let scaleUnit = "pixels";
        let isDrawingCalibration = false;

        let originMode = false;
        let originSet = false;
        let originPoint = { x: 0, y: 0 }; 

        // We'll store the frame rate once determined from MediaInfo, fallback to 30 if needed
        let frameRate = 30; // default, updated after parsing if possible

        // Define a fixed grid size in display pixels
        const gridSizeDisplay = 40; 
        // Define fixed sizes for overlay elements in display pixels
        const originDotRadiusDisplay = 5; 
        const axisLineWidthDisplay = 2; 

        // Utility functions
        function canvasYToCartesianY(y) {
            return frameCanvas.height - y;
        }

        function cartesianYToCanvasY(y) {
            return frameCanvas.height - y;
        }

        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time - Math.floor(time)) * 1000);
            return `${minutes}:${seconds.toString().padStart(2, "0")}.${milliseconds.toString().padStart(3, "0")}`;
        }

        // Prevent form submission on Enter key
        document.querySelectorAll('form').forEach(form => {
            form.addEventListener('submit', (e) => e.preventDefault());
        });

        // Initialize button states on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Disable all buttons except Upload Video
            playPauseButton.disabled = true;
            calibrateButton.disabled = true;
            setOriginButton.disabled = true;
            slider.disabled = true;
            plotVxButton.disabled = true;
            plotVyButton.disabled = true;
            backToPositionButton.disabled = true;
            clearDataPointsButton.disabled = true;
            clearCalibrationButton.disabled = true;
            clearOriginButton.disabled = true;
            exportDataButton.disabled = true;

            // Hide analysis containers
            document.getElementById('analysisContainer').style.display = "none";
            chartCanvasContainer.style.display = "none";
            // Hide frameCanvas initially
            frameCanvas.style.display = "none";
            // Hide export and calibration prompts
            calibrationPrompt.style.display = "none";
            exportPrompt.style.display = "none";
            // Clear frame rate message
            frameRateMessage.textContent = "";
        });

        // Upload Video Button Click
        uploadVideoButton.addEventListener('click', () => {
            videoUploadInput.click();
        });

        // Video Upload Input Change
        videoUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                // (B) Attempt to parse the video file's metadata with MediaInfo
                // to get the container-declared frame rate.
                try {
                    if (mediaInfoModule) {
                        const arrayBuffer = await file.arrayBuffer();
                        // analyzeData expects two callbacks:
                        //   1) size: a function returning total size 
                        //   2) readChunk: a function that slices the data 
                        const result = await mediaInfoModule.analyzeData(
                            () => arrayBuffer.byteLength,
                            (offset, length) => arrayBuffer.slice(offset, offset + length)
                        );

                        // The result is an object with .media.track[]; find the "Video" track
                        const videoTrack = result.media.track.find(t => t["@type"] === "Video");
                        if (videoTrack && videoTrack.FrameRate) {
                            frameRate = parseFloat(videoTrack.FrameRate);
                            if (isNaN(frameRate) || frameRate <= 0) {
                                frameRate = 30; 
                            }
                            console.log(`Auto-detected frame rate: ${frameRate} FPS`);
                        } else {
                            // No valid FrameRate found, fallback
                            frameRate = 30;
                            console.warn("No valid frame rate found in metadata; fallback 30 FPS");
                        }
                    } else {
                        // If mediaInfoModule was somehow not loaded, fallback
                        frameRate = 30;
                        console.warn("MediaInfo not loaded yet; fallback 30 FPS");
                    }
                } catch (err) {
                    console.warn("MediaInfo parse error, fallback 30 FPS:", err);
                    frameRate = 30;
                }

                // (C) Now that we have a frame rate guess, proceed to load the video
                recordedBlob = URL.createObjectURL(file);
                videoElement.src = recordedBlob;
                videoElement.addEventListener('loadedmetadata', onVideoLoaded);
            }
        });

        // Called once the browser has loaded the video's metadata
        function onVideoLoaded() {
            slider.max = videoElement.duration; 
            slider.value = 0; 
            timeDisplay.textContent = formatTime(0); 
            videoElement.currentTime = 0;
            videoElement.pause();

            // Force next lines to happen once after we can know the dimension
            videoElement.addEventListener('seeked', () => {
                resizeOverlay(); 
                drawOverlay();
                drawFrame();
                chartCanvasContainer.style.display = "flex"; 
                plotPosition(); // Initialize the chart
            }, { once: true });

            frameCanvas.style.display = "block";
            chartCanvasContainer.style.display = "flex"; 
            // Enable controls
            playPauseButton.removeAttribute('disabled');
            calibrateButton.removeAttribute('disabled');
            setOriginButton.removeAttribute('disabled');
            slider.removeAttribute('disabled');
            plotVxButton.removeAttribute('disabled');
            plotVyButton.removeAttribute('disabled');
            backToPositionButton.removeAttribute('disabled');
            clearDataPointsButton.removeAttribute('disabled');
            clearCalibrationButton.removeAttribute('disabled');
            clearOriginButton.removeAttribute('disabled');
            exportDataButton.removeAttribute('disabled');

            // Show analysis container
            document.getElementById('analysisContainer').style.display = "flex";

            // Update instruction message
            message.innerHTML = "<p>Use the control bar beneath the video to select the starting frame.</p><p>Select a point to track motion, and the video will skip to the next frame.</p>";

            // Show the final frame rate in the UI
            frameRateMessage.textContent = `Frame Rate = ${frameRate} FPS (Auto)`;
        }

        // Play/Pause Button Click
        playPauseButton.addEventListener('click', () => {
            togglePlayPause();
        });

        function togglePlayPause() {
            if (isPlaying) {
                videoElement.pause();
                playPauseButton.textContent = "Play";
            } else {
                videoElement.play();
                playPauseButton.textContent = "Pause";
            }
            isPlaying = !isPlaying;
        }

        // Video Time Update
        videoElement.addEventListener("timeupdate", () => {
            slider.value = videoElement.currentTime; 
            timeDisplay.textContent = formatTime(videoElement.currentTime); 
            if (!skippingFrame) drawFrame(); 
        });

        // Slider Input
        slider.addEventListener("input", () => {
            videoElement.currentTime = parseFloat(slider.value); 
        });

        // Frame Canvas Click - Add Data Point
        frameCanvas.addEventListener('click', (event) => {
            if (!calibrationMode && !originMode) {
                const rect = frameCanvas.getBoundingClientRect();
                const scaleX = frameCanvas.width / rect.width; 
                const scaleY = frameCanvas.height / rect.height; 
                const canvasX = (event.clientX - rect.left) * scaleX;
                const canvasY = (event.clientY - rect.top) * scaleY;
                const cartesianY = canvasYToCartesianY(canvasY);

                frameData.push({ x: canvasX, y: cartesianY, time: videoElement.currentTime });
                plotPosition();
                skipToNextFrame();
            }
        });

        // Overlay Canvas Click - Set Origin (if in originMode)
        overlayCanvas.addEventListener('click', (event) => {
            if (originMode && !calibrationMode) {
                const rect = overlayCanvas.getBoundingClientRect();
                const scaleX = overlayCanvas.width / rect.width;
                const scaleY = overlayCanvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                const cartesianY = canvasYToCartesianY(y);
                originPoint = { x, y: cartesianY };
                originSet = true;
                originMode = false;
                frameCanvas.style.cursor = "default";
                crosshair.style.display = "none";
                overlayCanvas.style.pointerEvents = "none";
                drawOverlay();
                plotPosition();
                message.innerHTML = "<p>Origin set. Data will now be plotted relative to the chosen origin.</p>";
            }
        });

        // Draw the current video frame and data points
        function drawFrame() {
            frameCanvas.width = videoElement.videoWidth;
            frameCanvas.height = videoElement.videoHeight;
            ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
            ctx.drawImage(videoElement, 0, 0, frameCanvas.width, frameCanvas.height);

            frameData.forEach((point) => {
                const x = point.x;
                const y = cartesianYToCanvasY(point.y);
                drawDataPoint(x, y);
            });
        }

        // Draw a single data point
        function drawDataPoint(x, y) {
            // Convert display size to canvas coordinates
            const circleRadius = originDotRadiusDisplay * (overlayCanvas.width / overlayCanvas.clientWidth); 
            const crossSize = 10 * (overlayCanvas.width / overlayCanvas.clientWidth); 

            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; 
            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1; 
            ctx.beginPath();
            ctx.moveTo(x - crossSize, y);
            ctx.lineTo(x + crossSize, y);
            ctx.moveTo(x, y - crossSize);
            ctx.lineTo(x, y + crossSize);
            ctx.stroke();
        }

        // Skip to the next frame using the (auto-detected or fallback) frame rate
        function skipToNextFrame() {
            skippingFrame = true;
            videoElement.currentTime += 1 / frameRate; 
            videoElement.addEventListener('seeked', () => {
                skippingFrame = false;
                drawFrame();
                drawOverlay(); 
            }, { once: true });
        }

        // Plot Position Data using Chart.js
        function plotPosition() {
            const xData = frameData.map((p) => parseFloat(p.time.toFixed(3))); 
            const yDataX = frameData.map((p) => parseFloat(((p.x - (originSet ? originPoint.x : 0)) * scaleFactor).toFixed(3)));
            const yDataY = frameData.map((p) => parseFloat(((p.y - (originSet ? originPoint.y : 0)) * scaleFactor).toFixed(3)));

            if (!positionChart) {
                positionChart = new Chart(positionChartCanvas.getContext("2d"), {
                    type: "scatter",
                    data: {
                        datasets: [
                            {
                                label: "x-position",
                                data: xData.map((t, i) => ({ x: t, y: yDataX[i] })),
                                borderColor: dataPointColors.x,
                                backgroundColor: dataPointColors.x,
                                showLine: false,
                                pointRadius: 4,
                            },
                            {
                                label: "y-position",
                                data: xData.map((t, i) => ({ x: t, y: yDataY[i] })),
                                borderColor: dataPointColors.y,
                                backgroundColor: dataPointColors.y,
                                showLine: false,
                                pointRadius: 4,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: "linear",
                                position: "bottom",
                                title: {
                                    display: true,
                                    text: "Time (s)",
                                },
                                grid: {
                                    color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)',
                                },
                            },
                            y: {
                                type: "linear",
                                position: "left",
                                title: {
                                    display: true,
                                    text: `Position (${scaleUnit})`,
                                },
                                grid: {
                                    color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)',
                                },
                            },
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                            }
                        }
                    },
                });
            } else {
                // Update existing chart
                positionChart.data.datasets = [
                    {
                        label: "x-position",
                        data: xData.map((t, i) => ({ x: t, y: yDataX[i] })),
                        borderColor: dataPointColors.x,
                        backgroundColor: dataPointColors.x,
                        showLine: false,
                        pointRadius: 4,
                    },
                    {
                        label: "y-position",
                        data: xData.map((t, i) => ({ x: t, y: yDataY[i] })),
                        borderColor: dataPointColors.y,
                        backgroundColor: dataPointColors.y,
                        showLine: false,
                        pointRadius: 4,
                    },
                ];
                positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
                positionChart.update();
            }
        }

        // Plot Velocity Data
        function plotVelocity(axis) {
            const windowSize = 3; 
            if (frameData.length < windowSize) {
                alert(`Insufficient data to calculate velocity. At least ${windowSize} points are needed.`);
                return;
            }

            const velocityEstimates = [];
            const velocityTimes = [];
            for (let i = 1; i < frameData.length; i++) {
                const deltaTime = frameData[i].time - frameData[i - 1].time;
                const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
                const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };

                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;
                const deltaPos = axis === 'x' ? deltaX : deltaY;

                const velocity = deltaTime > 0 ? (deltaPos * scaleFactor) / deltaTime : 0;
                if (deltaTime > 0) {
                    velocityEstimates.push(velocity);
                    velocityTimes.push(frameData[i].time);
                }
            }

            // Simple moving average or any smoothing
            const smoothedVelocities = [];
            const smoothedTimes = [];
            for (let i = 0; i < velocityEstimates.length; i++) {
                if (i < windowSize - 1) continue;
                const window = velocityEstimates.slice(i - windowSize + 1, i + 1);
                const averageVelocity = window.reduce((sum, val) => sum + val, 0) / windowSize;
                smoothedVelocities.push(parseFloat(averageVelocity.toFixed(3)));
                const timeWindow = velocityTimes.slice(i - windowSize + 1, i + 1);
                const midpointTime = (timeWindow[0] + timeWindow[windowSize - 1]) / 2;
                smoothedTimes.push(parseFloat(midpointTime.toFixed(3)));
            }

            if (!positionChart) return; // Safety check

            // Update chart with velocity data
            positionChart.data.datasets = [
                {
                    label: axis === "x" ? "x-velocity" : "y-velocity",
                    data: smoothedTimes.map((t, i) => ({ x: t, y: smoothedVelocities[i] })),
                    borderColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
                    backgroundColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
                    showLine: false,
                    pointRadius: 4,
                },
            ];
            positionChart.options.scales.y.title.text = `Velocity (${scaleUnit}/s)`;
            positionChart.update();
        }

        // Plot Velocity Buttons
        plotVxButton.addEventListener("click", () => plotVelocity("x"));
        plotVyButton.addEventListener("click", () => plotVelocity("y"));
        backToPositionButton.addEventListener("click", () => {
            plotPosition();
        });

        // Clear Data Points
        clearDataPointsButton.addEventListener("click", () => {
            frameData = []; 
            if (positionChart) {
                positionChart.data.datasets.forEach((dataset) => {
                    dataset.data = [];
                });
                positionChart.update();
            }
            drawFrame(); 
            drawOverlay(); 
            message.innerHTML = "<p>Data points cleared.</p>";
        });

        // Clear Calibration
        clearCalibrationButton.addEventListener("click", () => {
            scaleFactor = 1;
            scaleUnit = "pixels";
            calibrationStart = null;
            calibrationEnd = null;

            drawOverlay();
            drawFrame();

            if (positionChart) {
                positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
                plotPosition(); 
            }

            message.innerHTML = "<p>Calibration cleared. Positions are now in pixel units.</p>";
        });

        // Clear Origin
        clearOriginButton.addEventListener("click", () => {
            originSet = false;
            originPoint = { x: 0, y: 0 };
            drawOverlay();
            plotPosition();
            message.innerHTML = "<p>Origin cleared. Default origin (lower-left) is used.</p>";
        });

        // Export Data Button Click
        exportDataButton.addEventListener("click", () => {
            if (frameData.length === 0) {
                alert("No data to export.");
                return;
            }
            showExportPrompt();
        });

        // Show Export Prompt
        function showExportPrompt() {
            exportFilenameInput.value = "motion_tracker_data"; 
            exportPrompt.style.display = "block";
        }

        // Hide Export Prompt
        function hideExportPrompt() {
            exportPrompt.style.display = "none";
            exportFilenameInput.value = "";
        }

        // Confirm Export
        confirmExportButton.addEventListener('click', () => {
            const desiredFilename = exportFilenameInput.value.trim();

            if (desiredFilename === "") {
                alert("Please enter a valid filename.");
                return;
            }

            const sanitizedFilename = desiredFilename.replace(/[^a-zA-Z0-9-_.]/g, "_");
            let finalFilename = sanitizedFilename;
            if (!finalFilename.toLowerCase().endsWith(".csv")) {
                finalFilename += ".csv";
            }

            exportCSV(finalFilename);
            hideExportPrompt();
            message.innerHTML = `<p>Data exported as ${finalFilename}.</p>`;
        });

        // Cancel Export
        cancelExportButton.addEventListener('click', () => {
            hideExportPrompt();
            message.innerHTML = "<p>Export cancelled.</p>";
        });

        // Export CSV Function
        function exportCSV(filename) {
            const velocityData = [];
            for (let i = 1; i < frameData.length; i++) {
                const deltaTime = frameData[i].time - frameData[i - 1].time;
                const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
                const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };

                const deltaX = p2.x - p1.x;
                const deltaY = p2.y - p1.y;

                const v_x = deltaTime > 0 ? (deltaX * scaleFactor) / deltaTime : 0;
                const v_y = deltaTime > 0 ? (deltaY * scaleFactor) / deltaTime : 0;

                velocityData.push({ v_x, v_y });
            }

            let csvContent = `Time (s),x (${scaleUnit}),y (${scaleUnit}),v_x (${scaleUnit}/s),v_y (${scaleUnit}/s)\n`;

            for (let i = 0; i < frameData.length; i++) {
                const xAdj = (frameData[i].x - (originSet ? originPoint.x : 0)) * scaleFactor;
                const yAdj = (frameData[i].y - (originSet ? originPoint.y : 0)) * scaleFactor;

                const time = frameData[i].time.toFixed(3);
                const x = xAdj.toFixed(3);
                const y = yAdj.toFixed(3);
                const v_x = i > 0 ? velocityData[i - 1].v_x.toFixed(3) : "";
                const v_y = i > 0 ? velocityData[i - 1].v_y.toFixed(3) : "";
                csvContent += `${time},${x},${y},${v_x},${v_y}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Calibration Button Click
        calibrateButton.addEventListener('click', () => {
            crosshair.style.display = "none";
            overlayCanvas.style.pointerEvents = "auto"; 
            calibrationMode = true;
            isDrawingCalibration = false;
            calibrationStart = null;
            calibrationEnd = null;
            frameCanvas.style.cursor = "crosshair";
            message.innerHTML = "<p>Calibration: Click and drag on the video to draw a calibration line.</p>";
        });

        // Overlay Canvas Mousemove - Show Crosshair
        overlayCanvas.addEventListener('mousemove', (event) => {
            if (calibrationMode || originMode) {
                const rect = overlayCanvas.getBoundingClientRect();
                const crossX = event.clientX - rect.left;
                const crossY = event.clientY - rect.top;
                crosshair.style.left = `${crossX - 10}px`;
                crosshair.style.top = `${crossY - 10}px`;
                crosshair.style.display = "block";
            }
        });

        // Overlay Canvas Mousedown - Start Drawing Calibration Line
        overlayCanvas.addEventListener('mousedown', (event) => {
            if (calibrationMode) {
                isDrawingCalibration = true;
                const rect = overlayCanvas.getBoundingClientRect();
                const scaleX = overlayCanvas.width / rect.width;
                const scaleY = overlayCanvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                calibrationStart = { x, y };
                calibrationEnd = { x, y };
            }
        });

        // Overlay Canvas Mousemove - Update Calibration Line
        overlayCanvas.addEventListener('mousemove', (event) => {
            if (calibrationMode && isDrawingCalibration) {
                const rect = overlayCanvas.getBoundingClientRect();
                const scaleX = overlayCanvas.width / rect.width;
                const scaleY = overlayCanvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                calibrationEnd = { x, y };
                drawOverlay(); 
            }
        });

        // Overlay Canvas Mouseup - Finish Drawing Calibration Line
        overlayCanvas.addEventListener('mouseup', (event) => {
            if (calibrationMode && isDrawingCalibration) {
                isDrawingCalibration = false;
                calibrationMode = false;
                overlayCanvas.style.pointerEvents = "none";
                frameCanvas.style.cursor = "default";
                message.innerHTML = "<p>Calibration line drawn. Enter actual length and unit.</p>";
                showCalibrationPrompt();
            }
        });

        // Show Calibration Prompt
        function showCalibrationPrompt() {
            calibrationPrompt.style.display = "block";
        }

        // Hide Calibration Prompt
        function hideCalibrationPrompt() {
            calibrationPrompt.style.display = "none";
            actualLengthInput.value = "";
            actualUnitInput.value = "";
        }

        // Confirm Calibration
        confirmCalibrationButton.addEventListener('click', () => {
            const actualLength = parseFloat(actualLengthInput.value);
            const actualUnit = actualUnitInput.value.trim();

            if (isNaN(actualLength) || actualLength <= 0 || actualUnit === "") {
                alert("Please enter a valid actual length (positive number) and unit.");
                return;
            }

            const deltaX = calibrationEnd.x - calibrationStart.x;
            const deltaY = calibrationEnd.y - calibrationStart.y;
            const pixelLength = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (pixelLength === 0) {
                alert("Calibration line length cannot be zero.");
                return;
            }

            scaleFactor = actualLength / pixelLength;
            scaleUnit = actualUnit;

            hideCalibrationPrompt();
            drawOverlay();
            drawFrame();
            plotPosition();
            message.innerHTML = `<p>Calibration successful: 1 pixel = ${scaleFactor.toFixed(4)} ${scaleUnit}</p>`;
            crosshair.style.display = "none";
        });

        // Cancel Calibration
        cancelCalibrationButton.addEventListener('click', () => {
            hideCalibrationPrompt();
            calibrationMode = false;
            isDrawingCalibration = false;
            calibrationStart = null;
            calibrationEnd = null;
            drawOverlay();
            drawFrame();
            crosshair.style.display = "none";
            message.innerHTML = "<p>Calibration cancelled.</p>";
        });

        // Click outside Calibration or Export Prompts to close them
        window.addEventListener('click', (event) => {
            if (event.target == calibrationPrompt) {
                hideCalibrationPrompt();
                calibrationMode = false;
                isDrawingCalibration = false;
                calibrationStart = null;
                calibrationEnd = null;
                drawOverlay();
                drawFrame();
                crosshair.style.display = "none";
                overlayCanvas.style.pointerEvents = "none";
                message.innerHTML = "<p>Calibration cancelled.</p>";
            }
            if (event.target == exportPrompt) {
                hideExportPrompt();
                message.innerHTML = "<p>Export cancelled.</p>";
            }
        });

        // Set Origin Button Click
        setOriginButton.addEventListener('click', () => {
            calibrationMode = false;
            isDrawingCalibration = false;
            originMode = true;
            overlayCanvas.style.pointerEvents = "auto";
            frameCanvas.style.cursor = "crosshair";
            crosshair.style.display = "block";
            message.innerHTML = "<p>Origin Mode: Click on the video to set the new origin.</p>";
        });

        // Resize Overlay Canvas to match video dimensions
        function resizeOverlay() {
            if (videoElement.videoWidth && videoElement.videoHeight) {
                overlayCanvas.width = videoElement.videoWidth;
                overlayCanvas.height = videoElement.videoHeight;
            } else {
                overlayCanvas.width = frameCanvas.clientWidth;
                overlayCanvas.height = frameCanvas.clientHeight;
            }
        }

        // Draw Overlay - Grid, Axes, Calibration Line
        function drawOverlay() {
            resizeOverlay(); 
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            // Grid steps in *canvas* pixels
            const gridStepX = gridSizeDisplay * (overlayCanvas.width / overlayCanvas.clientWidth);
            const gridStepY = gridSizeDisplay * (overlayCanvas.height / overlayCanvas.clientHeight);

            // Add shadow for outline
            overlayCtx.save();
            overlayCtx.shadowColor = "black";
            overlayCtx.shadowBlur = 2;
            overlayCtx.strokeStyle = "white";
            overlayCtx.lineWidth = 0.5;

            // Draw vertical grid lines
            for (let x = 0; x <= overlayCanvas.width; x += gridStepX) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(x, 0);
                overlayCtx.lineTo(x, overlayCanvas.height);
                overlayCtx.stroke();
            }

            // Draw horizontal grid lines
            for (let y = 0; y <= overlayCanvas.height; y += gridStepY) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(0, y);
                overlayCtx.lineTo(overlayCanvas.width, y);
                overlayCtx.stroke();
            }
            overlayCtx.restore();

            // Draw axes if origin is set
            let ox = originSet ? originPoint.x : 0;
            let oy = originSet ? originPoint.y : 0;

            const originCanvasX = ox;
            const originCanvasY = cartesianYToCanvasY(oy);

            overlayCtx.save();
            const axisLineWidth = axisLineWidthDisplay * (overlayCanvas.width / overlayCanvas.clientWidth);
            overlayCtx.lineWidth = axisLineWidth;
            overlayCtx.shadowColor = "black";
            overlayCtx.shadowBlur = 2;

            // X axis
            overlayCtx.strokeStyle = 'white';
            overlayCtx.beginPath();
            overlayCtx.moveTo(0, originCanvasY);
            overlayCtx.lineTo(overlayCanvas.width, originCanvasY);
            overlayCtx.stroke();

            // Y axis
            overlayCtx.beginPath();
            overlayCtx.moveTo(originCanvasX, 0);
            overlayCtx.lineTo(originCanvasX, overlayCanvas.height);
            overlayCtx.stroke();
            overlayCtx.restore();

            // Origin dot
            const originDotRadius = originDotRadiusDisplay * (overlayCanvas.width / overlayCanvas.clientWidth);
            overlayCtx.fillStyle = "cyan";
            overlayCtx.beginPath();
            overlayCtx.arc(originCanvasX, originCanvasY, originDotRadius, 0, 2 * Math.PI);
            overlayCtx.fill();

            // Calibration line
            if (calibrationStart && calibrationEnd) {
                overlayCtx.save();
                overlayCtx.lineWidth = 2 * (overlayCanvas.width / overlayCanvas.clientWidth);
                overlayCtx.strokeStyle = "orange";
                overlayCtx.shadowColor = "black";
                overlayCtx.shadowBlur = 2;
                overlayCtx.setLineDash([5, 5]); 
                overlayCtx.beginPath();
                overlayCtx.moveTo(calibrationStart.x, calibrationStart.y);
                overlayCtx.lineTo(calibrationEnd.x, calibrationEnd.y);
                overlayCtx.stroke();
                overlayCtx.setLineDash([]); 
                overlayCtx.restore();
            }
        }

        // Ensure overlay and frame canvas are sized on window resize
        window.addEventListener('resize', () => {
            drawOverlay();
            drawFrame();
        });
    </script>

    <footer>
        &copy; 2024 <a href="https://panphy.github.io/">PanPhy</a>. All rights reserved.
    </footer>
</body>
</html>
