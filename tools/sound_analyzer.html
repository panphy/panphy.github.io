<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Spectrum & Waveform Analyzer</title>
  <link rel="icon" type="image/png" href="/favicon.png">
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .catch((err) => console.log('Service Worker registration failed', err));
      });
    }
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;
      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;
      --surface: #1e2129;
      --surface-alt: #17191f;
      --border: #2d3436;
      --shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5849d6;
      --btn-secondary: #00cec9;
      --btn-secondary-hover: #00b3ad;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 32px 32px;
      color: var(--text-main);
      font-family: var(--font-sans);
    }

    a {
      color: var(--brand-accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.4rem 1.25rem;
    }

    #titleBanner {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 1rem;
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(22, 24, 29, 0.85);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 0.4rem 1.1rem;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .banner-logo img {
      max-height: 28px;
      width: auto;
      height: auto;
    }

    .banner-title {
      text-align: center;
      margin: 0;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      font-family: var(--font-display);
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .banner-placeholder {
      width: 40px;
    }

    main {
      flex: 1;
      padding: 0 1.5rem 1.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .info-bar {
      max-width: 1200px;
      margin: 1.2rem auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }

    .info-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.6rem 1rem;
      box-shadow: var(--shadow);
      font-weight: 600;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .info-card span {
      display: inline-flex;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .info-card strong {
      display: inline-block;
      min-width: 9ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    details.panel {
      width: min(1100px, 100%);
      margin: 0 auto;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    details.panel summary {
      list-style: none;
      cursor: pointer;
      padding: 0.75rem 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    details.panel summary::-webkit-details-marker {
      display: none;
    }

    details.panel summary::after {
      content: "â–¾";
      font-size: 1rem;
      color: var(--text-secondary);
      transition: transform 0.2s ease;
    }

    details.panel[open] summary::after {
      transform: rotate(180deg);
    }

    details.panel[open] summary {
      border-bottom: 1px solid var(--border);
    }

    details.panel:not([open]) summary {
      border-bottom: none;
    }

    .panel-body {
      padding: 1rem;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: clamp(180px, 24vh, 240px);
      border-radius: 12px;
    }

    #visualizer {
      height: clamp(200px, 28vh, 280px);
    }

    #waveform {
      height: clamp(280px, 42vh, 420px);
      touch-action: pan-y;
    }

    #tooltip {
      position: absolute;
      display: none;
      background-color: rgba(15, 16, 20, 0.9);
      color: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      pointer-events: none;
      font-size: 0.8rem;
    }

    #sliders {
      width: min(1100px, 100%);
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.85rem 1.1rem;
    }

    #sliders label {
      display: block;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    input[type="range"] {
      width: 100%;
      cursor: pointer;
      accent-color: var(--brand-primary);
    }

    #controls {
      width: min(1100px, 100%);
      margin: 0 auto;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      justify-content: center;
    }

    button {
      margin: 0;
      padding: 0.6rem 1.4rem;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 999px;
      color: #fff;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-2px);
    }

    .toggle-button {
      background: linear-gradient(135deg, var(--btn-primary), var(--brand-accent));
      min-width: 140px;
      text-align: center;
    }

    .toggle-button:hover {
      background: linear-gradient(135deg, var(--btn-primary-hover), var(--brand-accent));
    }

    .export-button {
      background: linear-gradient(135deg, var(--btn-secondary), #0fb9b1);
    }

    .export-button:hover {
      background: linear-gradient(135deg, var(--btn-secondary-hover), #0ba39d);
    }

    footer {
      text-align: center;
      padding: 1rem 1rem 1.4rem;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    @media (pointer: coarse) {
      button,
      input,
      select,
      .control-row button {
        min-height: 44px;
        touch-action: manipulation;
      }

      input[type="range"] {
        min-height: 44px;
      }

      canvas {
        touch-action: none;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <div id="titleBanner">
        <div class="banner-logo">
          <a href="https://panphy.github.io/">
            <img src="/panphy.png" alt="PanPhy logo" />
          </a>
        </div>

        <h1 class="banner-title">Audio Spectrum & Waveform Analyzer</h1>

        <div class="banner-placeholder"></div>
      </div>
    </header>

    <main>
      <div class="info-bar">
        <div id="peak-frequency" class="info-card">
          <span>Peak Frequency</span>
          <strong id="peak-frequency-value">-- Hz</strong>
        </div>
        <div id="time-delta" class="info-card">
          <span>Marker Delta</span>
          <strong id="time-delta-value">-- ms</strong>
        </div>
      </div>

      <details class="panel" id="spectrum-panel">
        <summary>Spectrum</summary>
        <div id="visualizer-container" class="panel-body">
          <canvas id="visualizer" width="800" height="200"></canvas>
          <div id="tooltip"></div>
        </div>
      </details>

      <details class="panel" id="waveform-panel" open>
        <summary>Oscilloscope</summary>
        <div id="waveform-container" class="panel-body">
          <canvas id="waveform" width="800" height="200"></canvas>
        </div>
      </details>

      <div id="sliders">
        <div>
          <label for="yScale">Amplitude Scale</label>
          <input type="range" id="yScale" min="0.5" max="20" step="0.5" value="5">
        </div>
        <div>
          <label for="xScale">Time Scale</label>
          <input type="range" id="xScale" min="0.5" max="10" step="0.5" value="1">
        </div>
      </div>

      <div id="controls">
        <button id="toggleBtn" class="toggle-button">Start</button>
        <button id="exportSpectrumBtn" class="export-button" disabled>Export Spectrum (.csv)</button>
        <button id="exportWaveformBtn" class="export-button" disabled>Export Waveform (.csv)</button>
      </div>
    </main>

    <footer>
      &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
      <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
    </footer>
  </div>
</body>

<script>
  /* ADJUSTABLE GRID SETTINGS */
  const SQUARE_GRID_SPACING = 45;
  const SQUARE_GRID_ALPHA = 0.1;

  // ------------------ Global Variables ------------------
  let audioContext, analyzer, source, microphoneStream;
  let isRunning = false;
  let isStarting = false;
  let sampleRate;
  const fftSize = 2048;

  // Frequency data
  let dataArray;
  // Waveform data
  let timeDomainData;

  // Final paused frames
  let lastFreqFrame;
  let lastWaveFrame;

  // Zoom parameters
  let waveAmplitudeScale = 5.0;
  let waveTimeScale = 1.0;

  // DOM references
  const freqCanvas = document.getElementById('visualizer');
  const freqCtx = freqCanvas.getContext('2d');

  const waveCanvas = document.getElementById('waveform');
  const waveCtx = waveCanvas.getContext('2d');

  const tooltip = document.getElementById('tooltip');
  const peakFreqDisplay = document.getElementById('peak-frequency-value');
  const timeDeltaDisplay = document.getElementById('time-delta-value');
  const spectrumPanel = document.getElementById('spectrum-panel');
  const waveformPanel = document.getElementById('waveform-panel');

  const toggleBtn = document.getElementById('toggleBtn');
  const exportSpectrumBtn = document.getElementById('exportSpectrumBtn');
  const exportWaveformBtn = document.getElementById('exportWaveformBtn');

  const yScaleSlider = document.getElementById('yScale');
  const xScaleSlider = document.getElementById('xScale');

  const markerColor = '#ff5f1f';
  const markerGrabTolerance = 14;
  let markerA = 0.3;
  let markerB = 0.7;
  let activeMarker = null;

  let canvasDpr = 1;
  let freqCanvasSize = { width: 0, height: 0 };
  let waveCanvasSize = { width: 0, height: 0 };

  function setupCanvasResolution() {
    canvasDpr = window.devicePixelRatio || 1;

    const freqRect = freqCanvas.getBoundingClientRect();
    freqCanvasSize = { width: freqRect.width, height: freqRect.height };
    freqCanvas.width = Math.round(freqCanvasSize.width * canvasDpr);
    freqCanvas.height = Math.round(freqCanvasSize.height * canvasDpr);
    freqCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);

    const waveRect = waveCanvas.getBoundingClientRect();
    waveCanvasSize = { width: waveRect.width, height: waveRect.height };
    waveCanvas.width = Math.round(waveCanvasSize.width * canvasDpr);
    waveCanvas.height = Math.round(waveCanvasSize.height * canvasDpr);
    waveCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);
  }

  // ------------------ Main Entry ------------------
  window.addEventListener('load', async () => {
    setupCanvasResolution();
    requestAnimationFrame(drawLoop); // always running UI
    await resetAudioSession();
    // Important: do NOT auto-start audio on load.
    // User must tap Start (reliable on refresh, especially on iOS/Safari).
  });

  window.addEventListener('resize', setupCanvasResolution);

  window.addEventListener('pageshow', async (event) => {
    if (event.persisted) {
      await resetAudioSession();
    }
  });

  window.addEventListener('beforeunload', () => {
    teardownAudioSession();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (isRunning) pauseSpectrum();
    }
  });

  // ------------------ Button & Keyboard Listeners ------------------
  toggleBtn.addEventListener('click', toggleRunPause);

  exportSpectrumBtn.addEventListener('click', exportSpectrumAsCSV);
  exportWaveformBtn.addEventListener('click', exportWaveformAsCSV);

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      toggleRunPause(); // Space counts as a user gesture
    }
  });

  freqCanvas.addEventListener('mousemove', onCanvasHover);
  freqCanvas.addEventListener('touchstart', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchmove', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchend', hideTooltip);
  freqCanvas.addEventListener('touchcancel', hideTooltip);

  waveCanvas.addEventListener('pointerdown', onWaveformPointerDown);
  waveCanvas.addEventListener('pointermove', onWaveformPointerMove);
  window.addEventListener('pointerup', onWaveformPointerUp);
  window.addEventListener('pointercancel', onWaveformPointerUp);
  waveCanvas.addEventListener('touchstart', onWaveformTouchStart, { passive: false });
  waveCanvas.addEventListener('touchmove', onWaveformTouchMove, { passive: false });
  waveCanvas.addEventListener('touchend', onWaveformTouchEnd);
  waveCanvas.addEventListener('touchcancel', onWaveformTouchEnd);

  [spectrumPanel, waveformPanel].forEach((panel) => {
    panel.addEventListener('toggle', () => {
      requestAnimationFrame(setupCanvasResolution);
    });
  });

  yScaleSlider.addEventListener('input', () => {
    waveAmplitudeScale = parseFloat(yScaleSlider.value);
  });
  xScaleSlider.addEventListener('input', () => {
    waveTimeScale = parseFloat(xScaleSlider.value);
  });

  // ------------------ Microphone + Analyzer Setup ------------------
  async function startSpectrum() {
    if (isRunning || isStarting) return;
    isStarting = true;

    try {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioContext.sampleRate;
      }

      // Kick off permission-sensitive work immediately from this user gesture
      const resumePromise =
        (audioContext.state === 'suspended') ? audioContext.resume() : Promise.resolve();

      const streamPromise =
        microphoneStream ? Promise.resolve(microphoneStream)
          : navigator.mediaDevices.getUserMedia({ audio: true });

      const [, stream] = await Promise.all([resumePromise, streamPromise]);
      microphoneStream = stream;

      if (!analyzer) {
        analyzer = audioContext.createAnalyser();
        analyzer.fftSize = fftSize;
        dataArray = new Uint8Array(analyzer.frequencyBinCount);
        timeDomainData = new Uint8Array(analyzer.fftSize);
      }

      if (source) {
        try { source.disconnect(); } catch { }
        source = null;
      }

      source = audioContext.createMediaStreamSource(microphoneStream);
      source.connect(analyzer);

      isRunning = true;
      toggleBtn.textContent = 'Pause';
      exportSpectrumBtn.disabled = true;
      exportWaveformBtn.disabled = true;
    } catch (err) {
      console.warn('Start failed:', err);
      alert('Unable to start microphone/audio. Please tap Start again.\n\n' + (err?.message || err));
      await resetAudioSession();
    } finally {
      isStarting = false;
    }
  }

  async function resetAudioSession() {
    teardownAudioSession();

    if (audioContext && audioContext.state !== 'closed') {
      try {
        await audioContext.close();
      } catch (err) {
        console.warn('Unable to close audio context cleanly:', err);
      }
    }

    audioContext = null;
    analyzer = null;
    source = null;
    microphoneStream = null;
    sampleRate = null;
    dataArray = null;
    timeDomainData = null;
    lastFreqFrame = null;
    lastWaveFrame = null;
    isRunning = false;
    isStarting = false;

    toggleBtn.textContent = 'Start';
    exportSpectrumBtn.disabled = true;
    exportWaveformBtn.disabled = true;
    peakFreqDisplay.textContent = '-- Hz';
    timeDeltaDisplay.textContent = '-- ms';
  }

  function teardownAudioSession() {
    if (source) {
      try { source.disconnect(); } catch { }
      source = null;
    }
    if (microphoneStream) {
      microphoneStream.getTracks().forEach((track) => track.stop());
      microphoneStream = null;
    }
  }

  function toggleRunPause() {
    if (isRunning) {
      pauseSpectrum();
    } else {
      startSpectrum();
    }
  }

  function pauseSpectrum() {
    isRunning = false;
    toggleBtn.textContent = 'Resume';
    exportSpectrumBtn.disabled = false;
    exportWaveformBtn.disabled = false;

    if (dataArray) lastFreqFrame = dataArray.slice();
    if (timeDomainData) lastWaveFrame = timeDomainData.slice();

    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend();
    }

    teardownAudioSession();
  }

  // ------------------ The Continuous Draw Loop ------------------
  function drawLoop() {
    requestAnimationFrame(drawLoop);

    // Frequency Spectrum background
    freqCtx.fillStyle = '#1e1e1e';
    freqCtx.fillRect(0, 0, freqCanvasSize.width, freqCanvasSize.height);

    // Waveform background
    waveCtx.fillStyle = '#1e1e1e';
    waveCtx.fillRect(0, 0, waveCanvasSize.width, waveCanvasSize.height);
    drawSquareGridWithTime();

    if (!analyzer || !dataArray || !timeDomainData) {
      peakFreqDisplay.textContent = '-- Hz';
      return;
    }

    // Frequency data
    if (isRunning) {
      analyzer.getByteFrequencyData(dataArray);
    } else if (lastFreqFrame) {
      dataArray.set(lastFreqFrame);
    }

    // Peak freq
    let peakIndex = 0, peakValue = -1;
    for (let i = 0; i < dataArray.length; i++) {
      if (dataArray[i] > peakValue) {
        peakValue = dataArray[i];
        peakIndex = i;
      }
    }
    const peakFreq = indexToFrequency(peakIndex);
    peakFreqDisplay.textContent = `${peakFreq.toFixed(1)} Hz`;

    // Frequency bars
    const barCount = dataArray.length;
    const barWidth = freqCanvasSize.width / barCount;
    for (let i = 0; i < barCount; i++) {
      const barHeight = (dataArray[i] / 255) * freqCanvasSize.height * 0.8;
      const x = i * barWidth;
      const y = freqCanvasSize.height - barHeight;
      freqCtx.fillStyle = `rgb(${barHeight + 50}, 50, 50)`;
      freqCtx.fillRect(x, y, barWidth, barHeight);
    }

    // Frequency axis
    drawFrequencyAxis(freqCtx, freqCanvasSize.width, freqCanvasSize.height);

    // Time-domain waveform
    if (isRunning) {
      analyzer.getByteTimeDomainData(timeDomainData);
      lastWaveFrame = timeDomainData.slice();
    } else if (lastWaveFrame) {
      timeDomainData.set(lastWaveFrame);
    }

    waveCtx.lineWidth = 2;
    waveCtx.strokeStyle = '#98c616';
    waveCtx.beginPath();

    const totalSamples = timeDomainData.length;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(2, Math.floor(windowSize));

    const sliceWidth = waveCanvasSize.width / (windowSize - 1);

    let x = 0;
    for (let i = 0; i < windowSize; i++) {
      const v = (timeDomainData[i] - 128) / 128.0;
      const y = (waveCanvasSize.height / 2) + v * (waveCanvasSize.height / 2) * waveAmplitudeScale;
      if (i === 0) waveCtx.moveTo(x, y);
      else waveCtx.lineTo(x, y);
      x += sliceWidth;
    }
    waveCtx.stroke();

    drawWaveformMarkers();
  }

  // ------------------ Draw the Frequency Axis ------------------
  function drawFrequencyAxis(ctx, width, height) {
    if (!sampleRate || !analyzer) return;

    ctx.fillStyle = '#ffffff';
    ctx.font = '12px sans-serif';

    const maxFreq = sampleRate / 2;
    const numTicks = 5;

    for (let i = 0; i <= numTicks; i++) {
      const freq = (maxFreq / numTicks) * i;
      const bin = frequencyToIndex(freq);
      const x = bin * (width / analyzer.frequencyBinCount);

      ctx.beginPath();
      ctx.moveTo(x, height - 5);
      ctx.lineTo(x, height);
      ctx.strokeStyle = '#ffffff';
      ctx.stroke();

      let label;
      if (freq >= 1000) label = (freq / 1000).toFixed(1) + ' kHz';
      else label = freq.toFixed(0) + ' Hz';

      ctx.fillText(label, x + 2, height - 6);
    }
  }

  // ------------------ Square Grid & Time Axis ------------------
  function drawSquareGridWithTime() {
    waveCtx.save();
    waveCtx.strokeStyle = `rgba(255,255,255,${SQUARE_GRID_ALPHA})`;
    waveCtx.fillStyle = '#ffffff';
    waveCtx.font = '12px sans-serif';

    const dispW = waveCanvasSize.width;

    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const totalTimeSec = windowSize / (sampleRate || 44100);

    const numVertLines = Math.floor(dispW / SQUARE_GRID_SPACING);
    for (let i = 0; i <= numVertLines; i++) {
      const screenX = i * SQUARE_GRID_SPACING;

      waveCtx.beginPath();
      waveCtx.moveTo(screenX, 0);
      waveCtx.lineTo(screenX, waveCanvasSize.height);
      waveCtx.stroke();

      if (i % 2 === 0) {
        const frac = screenX / dispW;
        const ms = frac * totalTimeSec * 1000;
        waveCtx.fillText(ms.toFixed(1) + ' ms', screenX + 2, waveCanvasSize.height - 4);
      }
    }

    const centerY = waveCanvasSize.height / 2;
    const spacingY = SQUARE_GRID_SPACING;

    for (let y = centerY; y >= 0; y -= spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    for (let y = centerY + spacingY; y <= waveCanvasSize.height; y += spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    waveCtx.restore();
  }

  function drawWaveformMarkers() {
    const width = waveCanvasSize.width;
    if (!width) return;

    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    waveCtx.save();
    waveCtx.lineWidth = 1;
    waveCtx.strokeStyle = markerColor;

    waveCtx.beginPath();
    waveCtx.moveTo(markerX1, 0);
    waveCtx.lineTo(markerX1, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.beginPath();
    waveCtx.moveTo(markerX2, 0);
    waveCtx.lineTo(markerX2, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.restore();

    updateTimeDeltaDisplay(markerX1, markerX2);
  }

  function updateTimeDeltaDisplay(markerX1, markerX2) {
    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const totalTimeSec = windowSize / (sampleRate || 44100);
    const deltaMs = Math.abs(markerX2 - markerX1) / waveCanvasSize.width * totalTimeSec * 1000;

    timeDeltaDisplay.textContent = `${deltaMs.toFixed(2)} ms`;
  }

  function pickActiveMarker(cursorX, allowNearest = false) {
    const width = waveCanvasSize.width;
    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    if (Math.abs(cursorX - markerX1) <= markerGrabTolerance) return 'A';
    if (Math.abs(cursorX - markerX2) <= markerGrabTolerance) return 'B';
    if (!allowNearest) return null;
    return Math.abs(cursorX - markerX1) <= Math.abs(cursorX - markerX2) ? 'A' : 'B';
  }

  function getCursorXFromEvent(event) {
    const rect = waveCanvas.getBoundingClientRect();
    return event.clientX - rect.left;
  }

  function updateWaveformCursor(cursorX) {
    const marker = pickActiveMarker(cursorX);
    waveCanvas.style.cursor = marker ? 'ew-resize' : 'crosshair';
  }

  function updateMarkerPosition(cursorX) {
    const width = waveCanvasSize.width;
    if (!width) return;

    const clamped = Math.min(Math.max(cursorX / width, 0), 1);
    if (activeMarker === 'A') markerA = clamped;
    else if (activeMarker === 'B') markerB = clamped;
  }

  function onWaveformPointerDown(event) {
    const cursorX = getCursorXFromEvent(event);
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    waveCanvas.setPointerCapture(event.pointerId);
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformPointerMove(event) {
    const cursorX = getCursorXFromEvent(event);
    if (!activeMarker) {
      updateWaveformCursor(cursorX);
      return;
    }
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
  }

  function onWaveformPointerUp() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  function onWaveformTouchStart(event) {
    if (!event.touches.length) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchMove(event) {
    if (!event.touches.length || !activeMarker) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchEnd() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  // ------------------ Export Spectrum (remove zero-amplitude) ------------------
  function exportSpectrumAsCSV() {
    if (!analyzer || !lastFreqFrame) {
      alert("No paused data available. Please pause first.");
      return;
    }

    const binCount = analyzer.frequencyBinCount;
    let csvContent = "data:text/csv;charset=utf-8,Frequency (Hz),Amplitude (a.u.)\n";

    for (let i = 0; i < binCount; i++) {
      const amp = lastFreqFrame[i];
      if (amp > 0) {
        const freq = indexToFrequency(i);
        csvContent += freq.toFixed(1) + "," + amp + "\n";
      }
    }

    downloadCSV(csvContent, "spectrum_data.csv");
  }

  // ------------------ Export Waveform (Time vs Amplitude) only first 10 ms ------------------
  function exportWaveformAsCSV() {
    if (!lastWaveFrame || !sampleRate) {
      alert("No paused data available. Please pause first.");
      return;
    }

    let maxSamples = Math.floor(sampleRate * 0.01);
    if (maxSamples > lastWaveFrame.length) maxSamples = lastWaveFrame.length;

    let csvContent = "data:text/csv;charset=utf-8,Time (ms),Amplitude (normalized)\n";
    for (let i = 0; i < maxSamples; i++) {
      const timeMs = (i / sampleRate) * 1000;
      const amplitude = (lastWaveFrame[i] - 128) / 128;
      csvContent += timeMs.toFixed(2) + "," + amplitude + "\n";
    }

    downloadCSV(csvContent, "waveform_data.csv");
  }

  function downloadCSV(csvString, filename) {
    const encodedUri = encodeURI(csvString);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // ------------------ Utility: bin <-> frequency conversion ------------------
  function indexToFrequency(index) {
    if (!sampleRate) return 0;
    return index * (sampleRate / fftSize);
  }

  function frequencyToIndex(freq) {
    if (!sampleRate) return 0;
    return Math.round(freq / (sampleRate / fftSize));
  }

  // ------------------ Hover/Touch Inspection (Paused Only) ------------------
  function onCanvasHover(e) {
    if (isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    const rect = freqCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    showTooltip(x, y);
  }

  function onCanvasTouch(e) {
    if (isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    e.preventDefault();
    const touch = e.touches[0];
    const rect = freqCanvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    showTooltip(x, y);
  }

  function hideTooltip() {
    tooltip.style.display = 'none';
  }

  function showTooltip(x, y) {
    const binCount = analyzer.frequencyBinCount;
    const barWidth = freqCanvasSize.width / binCount;
    const binIndex = Math.floor(x / barWidth);

    if (binIndex < 0 || binIndex >= binCount) {
      tooltip.style.display = 'none';
      return;
    }

    const freq = indexToFrequency(binIndex).toFixed(1);
    const amplitude = lastFreqFrame[binIndex];

    tooltip.style.display = 'block';
    tooltip.style.left = (x + 10) + 'px';
    tooltip.style.top = (y + 10) + 'px';
    tooltip.innerHTML = `
      <div>Freq: ${freq} Hz</div>
      <div>Amp: ${amplitude} (a.u.)</div>
    `;
  }
</script>

</html>
