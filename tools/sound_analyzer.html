<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#f8f9fa">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <script>
    (function() {
      if (localStorage.getItem('sound-analyzer-dark')) {
        document.documentElement.setAttribute('data-theme', 'dark');
        var tc = document.querySelector('meta[name="theme-color"]');
        var sb = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (tc) tc.setAttribute('content', '#0f1014');
        if (sb) sb.setAttribute('content', 'black-translucent');
      }
    })();
    </script>
  <title>Audio Spectrum & Waveform Analyzer</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
    <script src="/assets/sw-register.js" defer></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --bg-color: #f8f9fa;
      --bg-pattern: #e9ecef;
      --text-main: #2d3436;
      --text-secondary: #636e72;
      --brand-primary: #6c5ce7;
      --brand-secondary: #a29bfe;
      --brand-accent: #00cec9;
      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --border: #e2e8f0;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.08);
      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5b4cdb;
      --btn-secondary: #00cec9;
      --btn-secondary-hover: #00b3ad;
      --btn-text: #ffffff;
      --nav-bg: rgba(255, 255, 255, 0.85);
      --nav-border: rgba(255, 255, 255, 0.6);
      --canvas-bg: #ffffff;
      --axis-color: #2d3436;
      --grid-color: #94a3b8;
      --wave-line: #16a34a;
      --marker-color: #f97316;
      --tooltip-bg: rgba(255, 255, 255, 0.95);
      --tooltip-text: #1f2933;
      --toggle-hover: rgba(108, 92, 231, 0.15);
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;
      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;
      --surface: #1e2129;
      --surface-alt: #17191f;
      --border: #2d3436;
      --shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5849d6;
      --btn-secondary: #00cec9;
      --btn-secondary-hover: #00b3ad;
      --btn-text: #ffffff;
      --nav-bg: rgba(22, 24, 29, 0.85);
      --nav-border: rgba(255, 255, 255, 0.08);
      --canvas-bg: #1e1e1e;
      --axis-color: #ffffff;
      --grid-color: #ffffff;
      --wave-line: #98c616;
      --marker-color: #ff5f1f;
      --tooltip-bg: rgba(15, 16, 20, 0.9);
      --tooltip-text: #ffffff;
      --toggle-hover: rgba(162, 155, 254, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 32px 32px;
      color: var(--text-main);
      font-family: var(--font-sans);
    }

    a {
      color: var(--brand-accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.4rem 1.25rem;
    }

    #titleBanner {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 1rem;
      max-width: 1100px;
      width: min(1100px, calc(100% - 3rem));
      margin: 0 auto;
      background: var(--nav-bg);
      border: 1px solid var(--nav-border);
      border-radius: 18px;
      padding: 0.4rem 1.1rem;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .banner-logo img {
      max-height: 28px;
      width: auto;
      height: auto;
    }

    .banner-title {
      text-align: center;
      margin: 0;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      font-family: var(--font-display);
      color: var(--brand-primary);
    }

    .banner-title.gradient-text {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .theme-toggle {
      display: flex;
      justify-content: flex-end;
    }

    .theme-toggle button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.15rem;
      padding: 0.45rem;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--text-main);
      min-width: 42px;
      min-height: 42px;
      line-height: 1;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }

    .theme-toggle button:hover {
      background-color: var(--toggle-hover);
      transform: rotate(15deg);
    }

    main {
      flex: 1;
      padding: 0 1.5rem 1.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .info-bar {
      max-width: 1200px;
      margin: 1.2rem auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }

    .info-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.6rem 1rem;
      box-shadow: var(--shadow);
      font-weight: 600;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
    }

    .info-card span {
      display: inline-flex;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .info-card strong {
      display: inline-block;
      min-width: 16ch;
      width: 16ch;
      flex: 0 0 16ch;
      text-align: right;
      font-family: var(--font-mono);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .panel,
    details.panel {
      width: min(1100px, 100%);
      margin: 0 auto;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .panel-header {
      padding: 0.75rem 1rem;
      font-weight: 600;
      border-bottom: 1px solid var(--border);
    }

    details.panel summary {
      list-style: none;
      cursor: pointer;
      padding: 0.75rem 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    details.panel summary::-webkit-details-marker {
      display: none;
    }

    details.panel summary::after {
      content: "▾";
      font-size: 1rem;
      color: var(--text-secondary);
      transition: transform 0.2s ease;
    }

    details.panel[open] summary::after {
      transform: rotate(180deg);
    }

    details.panel[open] summary {
      border-bottom: 1px solid var(--border);
    }

    details.panel:not([open]) summary {
      border-bottom: none;
    }

    .panel-body {
      padding: 1rem;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: clamp(180px, 24vh, 240px);
      border-radius: 12px;
      background-color: var(--canvas-bg);
      border: 1px solid var(--border);
    }

    #visualizer {
      height: clamp(200px, 28vh, 280px);
    }

    #visualizer-container {
      position: relative;
    }

    .spectrum-reset {
      position: absolute;
      top: 0.6rem;
      right: 0.8rem;
      padding: 0.35rem 0.8rem;
      font-size: 0.75rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      color: var(--text-secondary);
      box-shadow: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .spectrum-reset.is-hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spectrum-reset:hover {
      transform: translateY(-1px);
    }

    #waveform {
      height: clamp(280px, 42vh, 420px);
      touch-action: pan-y;
    }

    #tooltip {
      position: absolute;
      display: none;
      background-color: var(--tooltip-bg);
      color: var(--tooltip-text);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      pointer-events: none;
      font-size: 0.8rem;
    }

    #sliders {
      margin-top: 1rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.85rem 1.1rem;
    }

    #sliders label {
      display: block;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    input[type="range"] {
      width: 100%;
      cursor: pointer;
      accent-color: var(--brand-primary);
    }

    #controls {
      width: min(1100px, 100%);
      margin: 0 auto;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      justify-content: center;
    }

    button {
      margin: 0;
      padding: 0.6rem 1.4rem;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 999px;
      color: var(--btn-text);
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-2px);
    }

    .toggle-button {
      background: var(--btn-primary);
      min-width: 140px;
      text-align: center;
    }

    .toggle-button:hover {
      background: var(--btn-primary-hover);
    }

    .export-button {
      background: linear-gradient(135deg, var(--btn-secondary), #0fb9b1);
    }

    .export-button:hover {
      background: linear-gradient(135deg, var(--btn-secondary-hover), #0ba39d);
    }

    footer {
      text-align: center;
      padding: 1rem 1rem 1.4rem;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    @media (pointer: coarse) {
      button,
      input,
      select,
      .control-row button {
        min-height: 44px;
        touch-action: manipulation;
      }

      input[type="range"] {
        min-height: 44px;
      }

      canvas {
        touch-action: none;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <div id="titleBanner">
        <div class="banner-logo">
          <a href="https://panphy.github.io/">
            <img src="/assets/panphy.png" alt="PanPhy logo" />
          </a>
        </div>

        <h1 class="banner-title">Audio Spectrum & Waveform Analyzer</h1>

        <div class="theme-toggle">
          <button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">&#9728;&#65039;</button>
        </div>
      </div>
    </header>

    <main>
      <div class="info-bar">
        <div id="peak-frequency" class="info-card">
          <span>Peak Frequency</span>
          <strong id="peak-frequency-value">-- Hz</strong>
        </div>
        <div id="time-delta" class="info-card">
          <span>Marker Delta</span>
          <strong id="time-delta-value">-- ms</strong>
        </div>
      </div>

      <details class="panel" id="spectrum-panel">
        <summary>Spectrum</summary>
        <div id="visualizer-container" class="panel-body">
          <button id="resetZoomBtn" class="spectrum-reset is-hidden" type="button">Reset zoom</button>
          <canvas id="visualizer" width="800" height="200"></canvas>
          <div id="tooltip"></div>
        </div>
      </details>

      <section class="panel" id="waveform-panel">
        <div class="panel-header">Oscilloscope</div>
        <div id="waveform-container" class="panel-body">
          <canvas id="waveform" width="800" height="200"></canvas>
          <div id="sliders">
            <div>
              <label for="yScale">Amplitude Scale</label>
              <input type="range" id="yScale" min="0.5" max="20" step="0.5" value="5">
            </div>
            <div>
              <label for="xScale">Time Scale</label>
              <input type="range" id="xScale" min="0.5" max="10" step="0.5" value="1">
            </div>
          </div>
        </div>
      </section>

      <div id="controls">
        <button id="toggleBtn" class="toggle-button">Start</button>
        <button id="exportSpectrumBtn" class="export-button" disabled>Export Spectrum (.csv)</button>
        <button id="exportWaveformBtn" class="export-button" disabled>Export Waveform (.csv)</button>
      </div>
    </main>

    <footer>
      &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
      <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
    </footer>
  </div>
  <script>
    // Gradient text: skip on Brave iOS where background-clip:text is broken
    (function() {
      if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
      document.querySelectorAll('.banner-title').forEach(function(el) { el.classList.add('gradient-text'); });
    })();
  </script>
  <script>
    // Theme Toggle
    const themeButton = document.getElementById('theme-button');
    const DARK_THEME_KEY = "sound-analyzer-dark";
    const LIGHT_THEME_KEY = "sound-analyzer-light";

    const currentTheme = localStorage.getItem(DARK_THEME_KEY) ?
      "dark" :
      localStorage.getItem(LIGHT_THEME_KEY) ?
        "light" :
        "light";

    document.documentElement.setAttribute('data-theme', currentTheme);
    updateAppChromeTheme(currentTheme);
    updateButtonEmoji(currentTheme);

    function updateAppChromeTheme(theme) {
      const themeColorMeta = document.querySelector('meta[name="theme-color"]');
      const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      const isDarkTheme = theme === 'dark';

      if (themeColorMeta) {
        themeColorMeta.setAttribute('content', isDarkTheme ? '#0f1014' : '#f8f9fa');
      }

      if (appleStatusBarMeta) {
        appleStatusBarMeta.setAttribute('content', isDarkTheme ? 'black-translucent' : 'default');
      }
    }

    window.addEventListener('pageshow', function () {
      updateAppChromeTheme(document.documentElement.getAttribute('data-theme'));
    });

    function updateButtonEmoji(theme) {
      themeButton.textContent = theme === 'dark' ? '\u{1F319}' : '\u{2600}\u{FE0F}';
    }

    themeButton.addEventListener('click', function () {
      let theme = document.documentElement.getAttribute('data-theme');
      if (theme === 'light') {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem(DARK_THEME_KEY, 'true');
        localStorage.removeItem(LIGHT_THEME_KEY);
        updateAppChromeTheme('dark');
        updateButtonEmoji('dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem(LIGHT_THEME_KEY, 'true');
        localStorage.removeItem(DARK_THEME_KEY);
        updateAppChromeTheme('light');
        updateButtonEmoji('light');
      }
    });
  </script>
</body>

<script>
  /* ADJUSTABLE GRID SETTINGS */
  const SQUARE_GRID_SPACING = 45;
  const SQUARE_GRID_ALPHA = 0.1;

  // ------------------ Global Variables ------------------
  let audioContext, analyzer, source, microphoneStream;
  let isRunning = false;
  let isStarting = false;
  let sampleRate;
  const fftSize = 2048;
  const MICROPHONE_CONSTRAINTS = {
    audio: {
      autoGainControl: false,
      noiseSuppression: false,
      echoCancellation: false
    }
  };

  // Frequency data
  let dataArray;
  // Waveform data
  let timeDomainData;

  // Final paused frames
  let lastFreqFrame;
  let lastWaveFrame;

  // Zoom parameters
  let waveAmplitudeScale = 5.0;
  let waveTimeScale = 1.0;
  // Display-only normalization to reduce cross-device mic sensitivity differences.
  const AUTO_WAVE_REFERENCE_SCALE = 5.0;
  const AUTO_WAVE_TARGET_HEIGHT = 0.35;
  const AUTO_WAVE_MIN_PEAK = 0.0002;
  const AUTO_WAVE_MIN_GAIN = 0.4;
  const AUTO_WAVE_MAX_GAIN = 20;
  const AUTO_WAVE_ATTACK = 0.2;
  const AUTO_WAVE_RELEASE = 0.08;
  let adaptiveWaveGain = 1;

  // DOM references
  const freqCanvas = document.getElementById('visualizer');
  const freqCtx = freqCanvas.getContext('2d');

  const waveCanvas = document.getElementById('waveform');
  const waveCtx = waveCanvas.getContext('2d');

  const tooltip = document.getElementById('tooltip');
  const peakFreqDisplay = document.getElementById('peak-frequency-value');
  const timeDeltaDisplay = document.getElementById('time-delta-value');
  const spectrumPanel = document.getElementById('spectrum-panel');
  const resetZoomBtn = document.getElementById('resetZoomBtn');

  const toggleBtn = document.getElementById('toggleBtn');
  const exportSpectrumBtn = document.getElementById('exportSpectrumBtn');
  const exportWaveformBtn = document.getElementById('exportWaveformBtn');

  const yScaleSlider = document.getElementById('yScale');
  const xScaleSlider = document.getElementById('xScale');

  function getCssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
  const markerGrabTolerance = 14;
  let markerA = 0.3;
  let markerB = 0.7;
  let activeMarker = null;

  let canvasDpr = 1;
  let freqCanvasSize = { width: 0, height: 0 };
  let waveCanvasSize = { width: 0, height: 0 };
  let freqZoomRange = null;
  let isSelectingFreq = false;
  let freqSelectStartX = 0;
  let freqSelectCurrentX = 0;

  function setupCanvasResolution() {
    canvasDpr = window.devicePixelRatio || 1;

    const freqRect = freqCanvas.getBoundingClientRect();
    freqCanvasSize = { width: freqRect.width, height: freqRect.height };
    freqCanvas.width = Math.round(freqCanvasSize.width * canvasDpr);
    freqCanvas.height = Math.round(freqCanvasSize.height * canvasDpr);
    freqCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);

    const waveRect = waveCanvas.getBoundingClientRect();
    waveCanvasSize = { width: waveRect.width, height: waveRect.height };
    waveCanvas.width = Math.round(waveCanvasSize.width * canvasDpr);
    waveCanvas.height = Math.round(waveCanvasSize.height * canvasDpr);
    waveCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);
  }

  // ------------------ Main Entry ------------------
  window.addEventListener('load', async () => {
    setupCanvasResolution();
    requestAnimationFrame(drawLoop); // always running UI
    await resetAudioSession();
    // Important: do NOT auto-start audio on load.
    // User must tap Start (reliable on refresh, especially on iOS/Safari).
  });

  window.addEventListener('resize', setupCanvasResolution);

  window.addEventListener('pageshow', async (event) => {
    if (event.persisted) {
      await resetAudioSession();
    }
  });

  window.addEventListener('beforeunload', () => {
    teardownAudioSession();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (isRunning) pauseSpectrum();
    }
  });

  // ------------------ Button & Keyboard Listeners ------------------
  toggleBtn.addEventListener('click', toggleRunPause);

  exportSpectrumBtn.addEventListener('click', exportSpectrumAsCSV);
  exportWaveformBtn.addEventListener('click', exportWaveformAsCSV);

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      toggleRunPause(); // Space counts as a user gesture
    }
  });

  freqCanvas.addEventListener('mousemove', onCanvasHover);
  freqCanvas.addEventListener('touchstart', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchmove', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchend', hideTooltip);
  freqCanvas.addEventListener('touchcancel', hideTooltip);
  freqCanvas.addEventListener('pointerdown', onFreqPointerDown);
  freqCanvas.addEventListener('pointermove', onFreqPointerMove);
  freqCanvas.addEventListener('pointerup', onFreqPointerUp);
  freqCanvas.addEventListener('pointercancel', onFreqPointerUp);

  waveCanvas.addEventListener('pointerdown', onWaveformPointerDown);
  waveCanvas.addEventListener('pointermove', onWaveformPointerMove);
  window.addEventListener('pointerup', onWaveformPointerUp);
  window.addEventListener('pointercancel', onWaveformPointerUp);
  waveCanvas.addEventListener('touchstart', onWaveformTouchStart, { passive: false });
  waveCanvas.addEventListener('touchmove', onWaveformTouchMove, { passive: false });
  waveCanvas.addEventListener('touchend', onWaveformTouchEnd);
  waveCanvas.addEventListener('touchcancel', onWaveformTouchEnd);

  spectrumPanel.addEventListener('toggle', () => {
    requestAnimationFrame(setupCanvasResolution);
  });

  yScaleSlider.addEventListener('input', () => {
    waveAmplitudeScale = parseFloat(yScaleSlider.value);
  });
  xScaleSlider.addEventListener('input', () => {
    waveTimeScale = parseFloat(xScaleSlider.value);
  });
  resetZoomBtn.addEventListener('click', resetFrequencyZoom);

  // ------------------ Microphone + Analyzer Setup ------------------
  async function startSpectrum() {
    if (isRunning || isStarting) return;
    isStarting = true;
    toggleBtn.disabled = true;
    toggleBtn.textContent = 'Starting…';

    try {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioContext.sampleRate;
      }

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('This browser does not support microphone access.');
      }

      // Kick off permission-sensitive work immediately from this user gesture
      const resumePromise =
        (audioContext.state !== 'running') ? audioContext.resume() : Promise.resolve();

      const streamPromise =
        microphoneStream ? Promise.resolve(microphoneStream)
          : navigator.mediaDevices.getUserMedia(MICROPHONE_CONSTRAINTS);

      const [, stream] = await Promise.all([resumePromise, streamPromise]);
      microphoneStream = stream;

      if (!analyzer) {
        analyzer = audioContext.createAnalyser();
        analyzer.fftSize = fftSize;
        dataArray = new Uint8Array(analyzer.frequencyBinCount);
        timeDomainData = new Float32Array(analyzer.fftSize);
      }

      if (source) {
        try { source.disconnect(); } catch { }
        source = null;
      }

      source = audioContext.createMediaStreamSource(microphoneStream);
      source.connect(analyzer);

      isRunning = true;
      toggleBtn.textContent = 'Pause';
      exportSpectrumBtn.disabled = true;
      exportWaveformBtn.disabled = true;
    } catch (err) {
      console.warn('Start failed:', err);
      alert('Unable to start microphone/audio. Please tap Start again.\n\n' + (err?.message || err));
      await resetAudioSession();
    } finally {
      isStarting = false;
      toggleBtn.disabled = false;
      if (!isRunning) toggleBtn.textContent = 'Start';
    }
  }

  async function resetAudioSession() {
    teardownAudioSession();

    if (audioContext && audioContext.state !== 'closed') {
      try {
        await audioContext.close();
      } catch (err) {
        console.warn('Unable to close audio context cleanly:', err);
      }
    }

    audioContext = null;
    analyzer = null;
    source = null;
    microphoneStream = null;
    sampleRate = null;
    dataArray = null;
    timeDomainData = null;
    lastFreqFrame = null;
    lastWaveFrame = null;
    adaptiveWaveGain = 1;
    isRunning = false;
    isStarting = false;

    toggleBtn.textContent = 'Start';
    exportSpectrumBtn.disabled = true;
    exportWaveformBtn.disabled = true;
    peakFreqDisplay.textContent = '-- Hz';
    timeDeltaDisplay.textContent = '-- ms';
    resetFrequencyZoom();
  }

  function teardownAudioSession() {
    if (source) {
      try { source.disconnect(); } catch { }
      source = null;
    }
    if (microphoneStream) {
      microphoneStream.getTracks().forEach((track) => track.stop());
      microphoneStream = null;
    }
  }

  function toggleRunPause() {
    if (isRunning) {
      pauseSpectrum();
    } else {
      startSpectrum();
    }
  }

  function pauseSpectrum() {
    isRunning = false;
    toggleBtn.textContent = 'Resume';
    exportSpectrumBtn.disabled = false;
    exportWaveformBtn.disabled = false;

    if (dataArray) lastFreqFrame = dataArray.slice();
    if (timeDomainData) lastWaveFrame = timeDomainData.slice();

    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend();
    }

    teardownAudioSession();
  }

  function resetFrequencyZoom() {
    freqZoomRange = null;
    updateResetZoomButton();
  }

  function updateResetZoomButton() {
    const isHidden = !freqZoomRange;
    resetZoomBtn.classList.toggle('is-hidden', isHidden);
  }

  function setFrequencyZoom(startIndex, endIndex) {
    if (!analyzer) return;
    const binCount = analyzer.frequencyBinCount;
    const clampedStart = Math.max(0, Math.min(startIndex, binCount - 1));
    const clampedEnd = Math.max(0, Math.min(endIndex, binCount - 1));
    if (Math.abs(clampedEnd - clampedStart) < 3) return;
    freqZoomRange = {
      startIndex: Math.min(clampedStart, clampedEnd),
      endIndex: Math.max(clampedStart, clampedEnd)
    };
    updateResetZoomButton();
  }

  function getFrequencyZoomRange() {
    if (!analyzer) return { startIndex: 0, endIndex: 0, startFreq: 0, endFreq: 0 };
    const binCount = analyzer.frequencyBinCount;
    const startIndex = freqZoomRange ? freqZoomRange.startIndex : 0;
    const endIndex = freqZoomRange ? freqZoomRange.endIndex : binCount - 1;
    return {
      startIndex,
      endIndex,
      startFreq: indexToFrequency(startIndex),
      endFreq: indexToFrequency(endIndex)
    };
  }

  function xToBinIndex(x) {
    if (!analyzer) return 0;
    const { startIndex, endIndex } = getFrequencyZoomRange();
    const span = Math.max(1, endIndex - startIndex);
    const clampedX = Math.max(0, Math.min(x, freqCanvasSize.width));
    const ratio = clampedX / freqCanvasSize.width;
    return Math.round(startIndex + ratio * span);
  }

  function binIndexToX(index) {
    if (!analyzer) return 0;
    const { startIndex, endIndex } = getFrequencyZoomRange();
    const span = Math.max(1, endIndex - startIndex);
    const clampedIndex = Math.max(startIndex, Math.min(index, endIndex));
    const ratio = (clampedIndex - startIndex) / span;
    return ratio * freqCanvasSize.width;
  }

  function onFreqPointerDown(event) {
    if (!analyzer) return;
    const rect = freqCanvas.getBoundingClientRect();
    freqSelectStartX = event.clientX - rect.left;
    freqSelectCurrentX = freqSelectStartX;
    isSelectingFreq = true;
    freqCanvas.setPointerCapture(event.pointerId);
    tooltip.style.display = 'none';
    event.preventDefault();
  }

  function onFreqPointerMove(event) {
    if (!isSelectingFreq) return;
    const rect = freqCanvas.getBoundingClientRect();
    freqSelectCurrentX = event.clientX - rect.left;
  }

  function onFreqPointerUp() {
    if (!isSelectingFreq) return;
    isSelectingFreq = false;
    const minX = Math.min(freqSelectStartX, freqSelectCurrentX);
    const maxX = Math.max(freqSelectStartX, freqSelectCurrentX);
    const startIndex = xToBinIndex(minX);
    const endIndex = xToBinIndex(maxX);
    setFrequencyZoom(startIndex, endIndex);
  }

  function getAdaptiveWaveGain(samples) {
    if (!samples || !samples.length) return adaptiveWaveGain;

    let peak = 0;
    for (let i = 0; i < samples.length; i++) {
      const absoluteValue = Math.abs(samples[i]);
      if (absoluteValue > peak) peak = absoluteValue;
    }

    let targetGain = 1;
    if (peak >= AUTO_WAVE_MIN_PEAK) {
      targetGain = AUTO_WAVE_TARGET_HEIGHT / (peak * AUTO_WAVE_REFERENCE_SCALE);
      targetGain = Math.max(AUTO_WAVE_MIN_GAIN, Math.min(targetGain, AUTO_WAVE_MAX_GAIN));
    }

    const smoothing = targetGain > adaptiveWaveGain ? AUTO_WAVE_ATTACK : AUTO_WAVE_RELEASE;
    adaptiveWaveGain += (targetGain - adaptiveWaveGain) * smoothing;
    return adaptiveWaveGain;
  }

  // ------------------ The Continuous Draw Loop ------------------
  function drawLoop() {
    requestAnimationFrame(drawLoop);

    const canvasBg = getCssVar('--canvas-bg');
    const waveLine = getCssVar('--wave-line');

    // Frequency Spectrum background
    freqCtx.fillStyle = canvasBg;
    freqCtx.fillRect(0, 0, freqCanvasSize.width, freqCanvasSize.height);

    // Waveform background
    waveCtx.fillStyle = canvasBg;
    waveCtx.fillRect(0, 0, waveCanvasSize.width, waveCanvasSize.height);
    drawSquareGridWithTime();

    if (!analyzer || !dataArray || !timeDomainData) {
      peakFreqDisplay.textContent = '-- Hz';
      return;
    }

    // Frequency data
    if (isRunning) {
      analyzer.getByteFrequencyData(dataArray);
    } else if (lastFreqFrame) {
      dataArray.set(lastFreqFrame);
    }

    // Peak freq
    let peakIndex = 0, peakValue = -1;
    for (let i = 0; i < dataArray.length; i++) {
      if (dataArray[i] > peakValue) {
        peakValue = dataArray[i];
        peakIndex = i;
      }
    }
    const peakFreq = indexToFrequency(peakIndex);
    peakFreqDisplay.textContent = `${peakFreq.toFixed(1)} Hz`;

    const { startIndex, endIndex, startFreq, endFreq } = getFrequencyZoomRange();

    // Frequency bars
    const barCount = Math.max(1, endIndex - startIndex + 1);
    const barWidth = freqCanvasSize.width / barCount;
    for (let i = startIndex; i <= endIndex; i++) {
      const barHeight = (dataArray[i] / 255) * freqCanvasSize.height * 0.8;
      const x = (i - startIndex) * barWidth;
      const y = freqCanvasSize.height - barHeight;
      freqCtx.fillStyle = `rgb(${barHeight + 50}, 50, 50)`;
      freqCtx.fillRect(x, y, barWidth, barHeight);
    }

    // Frequency axis
    drawFrequencyAxis(freqCtx, freqCanvasSize.width, freqCanvasSize.height, startFreq, endFreq);

    if (isSelectingFreq) {
      const selectionX = Math.min(freqSelectStartX, freqSelectCurrentX);
      const selectionW = Math.abs(freqSelectCurrentX - freqSelectStartX);
      freqCtx.save();
      freqCtx.globalAlpha = 0.2;
      freqCtx.fillStyle = getCssVar('--brand-accent');
      freqCtx.fillRect(selectionX, 0, selectionW, freqCanvasSize.height);
      freqCtx.globalAlpha = 0.6;
      freqCtx.strokeStyle = getCssVar('--brand-accent');
      freqCtx.strokeRect(selectionX, 0, selectionW, freqCanvasSize.height);
      freqCtx.restore();
    }

    // Time-domain waveform
    if (isRunning) {
      analyzer.getFloatTimeDomainData(timeDomainData);
      lastWaveFrame = timeDomainData.slice();
    } else if (lastWaveFrame) {
      timeDomainData.set(lastWaveFrame);
    }

    waveCtx.lineWidth = 2;
    waveCtx.strokeStyle = waveLine;
    waveCtx.beginPath();

    const totalSamples = timeDomainData.length;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(2, Math.floor(windowSize));

    const sliceWidth = waveCanvasSize.width / (windowSize - 1);
    const frameWaveGain = isRunning ? getAdaptiveWaveGain(timeDomainData) : adaptiveWaveGain;
    const displayWaveGain = waveAmplitudeScale * frameWaveGain;

    let x = 0;
    for (let i = 0; i < windowSize; i++) {
      const v = timeDomainData[i];
      const y = (waveCanvasSize.height / 2) + v * (waveCanvasSize.height / 2) * displayWaveGain;
      if (i === 0) waveCtx.moveTo(x, y);
      else waveCtx.lineTo(x, y);
      x += sliceWidth;
    }
    waveCtx.stroke();

    drawWaveformMarkers();
  }

  // ------------------ Draw the Frequency Axis ------------------
  function drawFrequencyAxis(ctx, width, height, startFreq, endFreq) {
    if (!sampleRate || !analyzer) return;

    ctx.fillStyle = getCssVar('--axis-color');
    ctx.font = '12px sans-serif';

    const numTicks = 5;
    const minFreq = startFreq ?? 0;
    const maxFreq = endFreq ?? (sampleRate / 2);

    for (let i = 0; i <= numTicks; i++) {
      const freq = minFreq + ((maxFreq - minFreq) / numTicks) * i;
      const bin = frequencyToIndex(freq);
      const x = binIndexToX(bin);

      ctx.beginPath();
      ctx.moveTo(x, height - 5);
      ctx.lineTo(x, height);
      ctx.strokeStyle = getCssVar('--axis-color');
      ctx.stroke();

      let label;
      if (freq >= 1000) label = (freq / 1000).toFixed(1) + ' kHz';
      else label = freq.toFixed(0) + ' Hz';

      ctx.fillText(label, x + 2, height - 6);
    }
  }

  // ------------------ Square Grid & Time Axis ------------------
  function drawSquareGridWithTime() {
    waveCtx.save();
    const gridColor = getCssVar('--grid-color');
    waveCtx.globalAlpha = SQUARE_GRID_ALPHA;
    waveCtx.strokeStyle = gridColor;

    const dispW = waveCanvasSize.width;

    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const numVertLines = Math.floor(dispW / SQUARE_GRID_SPACING);
    for (let i = 0; i <= numVertLines; i++) {
      const screenX = i * SQUARE_GRID_SPACING;

      waveCtx.beginPath();
      waveCtx.moveTo(screenX, 0);
      waveCtx.lineTo(screenX, waveCanvasSize.height);
      waveCtx.stroke();
    }

    const centerY = waveCanvasSize.height / 2;
    const spacingY = SQUARE_GRID_SPACING;

    for (let y = centerY; y >= 0; y -= spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    for (let y = centerY + spacingY; y <= waveCanvasSize.height; y += spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    waveCtx.globalAlpha = 1;
    waveCtx.restore();
  }

  function drawWaveformMarkers() {
    const width = waveCanvasSize.width;
    if (!width) return;

    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    waveCtx.save();
    waveCtx.lineWidth = 1;
    waveCtx.strokeStyle = getCssVar('--marker-color');

    waveCtx.beginPath();
    waveCtx.moveTo(markerX1, 0);
    waveCtx.lineTo(markerX1, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.beginPath();
    waveCtx.moveTo(markerX2, 0);
    waveCtx.lineTo(markerX2, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.restore();

    updateTimeDeltaDisplay(markerX1, markerX2);
  }

  function updateTimeDeltaDisplay(markerX1, markerX2) {
    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const totalTimeSec = windowSize / (sampleRate || 44100);
    const deltaMs = Math.abs(markerX2 - markerX1) / waveCanvasSize.width * totalTimeSec * 1000;

    timeDeltaDisplay.textContent = `${deltaMs.toFixed(2)} ms`;
  }

  function pickActiveMarker(cursorX, allowNearest = false) {
    const width = waveCanvasSize.width;
    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    if (Math.abs(cursorX - markerX1) <= markerGrabTolerance) return 'A';
    if (Math.abs(cursorX - markerX2) <= markerGrabTolerance) return 'B';
    if (!allowNearest) return null;
    return Math.abs(cursorX - markerX1) <= Math.abs(cursorX - markerX2) ? 'A' : 'B';
  }

  function getCursorXFromEvent(event) {
    const rect = waveCanvas.getBoundingClientRect();
    return event.clientX - rect.left;
  }

  function updateWaveformCursor(cursorX) {
    const marker = pickActiveMarker(cursorX);
    waveCanvas.style.cursor = marker ? 'ew-resize' : 'crosshair';
  }

  function updateMarkerPosition(cursorX) {
    const width = waveCanvasSize.width;
    if (!width) return;

    const clamped = Math.min(Math.max(cursorX / width, 0), 1);
    if (activeMarker === 'A') markerA = clamped;
    else if (activeMarker === 'B') markerB = clamped;
  }

  function onWaveformPointerDown(event) {
    const cursorX = getCursorXFromEvent(event);
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    waveCanvas.setPointerCapture(event.pointerId);
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformPointerMove(event) {
    const cursorX = getCursorXFromEvent(event);
    if (!activeMarker) {
      updateWaveformCursor(cursorX);
      return;
    }
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
  }

  function onWaveformPointerUp() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  function onWaveformTouchStart(event) {
    if (!event.touches.length) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchMove(event) {
    if (!event.touches.length || !activeMarker) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchEnd() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  // ------------------ Export Spectrum (remove zero-amplitude) ------------------
  function exportSpectrumAsCSV() {
    if (!analyzer || !lastFreqFrame) {
      alert("No paused data available. Please pause first.");
      return;
    }

    const binCount = analyzer.frequencyBinCount;
    let csvContent = "data:text/csv;charset=utf-8,Frequency (Hz),Amplitude (a.u.)\n";

    for (let i = 0; i < binCount; i++) {
      const amp = lastFreqFrame[i];
      if (amp > 0) {
        const freq = indexToFrequency(i);
        csvContent += freq.toFixed(1) + "," + amp + "\n";
      }
    }

    downloadCSV(csvContent, "spectrum_data.csv");
  }

  // ------------------ Export Waveform (Time vs Amplitude) ------------------
  function exportWaveformAsCSV() {
    if (!lastWaveFrame || !sampleRate) {
      alert("No paused data available. Please pause first.");
      return;
    }

    const totalSamples = lastWaveFrame.length;

    let csvContent = "data:text/csv;charset=utf-8,Time (ms),Amplitude (normalized)\n";
    for (let i = 0; i < totalSamples; i++) {
      const timeMs = (i / sampleRate) * 1000;
      const amplitude = lastWaveFrame[i];
      csvContent += timeMs.toFixed(2) + "," + amplitude + "\n";
    }

    downloadCSV(csvContent, "waveform_data.csv");
  }

  function downloadCSV(csvString, filename) {
    const encodedUri = encodeURI(csvString);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // ------------------ Utility: bin <-> frequency conversion ------------------
  function indexToFrequency(index) {
    if (!sampleRate) return 0;
    return index * (sampleRate / fftSize);
  }

  function frequencyToIndex(freq) {
    if (!sampleRate) return 0;
    return Math.round(freq / (sampleRate / fftSize));
  }

  // ------------------ Hover/Touch Inspection (Paused Only) ------------------
  function onCanvasHover(e) {
    if (isSelectingFreq || isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    const rect = freqCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    showTooltip(x, y);
  }

  function onCanvasTouch(e) {
    if (isSelectingFreq || isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    e.preventDefault();
    const touch = e.touches[0];
    const rect = freqCanvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    showTooltip(x, y);
  }

  function hideTooltip() {
    tooltip.style.display = 'none';
  }

  function showTooltip(x, y) {
    const binIndex = xToBinIndex(x);

    if (!analyzer || binIndex < 0 || binIndex >= analyzer.frequencyBinCount) {
      tooltip.style.display = 'none';
      return;
    }

    const freq = indexToFrequency(binIndex).toFixed(1);
    const amplitude = lastFreqFrame[binIndex];

    tooltip.style.display = 'block';
    tooltip.style.left = (x + 10) + 'px';
    tooltip.style.top = (y + 10) + 'px';
    tooltip.innerHTML = `
      <div>Freq: ${freq} Hz</div>
      <div>Amp: ${amplitude} (a.u.)</div>
    `;
  }
</script>

</html>
