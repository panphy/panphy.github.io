<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#f8f9fa">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <script>
    (function() {
      if (localStorage.getItem('sound-analyzer-dark')) {
        document.documentElement.setAttribute('data-theme', 'dark');
        var tc = document.querySelector('meta[name="theme-color"]');
        var sb = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (tc) tc.setAttribute('content', '#0f1014');
        if (sb) sb.setAttribute('content', 'black-translucent');
      }
    })();
    </script>
  <title>Sound Analyzer</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
    <script src="/assets/sw-register.js" defer></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;

      /* Light Theme */
      --bg-color: #f8f9fa;
      --bg-pattern: #e9ecef;
      --text-main: #2d3436;
      --text-secondary: #636e72;

      --brand-primary: #6c5ce7;
      --brand-secondary: #a29bfe;
      --brand-accent: #00cec9;

      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);

      --canvas-bg: #ffffff;
      --canvas-baseline: #cbd5e1;

      --slider-track: #e2e8f0;
      --slider-thumb: #6c5ce7;

      --select-bg: #ffffff;
      --select-border: #e2e8f0;

      --header-bg: rgba(255, 255, 255, 0.9);
      --header-border: rgba(108, 92, 231, 0.1);

      --nav-bg: rgba(255, 255, 255, 0.85);
      --nav-border: rgba(255, 255, 255, 0.5);

      /* Sound analyzer specific */
      --axis-color: #2d3436;
      --grid-color: #94a3b8;
      --wave-line: #16a34a;
      --marker-color: #f97316;
      --tooltip-bg: rgba(255, 255, 255, 0.95);
      --tooltip-text: #1f2933;
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;

      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;

      --card-bg: #1e2129;
      --card-border: #2d3436;
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);

      --canvas-bg: #1e1e1e;
      --canvas-baseline: #4a5568;

      --slider-track: #4a5568;
      --slider-thumb: #a29bfe;

      --select-bg: #2d3436;
      --select-border: #4a5568;

      --header-bg: rgba(30, 33, 41, 0.95);
      --header-border: rgba(162, 155, 254, 0.1);

      --nav-bg: rgba(22, 24, 29, 0.85);
      --nav-border: rgba(255, 255, 255, 0.08);

      /* Sound analyzer specific */
      --axis-color: #ffffff;
      --grid-color: #ffffff;
      --wave-line: #98c616;
      --marker-color: #ff5f1f;
      --tooltip-bg: rgba(15, 16, 20, 0.9);
      --tooltip-text: #ffffff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    .offline-font {
      --font-sans: 'Inter', 'Poppins', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    body {
      font-family: var(--font-sans);
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 30px 30px;
      color: var(--text-main);
      min-height: 100vh;
      padding: 0;
    }

    a {
      color: var(--brand-accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    /* Compact Header */
    header.banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 8px 20px;
      margin: 16px auto 0;
      width: calc(100% - 40px);
      max-width: 1160px;
      background: var(--nav-bg);
      border: 1px solid var(--nav-border);
      border-radius: 20px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .banner-logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .banner-logo img {
      height: 36px;
      width: auto;
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
    }

    .banner-title {
      font-family: var(--font-display);
      font-size: 1.6rem;
      font-weight: 800;
      text-align: center;
      flex: 1;
      letter-spacing: -0.5px;
      color: var(--brand-primary);
    }

    .banner-title.gradient-text {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .banner-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .theme-toggle button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0.5rem;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--text-main);
      min-width: 42px;
      min-height: 42px;
      line-height: 1;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }

    .theme-toggle button:hover {
      background-color: rgba(108, 92, 231, 0.15);
      transform: rotate(15deg);
    }

    /* Main Content */
    .main-content {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Info Bar */
    .info-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .info-card {
      width: 240px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 999px;
      padding: 6px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      overflow: hidden;
    }

    .info-card span {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .info-card strong {
      font-family: var(--font-mono);
      font-size: 0.82rem;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      text-align: right;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--brand-primary);
    }

    /* Card Panels */
    .simulation-area {
      position: relative;
      background: var(--card-bg);
      border-radius: 16px;
      box-shadow: var(--card-shadow);
      border: 1px solid var(--card-border);
      overflow: hidden;
      margin-bottom: 16px;
    }

    .panel-header {
      padding: 12px 16px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--card-border);
    }

    .panel-body {
      padding: 16px;
      position: relative;
    }

    /* Collapsible Spectrum Panel */
    details.simulation-area summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 16px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    details.simulation-area summary::-webkit-details-marker {
      display: none;
    }

    details.simulation-area summary::after {
      content: "\25BE";
      font-size: 1rem;
      color: var(--text-secondary);
      transition: transform 0.2s ease;
    }

    details.simulation-area[open] summary::after {
      transform: rotate(180deg);
    }

    details.simulation-area[open] summary {
      border-bottom: 1px solid var(--card-border);
    }

    details.simulation-area:not([open]) summary {
      border-bottom: none;
    }

    /* Canvas Styling */
    canvas {
      display: block;
      width: 100%;
      height: auto;
      border: none;
      border-radius: 12px;
      background: var(--canvas-bg);
    }

    #visualizer {
      height: clamp(200px, 28vh, 280px);
    }

    #visualizer-container {
      position: relative;
    }

    .spectrum-reset {
      position: absolute;
      top: 8px;
      right: 12px;
      padding: 6px 14px;
      font-size: 0.72rem;
      font-weight: 500;
      font-family: var(--font-sans);
      border-radius: 999px;
      border: 1px solid var(--card-border);
      background: var(--card-bg);
      color: var(--text-secondary);
      cursor: pointer;
      box-shadow: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 2;
    }

    .spectrum-reset.is-hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spectrum-reset:hover {
      transform: translateY(-1px);
      border-color: var(--brand-primary);
      color: var(--brand-primary);
    }

    #waveform {
      height: clamp(280px, 42vh, 420px);
      touch-action: pan-y;
    }

    /* Grid Legend */
    .grid-legend {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .grid-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      font-family: var(--font-mono);
      font-size: 0.72rem;
      font-weight: 500;
      color: var(--text-secondary);
      white-space: nowrap;
      letter-spacing: 0.01em;
    }

    .grid-legend-icon {
      font-size: 0.7rem;
      color: var(--brand-primary);
      font-weight: 700;
      line-height: 1;
    }

    #tooltip {
      position: absolute;
      display: none;
      background-color: var(--tooltip-bg);
      color: var(--tooltip-text);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      pointer-events: none;
      font-size: 0.8rem;
      font-family: var(--font-mono);
      box-shadow: var(--card-shadow);
    }

    /* Controls Panel */
    .controls-panel {
      display: grid;
      grid-template-columns: minmax(200px, 1fr) minmax(200px, 1fr) minmax(200px, 1fr);
      margin-top: 16px;
      background: var(--card-bg);
      border-radius: 16px;
      box-shadow: var(--card-shadow);
      border: 1px solid var(--card-border);
      overflow: hidden;
    }

    .control-section {
      padding: 20px;
    }

    .control-section + .control-section {
      border-left: 1px solid var(--card-border);
    }

    .section-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    /* Slider Controls */
    .slider-control {
      margin-bottom: 16px;
    }

    .slider-control:last-child {
      margin-bottom: 0;
    }

    .slider-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .slider-header label {
      font-size: 0.82rem;
      font-weight: 500;
      color: var(--text-main);
      white-space: nowrap;
    }

    .slider-value {
      font-family: var(--font-mono);
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--brand-primary);
      text-align: right;
    }

    /* Select Input */
    .device-select {
      width: 100%;
      padding: 8px 32px 8px 12px;
      font-size: 0.82rem;
      font-family: var(--font-sans);
      color: var(--text-main);
      background-color: var(--select-bg);
      border: 1px solid var(--select-border);
      border-radius: 10px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23636e72' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 12px;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .device-select:focus {
      outline: none;
      border-color: var(--brand-primary);
      box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.15);
    }

    .device-select:hover {
      border-color: var(--brand-secondary);
    }

    /* Buttons */
    .btn-primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px 24px;
      font-size: 0.88rem;
      font-weight: 600;
      font-family: var(--font-sans);
      cursor: pointer;
      border: none;
      border-radius: 999px;
      color: #ffffff;
      background: var(--brand-primary);
      letter-spacing: 0.2px;
      transition: transform 0.15s ease, opacity 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      width: 100%;
      min-height: 42px;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-secondary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 16px;
      font-size: 0.78rem;
      font-weight: 500;
      font-family: var(--font-sans);
      cursor: pointer;
      border: 1px solid var(--card-border);
      border-radius: 999px;
      color: var(--text-main);
      background: var(--card-bg);
      letter-spacing: 0.2px;
      transition: transform 0.15s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      box-shadow: none;
      width: 100%;
    }

    .btn-secondary:hover:not(:disabled) {
      border-color: var(--brand-accent);
      color: var(--brand-accent);
      transform: translateY(-1px);
    }

    .btn-secondary:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Range Inputs */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 5px;
      background: transparent;
      outline: none;
      border: none;
      padding: 3px 0;
      margin-top: 2px;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--slider-thumb);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      margin-top: -6px;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--slider-thumb);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]:focus {
      outline: none;
    }

    /* Hint Text */
    .hint-text {
      text-align: center;
      font-size: 0.76rem;
      color: var(--text-secondary);
      margin-top: 14px;
      opacity: 0.6;
    }

    .hint-text kbd {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 4px;
      border: 1px solid var(--select-border);
      background: var(--select-bg);
      font-family: var(--font-mono);
      font-size: 0.72rem;
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 20px;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    footer a {
      color: var(--brand-primary);
      text-decoration: none;
      font-weight: 600;
    }

    footer a:hover {
      text-decoration: underline;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .controls-panel {
        grid-template-columns: 1fr;
      }

      .control-section + .control-section {
        border-left: none;
        border-top: 1px solid var(--card-border);
      }

      header.banner {
        flex-direction: column;
        text-align: center;
      }

      .banner-actions {
        width: 100%;
        justify-content: center;
      }

      .banner-title {
        font-size: 1.2rem;
      }
    }

    @media (max-width: 600px) {
      header.banner {
        padding: 8px 12px;
      }

      .banner-logo img {
        height: 28px;
      }

      .banner-title {
        font-size: 1rem;
      }

      .main-content {
        padding: 12px;
      }

      .controls-panel {
        margin-top: 12px;
      }

      .control-section {
        padding: 16px;
      }
    }

    @media (pointer: coarse) {
      button,
      select,
      .theme-toggle {
        min-height: 44px;
        touch-action: manipulation;
      }

      input[type="range"] {
        padding: 19px 0;
        touch-action: manipulation;
      }

      input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
      }

      input[type="range"]::-webkit-slider-thumb {
        width: 28px;
        height: 28px;
        margin-top: -11px;
      }

      input[type="range"]::-moz-range-thumb {
        width: 28px;
        height: 28px;
      }

      canvas {
        touch-action: none;
      }
    }
  </style>
</head>

<body>
  <header class="banner">
    <div class="banner-logo">
      <a href="https://panphy.github.io/">
        <img src="/assets/panphy.png" alt="PanPhy logo" />
      </a>
    </div>

    <div class="banner-title">Sound Analyzer</div>

    <div class="banner-actions">
      <div class="theme-toggle">
        <button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">&#9728;&#65039;</button>
      </div>
    </div>
  </header>

  <div class="main-content">
    <!-- Info Cards -->
    <div class="info-bar">
      <div id="peak-frequency" class="info-card">
        <span>Peak Frequency</span>
        <strong id="peak-frequency-value">-- Hz</strong>
      </div>
      <div id="time-delta" class="info-card">
        <span>Marker Delta</span>
        <strong id="time-delta-value">-- ms</strong>
      </div>
    </div>

    <!-- Spectrum Panel (collapsible) -->
    <details class="simulation-area" id="spectrum-panel" open>
      <summary>Spectrum</summary>
      <div id="visualizer-container" class="panel-body">
        <button id="resetZoomBtn" class="spectrum-reset is-hidden" type="button">Reset zoom</button>
        <canvas id="visualizer" width="800" height="200"></canvas>
        <div id="tooltip"></div>
      </div>
    </details>

    <!-- Oscilloscope Panel -->
    <section class="simulation-area" id="waveform-panel">
      <div class="panel-header">Oscilloscope</div>
      <div id="waveform-container" class="panel-body">
        <canvas id="waveform" width="800" height="200"></canvas>
        <div class="grid-legend">
          <span class="grid-legend-item"><span class="grid-legend-icon">&harr;</span> 1 div = <span id="gridTimeDiv">--</span></span>
          <span class="grid-legend-item"><span class="grid-legend-icon">&varr;</span> 1 div = <span id="gridAmpDiv">--</span></span>
        </div>
      </div>
    </section>

    <!-- Controls Panel -->
    <div class="controls-panel">
      <!-- Column 1: Sliders -->
      <div class="control-section">
        <h3 class="section-title">Scale</h3>
        <div class="slider-control">
          <div class="slider-header">
            <label for="yScale">Amplitude Scale</label>
            <span class="slider-value" id="yScaleValue">5.0</span>
          </div>
          <input type="range" id="yScale" min="0.5" max="20" step="0.5" value="5" aria-label="Amplitude Scale">
        </div>
        <div class="slider-control">
          <div class="slider-header">
            <label for="xScale">Time Scale</label>
            <span class="slider-value" id="xScaleValue">1.0</span>
          </div>
          <input type="range" id="xScale" min="0.5" max="10" step="0.5" value="1" aria-label="Time Scale">
        </div>
      </div>

      <!-- Column 2: Input Source -->
      <div class="control-section">
        <h3 class="section-title">Input Source</h3>
        <label for="inputDeviceSelect" class="slider-header" style="margin-bottom:8px;">
          <span style="font-size:0.82rem;font-weight:500;color:var(--text-main);">Device</span>
        </label>
        <select id="inputDeviceSelect" class="device-select">
          <option value="">Default Microphone</option>
        </select>
      </div>

      <!-- Column 3: Actions -->
      <div class="control-section">
        <h3 class="section-title">Actions</h3>
        <div class="button-group">
          <button id="toggleBtn" class="btn-primary">Start</button>
          <button id="exportSpectrumBtn" class="btn-secondary" disabled>Export Spectrum (.csv)</button>
          <button id="exportWaveformBtn" class="btn-secondary" disabled>Export Waveform (.csv)</button>
        </div>
      </div>
    </div>

    <p class="hint-text"><kbd>Space</kbd> to start / pause</p>
  </div>

  <footer>
    &copy; <a href="/">PanPhy Labs</a> |
    <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
  </footer>

  <script>
    // Gradient text: skip on Brave iOS where background-clip:text is broken
    (function() {
      if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
      document.querySelectorAll('.banner-title').forEach(function(el) { el.classList.add('gradient-text'); });
    })();
  </script>
  <script>
    // Theme Toggle
    const themeButton = document.getElementById('theme-button');
    const DARK_THEME_KEY = "sound-analyzer-dark";
    const LIGHT_THEME_KEY = "sound-analyzer-light";

    const currentTheme = localStorage.getItem(DARK_THEME_KEY) ?
      "dark" :
      localStorage.getItem(LIGHT_THEME_KEY) ?
        "light" :
        "light";

    document.documentElement.setAttribute('data-theme', currentTheme);
    updateAppChromeTheme(currentTheme);
    updateButtonEmoji(currentTheme);

    function updateAppChromeTheme(theme) {
      const themeColorMeta = document.querySelector('meta[name="theme-color"]');
      const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      const isDarkTheme = theme === 'dark';

      if (themeColorMeta) {
        themeColorMeta.setAttribute('content', isDarkTheme ? '#0f1014' : '#f8f9fa');
      }

      if (appleStatusBarMeta) {
        appleStatusBarMeta.setAttribute('content', isDarkTheme ? 'black-translucent' : 'default');
      }
    }

    window.addEventListener('pageshow', function () {
      updateAppChromeTheme(document.documentElement.getAttribute('data-theme'));
    });

    function updateButtonEmoji(theme) {
      themeButton.textContent = theme === 'dark' ? '\u{1F319}' : '\u{2600}\u{FE0F}';
    }

    themeButton.addEventListener('click', function () {
      let theme = document.documentElement.getAttribute('data-theme');
      if (theme === 'light') {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem(DARK_THEME_KEY, 'true');
        localStorage.removeItem(LIGHT_THEME_KEY);
        updateAppChromeTheme('dark');
        updateButtonEmoji('dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem(LIGHT_THEME_KEY, 'true');
        localStorage.removeItem(DARK_THEME_KEY);
        updateAppChromeTheme('light');
        updateButtonEmoji('light');
      }
    });

    // Offline font fallback
    function updateOfflineFontState() {
      document.documentElement.classList.toggle('offline-font', !navigator.onLine);
    }
    window.addEventListener('online', updateOfflineFontState);
    window.addEventListener('offline', updateOfflineFontState);
    updateOfflineFontState();
  </script>
</body>

<script>
  /* ADJUSTABLE GRID SETTINGS */
  const SQUARE_GRID_SPACING = 45;
  const SQUARE_GRID_ALPHA = 0.1;

  // ------------------ Global Variables ------------------
  let audioContext, analyzer, source, microphoneStream;
  let isRunning = false;
  let isStarting = false;
  let sampleRate;
  const fftSize = 2048;
  const MICROPHONE_CONSTRAINTS = {
    audio: {
      autoGainControl: false,
      noiseSuppression: false,
      echoCancellation: false
    }
  };
  // Lenient fallback when strict constraints fail
  const MICROPHONE_CONSTRAINTS_FALLBACK = { audio: true };

  // Frequency data
  let dataArray;
  // Waveform data
  let timeDomainData;

  // Final paused frames
  let lastFreqFrame;
  let lastWaveFrame;

  // Zoom parameters
  let waveAmplitudeScale = 5.0;
  let waveTimeScale = 1.0;
  // Display-only normalization to reduce cross-device mic sensitivity differences.
  const AUTO_WAVE_REFERENCE_SCALE = 5.0;
  const AUTO_WAVE_TARGET_HEIGHT = 0.35;
  const AUTO_WAVE_MIN_PEAK = 0.0002;
  const AUTO_WAVE_MIN_GAIN = 0.4;
  const AUTO_WAVE_MAX_GAIN = 20;
  const AUTO_WAVE_ATTACK = 0.2;
  const AUTO_WAVE_RELEASE = 0.08;
  let adaptiveWaveGain = 1;

  // DOM references
  const freqCanvas = document.getElementById('visualizer');
  const freqCtx = freqCanvas.getContext('2d');

  const waveCanvas = document.getElementById('waveform');
  const waveCtx = waveCanvas.getContext('2d');

  const tooltip = document.getElementById('tooltip');
  const peakFreqDisplay = document.getElementById('peak-frequency-value');
  const timeDeltaDisplay = document.getElementById('time-delta-value');
  const spectrumPanel = document.getElementById('spectrum-panel');
  const resetZoomBtn = document.getElementById('resetZoomBtn');

  const toggleBtn = document.getElementById('toggleBtn');
  const exportSpectrumBtn = document.getElementById('exportSpectrumBtn');
  const exportWaveformBtn = document.getElementById('exportWaveformBtn');

  const yScaleSlider = document.getElementById('yScale');
  const xScaleSlider = document.getElementById('xScale');
  const yScaleValue = document.getElementById('yScaleValue');
  const xScaleValue = document.getElementById('xScaleValue');
  const gridTimeDivEl = document.getElementById('gridTimeDiv');
  const gridAmpDivEl = document.getElementById('gridAmpDiv');
  const inputDeviceSelect = document.getElementById('inputDeviceSelect');
  const INPUT_DEVICE_KEY = 'sound-analyzer-input-device';
  let selectedDeviceId = localStorage.getItem(INPUT_DEVICE_KEY) || '';

  function getCssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
  const markerGrabTolerance = 14;
  let markerA = 0.3;
  let markerB = 0.7;
  let activeMarker = null;

  let canvasDpr = 1;
  let freqCanvasSize = { width: 0, height: 0 };
  let waveCanvasSize = { width: 0, height: 0 };
  let freqZoomRange = null;
  let isSelectingFreq = false;
  let freqSelectStartX = 0;
  let freqSelectCurrentX = 0;

  function setupCanvasResolution() {
    canvasDpr = window.devicePixelRatio || 1;

    const freqRect = freqCanvas.getBoundingClientRect();
    freqCanvasSize = { width: freqRect.width, height: freqRect.height };
    freqCanvas.width = Math.round(freqCanvasSize.width * canvasDpr);
    freqCanvas.height = Math.round(freqCanvasSize.height * canvasDpr);
    freqCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);

    const waveRect = waveCanvas.getBoundingClientRect();
    waveCanvasSize = { width: waveRect.width, height: waveRect.height };
    waveCanvas.width = Math.round(waveCanvasSize.width * canvasDpr);
    waveCanvas.height = Math.round(waveCanvasSize.height * canvasDpr);
    waveCtx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);
  }

  // ------------------ Input Device Enumeration ------------------
  async function enumerateAudioInputs() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      const previousValue = inputDeviceSelect.value;
      inputDeviceSelect.innerHTML = '';

      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'Default Microphone';
      inputDeviceSelect.appendChild(defaultOption);

      audioInputs.forEach((device, index) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.textContent = device.label || `Microphone ${index + 1}`;
        inputDeviceSelect.appendChild(option);
      });

      // Restore previous selection (from dropdown or saved preference)
      const preferred = previousValue || selectedDeviceId;
      if (preferred && [...inputDeviceSelect.options].some(o => o.value === preferred)) {
        inputDeviceSelect.value = preferred;
        selectedDeviceId = preferred;
      } else {
        inputDeviceSelect.value = '';
        selectedDeviceId = '';
      }
    } catch (err) {
      console.warn('Could not enumerate audio devices:', err);
    }
  }

  inputDeviceSelect.addEventListener('change', async () => {
    selectedDeviceId = inputDeviceSelect.value;
    if (selectedDeviceId) {
      localStorage.setItem(INPUT_DEVICE_KEY, selectedDeviceId);
    } else {
      localStorage.removeItem(INPUT_DEVICE_KEY);
    }
    // Force a fresh stream for the new device
    teardownAudioSession();
    microphoneStream = null;
    if (isRunning) {
      isRunning = false;
      await startSpectrum();
    }
  });

  // ------------------ Main Entry ------------------
  window.addEventListener('load', async () => {
    setupCanvasResolution();
    requestAnimationFrame(drawLoop); // always running UI
    await resetAudioSession();
    await enumerateAudioInputs();
    // Listen for audio device changes (e.g. hub connected/disconnected)
    if (navigator.mediaDevices) {
      navigator.mediaDevices.addEventListener('devicechange', onDeviceChange);
    }

    // Attempt to reduce startup friction by requesting mic access on load.
    // Some browsers still require a user gesture; failures are silent here.
    await startSpectrum({ showErrorAlert: false });
  });

  window.addEventListener('resize', setupCanvasResolution);

  window.addEventListener('pageshow', async (event) => {
    if (event.persisted) {
      await resetAudioSession();
    }
  });

  window.addEventListener('beforeunload', () => {
    teardownAudioSession();
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      if (isRunning) pauseSpectrum();
    }
  });

  // ------------------ Button & Keyboard Listeners ------------------
  toggleBtn.addEventListener('click', toggleRunPause);

  exportSpectrumBtn.addEventListener('click', exportSpectrumAsCSV);
  exportWaveformBtn.addEventListener('click', exportWaveformAsCSV);

  function handleGlobalSpaceShortcut(event) {
    if (event.code !== 'Space' || event.repeat) return;

    // Intercept Space globally in capture phase so no focused control
    // (e.g. an input-source <select>) can consume it first.
    event.preventDefault();
    event.stopPropagation(); // prevent the event reaching the focused element
    toggleRunPause(); // Space counts as a user gesture
  }

  window.addEventListener('keydown', handleGlobalSpaceShortcut, true);

  freqCanvas.addEventListener('mousemove', onCanvasHover);
  freqCanvas.addEventListener('touchstart', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchmove', onCanvasTouch, { passive: false });
  freqCanvas.addEventListener('touchend', hideTooltip);
  freqCanvas.addEventListener('touchcancel', hideTooltip);
  freqCanvas.addEventListener('pointerdown', onFreqPointerDown);
  freqCanvas.addEventListener('pointermove', onFreqPointerMove);
  freqCanvas.addEventListener('pointerup', onFreqPointerUp);
  freqCanvas.addEventListener('pointercancel', onFreqPointerUp);

  waveCanvas.addEventListener('pointerdown', onWaveformPointerDown);
  waveCanvas.addEventListener('pointermove', onWaveformPointerMove);
  window.addEventListener('pointerup', onWaveformPointerUp);
  window.addEventListener('pointercancel', onWaveformPointerUp);
  waveCanvas.addEventListener('touchstart', onWaveformTouchStart, { passive: false });
  waveCanvas.addEventListener('touchmove', onWaveformTouchMove, { passive: false });
  waveCanvas.addEventListener('touchend', onWaveformTouchEnd);
  waveCanvas.addEventListener('touchcancel', onWaveformTouchEnd);

  const SPECTRUM_OPEN_KEY = 'sound-analyzer-spectrum-open';
  const savedSpectrumState = localStorage.getItem(SPECTRUM_OPEN_KEY);
  if (savedSpectrumState === 'false') {
    spectrumPanel.removeAttribute('open');
  }

  spectrumPanel.addEventListener('toggle', () => {
    localStorage.setItem(SPECTRUM_OPEN_KEY, spectrumPanel.open);
    requestAnimationFrame(setupCanvasResolution);
  });

  yScaleSlider.addEventListener('input', () => {
    waveAmplitudeScale = parseFloat(yScaleSlider.value);
    yScaleValue.textContent = waveAmplitudeScale.toFixed(1);
  });
  xScaleSlider.addEventListener('input', () => {
    waveTimeScale = parseFloat(xScaleSlider.value);
    xScaleValue.textContent = waveTimeScale.toFixed(1);
  });
  resetZoomBtn.addEventListener('click', resetFrequencyZoom);

  // ------------------ Audio Recovery Helpers ------------------

  // iOS uses an 'interrupted' state when the audio session is taken by another app.
  function onAudioStateChange() {
    if (!audioContext) return;
    if (audioContext.state === 'interrupted' && isRunning) {
      // Hardware change interrupted the session â€” gracefully pause
      pauseSpectrum();
    }
  }

  // When audio devices change (hub connected/disconnected), invalidate any
  // stream whose tracks have ended so the next Start gets a fresh one.
  function onDeviceChange() {
    enumerateAudioInputs();
    if (microphoneStream) {
      const tracks = microphoneStream.getAudioTracks();
      const allEnded = !tracks.length || tracks.every(t => t.readyState === 'ended');
      if (allEnded) {
        microphoneStream = null;
        if (source) { try { source.disconnect(); } catch {} source = null; }
      }
    }
  }

  // Watch for tracks ending (e.g. mic unplugged, hub disconnected while running).
  function setupTrackEndedListeners(stream) {
    stream.getAudioTracks().forEach(track => {
      track.addEventListener('ended', () => {
        if (microphoneStream === stream) microphoneStream = null;
        if (source) { try { source.disconnect(); } catch {} source = null; }
        if (isRunning) pauseSpectrum();
      });
    });
  }

  async function ensureAudioContextRunning() {
    if (audioContext) {
      const state = audioContext.state;
      if (state === 'closed' || state === 'interrupted') {
        try { audioContext.removeEventListener('statechange', onAudioStateChange); } catch {}
        audioContext = null;
        analyzer = null;
        source = null;
        dataArray = null;
        timeDomainData = null;
      }
    }

    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = audioContext.sampleRate;
      audioContext.addEventListener('statechange', onAudioStateChange);
    }

    if (audioContext.state !== 'running') {
      await audioContext.resume();
    }
  }

  function applyDeviceId(constraints) {
    if (!selectedDeviceId) return constraints;
    const copy = JSON.parse(JSON.stringify(constraints));
    if (typeof copy.audio === 'object') {
      copy.audio.deviceId = { exact: selectedDeviceId };
    } else {
      copy.audio = { deviceId: { exact: selectedDeviceId } };
    }
    return copy;
  }

  async function requestMicrophoneStream() {
    if (microphoneStream) {
      return microphoneStream;
    }

    let stream;
    try {
      stream = await navigator.mediaDevices.getUserMedia(applyDeviceId(MICROPHONE_CONSTRAINTS));
    } catch {
      stream = await navigator.mediaDevices.getUserMedia(applyDeviceId(MICROPHONE_CONSTRAINTS_FALLBACK));
    }

    // Re-enumerate to get labels now that we have permission
    enumerateAudioInputs();
    return stream;
  }

  // ------------------ Microphone + Analyzer Setup ------------------
  async function startSpectrum(options = {}) {
    if (isRunning || isStarting) return;
    const { showErrorAlert = true } = options;
    isStarting = true;
    toggleBtn.disabled = true;
    toggleBtn.textContent = 'Starting\u2026';

    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('This browser does not support microphone access.');
      }

      // Discard the existing stream if its tracks have ended (hub disconnect, etc.)
      if (microphoneStream) {
        const tracks = microphoneStream.getAudioTracks();
        if (!tracks.length || tracks.some(t => t.readyState === 'ended')) {
          microphoneStream = null;
        }
      }

      const stream = await requestMicrophoneStream();
      microphoneStream = stream;

      // Watch for the track ending (e.g. device unplugged while running)
      setupTrackEndedListeners(stream);

      await ensureAudioContextRunning();

      if (!analyzer) {
        analyzer = audioContext.createAnalyser();
        analyzer.fftSize = fftSize;
        dataArray = new Uint8Array(analyzer.frequencyBinCount);
        timeDomainData = new Float32Array(analyzer.fftSize);
      }

      if (source) {
        try { source.disconnect(); } catch { }
        source = null;
      }

      source = audioContext.createMediaStreamSource(microphoneStream);
      source.connect(analyzer);

      isRunning = true;
      toggleBtn.textContent = 'Pause';
      exportSpectrumBtn.disabled = true;
      exportWaveformBtn.disabled = true;
    } catch (err) {
      console.warn('Start failed:', err);
      if (showErrorAlert) {
        alert('Unable to start microphone/audio. Please tap Start again.\n\n' + (err?.message || err));
      }
      await resetAudioSession();
    } finally {
      isStarting = false;
      toggleBtn.disabled = false;
      if (!isRunning) toggleBtn.textContent = 'Start';
    }
  }

  async function resetAudioSession() {
    teardownAudioSession();

    if (audioContext) {
      try { audioContext.removeEventListener('statechange', onAudioStateChange); } catch {}
      if (audioContext.state !== 'closed') {
        try {
          await audioContext.close();
        } catch (err) {
          console.warn('Unable to close audio context cleanly:', err);
        }
      }
    }

    audioContext = null;
    analyzer = null;
    source = null;
    microphoneStream = null;
    sampleRate = null;
    dataArray = null;
    timeDomainData = null;
    lastFreqFrame = null;
    lastWaveFrame = null;
    adaptiveWaveGain = 1;
    isRunning = false;
    isStarting = false;

    toggleBtn.textContent = 'Start';
    exportSpectrumBtn.disabled = true;
    exportWaveformBtn.disabled = true;
    peakFreqDisplay.textContent = '-- Hz';
    timeDeltaDisplay.textContent = '-- ms';
    resetFrequencyZoom();
  }

  function teardownAudioSession() {
    if (source) {
      try { source.disconnect(); } catch { }
      source = null;
    }
    if (microphoneStream) {
      microphoneStream.getTracks().forEach((track) => track.stop());
      microphoneStream = null;
    }
  }

  function toggleRunPause() {
    if (isRunning) {
      pauseSpectrum();
    } else {
      startSpectrum();
    }
  }

  function pauseSpectrum() {
    isRunning = false;
    toggleBtn.textContent = 'Resume';
    exportSpectrumBtn.disabled = false;
    exportWaveformBtn.disabled = false;

    if (dataArray) lastFreqFrame = dataArray.slice();
    if (timeDomainData) lastWaveFrame = timeDomainData.slice();

    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend();
    }

    teardownAudioSession();
  }

  function resetFrequencyZoom() {
    freqZoomRange = null;
    updateResetZoomButton();
  }

  function updateResetZoomButton() {
    const isHidden = !freqZoomRange;
    resetZoomBtn.classList.toggle('is-hidden', isHidden);
  }

  function setFrequencyZoom(startIndex, endIndex) {
    if (!analyzer) return;
    const binCount = analyzer.frequencyBinCount;
    const clampedStart = Math.max(0, Math.min(startIndex, binCount - 1));
    const clampedEnd = Math.max(0, Math.min(endIndex, binCount - 1));
    if (Math.abs(clampedEnd - clampedStart) < 3) return;
    freqZoomRange = {
      startIndex: Math.min(clampedStart, clampedEnd),
      endIndex: Math.max(clampedStart, clampedEnd)
    };
    updateResetZoomButton();
  }

  function getFrequencyZoomRange() {
    if (!analyzer) return { startIndex: 0, endIndex: 0, startFreq: 0, endFreq: 0 };
    const binCount = analyzer.frequencyBinCount;
    const startIndex = freqZoomRange ? freqZoomRange.startIndex : 0;
    const endIndex = freqZoomRange ? freqZoomRange.endIndex : binCount - 1;
    return {
      startIndex,
      endIndex,
      startFreq: indexToFrequency(startIndex),
      endFreq: indexToFrequency(endIndex)
    };
  }

  function xToBinIndex(x) {
    if (!analyzer) return 0;
    const { startIndex, endIndex } = getFrequencyZoomRange();
    const span = Math.max(1, endIndex - startIndex);
    const clampedX = Math.max(0, Math.min(x, freqCanvasSize.width));
    const ratio = clampedX / freqCanvasSize.width;
    return Math.round(startIndex + ratio * span);
  }

  function binIndexToX(index) {
    if (!analyzer) return 0;
    const { startIndex, endIndex } = getFrequencyZoomRange();
    const span = Math.max(1, endIndex - startIndex);
    const clampedIndex = Math.max(startIndex, Math.min(index, endIndex));
    const ratio = (clampedIndex - startIndex) / span;
    return ratio * freqCanvasSize.width;
  }

  function onFreqPointerDown(event) {
    if (!analyzer) return;
    const rect = freqCanvas.getBoundingClientRect();
    freqSelectStartX = event.clientX - rect.left;
    freqSelectCurrentX = freqSelectStartX;
    isSelectingFreq = true;
    freqCanvas.setPointerCapture(event.pointerId);
    tooltip.style.display = 'none';
    event.preventDefault();
  }

  function onFreqPointerMove(event) {
    if (!isSelectingFreq) return;
    const rect = freqCanvas.getBoundingClientRect();
    freqSelectCurrentX = event.clientX - rect.left;
  }

  function onFreqPointerUp() {
    if (!isSelectingFreq) return;
    isSelectingFreq = false;
    const minX = Math.min(freqSelectStartX, freqSelectCurrentX);
    const maxX = Math.max(freqSelectStartX, freqSelectCurrentX);
    const startIndex = xToBinIndex(minX);
    const endIndex = xToBinIndex(maxX);
    setFrequencyZoom(startIndex, endIndex);
  }

  function getAdaptiveWaveGain(samples) {
    if (!samples || !samples.length) return adaptiveWaveGain;

    let peak = 0;
    for (let i = 0; i < samples.length; i++) {
      const absoluteValue = Math.abs(samples[i]);
      if (absoluteValue > peak) peak = absoluteValue;
    }

    let targetGain = 1;
    if (peak >= AUTO_WAVE_MIN_PEAK) {
      targetGain = AUTO_WAVE_TARGET_HEIGHT / (peak * AUTO_WAVE_REFERENCE_SCALE);
      targetGain = Math.max(AUTO_WAVE_MIN_GAIN, Math.min(targetGain, AUTO_WAVE_MAX_GAIN));
    }

    const smoothing = targetGain > adaptiveWaveGain ? AUTO_WAVE_ATTACK : AUTO_WAVE_RELEASE;
    adaptiveWaveGain += (targetGain - adaptiveWaveGain) * smoothing;
    return adaptiveWaveGain;
  }

  // ------------------ The Continuous Draw Loop ------------------
  function drawLoop() {
    requestAnimationFrame(drawLoop);

    const canvasBg = getCssVar('--canvas-bg');
    const waveLine = getCssVar('--wave-line');

    // Frequency Spectrum background
    freqCtx.fillStyle = canvasBg;
    freqCtx.fillRect(0, 0, freqCanvasSize.width, freqCanvasSize.height);

    // Waveform background
    waveCtx.fillStyle = canvasBg;
    waveCtx.fillRect(0, 0, waveCanvasSize.width, waveCanvasSize.height);
    drawSquareGridWithTime();

    if (!analyzer || !dataArray || !timeDomainData) {
      peakFreqDisplay.textContent = '-- Hz';
      updateGridLegend(0);
      return;
    }

    // Frequency data
    if (isRunning) {
      analyzer.getByteFrequencyData(dataArray);
    } else if (lastFreqFrame) {
      dataArray.set(lastFreqFrame);
    }

    // Peak freq
    let peakIndex = 0, peakValue = -1;
    for (let i = 0; i < dataArray.length; i++) {
      if (dataArray[i] > peakValue) {
        peakValue = dataArray[i];
        peakIndex = i;
      }
    }
    const peakFreq = indexToFrequency(peakIndex);
    peakFreqDisplay.textContent = `${peakFreq.toFixed(1)} Hz`;

    const { startIndex, endIndex, startFreq, endFreq } = getFrequencyZoomRange();

    // Frequency bars
    const barCount = Math.max(1, endIndex - startIndex + 1);
    const barWidth = freqCanvasSize.width / barCount;
    for (let i = startIndex; i <= endIndex; i++) {
      const barHeight = (dataArray[i] / 255) * freqCanvasSize.height * 0.8;
      const x = (i - startIndex) * barWidth;
      const y = freqCanvasSize.height - barHeight;
      freqCtx.fillStyle = `rgb(${barHeight + 50}, 50, 50)`;
      freqCtx.fillRect(x, y, barWidth, barHeight);
    }

    // Frequency axis
    drawFrequencyAxis(freqCtx, freqCanvasSize.width, freqCanvasSize.height, startFreq, endFreq);

    if (isSelectingFreq) {
      const selectionX = Math.min(freqSelectStartX, freqSelectCurrentX);
      const selectionW = Math.abs(freqSelectCurrentX - freqSelectStartX);
      freqCtx.save();
      freqCtx.globalAlpha = 0.2;
      freqCtx.fillStyle = getCssVar('--brand-accent');
      freqCtx.fillRect(selectionX, 0, selectionW, freqCanvasSize.height);
      freqCtx.globalAlpha = 0.6;
      freqCtx.strokeStyle = getCssVar('--brand-accent');
      freqCtx.strokeRect(selectionX, 0, selectionW, freqCanvasSize.height);
      freqCtx.restore();
    }

    // Time-domain waveform
    if (isRunning) {
      analyzer.getFloatTimeDomainData(timeDomainData);
      lastWaveFrame = timeDomainData.slice();
    } else if (lastWaveFrame) {
      timeDomainData.set(lastWaveFrame);
    }

    waveCtx.lineWidth = 2;
    waveCtx.strokeStyle = waveLine;
    waveCtx.beginPath();

    const totalSamples = timeDomainData.length;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(2, Math.floor(windowSize));

    const sliceWidth = waveCanvasSize.width / (windowSize - 1);
    const frameWaveGain = isRunning ? getAdaptiveWaveGain(timeDomainData) : adaptiveWaveGain;
    const displayWaveGain = waveAmplitudeScale * frameWaveGain;

    let x = 0;
    for (let i = 0; i < windowSize; i++) {
      const v = timeDomainData[i];
      const y = (waveCanvasSize.height / 2) + v * (waveCanvasSize.height / 2) * displayWaveGain;
      if (i === 0) waveCtx.moveTo(x, y);
      else waveCtx.lineTo(x, y);
      x += sliceWidth;
    }
    waveCtx.stroke();

    drawWaveformMarkers();
    updateGridLegend(displayWaveGain);
  }

  // ------------------ Draw the Frequency Axis ------------------
  function drawFrequencyAxis(ctx, width, height, startFreq, endFreq) {
    if (!sampleRate || !analyzer) return;

    ctx.fillStyle = getCssVar('--axis-color');
    ctx.font = '12px sans-serif';

    const numTicks = 5;
    const minFreq = startFreq ?? 0;
    const maxFreq = endFreq ?? (sampleRate / 2);

    for (let i = 0; i <= numTicks; i++) {
      const freq = minFreq + ((maxFreq - minFreq) / numTicks) * i;
      const bin = frequencyToIndex(freq);
      const x = binIndexToX(bin);

      ctx.beginPath();
      ctx.moveTo(x, height - 5);
      ctx.lineTo(x, height);
      ctx.strokeStyle = getCssVar('--axis-color');
      ctx.stroke();

      let label;
      if (freq >= 1000) label = (freq / 1000).toFixed(1) + ' kHz';
      else label = freq.toFixed(0) + ' Hz';

      ctx.fillText(label, x + 2, height - 6);
    }
  }

  // ------------------ Square Grid & Time Axis ------------------
  function drawSquareGridWithTime() {
    waveCtx.save();
    const gridColor = getCssVar('--grid-color');
    waveCtx.globalAlpha = SQUARE_GRID_ALPHA;
    waveCtx.strokeStyle = gridColor;

    const dispW = waveCanvasSize.width;

    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const numVertLines = Math.floor(dispW / SQUARE_GRID_SPACING);
    for (let i = 0; i <= numVertLines; i++) {
      const screenX = i * SQUARE_GRID_SPACING;

      waveCtx.beginPath();
      waveCtx.moveTo(screenX, 0);
      waveCtx.lineTo(screenX, waveCanvasSize.height);
      waveCtx.stroke();
    }

    const centerY = waveCanvasSize.height / 2;
    const spacingY = SQUARE_GRID_SPACING;

    for (let y = centerY; y >= 0; y -= spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    for (let y = centerY + spacingY; y <= waveCanvasSize.height; y += spacingY) {
      waveCtx.beginPath();
      waveCtx.moveTo(0, y);
      waveCtx.lineTo(waveCanvasSize.width, y);
      waveCtx.stroke();
    }

    waveCtx.globalAlpha = 1;
    waveCtx.restore();
  }

  function updateGridLegend(displayWaveGain) {
    const dispW = waveCanvasSize.width;
    const dispH = waveCanvasSize.height;
    if (!dispW || !dispH) return;

    // Time per division
    const sr = sampleRate || 44100;
    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const totalTimeSec = windowSize / sr;
    const timePerDivSec = (SQUARE_GRID_SPACING / dispW) * totalTimeSec;
    const timePerDivMs = timePerDivSec * 1000;

    if (timePerDivMs >= 1) {
      gridTimeDivEl.textContent = timePerDivMs.toFixed(2) + ' ms';
    } else {
      gridTimeDivEl.textContent = (timePerDivMs * 1000).toFixed(1) + ' \u00B5s';
    }

    // Amplitude per division (normalized)
    const gain = displayWaveGain || (waveAmplitudeScale * adaptiveWaveGain);
    const halfHeight = dispH / 2;
    if (gain > 0 && halfHeight > 0) {
      const ampPerDiv = SQUARE_GRID_SPACING / (halfHeight * gain);
      if (ampPerDiv >= 0.01) {
        gridAmpDivEl.textContent = ampPerDiv.toFixed(3);
      } else {
        gridAmpDivEl.textContent = ampPerDiv.toExponential(1);
      }
    } else {
      gridAmpDivEl.textContent = '--';
    }
  }

  function drawWaveformMarkers() {
    const width = waveCanvasSize.width;
    if (!width) return;

    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    waveCtx.save();
    waveCtx.lineWidth = 1;
    waveCtx.strokeStyle = getCssVar('--marker-color');

    waveCtx.beginPath();
    waveCtx.moveTo(markerX1, 0);
    waveCtx.lineTo(markerX1, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.beginPath();
    waveCtx.moveTo(markerX2, 0);
    waveCtx.lineTo(markerX2, waveCanvasSize.height);
    waveCtx.stroke();

    waveCtx.restore();

    updateTimeDeltaDisplay(markerX1, markerX2);
  }

  function updateTimeDeltaDisplay(markerX1, markerX2) {
    const totalSamples = timeDomainData ? timeDomainData.length : fftSize;
    let windowSize = totalSamples / waveTimeScale;
    if (windowSize > totalSamples) windowSize = totalSamples;
    windowSize = Math.max(1, Math.floor(windowSize));

    const totalTimeSec = windowSize / (sampleRate || 44100);
    const deltaMs = Math.abs(markerX2 - markerX1) / waveCanvasSize.width * totalTimeSec * 1000;

    timeDeltaDisplay.textContent = `${deltaMs.toFixed(2)} ms`;
  }

  function pickActiveMarker(cursorX, allowNearest = false) {
    const width = waveCanvasSize.width;
    const markerX1 = markerA * width;
    const markerX2 = markerB * width;

    if (Math.abs(cursorX - markerX1) <= markerGrabTolerance) return 'A';
    if (Math.abs(cursorX - markerX2) <= markerGrabTolerance) return 'B';
    if (!allowNearest) return null;
    return Math.abs(cursorX - markerX1) <= Math.abs(cursorX - markerX2) ? 'A' : 'B';
  }

  function getCursorXFromEvent(event) {
    const rect = waveCanvas.getBoundingClientRect();
    return event.clientX - rect.left;
  }

  function updateWaveformCursor(cursorX) {
    const marker = pickActiveMarker(cursorX);
    waveCanvas.style.cursor = marker ? 'ew-resize' : 'crosshair';
  }

  function updateMarkerPosition(cursorX) {
    const width = waveCanvasSize.width;
    if (!width) return;

    const clamped = Math.min(Math.max(cursorX / width, 0), 1);
    if (activeMarker === 'A') markerA = clamped;
    else if (activeMarker === 'B') markerB = clamped;
  }

  function onWaveformPointerDown(event) {
    const cursorX = getCursorXFromEvent(event);
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    waveCanvas.setPointerCapture(event.pointerId);
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformPointerMove(event) {
    const cursorX = getCursorXFromEvent(event);
    if (!activeMarker) {
      updateWaveformCursor(cursorX);
      return;
    }
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
  }

  function onWaveformPointerUp() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  function onWaveformTouchStart(event) {
    if (!event.touches.length) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    activeMarker = pickActiveMarker(cursorX, true);
    if (!activeMarker) return;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchMove(event) {
    if (!event.touches.length || !activeMarker) return;
    const rect = waveCanvas.getBoundingClientRect();
    const touch = event.touches[0];
    const cursorX = touch.clientX - rect.left;
    updateMarkerPosition(cursorX);
    updateWaveformCursor(cursorX);
    event.preventDefault();
  }

  function onWaveformTouchEnd() {
    activeMarker = null;
    waveCanvas.style.cursor = 'crosshair';
  }

  // ------------------ Export Spectrum (remove zero-amplitude) ------------------
  function exportSpectrumAsCSV() {
    if (!analyzer || !lastFreqFrame) {
      alert("No paused data available. Please pause first.");
      return;
    }

    const binCount = analyzer.frequencyBinCount;
    let csvContent = "data:text/csv;charset=utf-8,Frequency (Hz),Amplitude (a.u.)\n";

    for (let i = 0; i < binCount; i++) {
      const amp = lastFreqFrame[i];
      if (amp > 0) {
        const freq = indexToFrequency(i);
        csvContent += freq.toFixed(1) + "," + amp + "\n";
      }
    }

    downloadCSV(csvContent, "spectrum_data.csv");
  }

  // ------------------ Export Waveform (Time vs Amplitude) ------------------
  function exportWaveformAsCSV() {
    if (!lastWaveFrame || !sampleRate) {
      alert("No paused data available. Please pause first.");
      return;
    }

    const totalSamples = lastWaveFrame.length;

    let csvContent = "data:text/csv;charset=utf-8,Time (ms),Amplitude (normalized)\n";
    for (let i = 0; i < totalSamples; i++) {
      const timeMs = (i / sampleRate) * 1000;
      const amplitude = lastWaveFrame[i];
      csvContent += timeMs.toFixed(2) + "," + amplitude + "\n";
    }

    downloadCSV(csvContent, "waveform_data.csv");
  }

  function downloadCSV(csvString, filename) {
    const encodedUri = encodeURI(csvString);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  // ------------------ Utility: bin <-> frequency conversion ------------------
  function indexToFrequency(index) {
    if (!sampleRate) return 0;
    return index * (sampleRate / fftSize);
  }

  function frequencyToIndex(freq) {
    if (!sampleRate) return 0;
    return Math.round(freq / (sampleRate / fftSize));
  }

  // ------------------ Hover/Touch Inspection (Paused Only) ------------------
  function onCanvasHover(e) {
    if (isSelectingFreq || isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    const rect = freqCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    showTooltip(x, y);
  }

  function onCanvasTouch(e) {
    if (isSelectingFreq || isRunning || !lastFreqFrame || !analyzer) {
      tooltip.style.display = 'none';
      return;
    }
    e.preventDefault();
    const touch = e.touches[0];
    const rect = freqCanvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    showTooltip(x, y);
  }

  function hideTooltip() {
    tooltip.style.display = 'none';
  }

  function showTooltip(x, y) {
    const binIndex = xToBinIndex(x);

    if (!analyzer || binIndex < 0 || binIndex >= analyzer.frequencyBinCount) {
      tooltip.style.display = 'none';
      return;
    }

    const freq = indexToFrequency(binIndex).toFixed(1);
    const amplitude = lastFreqFrame[binIndex];

    tooltip.style.display = 'block';
    tooltip.style.left = (x + 10) + 'px';
    tooltip.style.top = (y + 10) + 'px';
    tooltip.innerHTML = `
      <div>Freq: ${freq} Hz</div>
      <div>Amp: ${amplitude} (a.u.)</div>
    `;
  }
</script>

</html>
