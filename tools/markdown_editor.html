<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Editor with LaTeX</title>
  <link rel="icon" type="image/png" href="/favicon.png">

  <!-- MathJax Configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        packages: ['base', 'ams'],
      },
      svg: {
        fontCache: 'local',
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <!-- Marked.js -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- DOMPurify -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>

  <!-- Highlight.js Stylesheets -->
  <link id="highlightStyle" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">

  <!-- Highlight.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

  <!-- Initialize Highlight.js after DOM content is loaded -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      hljs.highlightAll();
    });
  </script>

  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    :root {
      --background-color: #ffffff;
      --text-color: #000000;
      --pane-background: #ffffff;
      --pane-heading-background: #333333;
      --pane-heading-color: #ffffff;
      --button-background: #f0f0f0;
      --button-color: #000000;
      --border-color: #ccc;
      --code-background: #f0f0f0;
      --table-border-color: black;
      --table-header-background: #f4f4f4;
    }

    body.dark-mode {
      --background-color: #1e1e1e;
      --text-color: #e0e0e0;
      --pane-background: #1e1e1e;
      --pane-heading-background: #2d2c2c;
      --pane-heading-color: #ffffff;
      --button-background: #474646;
      --button-color: #ffffff;
      --border-color: #555555;
      --code-background: #2f2f2f;
      --table-border-color: #555555;
      --table-header-background: #333333;
      --code-text-color: #f8f8f2;
    }

    body {
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin: 0;
      font-family: Helvetica, sans-serif;
      line-height: 1.5;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    html,
    body {
      overflow-x: hidden;
    }

    a {
      color: #ff5f1f;
      text-decoration: none;
    }

    a:hover {
      color: #ff5f1f;
      text-decoration: underline;
    }

    a:visited {
      color: #ff5f1f;
    }

    /* ---------------------------------------------------------------------- */
    /* Main container for both the input and output panes                     */
    /* ---------------------------------------------------------------------- */
    #editorContainer {
      display: flex;
      flex: 1;
      background-color: var(--pane-background);
      height: 100%;
      border-top: 0px solid var(--border-color);
      border-bottom: 0px solid var(--border-color);
    }

    /* ---------------------------------------------------------------------- */
    /* Left Pane = Markdown Input; Right Pane = Rendered Output               */
    /* Each is 50% width on larger screens                                   */
    /* ---------------------------------------------------------------------- */
    #inputPane,
    #outputPane {
      flex: 0 0 50%;
      padding: 0;
      box-sizing: border-box;
      background-color: var(--pane-background);
      display: flex;
      flex-direction: column;
      min-height: 0;
      min-width: 240px;
      border: none;
    }

    #inputPane {
      border-right: 1px solid var(--border-color);
    }

    /* ---------------------------------------------------------------------- */
    /* Draggable resizer between panes                                       */
    /* ---------------------------------------------------------------------- */
    #paneResizer {
      width: 8px;
      cursor: col-resize;
      background: transparent;
      position: relative;
      flex: 0 0 8px;
      z-index: 2;
    }

    #paneResizer::before {
      content: "";
      position: absolute;
      left: 3px;
      top: 0;
      bottom: 0;
      width: 2px;
      background-color: var(--border-color);
    }

    body.resizing {
      cursor: col-resize;
      user-select: none;
    }

    /* ---------------------------------------------------------------------- */
    /* Header container for each pane                                         */
    /* ---------------------------------------------------------------------- */
    .pane-heading-container {
      display: grid;
      grid-template-columns: 50px 1fr 50px;
      height: 45px;
      align-items: center;
      background-color: var(--pane-heading-background);
      color: var(--pane-heading-color);
      margin: 0;
      padding: 0 10px;
    }

    textarea:focus {
      outline: none;
    }

    .logo-container img {
      max-height: 30px;
      margin: 0 auto 0 0;
      display: block;
    }

    .heading-placeholder,
    .theme-toggle-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pane-heading {
      text-align: center;
      margin: 0;
      font-size: 1.2em;
    }

    /* ---------------------------------------------------------------------- */
    /* Theme toggle button                                                    */
    /* ---------------------------------------------------------------------- */
    .theme-toggle-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 18px;
      color: var(--pane-heading-color);
      margin: 0;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .theme-toggle-button:hover {
      opacity: 0.8;
    }

    /* ---------------------------------------------------------------------- */
    /* Button container under pane headers                                    */
    /* ---------------------------------------------------------------------- */
    .buttonContainer {
      margin: 10px 0;
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      position: relative;
    }

    body.dark-mode .buttonContainer button {
      background-color: var(--button-background);
      color: var(--button-color);
      border: none;
    }

    .scroll-sync-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9em;
      color: var(--pane-heading-color);
      cursor: pointer;
      user-select: none;
    }

    .scroll-sync-toggle input {
      cursor: pointer;
    }

    /* ---------------------------------------------------------------------- */
    /* Markdown input textarea                                                */
    /* ---------------------------------------------------------------------- */
    textarea {
      flex: 1;
      width: 100%;
      padding: 20px;
      border: none;
      resize: none;
      font-size: 15px;
      line-height: 1.5;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: var(--pane-background);
      color: var(--text-color);
    }

    /* ---------------------------------------------------------------------- */
    /* Rendered output area                                                   */
    /* ---------------------------------------------------------------------- */
    #renderedOutput {
      flex: 1;
      padding: 20px;
      font-size: 15px;
      line-height: 1.5;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: var(--pane-background);
      color: var(--text-color);
    }

    .md-block {
      scroll-margin-top: 20px;
    }

    .highlighted-block {
      outline: 2px solid #ff5f1f;
      background-color: rgba(255, 95, 31, 0.12);
      border-radius: 4px;
    }

    /* ---------------------------------------------------------------------- */
    /* Code blocks and syntax highlighting                                    */
    /* ---------------------------------------------------------------------- */
    code {
      background-color: var(--code-background);
      padding: 0.1em 0.2em;
      border-radius: 3px;
      font-size: 0.95em;
      line-height: 1;
      font-family: "Courier New", Courier, monospace;
      vertical-align: baseline;
      color: inherit;
    }

    pre {
      background-color: var(--code-background);
      padding: 0;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 0.95em;
      line-height: 1.5;
      margin: 2px 0;
    }

    pre code {
      background: none;
      padding: 0;
      border-radius: 0;
      font-family: inherit;
      line-height: 1.5;
      font-size: inherit;
      color: inherit;
    }

    .hljs {
      line-height: 1.5;
      font-size: 0.95em;
      background-color: inherit;
      color: inherit;
    }

    body.dark-mode .hljs {
      color: var(--code-text-color);
    }

    body.dark-mode .hljs-comment,
    body.dark-mode .hljs-quote {
      color: #8d9a70 !important;
    }

    body.dark-mode .hljs-keyword,
    body.dark-mode .hljs-selector-tag,
    body.dark-mode .hljs-subst {
      color: #66d9ef !important;
    }

    body.dark-mode .hljs-string,
    body.dark-mode .hljs-doctag {
      color: #e6db74 !important;
    }

    body.dark-mode .hljs-number,
    body.dark-mode .hljs-regexp,
    body.dark-mode .hljs-tag .hljs-attr {
      color: #ae81ff !important;
    }

    body.dark-mode .hljs-title,
    body.dark-mode .hljs-section {
      color: #a6e22e !important;
    }

    body.dark-mode .hljs-type,
    body.dark-mode .hljs-built_in {
      color: #fd971f !important;
    }

    body.dark-mode .hljs-symbol,
    body.dark-mode .hljs-bullet {
      color: #f92672 !important;
    }

    body.dark-mode .hljs-link {
      color: #e6db74 !important;
    }

    /* ---------------------------------------------------------------------- */
    /* Table styling                                                          */
    /* ---------------------------------------------------------------------- */
    table {
      max-width: 100%;
      margin: 20px auto;
      border-collapse: collapse;
      border: 1px solid var(--table-border-color);
    }

    th,
    td {
      border: 1px solid var(--table-border-color);
      padding: 8px 10px;
    }

    th[align="left"],
    td[align="left"] {
      text-align: left;
    }

    th[align="center"],
    td[align="center"] {
      text-align: center;
    }

    th[align="right"],
    td[align="right"] {
      text-align: right;
    }

    th,
    td {
      text-align: left;
    }

    /* ---------------------------------------------------------------------- */
    /* Printing styles                                                        */
    /* ---------------------------------------------------------------------- */
    @media print {
      :root {
        --background-color: #ffffff !important;
        --text-color: #000000 !important;
        --pane-background: #ffffff !important;
        --pane-heading-background: #333333 !important;
        --pane-heading-color: #ffffff !important;
        --button-background: #f0f0f0 !important;
        --button-color: #000000 !important;
        --border-color: #ccc !important;
        --code-background: #f0f0f0 !important;
        --table-border-color: black !important;
        --table-header-background: #f4f4f4 !important;
      }

      body {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
        margin: 0 !important;
      }

      #editorContainer {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
      }

      #inputPane {
        display: none !important;
      }

      #outputPane {
        display: block !important;
        width: auto !important;
        height: auto !important;
        overflow: visible !important;
        padding: 15mm !important;
        border: none !important;
      }

      .pane-heading-container {
        display: none !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      .no-print {
        display: none !important;
      }

      svg,
      pre {
        page-break-inside: avoid !important;
        line-height: 1.5 !important;
      }

      #renderedOutput {
        height: auto !important;
        overflow: visible !important;
      }

      footer {
        display: none !important;
      }

      .page-break {
        display: block;
        page-break-after: always;
        height: 0;
      }

      svg {
        color: #000000 !important;
        stroke: #000000 !important;
      }

      pre {
        background-color: #f0f0f0 !important;
        font-size: 0.95em !important;
        margin: 2px 0 !important;
      }

      .hljs {
        color: #000000 !important;
        line-height: 1.5 !important;
        font-size: 0.95em !important;
        background-color: inherit !important;
      }

      .hljs-comment,
      .hljs-quote {
        color: #008000 !important;
      }

      th[align="center"],
      td[align="center"] {
        text-align: center !important;
      }

      th[align="right"],
      td[align="right"] {
        text-align: right !important;
      }

      th,
      td {
        text-align: left !important;
      }
    }

    /* ---------------------------------------------------------------------- */
    /* Buttons and footer                                                     */
    /* ---------------------------------------------------------------------- */
    footer {
      text-align: center;
      padding: 5px;
      background: #f4f4f4;
      color: #555;
      margin: 5px 0;
      width: 100%;
    }

    body.dark-mode footer {
      background: #2d2c2c;
      color: #ccc;
    }

    button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      background-color: var(--button-background);
      color: var(--button-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      transition: background-color 0.3s, color 0.3s;
    }

    button:hover {
      opacity: 0.8;
    }

    /* ==========================================================================
     RESPONSIVE RULES
     ========================================================================== */

    /* 1) For narrow screens, stack the two panes vertically and have each fill
        available height equally */
    @media (max-width: 900px) {
      #editorContainer {
        flex-direction: column;
      }

      #inputPane,
      #outputPane {
        width: 100%;
        border-right: none;
        flex: 1 1 auto;
        /* Ensures both panes share the available height equally */
      }

      #paneResizer {
        display: none;
      }
    }

    /* 2) Wrap and resize the buttons when space is too narrow */
    @media (max-width: 600px) {
      .buttonContainer {
        flex-wrap: wrap;
        justify-content: center;
      }

      .buttonContainer button {
        flex: 1 0 auto;
        margin: 5px 2px;
        min-width: 110px;
      }

    }
  </style>
</head>

<body>
  <!--
      The main container with two panes:
      - Left = Markdown Input
      - Right = Rendered Output
  -->
  <div id="editorContainer">
    <!-- ============================================= -->
    <!-- =========== Markdown Input Pane ============= -->
    <!-- ============================================= -->
    <div id="inputPane">
      <!--
          New 3-column heading container:
          1) Logo on the left
          2) "Markdown Input" in the center
          3) placeholder on the right
      -->
      <div class="pane-heading-container">
        <!-- Logo Container (Left) -->
        <div class="logo-container">
          <!-- Link the logo to PanPhy website -->
          <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">
            <img src="/panphy.png" alt="PanPhy logo" />
          </a>
        </div>

        <!-- The heading in the Center -->
        <h2 class="pane-heading">Markdown Input</h2>

        <!-- Placeholder on the Right (keeps grid layout consistent) -->
        <div class="heading-placeholder"></div>
      </div>

      <!-- Buttons and the markdown input textarea below -->
      <div class="buttonContainer">
        <button id="loadFileButton">Open .md File</button>
        <button id="saveMDButton">Save .md</button>
        <button id="clearButton">Clear Input</button>
        <button id="loadSampleButton">Sample Document</button>
      </div>
      <textarea id="markdownInput" placeholder="Type your Markdown and LaTeX here..."></textarea>
    </div>

    <div id="paneResizer" aria-label="Resize panes" role="separator"></div>

    <!-- ============================================= -->
    <!-- ========== Rendered Output Pane ============= -->
    <!-- ============================================= -->
    <div id="outputPane">
      <!--
          New 3-column heading container:
          1) placeholder on the left
          2) "Rendered Output" in the center
          3) theme toggle on the right
      -->
      <div class="pane-heading-container">
        <!-- Placeholder on the Left -->
        <div class="heading-placeholder"></div>

        <!-- The heading in the Center -->
        <h2 class="pane-heading">Rendered Output</h2>

        <!-- Theme toggle button on the Right -->
        <div class="theme-toggle-wrapper">
          <button id="themeToggleButton" class="theme-toggle-button no-print" aria-label="Switch to Dark Mode"
            title="Switch to Dark Mode">
            ‚òÄÔ∏è
          </button>
        </div>
      </div>

      <!-- Buttons and rendered output below -->
      <div class="buttonContainer no-print">
        <button id="printButton" title="Prints in light mode">Print to PDF</button>
        <button id="exportHTMLButton" title="Exports in current theme">Export as HTML</button>
        <label class="scroll-sync-toggle" for="scrollSyncToggle">
          <input type="checkbox" id="scrollSyncToggle" />
          Scroll sync preview
        </label>
      </div>
      <div id="renderedOutput"></div>
    </div>
  </div>

  <footer>
    &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
    <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
  </footer>
</body>


<script>
  const markdownInput = document.getElementById('markdownInput');
  const renderedOutput = document.getElementById('renderedOutput');
  const clearButton = document.getElementById('clearButton');
  const loadSampleButton = document.getElementById('loadSampleButton');
  const exportHTMLButton = document.getElementById('exportHTMLButton');
  const printButton = document.getElementById('printButton');
  const saveMDButton = document.getElementById('saveMDButton');
  const loadFileButton = document.getElementById('loadFileButton');
  const themeToggleButton = document.getElementById('themeToggleButton');
  const scrollSyncToggle = document.getElementById('scrollSyncToggle');
  const highlightStyle = document.getElementById('highlightStyle');
  const editorContainer = document.getElementById('editorContainer');
  const inputPane = document.getElementById('inputPane');
  const outputPane = document.getElementById('outputPane');
  const paneResizer = document.getElementById('paneResizer');
  const paneSplitStorageKey = 'markdownPaneSplit';
  const draftStorageKey = 'markdownEditorDraft';
  let isScrollSyncEnabled = false;

  /**
   * Fetch and load the sample Markdown document from 'mkdwn_sample_doc.md'
   */
  function loadSampleDocument() {
    fetch('mkdwn_sample_doc.md')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.text();
      })
      .then(data => {
        markdownInput.value = data;
        renderContent();
        saveDraft();
      })
      .catch(error => {
        console.error('Error loading sample document:', error);
        alert('Failed to load the sample document.');
      });
  }

  /**
   * Preprocess the input Markdown by preserving valid TeX inside math blocks.
   *
   * Quick manual checks:
   * - Inline TeX: $\\frac{1}{2}$ should render correctly.
   * - Escaped backslashes: $\\\\$ should remain as a literal double backslash.
   * - Currency: $5/day should stay as plain text.
   * - Literal dollar: \\$ should stay as plain text.
   *
   * @param {string} input - The raw Markdown input.
   * @returns {string} - The processed Markdown with TeX preserved.
   */
  function preprocessMarkdown(input) {
    const isEscaped = index => index > 0 && input[index - 1] === '\\';
    const isCurrencyLike = content => /^\d/.test(content) && /\s/.test(content);

    let output = '';
    let i = 0;

    while (i < input.length) {
      const char = input[i];

      if (char === '$' && !isEscaped(i)) {
        const isDisplay = input[i + 1] === '$' && !isEscaped(i + 1);
        const delimiter = isDisplay ? '$$' : '$';
        const start = i;
        let searchIndex = i + delimiter.length;
        let closingIndex = -1;

        while (searchIndex < input.length) {
          if (input.startsWith(delimiter, searchIndex) && !isEscaped(searchIndex)) {
            closingIndex = searchIndex;
            break;
          }
          searchIndex += 1;
        }

        if (closingIndex === -1) {
          output += delimiter;
          i += delimiter.length;
          continue;
        }

        const content = input.slice(i + delimiter.length, closingIndex);

        if (!isDisplay && isCurrencyLike(content)) {
          output += '$';
          i = start + 1;
          continue;
        }

        output += delimiter + content + delimiter;
        i = closingIndex + delimiter.length;
        continue;
      }

      output += char;
      i += 1;
    }

    return output;
  }

  function buildLineBlocks(text) {
    const tokens = marked.lexer(text);

    const countNewlines = value => (value.match(/\n/g) || []).length;

    const getBlockTag = token => {
      switch (token.type) {
        case 'heading':
          return `h${token.depth}`;
        case 'paragraph':
          return 'p';
        case 'list':
          return token.ordered ? 'ol' : 'ul';
        case 'blockquote':
          return 'blockquote';
        case 'code':
          return 'pre';
        case 'table':
          return 'table';
        case 'hr':
          return 'hr';
        default:
          return null;
      }
    };

    const getChildTokens = token => {
      if (token.type === 'list') {
        return token.items.flatMap(item => item.tokens || []);
      }
      if (token.type === 'blockquote') {
        return token.tokens || [];
      }
      return [];
    };

    const collectBlocksFromTokens = (tokenList, sourceText, baseLine) => {
      const blocks = [];
      let cursor = 0;

      tokenList.forEach(token => {
        if (!token.raw) {
          return;
        }

        const matchIndex = sourceText.indexOf(token.raw, cursor);
        if (matchIndex === -1) {
          return;
        }

        const startLine = baseLine + countNewlines(sourceText.slice(0, matchIndex));
        const endLine = startLine + countNewlines(token.raw);
        const tag = getBlockTag(token);

        if (tag) {
          blocks.push({ start: startLine, end: endLine, tag });
        }

        const childTokens = getChildTokens(token);
        if (childTokens.length) {
          blocks.push(...collectBlocksFromTokens(childTokens, token.raw, startLine));
        }

        cursor = matchIndex + token.raw.length;
      });

      return blocks;
    };

    return collectBlocksFromTokens(tokens, text, 1);
  }

  function wrapRenderedBlocks(html, lineBlocks) {
    const container = document.createElement('div');
    container.innerHTML = html;
    const blockElements = Array.from(
      container.querySelectorAll('h1,h2,h3,h4,h5,h6,p,ul,ol,blockquote,pre,table,hr')
    );
    let elementIndex = 0;

    lineBlocks.forEach(block => {
      while (elementIndex < blockElements.length) {
        const element = blockElements[elementIndex];
        if (element.tagName.toLowerCase() === block.tag) {
          const wrapper = document.createElement('div');
          wrapper.classList.add('md-block');
          wrapper.dataset.srcStart = String(block.start);
          wrapper.dataset.srcEnd = String(block.end);
          element.replaceWith(wrapper);
          wrapper.appendChild(element);
          elementIndex += 1;
          return;
        }
        elementIndex += 1;
      }
    });
    return container.innerHTML;
  }

  function renderContent() {
    const inputText = markdownInput.value;
    const preprocessedText = preprocessMarkdown(inputText);

    const renderer = {
      listitem(token) {
        let checkbox = '';
        if (token.task) {
          checkbox = `<input type="checkbox" disabled${token.checked ? ' checked' : ''}> `;
        }
        const body = this.parser.parse(token.tokens);
        return `<li>${checkbox}${body}</li>`;
      }
    };

    marked.setOptions({
      gfm: true,
      headerIds: true,
      tables: true,
      langPrefix: 'hljs language-',
      highlight: function (code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        }
        return hljs.highlightAuto(code).value;
      }
    });
    marked.use({ renderer });

    const lineBlocks = buildLineBlocks(preprocessedText);
    const parsedMarkdown = marked.parse(preprocessedText);
    const sanitizedContent = DOMPurify.sanitize(parsedMarkdown);
    renderedOutput.innerHTML = wrapRenderedBlocks(sanitizedContent, lineBlocks);

    hljs.highlightAll();
    MathJax.typesetPromise([renderedOutput]).catch(console.error);
    updateHighlightedBlockFromCaret();
  }

  function saveDraft() {
    localStorage.setItem(draftStorageKey, markdownInput.value);
  }

  function clearDraft() {
    localStorage.removeItem(draftStorageKey);
  }

  function restoreDraft() {
    const savedDraft = localStorage.getItem(draftStorageKey);
    if (savedDraft !== null) {
      markdownInput.value = savedDraft;
    }
  }

  function debounce(fn, delay) {
    let timerId;
    return (...args) => {
      window.clearTimeout(timerId);
      timerId = window.setTimeout(() => {
        fn(...args);
      }, delay);
    };
  }

  function getLineNumberFromOffset(text, offset) {
    if (offset <= 0) {
      return 1;
    }
    return text.slice(0, offset).split('\n').length;
  }

  function getOffsetsForLineRange(text, startLine, endLine) {
    const lines = text.split('\n');
    let startOffset = 0;
    let endOffset = text.length;

    for (let i = 0; i < lines.length; i += 1) {
      if (i + 1 < startLine) {
        startOffset += lines[i].length + 1;
      }
    }

    let cursor = 0;
    for (let i = 0; i < lines.length; i += 1) {
      if (i + 1 <= endLine) {
        cursor += lines[i].length;
        if (i + 1 < lines.length) {
          cursor += 1;
        }
      }
    }
    endOffset = cursor;

    return { startOffset, endOffset };
  }

  function updateHighlightedBlockFromCaret({ forceScroll = false } = {}) {
    const lineNumber = getLineNumberFromOffset(markdownInput.value, markdownInput.selectionStart || 0);
    const blocks = Array.from(renderedOutput.querySelectorAll('[data-src-start][data-src-end]'));
    const matchingBlocks = blocks.filter(block => {
      const start = Number(block.dataset.srcStart);
      const end = Number(block.dataset.srcEnd);
      return lineNumber >= start && lineNumber <= end;
    });
    const matchingBlock = matchingBlocks.reduce((best, block) => {
      if (!best) {
        return block;
      }
      const bestSpan = Number(best.dataset.srcEnd) - Number(best.dataset.srcStart);
      const currentSpan = Number(block.dataset.srcEnd) - Number(block.dataset.srcStart);
      return currentSpan < bestSpan ? block : best;
    }, null);

    const current = renderedOutput.querySelector('.highlighted-block');
    if (current && current !== matchingBlock) {
      current.classList.remove('highlighted-block');
    }

    if (!matchingBlock) {
      return;
    }

    matchingBlock.classList.add('highlighted-block');
    if (isScrollSyncEnabled || forceScroll) {
      matchingBlock.scrollIntoView({ block: 'center', behavior: 'smooth' });
    }
  }

  function syncCaretFromOutputClick(event) {
    const targetBlock = event.target.closest('[data-src-start][data-src-end]');
    if (!targetBlock) return;

    const startLine = Number(targetBlock.dataset.srcStart);
    const endLine = Number(targetBlock.dataset.srcEnd);
    if (Number.isNaN(startLine) || Number.isNaN(endLine)) return;

    const text = markdownInput.value;
    const offsets = getOffsetsForLineRange(text, startLine, endLine);
    markdownInput.focus();
    markdownInput.setSelectionRange(offsets.startOffset, offsets.endOffset);

    const lineHeight = parseFloat(getComputedStyle(markdownInput).lineHeight) || 16;
    markdownInput.scrollTop = Math.max(0, (startLine - 1) * lineHeight);
    updateHighlightedBlockFromCaret({ forceScroll: true });
  }

  async function printToPDF() {
    const body = document.body;
    const hadDarkMode = body.classList.contains('dark-mode');
    if (hadDarkMode) {
      body.classList.remove('dark-mode');
    }
    highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    await MathJax.typesetPromise([renderedOutput]);
    hljs.highlightAll();
    window.print();
    if (hadDarkMode) {
      body.classList.add('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
      updateThemeToggleButton();
    }
  }

  function exportHTML() {
    const fileName = prompt('Enter file name for the HTML export:', 'document.html');
    if (!fileName) return;

    const sanitizedHTML = renderedOutput.innerHTML;
    const doc = document.implementation.createHTMLDocument('Exported Document');
    const head = doc.head;
    const body = doc.body;

    const meta = document.createElement('meta');
    meta.setAttribute('charset', 'UTF-8');
    head.appendChild(meta);

    const title = document.createElement('title');
    title.textContent = 'Exported Document';
    head.appendChild(title);

    const style = document.createElement('style');
    style.textContent = `
        :root {
          --background-color: #ffffff;
          --text-color: #000000;
          --pane-background: #ffffff;
          --pane-heading-background: #333333;
          --pane-heading-color: #ffffff;
          --button-background: #f0f0f0;
          --button-color: #000000;
          --border-color: #ccc;
          --code-background: #f0f0f0;
          --table-border-color: black;
          --table-header-background: #f4f4f4;
        }

        body.dark-mode {
          --background-color: #1e1e1e;
          --text-color: #e0e0e0;
          --pane-background: #1e1e1e;
          --pane-heading-background: #2d2c2c;
          --pane-heading-color: #ffffff;
          --button-background: #474646;
          --button-color: #ffffff;
          --border-color: #555555;
          --code-background: #2f2f2f;
          --table-border-color: #555555;
          --table-header-background: #333333;
          --code-text-color: #f8f8f2;
        }

        body {
          font-family: Helvetica, sans-serif;
          line-height: 1.5;
          margin: 20px;
          background-color: var(--background-color);
          color: var(--text-color);
        }

        body, div, p, h1, h2, h3, h4, h5, h6, pre, code, table, th, td, blockquote {
          background-color: var(--background-color);
          color: var(--text-color);
        }

        a {
          color: #ff5f1f;
          text-decoration: none;
        }

        a:hover {
          color: #ff5f1f;
          text-decoration: underline;
        }

        a:visited {
          color: #ff5f1f;
        }

        table {
          max-width: 100%;
          margin: 20px auto;
          border-collapse: collapse;
          border: 1px solid var(--table-border-color);
        }

        th, td {
          border: 1px solid var(--table-border-color);
          padding: 8px;
        }

        th[align="left"], td[align="left"] {
          text-align: left;
        }

        th[align="center"], td[align="center"] {
          text-align: center;
        }

        th[align="right"], td[align="right"] {
          text-align: right;
        }

        th, td {
          text-align: left;
        }

        code {
          background-color: var(--code-background);
          padding: 0.1em 0.2em;
          border-radius: 3px;
          font-size: 0.95em;
          line-height: 1;
          font-family: "Courier New", Courier, monospace;
          vertical-align: baseline;
          color: inherit;
        }

        pre {
          background-color: var(--code-background);
          padding: 0;
          border-radius: 5px;
          overflow-x: auto;
          font-size: 1.05em;
          line-height: 1.5;
          margin: 2px 0;
        }

        pre code {
          background: none;
          padding: 0;
          border-radius: 0;
          font-family: inherit;
          line-height: 1.5;
          font-size: inherit;
          color: inherit;
        }

        .hljs {
          line-height: 1.5;
          font-size: 1.05em;
          background-color: inherit;
          color: inherit;
        }

        body.dark-mode .hljs {
          color: #f8f8f2 !important;
        }

        body.dark-mode .hljs-comment,
        body.dark-mode .hljs-quote {
          color: #8d9a70 !important;
        }

        body.dark-mode .hljs-keyword,
        body.dark-mode .hljs-selector-tag,
        body.dark-mode .hljs-subst {
          color: #66d9ef !important;
        }

        body.dark-mode .hljs-string,
        body.dark-mode .hljs-doctag {
          color: #e6db74 !important;
        }

        body.dark-mode .hljs-number,
        body.dark-mode .hljs-regexp,
        body.dark-mode .hljs-tag .hljs-attr {
          color: #ae81ff !important;
        }

        body.dark-mode .hljs-title,
        body.dark-mode .hljs-section {
          color: #a6e22e !important;
        }

        body.dark-mode .hljs-type,
        body.dark-mode .hljs-built_in {
          color: #fd971f !important;
        }

        body.dark-mode .hljs-symbol,
        body.dark-mode .hljs-bullet {
          color: #f92672 !important;
        }

        body.dark-mode .hljs-link {
          color: #e6db74 !important;
        }

        img {
          max-width: 100%;
          height: auto;
        }
      `;
    head.appendChild(style);

    const isDarkMode = document.body.classList.contains('dark-mode');
    const highlightLink = document.createElement('link');
    highlightLink.rel = 'stylesheet';
    if (isDarkMode) {
      highlightLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      highlightLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
    head.appendChild(highlightLink);

    const highlightScript = document.createElement('script');
    highlightScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js';
    head.appendChild(highlightScript);

    const highlightInit = document.createElement('script');
    highlightInit.textContent = `
        window.addEventListener('DOMContentLoaded', () => {
          hljs.highlightAll();
        });
      `;
    head.appendChild(highlightInit);

    const mathjaxConfigScript = document.createElement('script');
    mathjaxConfigScript.textContent = `
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            packages: ['base', 'ams'],
          },
          svg: {
            fontCache: 'local',
          }
        };
      `;
    head.appendChild(mathjaxConfigScript);

    const mathjaxScript = document.createElement('script');
    mathjaxScript.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
    head.appendChild(mathjaxScript);

    body.innerHTML = sanitizedHTML;

    if (isDarkMode) {
      body.classList.add('dark-mode');
    }

    const exportedHTML = `<!DOCTYPE html>${doc.documentElement.outerHTML}`;
    const blob = new Blob([exportedHTML], { type: 'text/html' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
  }

  function saveMarkdown() {
    const fileName = prompt('Enter file name for the Markdown file:', 'document.md');
    if (!fileName) return;

    const blob = new Blob([markdownInput.value], { type: 'text/markdown' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
  }

  function loadMarkdownFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.md,text/markdown';
    input.onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = event => {
          markdownInput.value = event.target.result;
          renderContent();
          saveDraft();
        };
        reader.readAsText(file);
      }
    };
    input.click();
  }

  /**
   * Initialize the theme based on saved preference.
   */
  function initializeTheme() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'markdown-dark') {
      document.body.classList.add('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      document.body.classList.remove('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
    updateThemeToggleButton();
  }

  /**
   * Toggle between dark and light themes and save the preference.
   */
  function toggleTheme() {
    document.body.classList.toggle('dark-mode');

    if (document.body.classList.contains('dark-mode')) {
      themeToggleButton.textContent = 'üåô';
      themeToggleButton.setAttribute('aria-label', 'Switch to Light Mode');
      themeToggleButton.setAttribute('title', 'Switch to Light Mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
      localStorage.setItem('theme', 'markdown-dark');
    } else {
      themeToggleButton.textContent = '‚òÄÔ∏è';
      themeToggleButton.setAttribute('aria-label', 'Switch to Dark Mode');
      themeToggleButton.setAttribute('title', 'Switch to Dark Mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
      localStorage.setItem('theme', 'markdown-light');
    }
  }

  /**
   * Update the theme toggle button's icon and attributes.
   */
  function updateThemeToggleButton() {
    if (document.body.classList.contains('dark-mode')) {
      themeToggleButton.textContent = 'üåô';
      themeToggleButton.setAttribute('aria-label', 'Switch to Light Mode');
      themeToggleButton.setAttribute('title', 'Switch to Light Mode');
    } else {
      themeToggleButton.textContent = '‚òÄÔ∏è';
      themeToggleButton.setAttribute('aria-label', 'Switch to Dark Mode');
      themeToggleButton.setAttribute('title', 'Switch to Dark Mode');
    }
  }

  window.addEventListener('beforeprint', () => {
    highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
  });

  window.addEventListener('afterprint', () => {
    if (document.body.classList.contains('dark-mode')) {
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
  });

  // Initialize theme and render content on load
  initializeTheme();
  restoreDraft();
  renderContent();

  function setPaneSplit(percent, shouldPersist = true) {
    const clamped = Math.min(85, Math.max(15, percent));
    inputPane.style.flex = `0 0 ${clamped}%`;
    outputPane.style.flex = `0 0 ${100 - clamped}%`;
    if (shouldPersist) {
      localStorage.setItem(paneSplitStorageKey, clamped.toString());
    }
  }

  function resetPaneSplit() {
    inputPane.style.flex = '1 1 auto';
    outputPane.style.flex = '1 1 auto';
  }

  const splitMediaQuery = window.matchMedia('(max-width: 900px)');
  const storedSplit = parseFloat(localStorage.getItem(paneSplitStorageKey));
  if (!Number.isNaN(storedSplit) && !splitMediaQuery.matches) {
    setPaneSplit(storedSplit, false);
  }

  splitMediaQuery.addEventListener('change', event => {
    if (event.matches) {
      resetPaneSplit();
    } else {
      const savedSplit = parseFloat(localStorage.getItem(paneSplitStorageKey));
      setPaneSplit(Number.isNaN(savedSplit) ? 50 : savedSplit, false);
    }
  });

  paneResizer.addEventListener('pointerdown', event => {
    if (splitMediaQuery.matches) return;
    event.preventDefault();
    paneResizer.setPointerCapture(event.pointerId);
    document.body.classList.add('resizing');

    const onPointerMove = moveEvent => {
      const rect = editorContainer.getBoundingClientRect();
      const offsetX = moveEvent.clientX - rect.left;
      const percent = (offsetX / rect.width) * 100;
      setPaneSplit(percent);
    };

    const onPointerUp = upEvent => {
      paneResizer.releasePointerCapture(upEvent.pointerId);
      document.body.classList.remove('resizing');
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
    };

    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
  });

  const handleCaretChange = () => updateHighlightedBlockFromCaret();

  const debouncedRenderAndSave = debounce(() => {
    renderContent();
    saveDraft();
  }, 200);
  markdownInput.addEventListener('input', debouncedRenderAndSave);
  markdownInput.addEventListener('keyup', handleCaretChange);
  markdownInput.addEventListener('click', handleCaretChange);
  markdownInput.addEventListener('select', handleCaretChange);
  renderedOutput.addEventListener('click', syncCaretFromOutputClick);
  printButton.addEventListener('click', printToPDF);
  exportHTMLButton.addEventListener('click', exportHTML);
  saveMDButton.addEventListener('click', saveMarkdown);
  loadFileButton.addEventListener('click', loadMarkdownFile);
  loadSampleButton.addEventListener('click', loadSampleDocument); // Updated event listener
  clearButton.addEventListener('click', () => {
    markdownInput.value = '';
    clearDraft();
    renderContent();
  });
  themeToggleButton.addEventListener('click', toggleTheme);
  scrollSyncToggle.addEventListener('change', event => {
    isScrollSyncEnabled = event.target.checked;
    if (isScrollSyncEnabled) {
      updateHighlightedBlockFromCaret({ forceScroll: true });
    }
  });
</script>

</html>
