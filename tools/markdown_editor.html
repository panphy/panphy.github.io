<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markdown Editor with LaTeX</title>
  <link rel="icon" type="image/png" href="/favicon.png">
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .catch((err) => console.log('Service Worker registration failed', err));
      });
    }
  </script>
  <!-- MathJax Configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        packages: ['base', 'ams', 'array'],
      },
      svg: {
        fontCache: 'local',
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <!-- Marked.js -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- DOMPurify -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>

  <!-- Highlight.js Stylesheets -->
  <link id="highlightStyle" rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">

  <!-- Highlight.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

  <!-- Initialize Highlight.js after DOM content is loaded -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      hljs.highlightAll();
    });
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --background-color: #f8f9fa;
      --background-pattern: #e9ecef;
      --text-color: #2d3436;
      --text-muted: #636e72;
      --brand-primary: #6c5ce7;
      --brand-accent: #00cec9;
      --pane-background: #ffffff;
      --pane-heading-background: rgba(255, 255, 255, 0.85);
      --pane-heading-color: #2d3436;
      --button-background: #eef1f4;
      --button-color: #2d3436;
      --border-color: rgba(0, 0, 0, 0.08);
      --toolbar-background: rgba(255, 255, 255, 0.6);
      --code-background: #f1f3f5;
      --table-border-color: rgba(45, 52, 54, 0.4);
      --table-header-background: #f4f6f8;
      --shadow-soft: 0 8px 20px rgba(0, 0, 0, 0.06);
      --base-font-size: 16px;
    }

    body.dark-mode {
      --background-color: #0f1014;
      --background-pattern: #181a20;
      --text-color: #dfe6e9;
      --text-muted: #b2bec3;
      --brand-primary: #a29bfe;
      --brand-accent: #81ecec;
      --pane-background: #1e2129;
      --pane-heading-background: rgba(22, 24, 29, 0.85);
      --pane-heading-color: #dfe6e9;
      --button-background: #2a2f38;
      --button-color: #dfe6e9;
      --border-color: rgba(255, 255, 255, 0.1);
      --toolbar-background: rgba(22, 24, 29, 0.55);
      --code-background: #2b3038;
      --table-border-color: rgba(255, 255, 255, 0.2);
      --table-header-background: #252a33;
      --code-text-color: #f8f8f2;
      --shadow-soft: 0 8px 24px rgba(0, 0, 0, 0.35);
    }

    body {
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin: 0;
      font-family: var(--font-sans);
      line-height: 1.5;
      background-color: var(--background-color);
      background-image: radial-gradient(var(--background-pattern) 1px, transparent 1px);
      background-size: 28px 28px;
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    html,
    body {
      overflow-x: hidden;
    }

    a {
      color: #ff5f1f;
      text-decoration: none;
    }

    a:hover {
      color: #ff5f1f;
      text-decoration: underline;
    }

    a:visited {
      color: #ff5f1f;
    }

    /* ---------------------------------------------------------------------- */
    /* Main container for both the input and output panes                     */
    /* ---------------------------------------------------------------------- */
    #editorContainer {
      display: flex;
      flex: 1;
      background-color: var(--pane-background);
      height: 100%;
      border-top: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
      box-shadow: var(--shadow-soft);
    }

    /* ---------------------------------------------------------------------- */
    /* Left Pane = Markdown Input; Right Pane = Rendered Output               */
    /* Each is 50% width on larger screens                                   */
    /* ---------------------------------------------------------------------- */
    #inputPane,
    #outputPane {
      flex: 1 1 50%;
      padding: 0;
      box-sizing: border-box;
      background-color: var(--pane-background);
      display: flex;
      flex-direction: column;
      min-height: 0;
      min-width: 240px;
      border: none;
      position: relative;
    }

    #inputPane {
      border-right: 1px solid var(--border-color);
    }

    /* ---------------------------------------------------------------------- */
    /* Header container for each pane                                         */
    /* ---------------------------------------------------------------------- */
    .pane-heading-container {
      display: grid;
      grid-template-columns: 50px 1fr 50px;
      height: 44px;
      align-items: center;
      background-color: var(--pane-heading-background);
      color: var(--pane-heading-color);
      margin: 0;
      padding: 0 12px;
      border-bottom: 1px solid var(--border-color);
      backdrop-filter: blur(10px);
    }

    textarea:focus {
      outline: none;
    }

    .logo-container img {
      max-height: 30px;
      margin: 0 auto 0 0;
      display: block;
    }

    .heading-placeholder,
    .theme-toggle-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pane-heading {
      text-align: center;
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      font-family: var(--font-display);
      letter-spacing: 0.2px;
      color: var(--pane-heading-color);
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* ---------------------------------------------------------------------- */
    /* Theme toggle button                                                    */
    /* ---------------------------------------------------------------------- */
    .theme-toggle-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 18px;
      color: var(--pane-heading-color);
      margin: 0;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .theme-toggle-button:hover {
      opacity: 0.8;
    }

    /* ---------------------------------------------------------------------- */
    /* Button container under pane headers                                    */
    /* ---------------------------------------------------------------------- */
    .buttonContainer {
      margin: 8px 0;
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      position: relative;
      flex-wrap: wrap;
    }

    .buttonContainer.floating-toolbar {
      position: sticky;
      top: 12px;
      z-index: 20;
      margin: 8px 12px;
      padding: 8px 12px;
      background: var(--toolbar-background);
      border-radius: 999px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-soft);
    }

    .buttonContainer.output-controls {
      width: 100%;
      justify-content: space-between;
      flex-wrap: nowrap;
      padding: 0 12px;
    }

    .buttonContainer.floating-toolbar.output-controls {
      width: calc(100% - 24px);
      padding: 8px 12px;
    }

    .buttonContainer.output-controls .output-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin: 0 auto;
    }

    .buttonContainer.output-controls .output-toggles {
      display: inline-flex;
      gap: 12px;
      align-items: center;
      justify-content: flex-end;
    }

    body.dark-mode .buttonContainer button {
      background-color: var(--button-background);
      color: var(--button-color);
      border: none;
    }

    .scroll-sync-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 0.8rem;
      color: var(--text-color);
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    .scroll-sync-toggle input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .scroll-sync-toggle .toggle-slider {
      position: relative;
      width: 38px;
      height: 20px;
      border-radius: 999px;
      background: #b8c7d2;
      transition: background-color 0.2s ease;
      display: inline-flex;
      align-items: center;
      padding: 2px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .scroll-sync-toggle .toggle-slider {
      background: #4d5b66;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
    }

    .scroll-sync-toggle .toggle-slider::after {
      content: "";
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      transition: transform 0.2s ease;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .scroll-sync-toggle input:checked + .toggle-slider {
      background: var(--brand-accent);
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);
    }

    .scroll-sync-toggle input:checked + .toggle-slider::after {
      transform: translateX(18px);
    }

    .scroll-sync-toggle .toggle-label {
      font-weight: 600;
    }

    .font-size-selector {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 10px;
      border-radius: 999px;
      background-color: var(--button-background);
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
      font-size: 0.8rem;
      color: var(--text-color);
    }

    .font-size-selector label {
      font-weight: 600;
      color: var(--text-color);
    }

    .font-size-selector select {
      border: none;
      background: transparent;
      font-size: 0.8rem;
      color: var(--text-color);
      font-weight: 600;
      cursor: pointer;
      outline: none;
    }

    body.dark-mode .font-size-selector {
      background-color: var(--button-background);
      border-color: transparent;
    }

    /* ---------------------------------------------------------------------- */
    /* Markdown input textarea                                                */
    /* ---------------------------------------------------------------------- */
    textarea {
      flex: 1;
      width: 100%;
      padding: 18px;
      border: none;
      resize: none;
      font-size: var(--base-font-size);
      line-height: 1.5;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: var(--pane-background);
      color: var(--text-color);
    }

    /* ---------------------------------------------------------------------- */
    /* Rendered output area                                                   */
    /* ---------------------------------------------------------------------- */
    #renderedOutput {
      flex: 1;
      padding: 18px;
      font-size: var(--base-font-size);
      line-height: 1.5;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: var(--pane-background);
      color: var(--text-color);
      position: relative;
      z-index: 0;
    }

    .md-block {
      scroll-margin-top: 20px;
    }

    .highlighted-block {
      outline: 2px solid #ff5f1f;
      background-color: rgba(255, 95, 31, 0.12);
      border-radius: 4px;
    }

    /* ---------------------------------------------------------------------- */
    /* Code blocks and syntax highlighting                                    */
    /* ---------------------------------------------------------------------- */
    code {
      background-color: var(--code-background);
      padding: 0.1em 0.2em;
      border-radius: 3px;
      font-size: 0.95em;
      line-height: 1;
      font-family: var(--font-mono);
      vertical-align: baseline;
      color: inherit;
    }

    pre {
      background-color: var(--code-background);
      padding: 0;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 0.95em;
      line-height: 1.5;
      margin: 2px 0;
    }

    pre code {
      background: none;
      padding: 0;
      border-radius: 0;
      font-family: inherit;
      line-height: 1.5;
      font-size: inherit;
      color: inherit;
    }

    .hljs {
      line-height: 1.5;
      font-size: 0.95em;
      background-color: inherit;
      color: inherit;
    }

    body.dark-mode .hljs {
      color: var(--code-text-color);
    }

    body.dark-mode .hljs-comment,
    body.dark-mode .hljs-quote {
      color: #8d9a70 !important;
    }

    body.dark-mode .hljs-keyword,
    body.dark-mode .hljs-selector-tag,
    body.dark-mode .hljs-subst {
      color: #66d9ef !important;
    }

    body.dark-mode .hljs-string,
    body.dark-mode .hljs-doctag {
      color: #e6db74 !important;
    }

    body.dark-mode .hljs-number,
    body.dark-mode .hljs-regexp,
    body.dark-mode .hljs-tag .hljs-attr {
      color: #ae81ff !important;
    }

    body.dark-mode .hljs-title,
    body.dark-mode .hljs-section {
      color: #a6e22e !important;
    }

    body.dark-mode .hljs-type,
    body.dark-mode .hljs-built_in {
      color: #fd971f !important;
    }

    body.dark-mode .hljs-symbol,
    body.dark-mode .hljs-bullet {
      color: #f92672 !important;
    }

    body.dark-mode .hljs-link {
      color: #e6db74 !important;
    }

    /* ---------------------------------------------------------------------- */
    /* Table styling                                                          */
    /* ---------------------------------------------------------------------- */
    table {
      max-width: 100%;
      margin: 20px auto;
      border-collapse: collapse;
      border: 1px solid var(--table-border-color);
    }

    th,
    td {
      border: 1px solid var(--table-border-color);
      padding: 8px 10px;
    }

    th[align="left"],
    td[align="left"] {
      text-align: left;
    }

    th[align="center"],
    td[align="center"] {
      text-align: center;
    }

    th[align="right"],
    td[align="right"] {
      text-align: right;
    }

    th,
    td {
      text-align: left;
    }

    /* ---------------------------------------------------------------------- */
    /* Printing styles                                                        */
    /* ---------------------------------------------------------------------- */
    @media print {
      :root {
        --background-color: #ffffff !important;
        --text-color: #000000 !important;
        --pane-background: #ffffff !important;
        --pane-heading-background: #333333 !important;
        --pane-heading-color: #ffffff !important;
        --button-background: #f0f0f0 !important;
        --button-color: #000000 !important;
        --border-color: #ccc !important;
        --code-background: #f0f0f0 !important;
        --table-border-color: black !important;
        --table-header-background: #f4f4f4 !important;
      }

      body,
      body.dark-mode {
        --background-color: #ffffff !important;
        --text-color: #000000 !important;
        --pane-background: #ffffff !important;
        --pane-heading-background: #333333 !important;
        --pane-heading-color: #ffffff !important;
        --button-background: #f0f0f0 !important;
        --button-color: #000000 !important;
        --border-color: #ccc !important;
        --code-background: #f0f0f0 !important;
        --table-border-color: black !important;
        --table-header-background: #f4f4f4 !important;
        background-color: #ffffff !important;
        color: #000000 !important;
        color-scheme: light !important;
      }

      body {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
        margin: 0 !important;
        font-size: var(--base-font-size) !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        background-image: none !important;
      }

      #editorContainer {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
        border: none !important;
        box-shadow: none !important;
      }

      #inputPane {
        display: none !important;
      }

      #outputPane {
        display: block !important;
        width: auto !important;
        height: auto !important;
        overflow: visible !important;
        padding: 15mm !important;
        border: none !important;
        box-shadow: none !important;
      }

      .pane-heading-container {
        display: none !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      .no-print {
        display: none !important;
      }

      svg,
      pre {
        page-break-inside: avoid !important;
        line-height: 1.5 !important;
      }

      #renderedOutput {
        height: auto !important;
        overflow: visible !important;
      }

      footer {
        display: none !important;
      }

      .page-break {
        display: block;
        page-break-after: always;
        height: 0;
      }

      svg {
        color: #000000 !important;
        stroke: #000000 !important;
      }

      pre {
        background-color: #f0f0f0 !important;
        font-size: 0.95em !important;
        margin: 2px 0 !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      .hljs {
        color: #000000 !important;
        line-height: 1.5 !important;
        font-size: 0.95em !important;
        background-color: inherit !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      .hljs-comment,
      .hljs-quote {
        color: #008000 !important;
      }

      th[align="center"],
      td[align="center"] {
        text-align: center !important;
      }

      th[align="right"],
      td[align="right"] {
        text-align: right !important;
      }

      th,
      td {
        text-align: left !important;
      }
    }

    /* ---------------------------------------------------------------------- */
    /* Buttons and footer                                                     */
    /* ---------------------------------------------------------------------- */
    footer {
      text-align: center;
      padding: 6px;
      background: var(--pane-heading-background);
      color: var(--text-muted);
      margin: 0;
      width: 100%;
      border-top: 1px solid var(--border-color);
      font-size: 0.75rem;
    }

    body.dark-mode footer {
      background: var(--pane-heading-background);
      color: var(--text-muted);
    }

    button {
      margin: 2px;
      padding: 6px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      background-color: var(--button-background);
      color: var(--button-color);
      border: 1px solid var(--border-color);
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
      transition: background-color 0.3s, color 0.3s;
    }

    button:hover {
      opacity: 0.85;
      transform: translateY(-1px);
    }

    /* ==========================================================================
     RESPONSIVE RULES
     ========================================================================== */

    /* 1) For narrow screens, stack the two panes vertically and have each fill
        available height equally */
    @media (max-width: 900px) {
      #editorContainer {
        flex-direction: column;
      }

      #inputPane,
      #outputPane {
        width: 100%;
        border-right: none;
        flex: 1 1 auto;
        /* Ensures both panes share the available height equally */
      }

    }

    /* 2) Wrap and resize the buttons when space is too narrow */
    @media (max-width: 600px) {
      .buttonContainer {
        flex-wrap: wrap;
        justify-content: center;
      }

      .buttonContainer.floating-toolbar {
        border-radius: 24px;
      }

      .buttonContainer.output-controls {
        flex-wrap: wrap;
      }

      .buttonContainer.output-controls .output-actions {
        margin: 0;
      }

      .buttonContainer button {
        flex: 1 0 auto;
        margin: 4px 2px;
        min-width: 100px;
      }

    }

    @media (pointer: coarse) {
      button,
      input,
      select,
      textarea {
        min-height: 44px;
        touch-action: manipulation;
      }

      .buttonContainer button {
        padding: 0.6rem 0.9rem;
      }
    }

    .offline-font {
      --font-sans: 'Segoe UI', system-ui, -apple-system, 'Helvetica Neue', Arial, sans-serif;
    }

    /* Click-to-copy for equations */
    mjx-container {
      cursor: pointer;
      position: relative;
      transition: outline 0.15s ease;
      border-radius: 4px;
    }

    mjx-container:hover {
      outline: 2px solid var(--brand-accent);
      outline-offset: 4px;
    }

    mjx-container::after {
      content: "Click to copy image";
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--text-color);
      color: var(--pane-background);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: var(--font-sans);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 100;
    }

    /* Table tooltip */
    #renderedOutput table::before {
      content: "Click to copy table";
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--text-color);
      color: var(--pane-background);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: var(--font-sans);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 100;
    }

    #renderedOutput table {
      position: relative;
    }

    #renderedOutput table:hover::before {
      opacity: 1;
    }

    mjx-container:hover::after {
      opacity: 1;
    }

    /* Copy feedback animation */
    mjx-container.copied {
      outline: 2px solid #22c55e !important;
    }

    mjx-container.copied::after {
      content: "Copied!" !important;
      background: #22c55e !important;
      opacity: 1 !important;
    }

    /* Table click-to-copy */
    #renderedOutput table {
      cursor: pointer;
      transition: outline 0.15s ease;
    }

    #renderedOutput table:hover {
      outline: 2px solid var(--brand-accent);
      outline-offset: 4px;
    }

    #renderedOutput table.copied {
      outline: 2px solid #22c55e !important;
    }

    #renderedOutput table.copied::before {
      content: "Copied!" !important;
      background: #22c55e !important;
      opacity: 1 !important;
    }

    /* Code block click-to-copy */
    #renderedOutput pre {
      cursor: pointer;
      position: relative;
      transition: outline 0.15s ease;
    }

    #renderedOutput pre:hover {
      outline: 2px solid var(--brand-accent);
      outline-offset: 4px;
    }

    #renderedOutput pre::before {
      content: "Click to copy code";
      position: absolute;
      top: -28px;
      right: 8px;
      background: var(--text-color);
      color: var(--pane-background);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: var(--font-sans);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 100;
    }

    #renderedOutput pre:hover::before {
      opacity: 1;
    }

    #renderedOutput pre.copied {
      outline: 2px solid #22c55e !important;
    }

    #renderedOutput pre.copied::before {
      content: "Copied!" !important;
      background: #22c55e !important;
      opacity: 1 !important;
    }
  </style>
</head>

<body>
  <!--
      The main container with two panes:
      - Left = Markdown Input
      - Right = Rendered Output
  -->
  <div id="editorContainer">
    <!-- ============================================= -->
    <!-- =========== Markdown Input Pane ============= -->
    <!-- ============================================= -->
    <div id="inputPane">
      <!--
          New 3-column heading container:
          1) Logo on the left
          2) "Markdown Input" in the center
          3) placeholder on the right
      -->
      <div class="pane-heading-container">
        <!-- Logo Container (Left) -->
        <div class="logo-container">
          <!-- Link the logo to PanPhy website -->
          <a href="https://panphy.github.io/">
            <img src="/panphy.png" alt="PanPhy logo" />
          </a>
        </div>

        <!-- The heading in the Center -->
        <h2 class="pane-heading">Markdown Input</h2>

        <!-- Placeholder on the Right (keeps grid layout consistent) -->
        <div class="heading-placeholder"></div>
      </div>

      <!-- Buttons and the markdown input textarea below -->
      <div class="buttonContainer floating-toolbar">
        <button id="loadFileButton">Open .md File</button>
        <button id="saveMDButton">Save .md</button>
        <button id="clearButton">Clear Input</button>
        <button id="loadSampleButton" title="Sample document showing basic Markdown and LaTeX syntax.">Learn</button>
        <div class="font-size-selector">
          <label for="fontSizeSelect">Font Size</label>
          <select id="fontSizeSelect">
            <option value="14px">Small</option>
            <option value="16px">Medium</option>
            <option value="18px">Large</option>
            <option value="20px">XL</option>
          </select>
        </div>
      </div>
      <textarea id="markdownInput" placeholder="Type your Markdown and LaTeX here..."></textarea>
    </div>

    <!-- ============================================= -->
    <!-- ========== Rendered Output Pane ============= -->
    <!-- ============================================= -->
    <div id="outputPane">
      <!--
          New 3-column heading container:
          1) placeholder on the left
          2) "Rendered Output" in the center
          3) theme toggle on the right
      -->
      <div class="pane-heading-container">
        <!-- Placeholder on the Left -->
        <div class="heading-placeholder"></div>

        <!-- The heading in the Center -->
        <h2 class="pane-heading">Rendered Output</h2>

        <!-- Theme toggle button on the Right -->
        <div class="theme-toggle-wrapper">
          <button id="themeToggleButton" class="theme-toggle-button no-print" aria-label="Switch to Dark Mode"
            title="Switch to Dark Mode">
            ☀️
          </button>
        </div>
      </div>

      <!-- Buttons and rendered output below -->
      <div class="buttonContainer floating-toolbar output-controls no-print">
        <div class="output-actions">
          <button id="printButton" title="Prints in light mode">Print to PDF</button>
          <button id="exportHTMLButton" title="Exports in current theme">Export as HTML</button>
        </div>
        <div class="output-toggles">
          <label class="scroll-sync-toggle" for="scrollSyncToggle">
            <input type="checkbox" id="scrollSyncToggle" />
            <span class="toggle-slider" aria-hidden="true"></span>
            <span class="toggle-label">Link Scroll</span>
          </label>
          <label class="scroll-sync-toggle" for="highlightSyncToggle">
            <input type="checkbox" id="highlightSyncToggle" />
            <span class="toggle-slider" aria-hidden="true"></span>
            <span class="toggle-label">Link Highlight</span>
          </label>
        </div>
      </div>
      <div id="renderedOutput"></div>
    </div>
  </div>

  <footer>
    &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
    <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
  </footer>
</body>


<script>
  const markdownInput = document.getElementById('markdownInput');
  const renderedOutput = document.getElementById('renderedOutput');
  const clearButton = document.getElementById('clearButton');
  const loadSampleButton = document.getElementById('loadSampleButton');
  const exportHTMLButton = document.getElementById('exportHTMLButton');
  const printButton = document.getElementById('printButton');
  const saveMDButton = document.getElementById('saveMDButton');
  const loadFileButton = document.getElementById('loadFileButton');
  const themeToggleButton = document.getElementById('themeToggleButton');
  const scrollSyncToggle = document.getElementById('scrollSyncToggle');
  const highlightSyncToggle = document.getElementById('highlightSyncToggle');
  const fontSizeSelect = document.getElementById('fontSizeSelect');
  const highlightStyle = document.getElementById('highlightStyle');
  const draftStorageKey = 'markdownEditorDraft';
  const scrollSyncStorageKey = 'markdownScrollSync';
  const highlightSyncStorageKey = 'markdownHighlightSync';
  const fontSizeStorageKey = 'markdownFontSize';

  function updateOfflineFontState() {
    document.documentElement.classList.toggle('offline-font', !navigator.onLine);
  }

  window.addEventListener('online', updateOfflineFontState);
  window.addEventListener('offline', updateOfflineFontState);
  updateOfflineFontState();
  let isLinkScrollEnabled = false;
  let isHighlightSyncEnabled = true;

  /**
   * Fetch and load the sample Markdown document from 'mkdwn_sample_doc.md'
   */
  function loadSampleDocument() {
    fetch('mkdwn_sample_doc.md')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.text();
      })
      .then(data => {
        markdownInput.value = data;
        renderContent();
        saveDraft();
      })
      .catch(error => {
        console.error('Error loading sample document:', error);
        alert('Failed to load the sample document.');
      });
  }

  /**
   * Preprocess the input Markdown by preserving valid TeX inside math blocks.
   *
   * Quick manual checks:
   * - Inline TeX: $\\frac{1}{2}$ should render correctly.
   * - Escaped backslashes: $\\\\$ should remain as a literal double backslash.
   * - Currency: $5/day should stay as plain text.
   * - Currency punctuation: $5-month and $5 per day should stay as plain text.
   * - Literal dollar: \\$ should stay as plain text.
   *
   * @param {string} input - The raw Markdown input.
   * @returns {string} - The processed Markdown with TeX preserved.
   */
  function preprocessMarkdown(input) {
    const isEscaped = index => {
      let backslashCount = 0;
      for (let i = index - 1; i >= 0 && input[i] === '\\'; i -= 1) {
        backslashCount += 1;
      }
      return backslashCount % 2 === 1;
    };
    const isCurrencyLike = content => {
      const trimmed = content.trim();
      if (!/^\d/.test(trimmed)) {
        return false;
      }

      const currencyAbbreviation = /\b(?:aud|brl|cad|chf|cny|dkk|eur|gbp|hkd|inr|jpy|krw|mxn|nok|sek|sgd|usd|zar)\b/i;

      if (currencyAbbreviation.test(trimmed)) {
        return true;
      }

      if (/^\d+(?:[.,]\d+)?\s+[A-Za-z]/.test(trimmed)) {
        return true;
      }

      return /^\d+(?:[.,]\d+)?\s*[\/-]\s*[A-Za-z]/.test(trimmed);
    };

    let output = '';
    let i = 0;
    let inFencedCodeBlock = false;
    let fencedDelimiter = null;
    let inInlineCodeSpan = false;

    while (i < input.length) {
      const char = input[i];

      const lineStart = i === 0 || input[i - 1] === '\n';

      if (lineStart && (input.startsWith('```', i) || input.startsWith('~~~', i))) {
        const delimiter = input.startsWith('```', i) ? '```' : '~~~';
        if (!inFencedCodeBlock) {
          inFencedCodeBlock = true;
          fencedDelimiter = delimiter;
        } else if (fencedDelimiter === delimiter) {
          inFencedCodeBlock = false;
          fencedDelimiter = null;
        }
        output += delimiter;
        i += delimiter.length;
        continue;
      }

      if (!inFencedCodeBlock && char === '`' && !isEscaped(i) && input[i + 1] !== '`') {
        inInlineCodeSpan = !inInlineCodeSpan;
        output += char;
        i += 1;
        continue;
      }

      if (inFencedCodeBlock || inInlineCodeSpan) {
        output += char;
        i += 1;
        continue;
      }

      if (char === '$' && !isEscaped(i)) {
        const isDisplay = input[i + 1] === '$' && !isEscaped(i + 1);
        const delimiter = isDisplay ? '$$' : '$';
        const start = i;
        let searchIndex = i + delimiter.length;
        let closingIndex = -1;

        while (searchIndex < input.length) {
          if (input.startsWith(delimiter, searchIndex) && !isEscaped(searchIndex)) {
            closingIndex = searchIndex;
            break;
          }
          searchIndex += 1;
        }

        if (closingIndex === -1) {
          output += delimiter;
          i += delimiter.length;
          continue;
        }

        const content = input.slice(i + delimiter.length, closingIndex);

        if (!isDisplay && isCurrencyLike(content)) {
          output += '$';
          i = start + 1;
          continue;
        }

        const escapedContent = content.replace(/\\/g, '\\\\');
        // Preserve TeX backslashes only for math blocks outside code spans/blocks.
        output += delimiter + escapedContent + delimiter;
        i = closingIndex + delimiter.length;
        continue;
      }

      output += char;
      i += 1;
    }

    return output;
  }

  function runPreprocessMarkdownTests() {
    const cases = [
      { input: '$5/day', expected: '$5/day', label: 'currency slash' },
      { input: '$5-month', expected: '$5-month', label: 'currency hyphen' },
      { input: '$5 per day', expected: '$5 per day', label: 'currency spaced' },
      { input: '$\\frac{1}{2}$', expected: '$\\\\frac{1}{2}$', label: 'inline fraction' },
      {
        input: '$\\begin{matrix}a&b\\\\c&d\\end{matrix}$',
        expected: '$\\\\begin{matrix}a&b\\\\\\\\c&d\\\\end{matrix}$',
        label: 'matrix commands'
      }
    ];

    cases.forEach(({ input, expected, label }) => {
      const actual = preprocessMarkdown(input);
      console.assert(
        actual === expected,
        `preprocessMarkdown test failed (${label}): expected "${expected}", got "${actual}"`
      );
    });
  }

  runPreprocessMarkdownTests();

  function buildLineBlocks(text) {
    const tokens = marked.lexer(text);

    const countNewlines = value => (value.match(/\n/g) || []).length;
    const normalizeMatchText = value => value.replace(/\s+/g, ' ').trim();

    const getBlockTag = token => {
      switch (token.type) {
        case 'heading':
          return `h${token.depth}`;
        case 'paragraph':
          return 'p';
        case 'list':
          return token.ordered ? 'ol' : 'ul';
        case 'blockquote':
          return 'blockquote';
        case 'code':
          return 'pre';
        case 'table':
          return 'table';
        case 'hr':
          return 'hr';
        default:
          return null;
      }
    };

    const getChildTokens = token => {
      if (token.type === 'list') {
        return token.items.flatMap(item => item.tokens || []);
      }
      if (token.type === 'blockquote') {
        return token.tokens || [];
      }
      return [];
    };

    const getTokenMatchText = token => {
      if (!token.raw || token.type === 'hr') {
        return '';
      }

      try {
        const wrapper = document.createElement('div');
        wrapper.innerHTML = marked.parse(token.raw);
        return normalizeMatchText(wrapper.textContent || '');
      } catch (error) {
        return normalizeMatchText(token.text || token.raw);
      }
    };

    const collectBlocksFromTokens = (tokenList, sourceText, baseLine) => {
      const blocks = [];
      let cursor = 0;

      tokenList.forEach(token => {
        if (!token.raw) {
          return;
        }

        const matchIndex = sourceText.indexOf(token.raw, cursor);
        if (matchIndex === -1) {
          return;
        }

        const startLine = baseLine + countNewlines(sourceText.slice(0, matchIndex));
        const endLine = startLine + countNewlines(token.raw);
        const tag = getBlockTag(token);

        if (tag) {
          blocks.push({
            start: startLine,
            end: endLine,
            tag,
            matchText: getTokenMatchText(token)
          });
        }

        const childTokens = getChildTokens(token);
        if (childTokens.length) {
          blocks.push(...collectBlocksFromTokens(childTokens, token.raw, startLine));
        }

        cursor = matchIndex + token.raw.length;
      });

      return blocks;
    };

    return collectBlocksFromTokens(tokens, text, 1);
  }

  function wrapRenderedBlocks(html, lineBlocks) {
    const container = document.createElement('div');
    container.innerHTML = html;
    const blockElements = Array.from(
      container.querySelectorAll('h1,h2,h3,h4,h5,h6,p,ul,ol,blockquote,pre,table,hr')
    );
    const normalizeMatchText = value => value.replace(/\s+/g, ' ').trim();
    let elementIndex = 0;

    lineBlocks.forEach(block => {
      let matchIndex = -1;
      const expectedText = normalizeMatchText(block.matchText || '');

      for (let i = elementIndex; i < blockElements.length; i += 1) {
        const element = blockElements[i];
        if (element.tagName.toLowerCase() !== block.tag) {
          continue;
        }
        if (!expectedText) {
          matchIndex = i;
          break;
        }

        const elementText = normalizeMatchText(element.textContent || '');
        if (elementText && (elementText.includes(expectedText) || expectedText.includes(elementText))) {
          matchIndex = i;
          break;
        }
      }

      if (matchIndex === -1 && block.tag) {
        for (let i = elementIndex; i < blockElements.length; i += 1) {
          if (blockElements[i].tagName.toLowerCase() === block.tag) {
            matchIndex = i;
            break;
          }
        }
      }

      if (matchIndex === -1) {
        return;
      }

      const element = blockElements[matchIndex];
      const wrapper = document.createElement('div');
      wrapper.classList.add('md-block');
      wrapper.dataset.srcStart = String(block.start);
      wrapper.dataset.srcEnd = String(block.end);
      element.replaceWith(wrapper);
      wrapper.appendChild(element);
      elementIndex = matchIndex + 1;
    });
    return container.innerHTML;
  }

  function renderContent() {
    const inputText = markdownInput.value;
    const preprocessedText = preprocessMarkdown(inputText);

    const renderer = {
      listitem(token) {
        let checkbox = '';
        if (token.task) {
          checkbox = `<input type="checkbox" disabled${token.checked ? ' checked' : ''}> `;
        }
        const body = this.parser.parse(token.tokens);
        return `<li>${checkbox}${body}</li>`;
      }
    };

    marked.setOptions({
      gfm: true,
      headerIds: true,
      tables: true,
      langPrefix: 'hljs language-',
      highlight: function (code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        }
        return hljs.highlightAuto(code).value;
      }
    });
    marked.use({ renderer });

    const lineBlocks = buildLineBlocks(preprocessedText);
    const parsedMarkdown = marked.parse(preprocessedText);
    const sanitizedContent = DOMPurify.sanitize(parsedMarkdown);
    renderedOutput.innerHTML = wrapRenderedBlocks(sanitizedContent, lineBlocks);

    hljs.highlightAll();
    MathJax.typesetPromise([renderedOutput]).catch(console.error);
    updateHighlightedBlockFromCaret();
  }

  function saveDraft() {
    localStorage.setItem(draftStorageKey, markdownInput.value);
  }

  function clearDraft() {
    localStorage.removeItem(draftStorageKey);
  }

  function restoreDraft() {
    const savedDraft = localStorage.getItem(draftStorageKey);
    if (savedDraft !== null) {
      markdownInput.value = savedDraft;
    }
  }

  function debounce(fn, delay) {
    let timerId;
    return (...args) => {
      window.clearTimeout(timerId);
      timerId = window.setTimeout(() => {
        fn(...args);
      }, delay);
    };
  }

  function getLineNumberFromOffset(text, offset) {
    if (offset <= 0) {
      return 1;
    }
    return text.slice(0, offset).split('\n').length;
  }

  function getOffsetsForLineRange(text, startLine, endLine) {
    const lines = text.split('\n');
    let startOffset = 0;
    let endOffset = text.length;

    for (let i = 0; i < lines.length; i += 1) {
      if (i + 1 < startLine) {
        startOffset += lines[i].length + 1;
      }
    }

    let cursor = 0;
    for (let i = 0; i < lines.length; i += 1) {
      if (i + 1 <= endLine) {
        cursor += lines[i].length;
        if (i + 1 < lines.length) {
          cursor += 1;
        }
      }
    }
    endOffset = cursor;

    return { startOffset, endOffset };
  }

  function getMatchingBlockForLine(lineNumber) {
    const blocks = Array.from(renderedOutput.querySelectorAll('[data-src-start][data-src-end]'));
    const matchingBlocks = blocks.filter(block => {
      const start = Number(block.dataset.srcStart);
      const end = Number(block.dataset.srcEnd);
      return lineNumber >= start && lineNumber <= end;
    });
    return matchingBlocks.reduce((best, block) => {
      if (!best) {
        return block;
      }
      const bestSpan = Number(best.dataset.srcEnd) - Number(best.dataset.srcStart);
      const currentSpan = Number(block.dataset.srcEnd) - Number(block.dataset.srcStart);
      return currentSpan < bestSpan ? block : best;
    }, null);
  }

  function updateHighlightedBlockFromCaret({ forceScroll = false } = {}) {
    const current = renderedOutput.querySelector('.highlighted-block');
    if (!isHighlightSyncEnabled) {
      if (current) {
        current.classList.remove('highlighted-block');
      }
      return;
    }

    const lineNumber = getLineNumberFromOffset(markdownInput.value, markdownInput.selectionStart || 0);
    const matchingBlock = getMatchingBlockForLine(lineNumber);

    if (current && current !== matchingBlock) {
      current.classList.remove('highlighted-block');
    }

    if (!matchingBlock) {
      return;
    }

    matchingBlock.classList.add('highlighted-block');
    const shouldScroll = forceScroll || !isLinkScrollEnabled;
    if (shouldScroll) {
      matchingBlock.scrollIntoView({ block: 'center', behavior: forceScroll ? 'smooth' : 'auto' });
    }
  }

  function syncCaretFromOutputClick(event) {
    const targetBlock = event.target.closest('[data-src-start][data-src-end]');
    if (!targetBlock) return;

    const startLine = Number(targetBlock.dataset.srcStart);
    const endLine = Number(targetBlock.dataset.srcEnd);
    if (Number.isNaN(startLine) || Number.isNaN(endLine)) return;

    const text = markdownInput.value;
    const offsets = getOffsetsForLineRange(text, startLine, endLine);
    markdownInput.focus();
    markdownInput.setSelectionRange(offsets.startOffset, offsets.endOffset);

    const lineHeight = parseFloat(getComputedStyle(markdownInput).lineHeight) || 16;
    markdownInput.scrollTop = Math.max(0, (startLine - 1) * lineHeight);
    updateHighlightedBlockFromCaret({ forceScroll: true });
  }

  function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }

  function applyScrollTop(target, desiredTop) {
    const maxTop = Math.max(0, target.scrollHeight - target.clientHeight);
    const clampedTop = clamp(desiredTop, 0, maxTop);
    const distance = clampedTop - target.scrollTop;
    if (Math.abs(distance) < 0.5) {
      target.scrollTop = clampedTop;
      return;
    }
    target.scrollTop = target.scrollTop + distance * 0.35;
  }

  let isLinkingScroll = false;
  let linkScrollFrame = null;

  function syncLinkedScroll(source, target) {
    if (!isLinkScrollEnabled || isLinkingScroll) return;
    isLinkingScroll = true;
    if (linkScrollFrame) {
      cancelAnimationFrame(linkScrollFrame);
    }
    linkScrollFrame = requestAnimationFrame(() => {
      const sourceMax = Math.max(0, source.scrollHeight - source.clientHeight);
      const targetMax = Math.max(0, target.scrollHeight - target.clientHeight);
      const ratio = sourceMax > 0 ? source.scrollTop / sourceMax : 0;
      applyScrollTop(target, targetMax * ratio);
      isLinkingScroll = false;
    });
  }

  function linkOutputToInputScroll() {
    syncLinkedScroll(markdownInput, renderedOutput);
  }

  function linkInputToOutputScroll() {
    syncLinkedScroll(renderedOutput, markdownInput);
  }

  async function printToPDF() {
    const body = document.body;
    const hadDarkMode = body.classList.contains('dark-mode');
    if (hadDarkMode) {
      body.classList.remove('dark-mode');
    }
    highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    await MathJax.typesetPromise([renderedOutput]);
    hljs.highlightAll();
    window.print();
    if (hadDarkMode) {
      body.classList.add('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
      updateThemeToggleButton();
    }
  }

  function exportHTML() {
    const fileName = prompt('Enter file name for the HTML export:', 'document.html');
    if (!fileName) return;

    const sanitizedHTML = getCleanRenderedOutputHTML();
    const currentFontSize = getCurrentFontSize();
    const doc = document.implementation.createHTMLDocument('Exported Document');
    const head = doc.head;
    const body = doc.body;

    const meta = document.createElement('meta');
    meta.setAttribute('charset', 'UTF-8');
    head.appendChild(meta);

    const title = document.createElement('title');
    title.textContent = 'Exported Document';
    head.appendChild(title);

    const style = document.createElement('style');
    style.textContent = `
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

        :root {
          --background-color: #ffffff;
          --text-color: #000000;
          --pane-background: #ffffff;
          --pane-heading-background: #333333;
          --pane-heading-color: #ffffff;
          --button-background: #f0f0f0;
          --button-color: #000000;
          --border-color: #ccc;
          --code-background: #f0f0f0;
          --table-border-color: black;
          --table-header-background: #f4f4f4;
        }

        body.dark-mode {
          --background-color: #1e1e1e;
          --text-color: #e0e0e0;
          --pane-background: #1e1e1e;
          --pane-heading-background: #2d2c2c;
          --pane-heading-color: #ffffff;
          --button-background: #474646;
          --button-color: #ffffff;
          --border-color: #555555;
          --code-background: #2f2f2f;
          --table-border-color: #555555;
          --table-header-background: #333333;
          --code-text-color: #f8f8f2;
        }

        body {
          font-family: 'Inter', sans-serif;
          line-height: 1.5;
          font-size: ${currentFontSize};
          margin: 20px;
          background-color: var(--background-color);
          color: var(--text-color);
        }

        body, div, p, h1, h2, h3, h4, h5, h6, pre, code, table, th, td, blockquote {
          background-color: var(--background-color);
          color: var(--text-color);
        }

        a {
          color: #ff5f1f;
          text-decoration: none;
        }

        a:hover {
          color: #ff5f1f;
          text-decoration: underline;
        }

        a:visited {
          color: #ff5f1f;
        }

        table {
          max-width: 100%;
          margin: 20px auto;
          border-collapse: collapse;
          border: 1px solid var(--table-border-color);
        }

        th, td {
          border: 1px solid var(--table-border-color);
          padding: 8px;
        }

        th[align="left"], td[align="left"] {
          text-align: left;
        }

        th[align="center"], td[align="center"] {
          text-align: center;
        }

        th[align="right"], td[align="right"] {
          text-align: right;
        }

        th, td {
          text-align: left;
        }

        code {
          background-color: var(--code-background);
          padding: 0.1em 0.2em;
          border-radius: 3px;
          font-size: 0.95em;
          line-height: 1;
          font-family: 'JetBrains Mono', monospace;
          vertical-align: baseline;
          color: inherit;
        }

        pre {
          background-color: var(--code-background);
          padding: 0;
          border-radius: 5px;
          overflow-x: auto;
          font-size: 1.05em;
          line-height: 1.5;
          margin: 2px 0;
        }

        pre code {
          background: none;
          padding: 0;
          border-radius: 0;
          font-family: inherit;
          line-height: 1.5;
          font-size: inherit;
          color: inherit;
        }

        .hljs {
          line-height: 1.5;
          font-size: 1.05em;
          background-color: inherit;
          color: inherit;
        }

        body.dark-mode .hljs {
          color: #f8f8f2 !important;
        }

        body.dark-mode .hljs-comment,
        body.dark-mode .hljs-quote {
          color: #8d9a70 !important;
        }

        body.dark-mode .hljs-keyword,
        body.dark-mode .hljs-selector-tag,
        body.dark-mode .hljs-subst {
          color: #66d9ef !important;
        }

        body.dark-mode .hljs-string,
        body.dark-mode .hljs-doctag {
          color: #e6db74 !important;
        }

        body.dark-mode .hljs-number,
        body.dark-mode .hljs-regexp,
        body.dark-mode .hljs-tag .hljs-attr {
          color: #ae81ff !important;
        }

        body.dark-mode .hljs-title,
        body.dark-mode .hljs-section {
          color: #a6e22e !important;
        }

        body.dark-mode .hljs-type,
        body.dark-mode .hljs-built_in {
          color: #fd971f !important;
        }

        body.dark-mode .hljs-symbol,
        body.dark-mode .hljs-bullet {
          color: #f92672 !important;
        }

        body.dark-mode .hljs-link {
          color: #e6db74 !important;
        }

        img {
          max-width: 100%;
          height: auto;
        }
      `;
    head.appendChild(style);

    const isDarkMode = document.body.classList.contains('dark-mode');
    const highlightLink = document.createElement('link');
    highlightLink.rel = 'stylesheet';
    if (isDarkMode) {
      highlightLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      highlightLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
    head.appendChild(highlightLink);

    const highlightScript = document.createElement('script');
    highlightScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js';
    head.appendChild(highlightScript);

    const highlightInit = document.createElement('script');
    highlightInit.textContent = `
        window.addEventListener('DOMContentLoaded', () => {
          hljs.highlightAll();
        });
      `;
    head.appendChild(highlightInit);

    const mathjaxConfigScript = document.createElement('script');
    mathjaxConfigScript.textContent = `
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            packages: ['base', 'ams', 'array'],
          },
          svg: {
            fontCache: 'local',
          }
        };
      `;
    head.appendChild(mathjaxConfigScript);

    const mathjaxScript = document.createElement('script');
    mathjaxScript.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
    head.appendChild(mathjaxScript);

    body.innerHTML = sanitizedHTML;

    if (isDarkMode) {
      body.classList.add('dark-mode');
    }

    const exportedHTML = `<!DOCTYPE html>${doc.documentElement.outerHTML}`;
    const blob = new Blob([exportedHTML], { type: 'text/html' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
  }

  function getCleanRenderedOutputHTML() {
    const clonedOutput = renderedOutput.cloneNode(true);
    clonedOutput.querySelectorAll('[data-src-start]').forEach(element => {
      element.removeAttribute('data-src-start');
    });
    clonedOutput.querySelectorAll('[data-src-end]').forEach(element => {
      element.removeAttribute('data-src-end');
    });
    clonedOutput.querySelectorAll('.highlighted-block').forEach(element => {
      element.classList.remove('highlighted-block');
    });
    clonedOutput.querySelectorAll('.md-block').forEach(wrapper => {
      const parent = wrapper.parentNode;
      while (wrapper.firstChild) {
        parent.insertBefore(wrapper.firstChild, wrapper);
      }
      parent.removeChild(wrapper);
    });
    return clonedOutput.innerHTML;
  }

  /**
   * Copy an equation (MathJax SVG) to clipboard as PNG image.
   * Creates a tight-bounded PNG that can be pasted into Word, PowerPoint, etc.
   * PNG format is used because it has better compatibility with most applications.
   */
  async function copyEquationToClipboard(mjxContainer) {
    const svg = mjxContainer.querySelector('svg');
    if (!svg) return false;

    // Clone the SVG to avoid modifying the original
    const svgClone = svg.cloneNode(true);

    // MathJax uses a global defs cache - we need to inline all referenced glyphs
    // Find all <use> elements and their referenced definitions
    const useElements = svgClone.querySelectorAll('use');
    const referencedIds = new Set();

    useElements.forEach(use => {
      const href = use.getAttribute('href') || use.getAttribute('xlink:href');
      if (href && href.startsWith('#')) {
        referencedIds.add(href.substring(1));
      }
    });

    // Create or get the defs element in our clone
    let defsClone = svgClone.querySelector('defs');
    if (!defsClone) {
      defsClone = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      svgClone.insertBefore(defsClone, svgClone.firstChild);
    }

    // Find and clone referenced elements from the global MathJax cache
    referencedIds.forEach(id => {
      // Check if already in our defs
      if (defsClone.querySelector(`#${CSS.escape(id)}`)) return;

      // Look for the element in the document (MathJax global cache)
      const original = document.getElementById(id);
      if (original) {
        defsClone.appendChild(original.cloneNode(true));
      }
    });

    // Get computed dimensions - use getBoundingClientRect for more reliability
    const bbox = svg.getBBox();
    const padding = 8;

    // Handle edge case where bbox might be zero or invalid
    let width = bbox.width + padding * 2;
    let height = bbox.height + padding * 2;

    // Fallback to container dimensions if bbox is invalid
    if (width <= padding * 2 || height <= padding * 2) {
      const rect = svg.getBoundingClientRect();
      width = rect.width + padding * 2;
      height = rect.height + padding * 2;
    }

    // Ensure minimum dimensions
    width = Math.max(width, 20);
    height = Math.max(height, 20);

    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    svgClone.setAttribute('width', `${width}pt`);
    svgClone.setAttribute('height', `${height}pt`);
    svgClone.setAttribute('viewBox', `${bbox.x - padding} ${bbox.y - padding} ${width} ${height}`);

    // Remove any background, ensure transparency
    svgClone.style.backgroundColor = 'transparent';
    svgClone.removeAttribute('style');

    // Set fill color to black for all elements (better for documents)
    const fillColor = '#000000';

    // Apply fill to all relevant elements
    const applyFill = (el) => {
      const currentFill = el.getAttribute('fill');
      if (!currentFill || currentFill === 'currentColor' || currentFill === 'none') {
        // Don't override 'none' fills as they're intentional
        if (currentFill !== 'none') {
          el.setAttribute('fill', fillColor);
        }
      }
    };

    svgClone.querySelectorAll('g, path, rect, use, text, tspan').forEach(applyFill);

    // Also set the SVG's color property for currentColor inheritance
    svgClone.setAttribute('color', fillColor);
    svgClone.setAttribute('fill', fillColor);

    const svgString = new XMLSerializer().serializeToString(svgClone);

    // Convert SVG to PNG using canvas for better clipboard compatibility
    try {
      const scale = 4; // Higher resolution for better quality
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Convert pt to px (1pt = 1.333px approximately)
      const pxWidth = Math.ceil(width * 1.333 * scale);
      const pxHeight = Math.ceil(height * 1.333 * scale);

      canvas.width = pxWidth;
      canvas.height = pxHeight;

      // Create an image from SVG
      const img = new Image();

      // Add XML declaration and proper encoding for better compatibility
      const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);

      return new Promise((resolve) => {
        img.onload = async () => {
          // Draw with transparent background
          ctx.clearRect(0, 0, pxWidth, pxHeight);
          ctx.drawImage(img, 0, 0, pxWidth, pxHeight);

          try {
            // Convert canvas to blob and copy to clipboard
            const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
            if (blob) {
              await navigator.clipboard.write([
                new ClipboardItem({ 'image/png': blob })
              ]);
              resolve(true);
            } else {
              throw new Error('Failed to create blob');
            }
          } catch (clipErr) {
            console.error('Clipboard write failed:', clipErr);
            // Fallback: copy SVG as text
            try {
              await navigator.clipboard.writeText(svgString);
              resolve(true);
            } catch (textErr) {
              console.error('Failed to copy equation:', textErr);
              resolve(false);
            }
          }
        };

        img.onerror = async (err) => {
          console.error('Image load failed:', err);
          // Fallback: copy SVG as text
          try {
            await navigator.clipboard.writeText(svgString);
            resolve(true);
          } catch (copyErr) {
            console.error('Failed to copy equation:', copyErr);
            resolve(false);
          }
        };

        img.src = svgDataUrl;
      });
    } catch (err) {
      console.error('Failed to copy equation:', err);
      return false;
    }
  }

  /**
   * Copy a table as HTML to clipboard.
   * HTML format works well with MS Word.
   */
  async function copyTableToClipboard(table) {
    const tableClone = table.cloneNode(true);

    // Add inline styles for better Word compatibility
    tableClone.style.borderCollapse = 'collapse';
    tableClone.style.fontFamily = 'Arial, sans-serif';
    tableClone.style.fontSize = '12pt';

    tableClone.querySelectorAll('th, td').forEach(cell => {
      cell.style.border = '1px solid black';
      cell.style.padding = '8px';
    });

    const htmlString = tableClone.outerHTML;

    try {
      // Copy as HTML for better Word compatibility
      const blob = new Blob([htmlString], { type: 'text/html' });
      const clipboardItem = new ClipboardItem({
        'text/html': blob,
        'text/plain': new Blob([table.innerText], { type: 'text/plain' })
      });
      await navigator.clipboard.write([clipboardItem]);
      return true;
    } catch (err) {
      // Fallback to text copy
      try {
        await navigator.clipboard.writeText(htmlString);
        return true;
      } catch (fallbackErr) {
        console.error('Failed to copy table:', fallbackErr);
        return false;
      }
    }
  }

  /**
   * Show copy feedback animation on an element.
   */
  function showCopyFeedback(element) {
    element.classList.add('copied');
    setTimeout(() => {
      element.classList.remove('copied');
    }, 1500);
  }

  /**
   * Copy a code block as HTML with syntax highlighting to clipboard.
   * HTML format preserves colors when pasting into Word/rich text editors.
   */
  async function copyCodeBlockToClipboard(preElement) {
    const preClone = preElement.cloneNode(true);
    const codeElement = preClone.querySelector('code');
    const plainText = codeElement ? codeElement.textContent : preClone.textContent;

    // Get computed styles for syntax highlighting colors
    const computedStyle = getComputedStyle(preElement);
    const bgColor = computedStyle.backgroundColor || '#f1f3f5';
    const textColor = computedStyle.color || '#000000';

    // Add inline styles for Word compatibility
    preClone.style.backgroundColor = bgColor;
    preClone.style.color = textColor;
    preClone.style.fontFamily = "'JetBrains Mono', 'Consolas', 'Monaco', monospace";
    preClone.style.fontSize = '10pt';
    preClone.style.padding = '12px';
    preClone.style.borderRadius = '5px';
    preClone.style.whiteSpace = 'pre-wrap';
    preClone.style.wordWrap = 'break-word';

    // Inline the syntax highlighting colors from hljs spans
    preClone.querySelectorAll('[class*="hljs"]').forEach(el => {
      const elStyle = getComputedStyle(preElement.querySelector(`.${el.className.split(' ').find(c => c.startsWith('hljs'))}`) || el);
      if (elStyle.color) {
        el.style.color = elStyle.color;
      }
    });

    const htmlString = preClone.outerHTML;

    try {
      // Copy as HTML for syntax highlighting + plain text fallback
      const htmlBlob = new Blob([htmlString], { type: 'text/html' });
      const textBlob = new Blob([plainText], { type: 'text/plain' });
      const clipboardItem = new ClipboardItem({
        'text/html': htmlBlob,
        'text/plain': textBlob
      });
      await navigator.clipboard.write([clipboardItem]);
      return true;
    } catch (err) {
      // Fallback to plain text copy
      try {
        await navigator.clipboard.writeText(plainText);
        return true;
      } catch (fallbackErr) {
        console.error('Failed to copy code:', fallbackErr);
        return false;
      }
    }
  }

  /**
   * Handle clicks on the rendered output for copy-to-clipboard functionality.
   */
  function handleCopyClick(event) {
    // Check if clicked on a MathJax container
    const mjxContainer = event.target.closest('mjx-container');
    if (mjxContainer) {
      event.preventDefault();
      event.stopPropagation();
      copyEquationToClipboard(mjxContainer).then(success => {
        if (success) {
          showCopyFeedback(mjxContainer);
        }
      });
      return;
    }

    // Check if clicked on a table (but not inside a cell for text selection)
    const table = event.target.closest('table');
    if (table && !window.getSelection().toString()) {
      event.preventDefault();
      copyTableToClipboard(table).then(success => {
        if (success) {
          showCopyFeedback(table);
        }
      });
      return;
    }

    // Check if clicked on a code block
    const preElement = event.target.closest('pre');
    if (preElement && !window.getSelection().toString()) {
      event.preventDefault();
      copyCodeBlockToClipboard(preElement).then(success => {
        if (success) {
          showCopyFeedback(preElement);
        }
      });
      return;
    }
  }

  function saveMarkdown() {
    const fileName = prompt('Enter file name for the Markdown file:', 'document.md');
    if (!fileName) return;

    const blob = new Blob([markdownInput.value], { type: 'text/markdown' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
  }

  function loadMarkdownFile() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.md,text/markdown';
    input.onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = event => {
          markdownInput.value = event.target.result;
          renderContent();
          saveDraft();
        };
        reader.readAsText(file);
      }
    };
    input.click();
  }

  /**
   * Initialize the theme based on saved preference.
   */
  function initializeTheme() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'markdown-dark') {
      document.body.classList.add('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      document.body.classList.remove('dark-mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
    updateThemeToggleButton();
  }

  /**
   * Initialize scroll sync toggle based on saved preference.
   */
  function initializeScrollSyncToggle() {
    const savedScrollSync = localStorage.getItem(scrollSyncStorageKey);
    isLinkScrollEnabled = savedScrollSync === 'true';
    scrollSyncToggle.checked = isLinkScrollEnabled;
  }

  /**
   * Initialize highlight sync toggle based on saved preference.
   */
  function initializeHighlightSyncToggle() {
    const savedHighlightSync = localStorage.getItem(highlightSyncStorageKey);
    if (savedHighlightSync === null) {
      isHighlightSyncEnabled = true;
    } else {
      isHighlightSyncEnabled = savedHighlightSync === 'true';
    }
    highlightSyncToggle.checked = isHighlightSyncEnabled;
  }

  function getCurrentFontSize() {
    const currentValue = getComputedStyle(document.documentElement)
      .getPropertyValue('--base-font-size')
      .trim();
    return currentValue || '16px';
  }

  function applyFontSize(value) {
    document.documentElement.style.setProperty('--base-font-size', value);
    localStorage.setItem(fontSizeStorageKey, value);
  }

  function initializeFontSize() {
    const savedFontSize = localStorage.getItem(fontSizeStorageKey);
    const initialFontSize = savedFontSize || getCurrentFontSize();
    applyFontSize(initialFontSize);
    if (fontSizeSelect) {
      fontSizeSelect.value = initialFontSize;
    }
  }

  /**
   * Toggle between dark and light themes and save the preference.
   */
  function toggleTheme() {
    document.body.classList.toggle('dark-mode');

    if (document.body.classList.contains('dark-mode')) {
      themeToggleButton.textContent = '🌙';
      themeToggleButton.setAttribute('aria-label', 'Switch to Light Mode');
      themeToggleButton.setAttribute('title', 'Switch to Light Mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
      localStorage.setItem('theme', 'markdown-dark');
    } else {
      themeToggleButton.textContent = '☀️';
      themeToggleButton.setAttribute('aria-label', 'Switch to Dark Mode');
      themeToggleButton.setAttribute('title', 'Switch to Dark Mode');
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
      localStorage.setItem('theme', 'markdown-light');
    }
  }

  /**
   * Update the theme toggle button's icon and attributes.
   */
  function updateThemeToggleButton() {
    if (document.body.classList.contains('dark-mode')) {
      themeToggleButton.textContent = '🌙';
      themeToggleButton.setAttribute('aria-label', 'Switch to Light Mode');
      themeToggleButton.setAttribute('title', 'Switch to Light Mode');
    } else {
      themeToggleButton.textContent = '☀️';
      themeToggleButton.setAttribute('aria-label', 'Switch to Dark Mode');
      themeToggleButton.setAttribute('title', 'Switch to Dark Mode');
    }
  }

  window.addEventListener('beforeprint', () => {
    highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
  });

  window.addEventListener('afterprint', () => {
    if (document.body.classList.contains('dark-mode')) {
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
    } else {
      highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
    }
  });

  // Initialize theme and render content on load
  initializeTheme();
  initializeScrollSyncToggle();
  initializeHighlightSyncToggle();
  initializeFontSize();
  restoreDraft();
  renderContent();

  const handleCaretChange = () => updateHighlightedBlockFromCaret();

  const debouncedRenderAndSave = debounce(() => {
    renderContent();
    saveDraft();
  }, 200);
  markdownInput.addEventListener('input', debouncedRenderAndSave);
  markdownInput.addEventListener('keyup', handleCaretChange);
  markdownInput.addEventListener('click', handleCaretChange);
  markdownInput.addEventListener('select', handleCaretChange);
  markdownInput.addEventListener('scroll', linkOutputToInputScroll);
  renderedOutput.addEventListener('click', event => {
    // Handle copy clicks first (equations, tables, code blocks)
    handleCopyClick(event);
    // Then handle caret sync (only if not clicking on copyable elements)
    if (!event.target.closest('mjx-container') && !event.target.closest('table') && !event.target.closest('pre')) {
      syncCaretFromOutputClick(event);
    }
  });
  renderedOutput.addEventListener('scroll', linkInputToOutputScroll);
  printButton.addEventListener('click', printToPDF);
  exportHTMLButton.addEventListener('click', exportHTML);
  saveMDButton.addEventListener('click', saveMarkdown);
  loadFileButton.addEventListener('click', loadMarkdownFile);
  loadSampleButton.addEventListener('click', loadSampleDocument); // Updated event listener
  clearButton.addEventListener('click', () => {
    markdownInput.value = '';
    clearDraft();
    renderContent();
  });
  themeToggleButton.addEventListener('click', toggleTheme);
  scrollSyncToggle.addEventListener('change', event => {
    isLinkScrollEnabled = event.target.checked;
    localStorage.setItem(scrollSyncStorageKey, isLinkScrollEnabled);
    if (isLinkScrollEnabled) {
      updateHighlightedBlockFromCaret({ forceScroll: true });
    }
  });
  highlightSyncToggle.addEventListener('change', event => {
    isHighlightSyncEnabled = event.target.checked;
    localStorage.setItem(highlightSyncStorageKey, isHighlightSyncEnabled);
    if (isHighlightSyncEnabled) {
      updateHighlightedBlockFromCaret({ forceScroll: true });
    } else {
      updateHighlightedBlockFromCaret();
    }
  });
  if (fontSizeSelect) {
    fontSizeSelect.addEventListener('change', event => {
      applyFontSize(event.target.value);
    });
  }
</script>

</html>
