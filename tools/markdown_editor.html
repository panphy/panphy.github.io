<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Markdown Editor with LaTeX</title>
	<link rel="icon" type="image/png" href="/favicon.png">

	<script>
		window.MathJax = {
			tex: {
				inlineMath: [
					['$', '$']
				],
				displayMath: [
					['$$', '$$']
				],
				processEscapes: true,
				packages: ['base', 'ams'],
			},
			svg: {
				fontCache: 'local',
			}
		};
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-svg.js"></script>

	<script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>

	<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

	<link id="highlightStyle" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

	<style>
		*,
		*::before,
		*::after {
			box-sizing: border-box;
		}

		:root {
			--background-color: #ffffff;
			--text-color: #000000;
			--pane-background: #ffffff;
			--pane-heading-background: #333333;
			--pane-heading-color: #ffffff;
			--button-background: #f0f0f0;
			--button-color: #000000;
			--border-color: #ccc;
			--code-background: #f0f0f0;
			--table-border-color: black;
			--table-header-background: #f4f4f4;
			--switch-width: 42px;
			--switch-height: 18px;
			--slider-size: 13px;
			--slider-transform: 23px;
			--switch-background-color: #ccc;
			--switch-knob-color: white;
			--switch-label-font-size: 14px;
			--switch-active-color: #009688;
		}

		body.dark-mode {
			--background-color: #1e1e1e;
			--text-color: #e0e0e0;
			--pane-background: #1e1e1e;
			--pane-heading-background: #2d2c2c;
			--pane-heading-color: #ffffff;
			--button-background: #474646;
			--button-color: #ffffff;
			--border-color: #555555;
			--code-background: #2f2f2f;
			--table-border-color: #555555;
			--table-header-background: #333333;
			--code-text-color: #f8f8f2;
		}

		body {
			display: flex;
			flex-direction: column;
			height: 100vh;
			margin: 0;
			font-family: Helvetica, sans-serif;
			line-height: 1.5;
			background-color: var(--background-color);
			color: var(--text-color);
			transition: background-color 0.3s, color 0.3s;
		}

		html,
		body {
			overflow-x: hidden;
		}

		a {
			color: #ff5f1f;
			text-decoration: none;
		}

		a:hover {
			color: #ff5f1f;
			text-decoration: underline;
		}

		a:visited {
			color: #ff5f1f;
		}

		#editorContainer {
			display: flex;
			flex: 1;
			background-color: var(--pane-background);
			height: 100%;
		}

		#inputPane,
		#outputPane {
			width: 50%;
			padding: 0;
			box-sizing: border-box;
			background-color: var(--pane-background);
			display: flex;
			flex-direction: column;
			min-height: 0;
			border: none;
		}

		#inputPane {
			border-right: 1px solid var(--border-color);
		}

		.pane-heading-container {
			display: grid;
			grid-template-columns: 50px 1fr 50px;
			height: 45px;
			align-items: center;
			background-color: var(--pane-heading-background);
			color: var(--pane-heading-color);
			margin: 0;
			padding: 0 10px;
		}

		textarea:focus {
			outline: none;
		}

		.logo-container img {
			max-height: 30px;
			margin: 0 auto 0 0;
			display: block;
		}

		.heading-placeholder,
		.theme-toggle-wrapper {
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.pane-heading {
			text-align: center;
			margin: 0;
			font-size: 1.2em;
		}

		.theme-toggle-button {
			background: none;
			border: none;
			cursor: pointer;
			font-size: 18px;
			color: var(--pane-heading-color);
			margin: 0;
			display: block;
			margin-left: auto;
			margin-right: auto;
		}

		.theme-toggle-button:hover {
			opacity: 0.8;
		}

		.buttonContainer {
			margin: 10px 0;
			text-align: center;
			display: flex;
			justify-content: center;
			align-items: center;
			position: relative;
		}

		body.dark-mode .buttonContainer button {
			background-color: var(--button-background);
			color: var(--button-color);
			border: none;
		}

		.toggle-container {
			position: absolute;
			right: 15px;
			display: flex;
			align-items: center;
		}

		.switch {
			position: relative;
			display: inline-block;
			width: var(--switch-width);
			height: var(--switch-height);
			margin-left: 2px;
		}

		.switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: var(--switch-background-color);
			transition: 0.4s;
			border-radius: calc(var(--switch-height) / 2);
		}

		.slider:before {
			position: absolute;
			content: "";
			height: var(--slider-size);
			width: var(--slider-size);
			left: 2.5px;
			bottom: 2.5px;
			background-color: var(--switch-knob-color);
			transition: 0.4s;
			border-radius: 50%;
		}

		input:checked+.slider {
			background-color: var(--switch-active-color);
		}

		input:focus+.slider {
			box-shadow: 0 0 1px var(--switch-active-color);
		}

		input:checked+.slider:before {
			transform: translateX(var(--slider-transform));
		}

		.switch-label {
			font-size: var(--switch-label-font-size);
			margin-right: 5px;
		}

		textarea {
			flex: 1;
			width: 100%;
			padding: 20px;
			border: none;
			resize: none;
			font-size: 15px;
			line-height: 1.5;
			box-sizing: border-box;
			overflow-y: auto;
			background-color: var(--pane-background);
			color: var(--text-color);
		}

		#renderedOutput {
			flex: 1;
			padding: 20px;
			font-size: 15px;
			line-height: 1.5;
			box-sizing: border-box;
			overflow-y: auto;
			background-color: var(--pane-background);
			color: var(--text-color);
		}

		/* Code blocks */
		code {
			background-color: var(--code-background);
			padding: 0.1em 0.2em;
			border-radius: 3px;
			font-size: 0.95em;
			line-height: 1;
			font-family: "Courier New", Courier, monospace;
			vertical-align: baseline;
			color: inherit;
		}

		pre {
			background-color: var(--code-background);
			padding: 0;
			border-radius: 5px;
			overflow-x: auto;
			font-size: 0.95em;
			line-height: 1.5;
			margin: 2px 0;
		}

		pre code {
			background: none;
			padding: 0;
			border-radius: 0;
			font-family: inherit;
			line-height: 1.5;
			font-size: inherit;
			color: inherit;
		}

		.hljs {
			line-height: 1.5;
			font-size: 0.95em;
			background-color: inherit;
			color: inherit;
		}

		body.dark-mode .hljs {
			color: var(--code-text-color);
		}

		/* Dark Mode Syntax Colors */
		body.dark-mode .hljs-comment,
		body.dark-mode .hljs-quote {
			color: #8d9a70 !important;
		}

		body.dark-mode .hljs-keyword,
		body.dark-mode .hljs-selector-tag,
		body.dark-mode .hljs-subst {
			color: #66d9ef !important;
		}

		body.dark-mode .hljs-string,
		body.dark-mode .hljs-doctag {
			color: #e6db74 !important;
		}

		body.dark-mode .hljs-number,
		body.dark-mode .hljs-regexp,
		body.dark-mode .hljs-tag .hljs-attr {
			color: #ae81ff !important;
		}

		body.dark-mode .hljs-title,
		body.dark-mode .hljs-section {
			color: #a6e22e !important;
		}

		body.dark-mode .hljs-type,
		body.dark-mode .hljs-built_in {
			color: #fd971f !important;
		}

		body.dark-mode .hljs-symbol,
		body.dark-mode .hljs-bullet {
			color: #f92672 !important;
		}

		body.dark-mode .hljs-link {
			color: #e6db74 !important;
		}

		/* Tables */
		table {
			max-width: 100%;
			margin: 20px auto;
			border-collapse: collapse;
			border: 1px solid var(--table-border-color);
		}

		th,
		td {
			border: 1px solid var(--table-border-color);
			padding: 8px 10px;
		}

		th[align="left"],
		td[align="left"] {
			text-align: left;
		}

		th[align="center"],
		td[align="center"] {
			text-align: center;
		}

		th[align="right"],
		td[align="right"] {
			text-align: right;
		}

		th,
		td {
			text-align: left;
		}

		/* Print Styles */
		@media print {
			:root {
				--background-color: #ffffff !important;
				--text-color: #000000 !important;
				--pane-background: #ffffff !important;
				--pane-heading-background: #ffffff !important;
				--pane-heading-color: #000000 !important;
				--button-background: #ffffff !important;
				--button-color: #000000 !important;
				--border-color: #cccccc !important;
				--code-background: #ffffff !important;
				--table-border-color: #000000 !important;
				--table-header-background: #ffffff !important;
			}

			* {
				-webkit-print-color-adjust: exact !important;
				print-color-adjust: exact !important;
			}

			body,
			#editorContainer,
			#outputPane,
			#renderedOutput,
			table,
			th,
			td,
			pre,
			code,
			p,
			h1,
			h2,
			h3,
			h4,
			h5,
			h6,
			li,
			blockquote {
				background-color: #ffffff !important;
				color: #000000;
				/* Standard black text, but allows inline colors */
			}

			body {
				display: block !important;
				height: auto !important;
				overflow: visible !important;
				margin: 0 !important;
			}

			#editorContainer {
				display: block !important;
				height: auto !important;
				overflow: visible !important;
			}

			#inputPane,
			.pane-heading-container,
			.no-print {
				display: none !important;
			}

			#outputPane {
				display: block !important;
				width: auto !important;
				height: auto !important;
				overflow: visible !important;
				padding: 15mm !important;
				border: none !important;
			}

			svg,
			pre {
				page-break-inside: avoid !important;
				line-height: 1.5 !important;
			}

			#renderedOutput {
				height: auto !important;
				overflow: visible !important;
			}

			footer {
				display: none !important;
			}

			svg {
				color: #000000 !important;
				stroke: #000000 !important;
			}

			pre {
				border: 1px solid #dddddd !important;
				font-size: 0.95em !important;
				margin: 2px 0 !important;
			}

			code {
				background-color: #ffffff !important;
			}

			a,
			a:visited {
				color: #000000 !important;
				text-decoration: underline !important;
			}

			th[align="center"],
			td[align="center"] {
				text-align: center !important;
			}

			th[align="right"],
			td[align="right"] {
				text-align: right !important;
			}

			th,
			td {
				text-align: left !important;
			}
		}

		footer {
			text-align: center;
			padding: 5px;
			background: #f4f4f4;
			color: #555;
			margin: 5px 0;
			width: 100%;
		}

		body.dark-mode footer {
			background: #2d2c2c;
			color: #ccc;
		}

		button {
			margin: 5px;
			padding: 8px 12px;
			font-size: 14px;
			cursor: pointer;
			background-color: var(--button-background);
			color: var(--button-color);
			border: 1px solid var(--border-color);
			border-radius: 4px;
			transition: background-color 0.3s, color 0.3s;
		}

		button:hover {
			opacity: 0.8;
		}

		@media (max-width: 900px) {
			#editorContainer {
				flex-direction: column;
			}

			#inputPane,
			#outputPane {
				width: 100%;
				border-right: none;
				flex: 1;
			}
		}

		@media (max-width: 600px) {
			.buttonContainer {
				flex-wrap: wrap;
				justify-content: center;
			}

			.buttonContainer button {
				flex: 1 0 auto;
				margin: 5px 2px;
				min-width: 110px;
			}

			.toggle-container {
				position: static;
				margin-top: 5px;
			}

			.switch-label {
				font-size: 12px;
			}
		}
	</style>
</head>

<body>
	<div id="editorContainer">
		<div id="inputPane">
			<div class="pane-heading-container">
				<div class="logo-container">
					<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">
						<img src="/panphy.png" alt="PanPhy logo" />
					</a>
				</div>
				<h2 class="pane-heading">Markdown Input</h2>
				<div class="heading-placeholder"></div>
			</div>
			<div class="buttonContainer">
				<button id="loadFileButton">Open .md File</button>
				<button id="saveMDButton">Save .md</button>
				<button id="clearButton">Clear Input</button>
				<button id="loadSampleButton">Sample Document</button>
			</div>
			<textarea id="markdownInput" placeholder="Type your Markdown and LaTeX here..."></textarea>
		</div>

		<div id="outputPane">
			<div class="pane-heading-container">
				<div class="heading-placeholder"></div>
				<h2 class="pane-heading">Rendered Output</h2>
				<div class="theme-toggle-wrapper">
					<button id="themeToggleButton" class="theme-toggle-button no-print" aria-label="Switch to Dark Mode" title="Switch to Dark Mode">‚òÄÔ∏è</button>
				</div>
			</div>
			<div class="buttonContainer no-print">
				<button id="printButton" title="Print to PDF">Print to PDF</button>
				<button id="exportHTMLButton" title="Exports in current theme">Export as HTML</button>
				<div class="toggle-container">
					<label for="syncScrollSwitch" class="switch-label">Sync Scroll</label>
					<label class="switch">
						<input type="checkbox" id="syncScrollSwitch">
						<span class="slider"></span>
					</label>
				</div>
			</div>
			<div id="renderedOutput"></div>
		</div>
	</div>

	<footer>
		&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

<script>
	const markdownInput = document.getElementById('markdownInput');
	const renderedOutput = document.getElementById('renderedOutput');
	const clearButton = document.getElementById('clearButton');
	const loadSampleButton = document.getElementById('loadSampleButton');
	const exportHTMLButton = document.getElementById('exportHTMLButton');
	const printButton = document.getElementById('printButton');
	const saveMDButton = document.getElementById('saveMDButton');
	const loadFileButton = document.getElementById('loadFileButton');
	const themeToggleButton = document.getElementById('themeToggleButton');
	const highlightStyle = document.getElementById('highlightStyle');
	const syncScrollSwitch = document.getElementById('syncScrollSwitch');

	/* ---------------------------------------------------------------------- */
	/* 1) Utility: debounce                                                   */
	/* ---------------------------------------------------------------------- */
	function debounce(fn, wait) {
		let t = null;

		function debounced(...args) {
			if (t) clearTimeout(t);
			t = setTimeout(() => { t = null;
				fn.apply(this, args); }, wait);
		}
		debounced.flush = (...args) => {
			if (t) { clearTimeout(t);
				t = null; }
			fn.apply(this, args);
		};
		debounced.cancel = () => { if (t) clearTimeout(t);
			t = null; };
		return debounced;
	}

	/* ---------------------------------------------------------------------- */
	/* 2) Marked configuration                                                */
	/* ---------------------------------------------------------------------- */
	marked.setOptions({
		gfm: true,
		headerIds: true,
		tables: true,
		langPrefix: 'hljs language-',
		highlight: function(code, lang) {
			if (lang && hljs.getLanguage(lang)) {
				return hljs.highlight(code, { language: lang }).value;
			}
			return hljs.highlightAuto(code).value;
		}
	});

	// Helper: Inject Line Numbers into Rendered HTML for Sync (Naive Implementation)
	// This helps mapping, though Marked doesn't natively support easy line mapping in the browser.
	// We will stick to the improved line-count sync logic below.

	/* ---------------------------------------------------------------------- */
	/* 3) Main Render Logic (Tokenized to fix Math in Tables)                 */
	/* ---------------------------------------------------------------------- */
	// We use a "Masking" strategy:
	// 1. Find all LaTeX ($...$) and replace them with unique placeholders.
	// 2. Run Marked (Markdown -> HTML). Marked will treat placeholders as plain text (safe!).
	// 3. Swap placeholders back to real LaTeX.
	// 4. Let MathJax render the LaTeX.

	function renderContent() {
		const rawMarkdown = markdownInput.value;
		const mathMap = new Map();
		let mathId = 0;

		// A. Masking Stage
		// Regex matches: $$...$$ (Display) OR $...$ (Inline, not preceded by backslash)
		// We mask them so Marked doesn't escape the $ or confuse pipes | in tables.
		const maskedText = rawMarkdown.replace(/(\$\$[\s\S]*?\$\$)|((?<!\\)\$(?:\\.|[^$\\])*\$)/g, (match) => {
			// Create a unique token
			const token = `MATH_TOKEN_${mathId++}_MATH_TOKEN`;
			mathMap.set(token, match);
			return token;
		});

		// B. Parse Markdown
		const parsedHtml = marked.parse(maskedText);
		const sanitizedHtml = DOMPurify.sanitize(parsedHtml);

		// C. Unmasking Stage
		// Restore the Math content into the HTML
		const finalHtml = sanitizedHtml.replace(/MATH_TOKEN_\d+_MATH_TOKEN/g, (match) => {
			const original = mathMap.get(match);
			// Double-escape backslashes for MathJax (standard behavior for this stack)
			return original ? original.replace(/\\/g, '\\\\') : match;
		});

		renderedOutput.innerHTML = finalHtml;

		// D. Syntax Highlighting & MathJax
		if (window.hljs) hljs.highlightAll();
		MathJax.typesetPromise([renderedOutput]).catch(console.error);
	}

	/* ---------------------------------------------------------------------- */
	/* 4) Scroll Sync: Line-Count Estimation                                  */
	/* ---------------------------------------------------------------------- */
	// The old "Percentage" sync fails because Input (text) and Output (images) 
	// have vastly different heights. 
	// New Logic: 
	// 1. Calculate which "line number" is at the top of the Textarea.
	// 2. Estimate position in Output based on that ratio.

	let activePane = 'input';

	function setActivePane(pane) { activePane = pane; }

	markdownInput.addEventListener('mouseover', () => setActivePane('input'));
	renderedOutput.addEventListener('mouseover', () => setActivePane('output'));
	markdownInput.addEventListener('focus', () => setActivePane('input'));
	renderedOutput.addEventListener('pointerdown', () => setActivePane('output'));
	markdownInput.addEventListener('pointerdown', () => setActivePane('input'));

	let inputScrollRAF = null;
	let outputScrollRAF = null;

	// Simple Line-Count Sync (Better than raw %)
	function syncScroll(sourceEl, targetEl) {
		// 1. Get total lines in input
		const text = markdownInput.value;
		const totalLines = text.split('\n').length;

		// 2. Calculate current top line
		// We assume an average line height for the textarea (approx 22.5px usually, but we calculate)
		const textAreaLineHeight = 22.5; // Approximation for font-size 15px * 1.5
		const currentLine = markdownInput.scrollTop / textAreaLineHeight;

		// 3. Ratio based on lines, not pixels
		const ratio = Math.min(currentLine / totalLines, 1);

		// 4. Apply to output
		if (activePane === 'input') {
			const targetScrollable = renderedOutput.scrollHeight - renderedOutput.clientHeight;
			renderedOutput.scrollTop = ratio * targetScrollable;
		} else {
			// Reverse sync (Output -> Input) is harder because we don't know "lines" in HTML.
			// We fall back to standard percentage for this direction.
			const outRatio = renderedOutput.scrollTop / (renderedOutput.scrollHeight - renderedOutput.clientHeight);
			markdownInput.scrollTop = outRatio * (markdownInput.scrollHeight - markdownInput.clientHeight);
		}
	}

	markdownInput.addEventListener('scroll', () => {
		if (!syncScrollSwitch.checked || activePane !== 'input') return;
		if (inputScrollRAF) return;
		inputScrollRAF = requestAnimationFrame(() => {
			inputScrollRAF = null;
			syncScroll(markdownInput, renderedOutput);
		});
	}, { passive: true });

	renderedOutput.addEventListener('scroll', () => {
		if (!syncScrollSwitch.checked || activePane !== 'output') return;
		if (outputScrollRAF) return;
		outputScrollRAF = requestAnimationFrame(() => {
			outputScrollRAF = null;
			syncScroll(renderedOutput, markdownInput);
		});
	}, { passive: true });


	/* ---------------------------------------------------------------------- */
	/* 5) File & Print Operations                                             */
	/* ---------------------------------------------------------------------- */

	function loadSampleDocument() {
		fetch('mkdwn_sample_doc.md')
			.then(r => { if (!r.ok) throw new Error('Err'); return r.text(); })
			.then(d => { markdownInput.value = d;
				renderContent(); })
			.catch(e => {
				if (window.location.protocol === 'file:') {
					alert('Local File Security Block: Browsers do not allow fetching files (like the sample) when opening HTML directly from disk. Please use "Open .md File" instead.');
				} else {
					alert('Failed to load sample document.');
				}
			});
	}

	async function printToPDF() {
		debouncedRender.flush();
		const isDark = document.body.classList.contains('dark-mode');

		// Temporary Theme Swap for "Colorful" Print
		if (isDark) {
			highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
			// Wait for style to load
			await new Promise(r => setTimeout(r, 150));
		}

		await MathJax.typesetPromise([renderedOutput]).catch(console.error);
		window.print();

		// Revert Theme
		if (isDark) {
			highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
		}
	}

	function exportHTML() {
		const fileName = prompt('Enter file name:', 'document.html');
		if (!fileName) return;

		const doc = document.implementation.createHTMLDocument('Export');
		const head = doc.head;
		const body = doc.body;

		// Add Meta & Title
		const meta = document.createElement('meta');
		meta.setAttribute('charset', 'UTF-8');
		head.appendChild(meta);
		const title = document.createElement('title');
		title.textContent = 'Exported Document';
		head.appendChild(title);

		// CSS Block (Copy of Main CSS + Dark Mode support)
		const style = document.createElement('style');
		// We insert a simplified version of the CSS for the export
		style.textContent = `
      body { font-family: Helvetica, sans-serif; line-height: 1.5; padding: 20px; color: #000; background: #fff; }
      body.dark-mode { background: #1e1e1e; color: #e0e0e0; }
      table { border-collapse: collapse; margin: 20px 0; }
      th, td { border: 1px solid #555; padding: 8px; }
      code { background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
      pre { background: #f0f0f0; padding: 10px; overflow-x: auto; border-radius: 5px; }
      body.dark-mode code, body.dark-mode pre { background: #2f2f2f; color: #f8f8f2; }
      a { color: #ff5f1f; }
      img { max-width: 100%; }
      /* Print Rules for Export */
      @media print { body { color: #000 !important; background: #fff !important; } }
    `;
		head.appendChild(style);

		// Libraries
		const isDark = document.body.classList.contains('dark-mode');
		const hlStyle = document.createElement('link');
		hlStyle.rel = 'stylesheet';
		hlStyle.href = isDark ?
			'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css' :
			'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
		head.appendChild(hlStyle);

		// Scripts
		const hlScript = document.createElement('script');
		hlScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js';
		head.appendChild(hlScript);

		const mjConfig = document.createElement('script');
		mjConfig.textContent = "window.MathJax={tex:{inlineMath:[['$','$']],displayMath:[['$$','$$']],processEscapes:true},svg:{fontCache:'local'}};";
		head.appendChild(mjConfig);

		const mjScript = document.createElement('script');
		mjScript.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-svg.js';
		head.appendChild(mjScript);

		const initScript = document.createElement('script');
		initScript.textContent = "window.addEventListener('DOMContentLoaded',()=>hljs.highlightAll());";
		head.appendChild(initScript);

		body.innerHTML = renderedOutput.innerHTML;
		if (isDark) body.classList.add('dark-mode');

		const blob = new Blob([`<!DOCTYPE html>${doc.documentElement.outerHTML}`], { type: 'text/html' });
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = fileName;
		link.click();
	}

	function saveMarkdown() {
		const fileName = prompt('File name:', 'document.md');
		if (!fileName) return;
		const blob = new Blob([markdownInput.value], { type: 'text/markdown' });
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = fileName;
		link.click();
	}

	function loadMarkdownFile() {
		const input = document.createElement('input');
		input.type = 'file';
		input.accept = '.md,text/markdown';
		input.onchange = e => {
			const file = e.target.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = event => { markdownInput.value = event.target.result;
				renderContent(); };
			reader.readAsText(file);
		};
		input.click();
	}

	function initializeTheme() {
		const savedTheme = localStorage.getItem('theme');
		if (savedTheme === 'markdown-dark') {
			document.body.classList.add('dark-mode');
			highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css';
		} else {
			document.body.classList.remove('dark-mode');
			highlightStyle.href = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
		}
		updateThemeToggleButton();
	}

	function toggleTheme() {
		document.body.classList.toggle('dark-mode');
		const isDark = document.body.classList.contains('dark-mode');
		highlightStyle.href = isDark ?
			'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css' :
			'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css';
		localStorage.setItem('theme', isDark ? 'markdown-dark' : 'markdown-light');
		updateThemeToggleButton();
	}

	function updateThemeToggleButton() {
		const isDark = document.body.classList.contains('dark-mode');
		themeToggleButton.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
		themeToggleButton.title = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
	}

	/* Init */
	const debouncedRender = debounce(renderContent, 300);
	initializeTheme();
	renderContent();

	markdownInput.addEventListener('input', debouncedRender);
	printButton.addEventListener('click', printToPDF);
	exportHTMLButton.addEventListener('click', exportHTML);
	saveMDButton.addEventListener('click', saveMarkdown);
	loadFileButton.addEventListener('click', loadMarkdownFile);
	loadSampleButton.addEventListener('click', loadSampleDocument);
	clearButton.addEventListener('click', () => { markdownInput.value = '';
		renderContent(); });
	themeToggleButton.addEventListener('click', toggleTheme);
</script>

</html>