<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#f8f9fa">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <script>
    (function() {
      var hasDarkPreference = false;
      try {
        hasDarkPreference = Boolean(localStorage.getItem('tone-generator-dark'));
      } catch (_) {
        hasDarkPreference = false;
      }

      if (hasDarkPreference) {
        document.documentElement.setAttribute('data-theme', 'dark');
        var tc = document.querySelector('meta[name="theme-color"]');
        var sb = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (tc) tc.setAttribute('content', '#0f1014');
        if (sb) sb.setAttribute('content', 'black-translucent');
      }
    })();
    </script>
  <title>Multi-Channel Tone Generator</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <script src="/assets/sw-register.js" defer></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;

      --bg-color: #f8f9fa;
      --bg-pattern: #e9ecef;
      --text-main: #2d3436;
      --text-secondary: #636e72;

      --brand-primary: #6c5ce7;
      --brand-secondary: #a29bfe;
      --brand-accent: #00cec9;
      --danger: #d92d20;

      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --border: #e2e8f0;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.08);
      --canvas-bg: #ffffff;

      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5b4cdb;
      --btn-text: #ffffff;

      --nav-bg: rgba(255, 255, 255, 0.85);
      --nav-border: rgba(255, 255, 255, 0.5);

      --slider-track: #e2e8f0;
      --slider-thumb: #6c5ce7;
      --toggle-hover: rgba(108, 92, 231, 0.15);

      --channel-line: #1d9bf0;
      --channel-line-paused: #7ea8c7;
      --combined-line: #ef4444;
      --combined-line-paused: #c58888;
      --axis-line: #d8e2f4;
      --paused-overlay: rgba(253, 253, 255, 0.5);
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;

      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;
      --danger: #ff7870;

      --surface: #1e2129;
      --surface-alt: #17191f;
      --border: #2d3436;
      --shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      --canvas-bg: #1e1e1e;

      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5849d6;
      --btn-text: #ffffff;

      --nav-bg: rgba(22, 24, 29, 0.85);
      --nav-border: rgba(255, 255, 255, 0.08);

      --slider-track: #4a5568;
      --slider-thumb: #a29bfe;
      --toggle-hover: rgba(162, 155, 254, 0.2);

      --channel-line: #6cc8ff;
      --channel-line-paused: #4f6f8d;
      --combined-line: #ff6f82;
      --combined-line-paused: #96656d;
      --axis-line: #27344a;
      --paused-overlay: rgba(7, 11, 18, 0.42);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-sans);
      color: var(--text-main);
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 30px 30px;
      overflow: hidden;
    }

    a {
      color: var(--brand-primary);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      padding: 0;
    }

    #titleBanner {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 16px;
      width: calc(100% - 40px);
      max-width: 1360px;
      margin: 16px auto 0;
      background: var(--nav-bg);
      border: 1px solid var(--nav-border);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      min-height: 58px;
      padding: 8px 20px;
    }

    .banner-logo img {
      width: auto;
      height: 36px;
      display: block;
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
    }

    .banner-title {
      margin: 0;
      text-align: center;
      font-family: var(--font-display);
      font-size: 1.6rem;
      font-weight: 800;
      letter-spacing: -0.5px;
      color: var(--brand-primary);
    }

    .banner-title.gradient-text {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .banner-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 12px;
    }

    #theme-button {
      background: transparent;
      border: none;
      color: var(--text-main);
      border-radius: 50%;
      font-size: 1.2rem;
      line-height: 1;
      min-height: 42px;
      min-width: 42px;
      padding: 0.5rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }

    #theme-button:hover {
      background-color: var(--toggle-hover);
      transform: rotate(15deg);
    }

    #theme-button:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    #workspace {
      min-height: 0;
      flex: 1;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.9rem;
      width: calc(100% - 40px);
      max-width: 1360px;
      margin: 0 auto;
      padding-bottom: 0.75rem;
    }

    #transportPanel,
    #channelsPanel {
      min-height: 0;
    }

    #transportPanel {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .panel,
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
    }

    .card {
      padding: 0.9rem;
    }

    .transport-header {
      display: flex;
      justify-content: space-between;
      gap: 0.7rem;
      align-items: flex-start;
      margin-bottom: 0.65rem;
    }

    .eyebrow {
      margin: 0;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.11em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .transport-meta {
      margin-top: 0.32rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    #activeSummary {
      margin: 0;
      font-size: 0.82rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    #combinedCanvas {
      display: block;
      width: 100%;
      height: 220px;
      background: var(--canvas-bg);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    #transportHint {
      margin: 0.5rem 0 0;
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 28px;
      padding: 0 0.65rem;
      border-radius: 999px;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      border: 1px solid transparent;
      user-select: none;
    }

    .status-chip.playing {
      background: rgba(14, 165, 233, 0.15);
      border-color: rgba(14, 165, 233, 0.28);
      color: #0075b1;
    }

    [data-theme="dark"] .status-chip.playing {
      color: #9ddfff;
    }

    .status-chip.armed {
      background: rgba(249, 115, 22, 0.14);
      border-color: rgba(249, 115, 22, 0.3);
      color: #b45309;
    }

    [data-theme="dark"] .status-chip.armed {
      color: #ffc58f;
    }

    .status-chip.paused {
      background: rgba(127, 138, 162, 0.14);
      border-color: rgba(127, 138, 162, 0.3);
      color: #63708a;
    }

    [data-theme="dark"] .status-chip.paused {
      color: #b4bfd6;
    }

    .btn {
      border: 1px solid transparent;
      border-radius: 12px;
      min-height: 46px;
      padding: 0.55rem 0.95rem;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.16s ease, filter 0.16s ease, border-color 0.16s ease;
      white-space: normal;
      overflow-wrap: anywhere;
      line-height: 1.2;
      text-align: center;
    }

    .btn:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.02);
    }

    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
      filter: none;
    }

    .btn-primary {
      background: var(--btn-primary);
      color: var(--btn-text);
      min-width: 128px;
    }

    .btn-primary:hover {
      background: var(--btn-primary-hover);
    }

    .btn-secondary {
      background: var(--surface-alt);
      color: var(--text-main);
      border-color: var(--border);
    }

    .btn-danger {
      background: rgba(217, 45, 32, 0.11);
      color: var(--danger);
      border-color: rgba(217, 45, 32, 0.24);
    }

    .btn-small {
      min-height: 40px;
      padding: 0.45rem 0.7rem;
      border-radius: 10px;
      font-size: 0.82rem;
    }

    #controlsCard {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.8rem;
    }

    .control-block {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .control-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.4rem;
    }

    .control-header label {
      font-size: 0.79rem;
      font-weight: 700;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-header span {
      font-family: var(--font-mono);
      font-size: 0.78rem;
      color: var(--text-main);
    }

    input[type="range"] {
      width: 100%;
      height: 32px;
      background: transparent;
      cursor: pointer;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]:focus-visible {
      outline: none;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      margin-top: -6px;
      border-radius: 50%;
      border: none;
      background: var(--slider-thumb);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: none;
      background: var(--slider-thumb);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .utility-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.55rem;
    }

    .utility-row .btn {
      width: 100%;
      min-width: 0;
    }

    #channelsPanel {
      display: flex;
      flex-direction: column;
      padding: 0.95rem;
      overflow: hidden;
    }

    .channels-header {
      margin-bottom: 0.6rem;
    }

    .channels-header h2 {
      margin: 0;
      font-family: var(--font-display);
      font-size: 1.06rem;
      letter-spacing: -0.01em;
    }

    .channels-header p {
      margin: 0.2rem 0 0;
      color: var(--text-secondary);
      font-size: 0.86rem;
    }

    #channelsList {
      min-height: 0;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
      padding-right: 0.4rem;
    }

    .channel-card {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 0.75rem;
      display: grid;
      gap: 0.6rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .channel-card[data-state="playing"] {
      border-color: rgba(14, 165, 233, 0.45);
      box-shadow: 0 0 0 1px rgba(14, 165, 233, 0.16);
    }

    .channel-card[data-state="armed"] {
      border-color: rgba(249, 115, 22, 0.42);
      box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.15);
    }

    .channel-header {
      display: flex;
      justify-content: space-between;
      gap: 0.6rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .channel-title-wrap {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      min-height: 40px;
    }

    .channel-title {
      margin: 0;
      font-size: 0.98rem;
    }

    .channel-actions {
      display: inline-flex;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .channel-actions .btn {
      min-width: 0;
    }

    .frequency-row {
      display: grid;
      gap: 0.35rem;
    }

    .freq-label {
      font-size: 0.79rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .freq-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.55rem;
      flex-wrap: wrap;
    }

    .freq-number {
      width: 98px;
      min-height: 40px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--canvas-bg);
      color: var(--text-main);
      font-family: var(--font-mono);
      font-size: 0.86rem;
      padding: 0.35rem 0.5rem;
    }

    .freq-number:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .freq-value {
      font-size: 0.82rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
      font-weight: 600;
    }

    .channel-canvas {
      width: 100%;
      height: 92px;
      display: block;
      background: var(--canvas-bg);
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    #emptyState {
      border: 1px dashed var(--border);
      border-radius: 12px;
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.36);
      text-align: center;
      padding: 1rem;
      font-size: 0.89rem;
      font-weight: 600;
    }

    [data-theme="dark"] #emptyState {
      background: rgba(9, 12, 18, 0.4);
    }

    footer {
      flex: 0 0 auto;
      text-align: center;
      font-size: 0.9rem;
      color: var(--text-secondary);
      padding: 0.5rem 1rem;
    }

    @media (pointer: coarse) {
      .btn,
      .btn-small,
      .freq-number,
      #theme-button {
        min-height: 48px;
      }

      #theme-button {
        min-width: 48px;
      }

      input[type="range"] {
        height: 40px;
      }

      input[type="range"]::-webkit-slider-thumb {
        width: 22px;
        height: 22px;
        margin-top: -8px;
      }

      input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
      }
    }

    @media (max-width: 1050px) {
      body {
        overflow: auto;
      }

      #app {
        height: auto;
        min-height: 100%;
      }

      #workspace {
        grid-template-columns: 1fr;
      }

      #transportPanel {
        order: 1;
      }

      #channelsPanel {
        order: 2;
        min-height: 52vh;
      }

      .control-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      #titleBanner {
        width: calc(100% - 24px);
        margin: 12px auto 0;
        min-height: 52px;
        border-radius: 18px;
        padding: 8px 12px;
      }

      #workspace {
        width: calc(100% - 24px);
      }

      .banner-logo img {
        height: 28px;
      }

      .banner-title {
        font-size: 1rem;
      }

      #theme-button {
        min-width: 40px;
        min-height: 40px;
        font-size: 1.05rem;
        padding: 0.45rem;
      }

      .utility-row {
        grid-template-columns: 1fr;
      }

      .transport-header {
        flex-direction: column;
        align-items: stretch;
      }

      .btn-primary {
        width: 100%;
      }

      .channel-actions {
        width: 100%;
      }

      .channel-actions .btn-small {
        flex: 1;
      }

      .freq-meta {
        justify-content: flex-start;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <header id="titleBanner">
      <div class="banner-logo">
        <a href="https://panphy.github.io/">
          <img src="/assets/panphy.png" alt="PanPhy logo">
        </a>
      </div>
      <h1 class="banner-title">Tone Mixer Lab</h1>
      <div class="banner-actions">
        <div class="theme-toggle">
          <button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">&#9728;&#65039;</button>
        </div>
      </div>
    </header>

    <main id="workspace">
      <section id="transportPanel">
        <div class="card" id="combinedCard">
          <div class="transport-header">
            <div>
              <p class="eyebrow">Combined Output</p>
              <div class="transport-meta">
                <span id="combinedStateChip" class="status-chip paused">Paused</span>
                <p id="activeSummary">0 active / 0 channels</p>
              </div>
            </div>
            <button id="toggleCombinedBtn" class="btn btn-primary" disabled>Play Combined</button>
          </div>
          <canvas id="combinedCanvas"></canvas>
          <p id="transportHint">Space key toggles combined play/pause.</p>
        </div>

        <div class="card" id="controlsCard">
          <div class="control-grid">
            <div class="control-block">
              <div class="control-header">
                <label for="volumeSlider">Volume</label>
                <span id="volumeValue">100%</span>
              </div>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="panningSlider">L/R Pan</label>
                <span id="panningValue">0.00</span>
              </div>
              <input type="range" id="panningSlider" min="-1" max="1" step="0.01" value="0">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="timeScaleSlider">Animation Speed</label>
                <span id="timeScaleValue">1.000x</span>
              </div>
              <input type="range" id="timeScaleSlider" min="-3" max="1" step="0.01" value="0">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="zoomScaleSlider">Wave Zoom</label>
                <span id="zoomScaleValue">1.00x</span>
              </div>
              <input type="range" id="zoomScaleSlider" min="0.01" max="50" step="0.01" value="1">
            </div>
          </div>

          <div class="utility-row">
            <button id="addChannelBtn" class="btn btn-primary">Add Channel</button>
            <button id="playAllBtn" class="btn btn-secondary" disabled>Play All Channels</button>
            <button id="pauseAllBtn" class="btn btn-secondary" disabled>Pause All Channels</button>
          </div>
        </div>
      </section>

      <section id="channelsPanel" class="panel">
        <div class="channels-header">
          <h2>Channel Mixer</h2>
          <p>Each channel has independent play/pause. Combined play controls final audio output and combined waveform motion.</p>
        </div>
        <div id="channelsList"></div>
      </section>
    </main>

    <footer>
      &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
      <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
    </footer>
  </div>

  <script>
    // Gradient text: skip on Brave iOS where background-clip:text is broken
    (function () {
      if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
      document.querySelectorAll('.banner-title').forEach(function (el) {
        el.classList.add('gradient-text');
      });
    })();

    // Theme Toggle
    const themeButton = document.getElementById('theme-button');
    const DARK_THEME_KEY = 'tone-generator-dark';
    const LIGHT_THEME_KEY = 'tone-generator-light';
    function safeStorageGet(key) {
      try {
        return localStorage.getItem(key);
      } catch (_) {
        return null;
      }
    }
    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (_) {
        // Ignore storage errors so theme toggle still works for this session.
      }
    }
    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
      } catch (_) {
        // Ignore storage errors so theme toggle still works for this session.
      }
    }

    const currentTheme = safeStorageGet(DARK_THEME_KEY)
      ? 'dark'
      : safeStorageGet(LIGHT_THEME_KEY)
        ? 'light'
        : 'light';

    document.documentElement.setAttribute('data-theme', currentTheme);
    updateAppChromeTheme(currentTheme);
    updateButtonEmoji(currentTheme);

    function updateAppChromeTheme(theme) {
      const themeColorMeta = document.querySelector('meta[name="theme-color"]');
      const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      const isDarkTheme = theme === 'dark';

      if (themeColorMeta) {
        themeColorMeta.setAttribute('content', isDarkTheme ? '#0f1014' : '#f8f9fa');
      }

      if (appleStatusBarMeta) {
        appleStatusBarMeta.setAttribute('content', isDarkTheme ? 'black-translucent' : 'default');
      }
    }

    window.addEventListener('pageshow', function () {
      updateAppChromeTheme(document.documentElement.getAttribute('data-theme'));
    });

    function updateButtonEmoji(theme) {
      themeButton.textContent = theme === 'dark' ? '\u{1F319}' : '\u{2600}\u{FE0F}';
    }

    themeButton.addEventListener('click', function () {
      let theme = document.documentElement.getAttribute('data-theme');
      if (theme === 'light') {
        document.documentElement.setAttribute('data-theme', 'dark');
        safeStorageSet(DARK_THEME_KEY, 'true');
        safeStorageRemove(LIGHT_THEME_KEY);
        updateAppChromeTheme('dark');
        updateButtonEmoji('dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        safeStorageSet(LIGHT_THEME_KEY, 'true');
        safeStorageRemove(DARK_THEME_KEY);
        updateAppChromeTheme('light');
        updateButtonEmoji('light');
      }
    });
  </script>

  <script>
    (function () {
    const addChannelBtn = document.getElementById('addChannelBtn');
    const playAllBtn = document.getElementById('playAllBtn');
    const pauseAllBtn = document.getElementById('pauseAllBtn');
    const channelsList = document.getElementById('channelsList');

    const combinedCanvas = document.getElementById('combinedCanvas');
    const combinedCtx = combinedCanvas.getContext('2d');
    const toggleCombinedBtn = document.getElementById('toggleCombinedBtn');
    const combinedStateChip = document.getElementById('combinedStateChip');
    const activeSummary = document.getElementById('activeSummary');

    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');

    const panningSlider = document.getElementById('panningSlider');
    const panningValue = document.getElementById('panningValue');

    const timeScaleSlider = document.getElementById('timeScaleSlider');
    const timeScaleValue = document.getElementById('timeScaleValue');

    const zoomScaleSlider = document.getElementById('zoomScaleSlider');
    const zoomScaleValue = document.getElementById('zoomScaleValue');
    const transportHint = document.getElementById('transportHint');

    const DEFAULT_TRANSPORT_HINT = 'Space key toggles combined play/pause.';
    const AUDIO_BLOCKED_HINT = 'Tap or click to enable audio, then try again.';
    const AUDIO_UNAVAILABLE_HINT = 'Audio output is unavailable in this browser.';

    function setAudioUnavailableState(message) {
      if (transportHint) {
        transportHint.textContent = message || AUDIO_UNAVAILABLE_HINT;
      }
      if (combinedStateChip) {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'Unavailable';
      }
      if (activeSummary) {
        activeSummary.textContent = 'Audio unavailable';
      }
      [
        addChannelBtn,
        playAllBtn,
        pauseAllBtn,
        toggleCombinedBtn,
        volumeSlider,
        panningSlider,
        timeScaleSlider,
        zoomScaleSlider
      ].forEach((control) => {
        if (control) {
          control.disabled = true;
        }
      });
    }

    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    if (AudioContextClass) {
      try {
        audioCtx = new AudioContextClass({ latencyHint: 'interactive' });
      } catch (_) {
        audioCtx = null;
      }
    }

    if (!audioCtx) {
      setAudioUnavailableState(AUDIO_UNAVAILABLE_HINT);
      return;
    }

    const channelBus = audioCtx.createGain();
    channelBus.gain.value = 1;

    const volumeGain = audioCtx.createGain();
    volumeGain.gain.value = 1;

    const combinedGain = audioCtx.createGain();
    combinedGain.gain.value = 0;

    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -22;
    compressor.knee.value = 18;
    compressor.ratio.value = 3;
    compressor.attack.value = 0.004;
    compressor.release.value = 0.2;

    const supportsStereoPanner = typeof audioCtx.createStereoPanner === 'function';
    const stereoPanner = supportsStereoPanner ? audioCtx.createStereoPanner() : null;

    channelBus.connect(volumeGain);
    volumeGain.connect(combinedGain);
    combinedGain.connect(compressor);
    if (stereoPanner) {
      compressor.connect(stereoPanner);
      stereoPanner.connect(audioCtx.destination);
    } else {
      compressor.connect(audioCtx.destination);
      if (panningSlider) {
        panningSlider.disabled = true;
      }
      if (panningValue) {
        panningValue.textContent = 'N/A';
      }
    }

    const MIN_FREQUENCY_HZ = 15;
    const MAX_FREQUENCY_HZ = Math.max(
      MIN_FREQUENCY_HZ,
      Math.min(23000, Math.floor(audioCtx.sampleRate / 2) - 1)
    );
    const MAX_CHANNELS = 10;

    const channels = [];
    let nextChannelId = 1;
    let combinedPlaying = false;
    let timeScale = Math.pow(10, parseFloat(timeScaleSlider.value));
    let zoomScale = parseFloat(zoomScaleSlider.value);
    let lastFrameTime = null;

    const BASE_WINDOW = 0.01;
    const INTERACTIVE_TAGS = new Set(['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON']);
    const TWO_PI = Math.PI * 2;
    const DEG_TO_RAD = Math.PI / 180;
    const RAD_TO_DEG = 180 / Math.PI;
    const PHASE_SNAP_DEGREES = 8;
    const MIN_PHASE_DEGREES = -180;
    const MAX_PHASE_DEGREES = 180;

    let resumePromise = null;

    function normalizePhase(phase) {
      if (!Number.isFinite(phase)) return 0;
      let normalized = phase % TWO_PI;
      if (normalized < 0) {
        normalized += TWO_PI;
      }
      return normalized;
    }

    function normalizeSignedPhase(phase) {
      const normalized = normalizePhase(phase);
      return normalized > Math.PI ? normalized - TWO_PI : normalized;
    }

    function advanceChannelPhase(channel, now = audioCtx.currentTime) {
      if (!channel || !Number.isFinite(channel.phaseTimestamp) || !Number.isFinite(channel.phase)) {
        return 0;
      }
      const elapsed = Math.max(0, now - channel.phaseTimestamp);
      if (elapsed > 0) {
        channel.phase = normalizePhase(channel.phase + TWO_PI * channel.frequency * elapsed);
        channel.phaseTimestamp = now;
      }
      return channel.phase;
    }

    function applyOscillatorPhase(oscillator, phase) {
      const normalizedPhase = normalizePhase(phase);
      const real = new Float32Array(2);
      const imag = new Float32Array(2);
      real[1] = Math.sin(normalizedPhase);
      imag[1] = Math.cos(normalizedPhase);
      oscillator.setPeriodicWave(audioCtx.createPeriodicWave(real, imag));
    }

    function createOscillatorWithPhase(frequency, phase, startTime) {
      const oscillator = audioCtx.createOscillator();
      applyOscillatorPhase(oscillator, phase);
      oscillator.frequency.setValueAtTime(frequency, startTime);
      return oscillator;
    }

    function formatPhaseOffsetDegrees(phaseDegrees, isReference = false) {
      const rounded = Math.round(phaseDegrees);
      if (isReference) {
        return '0° (ref)';
      }
      if (rounded === 0) {
        return '0°';
      }
      return `${rounded > 0 ? '+' : ''}${rounded}°`;
    }

    function updateChannelPhaseControls(channel, isReference) {
      if (!channel || !channel.phaseSlider || !channel.phaseValue) return;
      const displayDegrees = isReference ? 0 : Math.round(channel.phaseOffsetDeg || 0);
      channel.phaseSlider.value = String(displayDegrees);
      channel.phaseSlider.disabled = isReference;
      channel.phaseValue.textContent = formatPhaseOffsetDegrees(displayDegrees, isReference);
      channel.phaseSlider.title = isReference
        ? 'Reference channel (fixed at 0°)'
        : 'Phase difference relative to Channel 1';
    }

    function syncPhaseOffsetsToReference() {
      if (channels.length === 0) return;

      const now = audioCtx.currentTime;
      const referenceChannel = channels[0];
      const referencePhase = advanceChannelPhase(referenceChannel, now);
      referenceChannel.phaseOffsetRad = 0;
      referenceChannel.phaseOffsetDeg = 0;
      updateChannelPhaseControls(referenceChannel, true);

      for (let i = 1; i < channels.length; i += 1) {
        const channel = channels[i];
        const channelPhase = advanceChannelPhase(channel, now);
        const relativePhase = normalizeSignedPhase(channelPhase - referencePhase);
        const relativeDegrees = Math.round(relativePhase * RAD_TO_DEG);
        channel.phaseOffsetDeg = relativeDegrees;
        channel.phaseOffsetRad = relativeDegrees * DEG_TO_RAD;
        channel.phase = normalizePhase(referencePhase + channel.phaseOffsetRad);
        channel.phaseTimestamp = now;
        applyOscillatorPhase(channel.oscillator, channel.phase);
        updateChannelPhaseControls(channel, false);
      }
    }

    function setChannelPhaseOffsetRelativeToReference(channel, rawDegrees) {
      if (!channel) return;
      const referenceChannel = channels[0] || null;
      if (!referenceChannel || channel === referenceChannel) {
        channel.phaseOffsetDeg = 0;
        channel.phaseOffsetRad = 0;
        updateChannelPhaseControls(channel, true);
        return;
      }

      const safeDegrees = Number.isFinite(rawDegrees) ? rawDegrees : 0;
      let phaseDegrees = Math.round(clamp(safeDegrees, MIN_PHASE_DEGREES, MAX_PHASE_DEGREES));
      if (Math.abs(phaseDegrees) <= PHASE_SNAP_DEGREES) {
        phaseDegrees = 0;
      }

      const now = audioCtx.currentTime;
      const referencePhase = advanceChannelPhase(referenceChannel, now);
      channel.phaseOffsetDeg = phaseDegrees;
      channel.phaseOffsetRad = phaseDegrees * DEG_TO_RAD;
      channel.phase = normalizePhase(referencePhase + channel.phaseOffsetRad);
      channel.phaseTimestamp = now;
      applyOscillatorPhase(channel.oscillator, channel.phase);
      updateChannelPhaseControls(channel, false);
    }

    function setAudioBlockedHint() {
      if (transportHint) {
        transportHint.textContent = AUDIO_BLOCKED_HINT;
      }
    }

    function setAudioReadyHint() {
      if (transportHint) {
        transportHint.textContent = DEFAULT_TRANSPORT_HINT;
      }
    }

    async function ensureAudioContext() {
      if (audioCtx.state === 'running') {
        return true;
      }

      if (!resumePromise) {
        resumePromise = audioCtx.resume()
          .then(() => audioCtx.state === 'running')
          .catch(() => false)
          .finally(() => {
            resumePromise = null;
          });
      }

      const resumed = await resumePromise;
      return resumed || audioCtx.state === 'running';
    }

    function setGain(node, targetValue) {
      const now = audioCtx.currentTime;
      node.gain.cancelScheduledValues(now);
      node.gain.setTargetAtTime(targetValue, now, 0.012);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function getCssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function getThemeColors() {
      return {
        canvasBg: getCssVar('--canvas-bg'),
        axisLine: getCssVar('--axis-line'),
        textMuted: getCssVar('--text-secondary'),
        pausedOverlay: getCssVar('--paused-overlay'),
        channelLine: getCssVar('--channel-line'),
        channelLinePaused: getCssVar('--channel-line-paused'),
        combinedLine: getCssVar('--combined-line'),
        combinedLinePaused: getCssVar('--combined-line-paused')
      };
    }

    function updateControlReadouts() {
      const volumePercent = Math.round(parseFloat(volumeSlider.value) * 100);
      volumeValue.textContent = `${volumePercent}%`;

      if (stereoPanner) {
        const pan = parseFloat(panningSlider.value);
        panningValue.textContent = pan.toFixed(2);
      } else {
        panningValue.textContent = 'N/A';
      }

      timeScaleValue.textContent = `${timeScale.toFixed(3)}x`;
      zoomScaleValue.textContent = `${zoomScale.toFixed(2)}x`;
    }

    function drawCenterAxis(ctx, width, height, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawWavePath(ctx, width, height, frequency, waveTime, timeWindow, phaseOffset, color) {
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;

      for (let x = 0; x < width; x += 1) {
        const fraction = x / (width - 1 || 1);
        const t = waveTime - fraction * timeWindow;
        const sample = Math.sin(2 * Math.PI * frequency * t + phaseOffset);
        const y = (sample * 0.5 + 0.5) * height;
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }

      ctx.stroke();
    }

    function drawChannelWave(channel, colors) {
      const ctx = channel.ctx;
      const canvas = channel.canvas;
      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = colors.canvasBg;
      ctx.fillRect(0, 0, width, height);
      drawCenterAxis(ctx, width, height, colors.axisLine);

      const timeWindow = BASE_WINDOW * zoomScale;
      const animated = combinedPlaying && channel.isPlaying;
      drawWavePath(
        ctx,
        width,
        height,
        channel.frequency,
        channel.waveTime,
        timeWindow,
        channel.phaseOffsetRad || 0,
        animated ? colors.channelLine : colors.channelLinePaused
      );

      if (!animated) {
        ctx.fillStyle = colors.pausedOverlay;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = colors.textMuted;
        ctx.font = '12px "JetBrains Mono", monospace';
        ctx.textAlign = 'right';
        ctx.fillText(channel.isPlaying ? 'Armed' : 'Paused', width - 10, 16);
      }
    }

    function drawCombinedWave(colors) {
      const width = combinedCanvas.width;
      const height = combinedCanvas.height;

      combinedCtx.fillStyle = colors.canvasBg;
      combinedCtx.fillRect(0, 0, width, height);
      drawCenterAxis(combinedCtx, width, height, colors.axisLine);

      const activeChannels = channels.filter((channel) => channel.isPlaying);
      if (activeChannels.length === 0) {
        combinedCtx.fillStyle = colors.textMuted;
        combinedCtx.textAlign = 'center';
        combinedCtx.font = '13px "JetBrains Mono", monospace';
        combinedCtx.fillText('No active channels', width / 2, height / 2 - 8);
        combinedCtx.fillText('Press Play on a channel to add it to the mix', width / 2, height / 2 + 14);
        return;
      }

      const timeWindow = BASE_WINDOW * zoomScale;
      combinedCtx.beginPath();
      combinedCtx.lineWidth = 2.25;
      combinedCtx.strokeStyle = combinedPlaying ? colors.combinedLine : colors.combinedLinePaused;

      const ampScale = activeChannels.length;

      for (let x = 0; x < width; x += 1) {
        const fraction = x / (width - 1 || 1);
        let sampleSum = 0;

        for (const channel of activeChannels) {
          const t = channel.waveTime - fraction * timeWindow;
          sampleSum += Math.sin(2 * Math.PI * channel.frequency * t + (channel.phaseOffsetRad || 0));
        }

        const y = (sampleSum / ampScale * 0.5 + 0.5) * height;

        if (x === 0) {
          combinedCtx.moveTo(x, y);
        } else {
          combinedCtx.lineTo(x, y);
        }
      }

      combinedCtx.stroke();

      if (!combinedPlaying) {
        combinedCtx.fillStyle = colors.pausedOverlay;
        combinedCtx.fillRect(0, 0, width, height);
        combinedCtx.fillStyle = colors.textMuted;
        combinedCtx.textAlign = 'right';
        combinedCtx.font = '12px "JetBrains Mono", monospace';
        combinedCtx.fillText('Combined paused', width - 10, 18);
      }
    }

    function refreshChannelTitles() {
      channels.forEach((channel, index) => {
        channel.title.textContent = `Channel ${index + 1}`;
      });
    }

    function syncChannelUi(channel) {
      let visualState = 'paused';
      let label = 'Paused';

      if (channel.isPlaying && combinedPlaying) {
        visualState = 'playing';
        label = 'Playing';
      } else if (channel.isPlaying) {
        visualState = 'armed';
        label = 'Armed';
      }

      channel.card.dataset.state = visualState;
      channel.statusChip.className = `status-chip ${visualState}`;
      channel.statusChip.textContent = label;

      channel.toggleBtn.textContent = channel.isPlaying ? 'Pause' : 'Play';
      channel.toggleBtn.setAttribute('aria-pressed', channel.isPlaying ? 'true' : 'false');
    }

    function syncCombinedUi() {
      if (combinedPlaying) {
        combinedStateChip.className = 'status-chip playing';
        combinedStateChip.textContent = 'Playing';
        toggleCombinedBtn.textContent = 'Pause Combined';
      } else {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'Paused';
        toggleCombinedBtn.textContent = 'Play Combined';
      }

      if (channels.length === 0) {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'No Channels';
        toggleCombinedBtn.disabled = true;
      }
    }

    function refreshSummary() {
      const activeCount = channels.filter((channel) => channel.isPlaying).length;
      activeSummary.textContent = `${activeCount} active / ${channels.length} channels`;

      const normalizedBusGain = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
      setGain(channelBus, normalizedBusGain);

      playAllBtn.disabled = channels.length === 0 || activeCount === channels.length;
      pauseAllBtn.disabled = channels.length === 0 || activeCount === 0;
      const reachedMaxChannels = channels.length >= MAX_CHANNELS;
      addChannelBtn.disabled = reachedMaxChannels;
      addChannelBtn.title = reachedMaxChannels
        ? `Maximum ${MAX_CHANNELS} channels reached`
        : 'Add Channel';

      if (channels.length === 0 && combinedPlaying) {
        combinedPlaying = false;
        setGain(combinedGain, 0);
      }

      toggleCombinedBtn.disabled = channels.length === 0;
      syncCombinedUi();
    }

    function applyFrequency(channel, rawFrequency) {
      const now = audioCtx.currentTime;
      advanceChannelPhase(channel, now);
      const frequency = Math.round(clamp(rawFrequency, MIN_FREQUENCY_HZ, MAX_FREQUENCY_HZ));
      channel.frequency = frequency;
      channel.phaseTimestamp = now;
      channel.oscillator.frequency.setValueAtTime(frequency, now);
      channel.freqSlider.value = String(frequency);
      channel.freqNumber.value = String(frequency);
      channel.freqValue.textContent = `${frequency} Hz`;
    }

    async function toggleChannel(channelId) {
      const channel = channels.find((item) => item.id === channelId);
      if (!channel) {
        return;
      }

      const ready = await ensureAudioContext();
      if (!ready) {
        setAudioBlockedHint();
        return;
      }
      setAudioReadyHint();
      channel.isPlaying = !channel.isPlaying;
      setGain(channel.gainNode, channel.isPlaying ? 1 : 0);
      syncChannelUi(channel);
      refreshSummary();
    }

    function removeChannel(channelId) {
      const index = channels.findIndex((item) => item.id === channelId);
      if (index === -1) {
        return;
      }

      const [channel] = channels.splice(index, 1);
      channel.oscillator.stop();
      channel.oscillator.disconnect();
      channel.gainNode.disconnect();
      channel.card.remove();

      refreshChannelTitles();
      syncPhaseOffsetsToReference();
      refreshSummary();

      if (channels.length === 0) {
        renderEmptyState();
      }
    }

    function renderEmptyState() {
      if (document.getElementById('emptyState')) {
        return;
      }
      const empty = document.createElement('div');
      empty.id = 'emptyState';
      empty.textContent = 'No channels yet. Add a channel to begin mixing.';
      channelsList.appendChild(empty);
    }

    function clearEmptyState() {
      const empty = document.getElementById('emptyState');
      if (empty) {
        empty.remove();
      }
    }

    function addChannel(options = {}) {
      if (channels.length >= MAX_CHANNELS) {
        refreshSummary();
        return false;
      }

      clearEmptyState();

      const now = audioCtx.currentTime;
      const referenceChannel = channels[0] || null;
      const initialFrequency = Number.isFinite(options.frequency) ? options.frequency : 440;
      const initialPhaseOffsetDegrees = 0;
      const initialPhaseOffset = initialPhaseOffsetDegrees * DEG_TO_RAD;
      const initialPhase = referenceChannel
        ? normalizePhase(advanceChannelPhase(referenceChannel, now) + initialPhaseOffset)
        : 0;
      const channel = {
        id: nextChannelId,
        frequency: Math.round(clamp(initialFrequency, MIN_FREQUENCY_HZ, MAX_FREQUENCY_HZ)),
        isPlaying: options.isPlaying === undefined ? true : Boolean(options.isPlaying),
        waveTime: referenceChannel ? referenceChannel.waveTime : 0,
        phaseOffsetDeg: initialPhaseOffsetDegrees,
        phaseOffsetRad: initialPhaseOffset,
        phase: initialPhase,
        phaseTimestamp: now
      };
      nextChannelId += 1;

      const oscillator = createOscillatorWithPhase(channel.frequency, initialPhase, now);

      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(channel.isPlaying ? 1 : 0, now);

      oscillator.connect(gainNode);
      gainNode.connect(channelBus);
      oscillator.start(now);

      channel.oscillator = oscillator;
      channel.gainNode = gainNode;

      const card = document.createElement('article');
      card.className = 'channel-card';
      card.dataset.state = 'paused';

      const header = document.createElement('div');
      header.className = 'channel-header';

      const titleWrap = document.createElement('div');
      titleWrap.className = 'channel-title-wrap';

      const title = document.createElement('h3');
      title.className = 'channel-title';
      title.textContent = 'Channel';

      const statusChip = document.createElement('span');
      statusChip.className = 'status-chip paused';
      statusChip.textContent = 'Paused';

      titleWrap.appendChild(title);
      titleWrap.appendChild(statusChip);

      const actions = document.createElement('div');
      actions.className = 'channel-actions';

      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'btn btn-secondary btn-small';
      toggleBtn.textContent = 'Play';

      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-danger btn-small';
      removeBtn.textContent = 'Remove';

      actions.appendChild(toggleBtn);
      actions.appendChild(removeBtn);

      header.appendChild(titleWrap);
      header.appendChild(actions);

      const frequencyRow = document.createElement('div');
      frequencyRow.className = 'frequency-row';

      const freqLabel = document.createElement('label');
      freqLabel.className = 'freq-label';
      freqLabel.textContent = 'Frequency';

      const freqSlider = document.createElement('input');
      freqSlider.type = 'range';
      freqSlider.min = String(MIN_FREQUENCY_HZ);
      freqSlider.max = String(MAX_FREQUENCY_HZ);
      freqSlider.step = '1';
      freqSlider.value = String(channel.frequency);

      const freqMeta = document.createElement('div');
      freqMeta.className = 'freq-meta';

      const freqNumber = document.createElement('input');
      freqNumber.className = 'freq-number';
      freqNumber.type = 'number';
      freqNumber.min = String(MIN_FREQUENCY_HZ);
      freqNumber.max = String(MAX_FREQUENCY_HZ);
      freqNumber.step = '1';
      freqNumber.value = String(channel.frequency);

      const freqValue = document.createElement('span');
      freqValue.className = 'freq-value';
      freqValue.textContent = `${channel.frequency} Hz`;

      freqMeta.appendChild(freqNumber);
      freqMeta.appendChild(freqValue);

      const phaseRow = document.createElement('div');
      phaseRow.className = 'frequency-row';

      const phaseLabel = document.createElement('label');
      phaseLabel.className = 'freq-label';
      phaseLabel.textContent = 'Phase vs Ch1';

      const phaseSlider = document.createElement('input');
      phaseSlider.type = 'range';
      phaseSlider.min = String(MIN_PHASE_DEGREES);
      phaseSlider.max = String(MAX_PHASE_DEGREES);
      phaseSlider.step = '1';
      phaseSlider.value = '0';

      const phaseMeta = document.createElement('div');
      phaseMeta.className = 'freq-meta';

      const phaseValue = document.createElement('span');
      phaseValue.className = 'freq-value';
      phaseValue.textContent = '0°';

      phaseMeta.appendChild(phaseValue);

      const canvas = document.createElement('canvas');
      canvas.className = 'channel-canvas';
      const ctx = canvas.getContext('2d');

      frequencyRow.appendChild(freqLabel);
      frequencyRow.appendChild(freqSlider);
      frequencyRow.appendChild(freqMeta);
      phaseRow.appendChild(phaseLabel);
      phaseRow.appendChild(phaseSlider);
      phaseRow.appendChild(phaseMeta);

      card.appendChild(header);
      card.appendChild(frequencyRow);
      card.appendChild(phaseRow);
      card.appendChild(canvas);

      channelsList.appendChild(card);

      channel.card = card;
      channel.title = title;
      channel.statusChip = statusChip;
      channel.toggleBtn = toggleBtn;
      channel.freqSlider = freqSlider;
      channel.freqNumber = freqNumber;
      channel.freqValue = freqValue;
      channel.phaseSlider = phaseSlider;
      channel.phaseValue = phaseValue;
      channel.canvas = canvas;
      channel.ctx = ctx;

      freqSlider.addEventListener('input', () => {
        applyFrequency(channel, parseFloat(freqSlider.value));
      });

      freqNumber.addEventListener('change', () => {
        const raw = parseFloat(freqNumber.value);
        applyFrequency(channel, Number.isFinite(raw) ? raw : channel.frequency);
      });

      phaseSlider.addEventListener('input', () => {
        setChannelPhaseOffsetRelativeToReference(channel, parseFloat(phaseSlider.value));
      });

      toggleBtn.addEventListener('click', () => {
        toggleChannel(channel.id);
      });

      removeBtn.addEventListener('click', () => {
        removeChannel(channel.id);
      });

      channels.push(channel);

      resizeCanvas(canvas);
      refreshChannelTitles();
      syncPhaseOffsetsToReference();
      syncChannelUi(channel);
      refreshSummary();
      return true;
    }

    async function setAllChannelsPlaying(targetPlaying) {
      if (channels.length === 0) {
        return;
      }

      const ready = await ensureAudioContext();
      if (!ready) {
        setAudioBlockedHint();
        return;
      }
      setAudioReadyHint();
      channels.forEach((channel) => {
        channel.isPlaying = targetPlaying;
        setGain(channel.gainNode, targetPlaying ? 1 : 0);
        syncChannelUi(channel);
      });

      refreshSummary();
    }

    async function toggleCombined() {
      if (channels.length === 0) {
        return;
      }

      if (!combinedPlaying) {
        const ready = await ensureAudioContext();
        if (!ready) {
          setAudioBlockedHint();
          syncCombinedUi();
          return;
        }
        setAudioReadyHint();
      }

      combinedPlaying = !combinedPlaying;
      setGain(combinedGain, combinedPlaying ? 1 : 0);
      syncCombinedUi();
      channels.forEach((channel) => {
        syncChannelUi(channel);
      });
    }

    function draw(timestamp) {
      requestAnimationFrame(draw);

      if (lastFrameTime === null) {
        lastFrameTime = timestamp;
        return;
      }

      const deltaSeconds = Math.min((timestamp - lastFrameTime) / 1000, 0.1);
      lastFrameTime = timestamp;

      if (combinedPlaying) {
        const step = deltaSeconds * timeScale;
        channels.forEach((channel) => {
          if (channel.isPlaying) {
            channel.waveTime += step;
          }
        });
      }

      const colors = getThemeColors();
      channels.forEach((channel) => {
        drawChannelWave(channel, colors);
      });
      drawCombinedWave(colors);
    }

    function resizeCanvas(canvas) {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width));
      const height = Math.max(1, Math.floor(rect.height));

      if (canvas.width !== width) {
        canvas.width = width;
      }
      if (canvas.height !== height) {
        canvas.height = height;
      }
    }

    function debounce(fn, waitMs) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          fn(...args);
        }, waitMs);
      };
    }

    addChannelBtn.addEventListener('click', async () => {
      const ready = await ensureAudioContext();
      if (!ready) {
        setAudioBlockedHint();
        return;
      }
      setAudioReadyHint();
      addChannel({ frequency: 440, isPlaying: true });
    });

    playAllBtn.addEventListener('click', async () => {
      await setAllChannelsPlaying(true);
    });

    pauseAllBtn.addEventListener('click', async () => {
      await setAllChannelsPlaying(false);
    });

    toggleCombinedBtn.addEventListener('click', async () => {
      await toggleCombined();
    });

    volumeSlider.addEventListener('input', () => {
      const volume = parseFloat(volumeSlider.value);
      setGain(volumeGain, volume);
      updateControlReadouts();
    });

    panningSlider.addEventListener('input', () => {
      if (!stereoPanner) {
        panningSlider.value = '0';
        updateControlReadouts();
        return;
      }
      let pan = parseFloat(panningSlider.value);
      if (Math.abs(pan) < 0.05) {
        pan = 0;
        panningSlider.value = '0';
      }
      stereoPanner.pan.setValueAtTime(pan, audioCtx.currentTime);
      updateControlReadouts();
    });

    timeScaleSlider.addEventListener('input', () => {
      const sliderValue = parseFloat(timeScaleSlider.value);
      timeScale = Math.pow(10, sliderValue);
      updateControlReadouts();
    });

    zoomScaleSlider.addEventListener('input', () => {
      zoomScale = parseFloat(zoomScaleSlider.value);
      updateControlReadouts();
    });

    document.addEventListener('keydown', (event) => {
      if (event.code !== 'Space') {
        return;
      }
      const targetTag = event.target && event.target.tagName ? event.target.tagName.toUpperCase() : '';
      if (INTERACTIVE_TAGS.has(targetTag)) {
        return;
      }
      event.preventDefault();
      toggleCombined();
    });

    const unlockAudio = () => {
      ensureAudioContext().then((ready) => {
        if (ready) {
          setAudioReadyHint();
        }
      });
    };
    window.addEventListener('pointerdown', unlockAudio, { passive: true });
    window.addEventListener('keydown', unlockAudio);

    window.addEventListener('resize', debounce(() => {
      resizeCanvas(combinedCanvas);
      channels.forEach((channel) => {
        resizeCanvas(channel.canvas);
      });
    }, 180));

    resizeCanvas(combinedCanvas);
    updateControlReadouts();
    syncCombinedUi();
    renderEmptyState();
    addChannel({ frequency: 440, isPlaying: true });
    requestAnimationFrame(draw);
    })();
  </script>
</body>

</html>
