<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#f8f9fa">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <script>
    (function() {
      var hasDarkPreference = false;
      try {
        hasDarkPreference = Boolean(localStorage.getItem('tone-generator-dark'));
      } catch (_) {
        hasDarkPreference = false;
      }

      if (hasDarkPreference) {
        document.documentElement.setAttribute('data-theme', 'dark');
        var tc = document.querySelector('meta[name="theme-color"]');
        var sb = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (tc) tc.setAttribute('content', '#0f1014');
        if (sb) sb.setAttribute('content', 'black-translucent');
      }
    })();
    </script>
  <title>Two-Channel Tone Generator</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <script src="/assets/sw-register.js" defer></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;

      --bg-color: #f8f9fa;
      --bg-pattern: #e9ecef;
      --text-main: #2d3436;
      --text-secondary: #636e72;

      --brand-primary: #6c5ce7;
      --brand-secondary: #a29bfe;
      --brand-accent: #00cec9;
      --danger: #d92d20;

      --surface: #ffffff;
      --surface-alt: #f1f5f9;
      --border: #e2e8f0;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.08);
      --canvas-bg: #ffffff;

      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5b4cdb;
      --btn-text: #ffffff;

      --nav-bg: rgba(255, 255, 255, 0.85);
      --nav-border: rgba(255, 255, 255, 0.5);

      --slider-track: #e2e8f0;
      --slider-thumb: #6c5ce7;
      --toggle-hover: rgba(108, 92, 231, 0.15);

      --channel-line: #1d9bf0;
      --channel-line-paused: #7ea8c7;
      --combined-line: #ef4444;
      --combined-line-paused: #c58888;
      --axis-line: #d8e2f4;
      --paused-overlay: rgba(253, 253, 255, 0.5);
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;

      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;
      --danger: #ff7870;

      --surface: #1e2129;
      --surface-alt: #17191f;
      --border: #2d3436;
      --shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
      --canvas-bg: #1e1e1e;

      --btn-primary: #6c5ce7;
      --btn-primary-hover: #5849d6;
      --btn-text: #ffffff;

      --nav-bg: rgba(22, 24, 29, 0.85);
      --nav-border: rgba(255, 255, 255, 0.08);

      --slider-track: #4a5568;
      --slider-thumb: #a29bfe;
      --toggle-hover: rgba(162, 155, 254, 0.2);

      --channel-line: #6cc8ff;
      --channel-line-paused: #4f6f8d;
      --combined-line: #ff6f82;
      --combined-line-paused: #96656d;
      --axis-line: #27344a;
      --paused-overlay: rgba(7, 11, 18, 0.42);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-sans);
      color: var(--text-main);
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 30px 30px;
      overflow: hidden;
    }

    a {
      color: var(--brand-primary);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      padding: 0;
    }

    #titleBanner {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 16px;
      width: calc(100% - 40px);
      max-width: 1360px;
      margin: 16px auto 0;
      background: var(--nav-bg);
      border: 1px solid var(--nav-border);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      min-height: 58px;
      padding: 8px 20px;
    }

    .banner-logo img {
      width: auto;
      height: 36px;
      display: block;
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
    }

    .banner-title {
      margin: 0;
      text-align: center;
      font-family: var(--font-display);
      font-size: 1.6rem;
      font-weight: 800;
      letter-spacing: -0.5px;
      color: var(--brand-primary);
    }

    .banner-title.gradient-text {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .banner-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 12px;
    }

    #theme-button {
      background: transparent;
      border: none;
      color: var(--text-main);
      border-radius: 50%;
      font-size: 1.2rem;
      line-height: 1;
      min-height: 42px;
      min-width: 42px;
      padding: 0.5rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }

    #theme-button:hover {
      background-color: var(--toggle-hover);
      transform: rotate(15deg);
    }

    #theme-button:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    #workspace {
      min-height: 0;
      flex: 1;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.9rem;
      width: calc(100% - 40px);
      max-width: 1360px;
      margin: 0 auto;
      padding-bottom: 0.75rem;
    }

    #transportPanel,
    #channelsPanel {
      min-height: 0;
    }

    #transportPanel {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    #combinedCard {
      display: grid;
      grid-template-rows: auto minmax(0, 1fr) auto;
      min-height: 0;
      flex: 1 1 auto;
    }

    .panel,
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
    }

    .card {
      padding: 0.9rem;
    }

    .transport-header {
      display: flex;
      justify-content: space-between;
      gap: 0.7rem;
      align-items: flex-start;
      margin-bottom: 0.65rem;
    }

    .eyebrow {
      margin: 0;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.11em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .transport-meta {
      margin-top: 0.32rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    #activeSummary {
      margin: 0;
      font-size: 0.82rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    #combinedCanvas {
      display: block;
      width: 100%;
      height: 100%;
      min-height: 0;
      background: var(--canvas-bg);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    #transportHint {
      margin: 0.5rem 0 0;
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 28px;
      padding: 0 0.65rem;
      border-radius: 999px;
      font-size: 0.74rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      border: 1px solid transparent;
      user-select: none;
    }

    .channel-card .status-chip {
      min-width: 72px;
      text-align: center;
    }

    .status-chip.playing {
      background: rgba(14, 165, 233, 0.15);
      border-color: rgba(14, 165, 233, 0.28);
      color: #0075b1;
    }

    [data-theme="dark"] .status-chip.playing {
      color: #9ddfff;
    }

    .status-chip.armed {
      background: rgba(249, 115, 22, 0.14);
      border-color: rgba(249, 115, 22, 0.3);
      color: #b45309;
    }

    [data-theme="dark"] .status-chip.armed {
      color: #ffc58f;
    }

    .status-chip.paused {
      background: rgba(127, 138, 162, 0.14);
      border-color: rgba(127, 138, 162, 0.3);
      color: #63708a;
    }

    [data-theme="dark"] .status-chip.paused {
      color: #b4bfd6;
    }

    .btn {
      border: 1px solid transparent;
      border-radius: 12px;
      min-height: 46px;
      padding: 0.55rem 0.95rem;
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.16s ease, filter 0.16s ease, border-color 0.16s ease;
      white-space: normal;
      overflow-wrap: anywhere;
      line-height: 1.2;
      text-align: center;
    }

    .btn:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.02);
    }

    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      transform: none;
      filter: none;
    }

    .btn-primary {
      background: var(--btn-primary);
      color: var(--btn-text);
      min-width: 128px;
    }

    .btn-primary:hover {
      background: var(--btn-primary-hover);
    }

    .btn-secondary {
      background: var(--surface-alt);
      color: var(--text-main);
      border-color: var(--border);
    }

    .btn-danger {
      background: rgba(217, 45, 32, 0.11);
      color: var(--danger);
      border-color: rgba(217, 45, 32, 0.24);
    }

    .btn-small {
      min-height: 40px;
      padding: 0.45rem 0.7rem;
      border-radius: 10px;
      font-size: 0.82rem;
    }

    #controlsCard {
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.8rem;
    }

    .control-block {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .control-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.4rem;
    }

    .control-header label {
      font-size: 0.79rem;
      font-weight: 700;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-header span {
      font-family: var(--font-mono);
      font-size: 0.78rem;
      color: var(--text-main);
    }

    input[type="range"] {
      width: 100%;
      height: 32px;
      background: transparent;
      cursor: pointer;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]:focus-visible {
      outline: none;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      margin-top: -6px;
      border-radius: 50%;
      border: none;
      background: var(--slider-thumb);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 5px;
      background: var(--slider-track);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: none;
      background: var(--slider-thumb);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    #channelsPanel {
      display: flex;
      flex-direction: column;
      padding: 0.95rem;
      overflow: hidden;
    }

    .channels-header {
      margin-bottom: 0.6rem;
    }

    .channels-header h2 {
      margin: 0;
      font-family: var(--font-display);
      font-size: 1.06rem;
      letter-spacing: -0.01em;
    }

    .channels-header p {
      margin: 0.2rem 0 0;
      color: var(--text-secondary);
      font-size: 0.86rem;
    }

    #channelsList {
      min-height: 0;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
      padding-right: 0.4rem;
    }

    #channelsList[data-channel-count="1"],
    #channelsList[data-channel-count="2"] {
      display: grid;
      grid-template-rows: repeat(2, minmax(0, 1fr));
      align-content: stretch;
      overflow: hidden;
      min-height: 0;
    }

    #channelsList[data-channel-count="1"] #addChannelSlot,
    #channelsList[data-channel-count="2"] #addChannelSlot {
      min-height: 0;
      height: 100%;
    }

    #channelsList[data-channel-count="1"] .channel-card,
    #channelsList[data-channel-count="2"] .channel-card {
      min-height: 0;
      height: 100%;
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr);
      overflow: hidden;
    }

    #channelsList[data-channel-count="1"] .channel-canvas,
    #channelsList[data-channel-count="2"] .channel-canvas {
      height: 100%;
      min-height: 0;
    }

    #addChannelSlot {
      min-height: 0;
      border: 1px dashed var(--border);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.32);
    }

    [data-theme="dark"] #addChannelSlot {
      background: rgba(9, 12, 18, 0.35);
    }

    #addChannelSlot .btn {
      width: min(220px, 100%);
    }

    .channel-card {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 0.62rem;
      display: grid;
      gap: 0.48rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .channel-card[data-state="playing"] {
      border-color: rgba(14, 165, 233, 0.45);
      box-shadow: 0 0 0 1px rgba(14, 165, 233, 0.16);
    }

    .channel-card[data-state="armed"] {
      border-color: rgba(249, 115, 22, 0.42);
      box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.15);
    }

    .channel-header {
      display: flex;
      justify-content: space-between;
      gap: 0.6rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .channel-title-wrap {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      min-height: 34px;
    }

    .channel-title {
      margin: 0;
      font-size: 0.98rem;
    }

    .phase-toggle-inline {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      margin-left: 0.25rem;
    }

    .phase-toggle-switch {
      position: relative;
      display: inline-block;
      width: 42px;
      height: 20px;
      flex: 0 0 auto;
    }

    .phase-toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
      margin: 0;
    }

    .phase-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #cfd5df;
      transition: 0.3s ease;
      border-radius: 20px;
    }

    [data-theme="dark"] .phase-toggle-slider {
      background-color: #4b5563;
    }

    .phase-toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: #fff;
      transition: 0.3s ease;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .phase-toggle-switch input:checked + .phase-toggle-slider {
      background-color: var(--brand-accent);
    }

    [data-theme="dark"] .phase-toggle-switch input:checked + .phase-toggle-slider {
      background-color: #53c7c8;
    }

    .phase-toggle-switch input:checked + .phase-toggle-slider:before {
      transform: translateX(22px);
    }

    .phase-toggle-switch input:disabled + .phase-toggle-slider {
      cursor: not-allowed;
      opacity: 0.65;
    }

    .phase-toggle-text {
      min-width: 70px;
      font-size: 0.76rem;
      color: var(--text-secondary);
      font-family: var(--font-mono);
      font-weight: 600;
      user-select: none;
    }

    .channel-actions {
      display: inline-flex;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .channel-actions .btn {
      min-width: 0;
    }

    .frequency-row {
      display: grid;
      grid-template-columns: auto 88px minmax(0, 1fr);
      align-items: center;
      gap: 0.5rem;
    }

    .freq-label {
      font-size: 0.79rem;
      color: var(--text-secondary);
      font-weight: 600;
      white-space: nowrap;
    }

    .freq-number {
      width: 88px;
      min-height: 36px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--canvas-bg);
      color: var(--text-main);
      font-family: var(--font-mono);
      font-size: 0.86rem;
      padding: 0.35rem 0.5rem;
    }

    .freq-number:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .channel-canvas {
      width: 100%;
      height: 108px;
      display: block;
      background: var(--canvas-bg);
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    #emptyState {
      border: 1px dashed var(--border);
      border-radius: 12px;
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.36);
      text-align: center;
      padding: 1rem;
      font-size: 0.89rem;
      font-weight: 600;
    }

    [data-theme="dark"] #emptyState {
      background: rgba(9, 12, 18, 0.4);
    }

    footer {
      flex: 0 0 auto;
      text-align: center;
      font-size: 0.9rem;
      color: var(--text-secondary);
      padding: 0.5rem 1rem;
    }

    @media (pointer: coarse) {
      .btn,
      .btn-small,
      .freq-number,
      #theme-button {
        min-height: 48px;
      }

      #theme-button {
        min-width: 48px;
      }

      input[type="range"] {
        height: 40px;
      }

      input[type="range"]::-webkit-slider-thumb {
        width: 22px;
        height: 22px;
        margin-top: -8px;
      }

      input[type="range"]::-moz-range-thumb {
        width: 22px;
        height: 22px;
      }
    }

    @media (max-width: 1050px) {
      body {
        overflow: auto;
      }

      #app {
        height: auto;
        min-height: 100%;
      }

      #workspace {
        grid-template-columns: 1fr;
      }

      #transportPanel {
        order: 1;
      }

      #channelsPanel {
        order: 2;
        min-height: 52vh;
      }

      #combinedCard {
        flex: 0 0 auto;
      }

      #combinedCanvas {
        height: 220px;
        min-height: 0;
      }

      #channelsList[data-channel-count="1"],
      #channelsList[data-channel-count="2"] {
        display: flex;
        overflow-y: auto;
      }

      #channelsList[data-channel-count="1"] .channel-card,
      #channelsList[data-channel-count="2"] .channel-card {
        height: auto;
        flex: 0 0 auto;
        grid-template-rows: none;
      }

      #channelsList[data-channel-count="1"] .channel-canvas,
      #channelsList[data-channel-count="2"] .channel-canvas {
        height: 108px;
        min-height: 0;
      }

      .control-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      #titleBanner {
        width: calc(100% - 24px);
        margin: 12px auto 0;
        min-height: 52px;
        border-radius: 18px;
        padding: 8px 12px;
      }

      #workspace {
        width: calc(100% - 24px);
      }

      .banner-logo img {
        height: 28px;
      }

      .banner-title {
        font-size: 1rem;
      }

      #theme-button {
        min-width: 40px;
        min-height: 40px;
        font-size: 1.05rem;
        padding: 0.45rem;
      }

      .transport-header {
        flex-direction: column;
        align-items: stretch;
      }

      .btn-primary {
        width: 100%;
      }

      .channel-actions {
        width: 100%;
      }

      .channel-actions .btn-small {
        flex: 1;
      }

      .frequency-row {
        grid-template-columns: auto 82px minmax(0, 1fr);
        gap: 0.4rem;
      }

      #addChannelSlot {
        min-height: 84px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <header id="titleBanner">
      <div class="banner-logo">
        <a href="https://panphy.github.io/">
          <img src="/assets/panphy.png" alt="PanPhy logo">
        </a>
      </div>
      <h1 class="banner-title">Tone Mixer Lab</h1>
      <div class="banner-actions">
        <div class="theme-toggle">
          <button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">&#9728;&#65039;</button>
        </div>
      </div>
    </header>

    <main id="workspace">
      <section id="transportPanel">
        <div class="card" id="combinedCard">
          <div class="transport-header">
            <div>
              <p class="eyebrow">Combined Output</p>
              <div class="transport-meta">
                <span id="combinedStateChip" class="status-chip paused">Paused</span>
                <p id="activeSummary">0 active / 0 channels</p>
              </div>
            </div>
            <button id="toggleCombinedBtn" class="btn btn-primary" disabled>Play Combined</button>
          </div>
          <canvas id="combinedCanvas"></canvas>
          <p id="transportHint">Space key toggles combined play/pause.</p>
        </div>

        <div class="card" id="controlsCard">
          <div class="control-grid">
            <div class="control-block">
              <div class="control-header">
                <label for="volumeSlider">Volume</label>
                <span id="volumeValue">100%</span>
              </div>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="panningSlider">L/R Pan</label>
                <span id="panningValue">0.00</span>
              </div>
              <input type="range" id="panningSlider" min="-1" max="1" step="0.01" value="0">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="timeScaleSlider">Animation Speed</label>
                <span id="timeScaleValue">1.000x</span>
              </div>
              <input type="range" id="timeScaleSlider" min="-3" max="1" step="0.01" value="0">
            </div>

            <div class="control-block">
              <div class="control-header">
                <label for="zoomScaleSlider">Wave Zoom</label>
                <span id="zoomScaleValue">1.00x</span>
              </div>
              <input type="range" id="zoomScaleSlider" min="0.01" max="50" step="0.01" value="1">
            </div>
          </div>

        </div>
      </section>

      <section id="channelsPanel" class="panel">
        <div class="channels-header">
          <h2>Channel Mixer</h2>
          <p>Use up to two channels. Channel 2 can be switched in-phase or anti-phase relative to Channel 1.</p>
        </div>
        <div id="channelsList">
          <div id="addChannelSlot">
            <button id="addChannelBtn" class="btn btn-primary">Add Channel</button>
          </div>
        </div>
      </section>
    </main>

    <footer>
      &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
      <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
    </footer>
  </div>

  <script>
    // Gradient text: skip on Brave iOS where background-clip:text is broken
    (function () {
      if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
      document.querySelectorAll('.banner-title').forEach(function (el) {
        el.classList.add('gradient-text');
      });
    })();

    // Theme Toggle
    const themeButton = document.getElementById('theme-button');
    const DARK_THEME_KEY = 'tone-generator-dark';
    const LIGHT_THEME_KEY = 'tone-generator-light';
    function safeStorageGet(key) {
      try {
        return localStorage.getItem(key);
      } catch (_) {
        return null;
      }
    }
    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (_) {
        // Ignore storage errors so theme toggle still works for this session.
      }
    }
    function safeStorageRemove(key) {
      try {
        localStorage.removeItem(key);
      } catch (_) {
        // Ignore storage errors so theme toggle still works for this session.
      }
    }

    const currentTheme = safeStorageGet(DARK_THEME_KEY)
      ? 'dark'
      : safeStorageGet(LIGHT_THEME_KEY)
        ? 'light'
        : 'light';

    document.documentElement.setAttribute('data-theme', currentTheme);
    updateAppChromeTheme(currentTheme);
    updateButtonEmoji(currentTheme);

    function updateAppChromeTheme(theme) {
      const themeColorMeta = document.querySelector('meta[name="theme-color"]');
      const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      const isDarkTheme = theme === 'dark';

      if (themeColorMeta) {
        themeColorMeta.setAttribute('content', isDarkTheme ? '#0f1014' : '#f8f9fa');
      }

      if (appleStatusBarMeta) {
        appleStatusBarMeta.setAttribute('content', isDarkTheme ? 'black-translucent' : 'default');
      }
    }

    window.addEventListener('pageshow', function () {
      updateAppChromeTheme(document.documentElement.getAttribute('data-theme'));
    });

    function updateButtonEmoji(theme) {
      themeButton.textContent = theme === 'dark' ? '\u{1F319}' : '\u{2600}\u{FE0F}';
    }

    themeButton.addEventListener('click', function () {
      let theme = document.documentElement.getAttribute('data-theme');
      if (theme === 'light') {
        document.documentElement.setAttribute('data-theme', 'dark');
        safeStorageSet(DARK_THEME_KEY, 'true');
        safeStorageRemove(LIGHT_THEME_KEY);
        updateAppChromeTheme('dark');
        updateButtonEmoji('dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        safeStorageSet(LIGHT_THEME_KEY, 'true');
        safeStorageRemove(DARK_THEME_KEY);
        updateAppChromeTheme('light');
        updateButtonEmoji('light');
      }
    });
  </script>

  <script>
    (function () {
    const addChannelBtn = document.getElementById('addChannelBtn');
    const addChannelSlot = document.getElementById('addChannelSlot');
    const channelsList = document.getElementById('channelsList');

    const combinedCanvas = document.getElementById('combinedCanvas');
    const combinedCtx = combinedCanvas.getContext('2d');
    const toggleCombinedBtn = document.getElementById('toggleCombinedBtn');
    const combinedStateChip = document.getElementById('combinedStateChip');
    const activeSummary = document.getElementById('activeSummary');

    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');

    const panningSlider = document.getElementById('panningSlider');
    const panningValue = document.getElementById('panningValue');

    const timeScaleSlider = document.getElementById('timeScaleSlider');
    const timeScaleValue = document.getElementById('timeScaleValue');

    const zoomScaleSlider = document.getElementById('zoomScaleSlider');
    const zoomScaleValue = document.getElementById('zoomScaleValue');
    const transportHint = document.getElementById('transportHint');

    const DEFAULT_TRANSPORT_HINT = 'Space key toggles combined play/pause.';
    const AUDIO_BLOCKED_HINT = 'Tap or click to enable audio, then try again.';
    const AUDIO_UNAVAILABLE_HINT = 'Audio output is unavailable in this browser.';

    function setAudioUnavailableState(message) {
      if (transportHint) {
        transportHint.textContent = message || AUDIO_UNAVAILABLE_HINT;
      }
      if (combinedStateChip) {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'Unavailable';
      }
      if (activeSummary) {
        activeSummary.textContent = 'Audio unavailable';
      }
      [
        addChannelBtn,
        toggleCombinedBtn,
        volumeSlider,
        panningSlider,
        timeScaleSlider,
        zoomScaleSlider
      ].forEach((control) => {
        if (control) {
          control.disabled = true;
        }
      });
    }

    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    if (AudioContextClass) {
      try {
        audioCtx = new AudioContextClass({ latencyHint: 'interactive' });
      } catch (_) {
        try {
          audioCtx = new AudioContextClass();
        } catch (_) {
          audioCtx = null;
        }
      }
    }

    if (!audioCtx) {
      setAudioUnavailableState(AUDIO_UNAVAILABLE_HINT);
      return;
    }

    const channelBus = audioCtx.createGain();
    channelBus.gain.value = 1;

    const volumeGain = audioCtx.createGain();
    volumeGain.gain.value = 1;

    const combinedGain = audioCtx.createGain();
    combinedGain.gain.value = 0;

    const isAppleTouchDevice = /iPad|iPhone|iPod/.test(navigator.userAgent)
      || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    let stereoPanner = null;
    if (!isAppleTouchDevice && typeof audioCtx.createStereoPanner === 'function') {
      try {
        stereoPanner = audioCtx.createStereoPanner();
      } catch (_) {
        stereoPanner = null;
      }
    }
    const supportsStereoPanner = Boolean(stereoPanner);

    channelBus.connect(volumeGain);
    volumeGain.connect(combinedGain);
    if (stereoPanner) {
      combinedGain.connect(stereoPanner);
      stereoPanner.connect(audioCtx.destination);
    } else {
      combinedGain.connect(audioCtx.destination);
      if (panningSlider) {
        panningSlider.disabled = true;
      }
      if (panningValue) {
        panningValue.textContent = 'N/A';
      }
    }

    const MIN_FREQUENCY_HZ = 15;
    const MAX_FREQUENCY_HZ = Math.max(
      MIN_FREQUENCY_HZ,
      Math.min(23000, Math.floor(audioCtx.sampleRate / 2) - 1)
    );
    const MAX_CHANNELS = 2;

    const channels = [];
    let nextChannelId = 1;
    let combinedPlaying = false;
    let timeScale = Math.pow(10, parseFloat(timeScaleSlider.value));
    let zoomScale = parseFloat(zoomScaleSlider.value);
    let lastFrameTime = null;

    const BASE_WINDOW = 0.01;
    const INTERACTIVE_TAGS = new Set(['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON']);
    const PHASE_MODE_IN = 'in';
    const PHASE_MODE_ANTI = 'anti';

    let audioPrimed = false;

    function stopAndDisconnectOscillator(oscillator, stopTime = audioCtx.currentTime) {
      if (!oscillator) return;
      try {
        oscillator.stop(stopTime);
      } catch (_) {
        // Ignore already-stopped oscillator errors.
      }
      try {
        oscillator.disconnect();
      } catch (_) {
        // Ignore disconnect errors if already disconnected.
      }
    }

    function createChannelOscillator(channel, startTime) {
      const oscillator = audioCtx.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(channel.frequency, startTime);
      oscillator.connect(channel.gainNode);
      oscillator.start(startTime);
      return oscillator;
    }

    function primeAudioContext() {
      if (audioPrimed) return;
      try {
        const source = audioCtx.createBufferSource();
        source.buffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
        source.connect(audioCtx.destination);
        source.start(audioCtx.currentTime);
        source.stop(audioCtx.currentTime + 0.001);
        audioPrimed = true;
      } catch (_) {
        // If priming fails, keep going and let normal playback path handle it.
      }
    }

    function getPhaseOffsetForMode(mode) {
      return mode === PHASE_MODE_ANTI ? Math.PI : 0;
    }

    function getChannelOutputGain(channel) {
      if (!channel || !channel.isPlaying) return 0;
      return channel.phaseMode === PHASE_MODE_ANTI ? -1 : 1;
    }

    function setChannelOutputGain(channel) {
      if (!channel || !channel.gainNode) return;
      setGain(channel.gainNode, getChannelOutputGain(channel));
    }

    function updateChannelPhaseToggle(channel, isReference) {
      if (!channel || !channel.phaseToggle || !channel.phaseToggleText || !channel.phaseToggleInline) return;

      const isSecondChannel = channels[1] === channel;
      channel.phaseToggleInline.style.display = isSecondChannel ? 'inline-flex' : 'none';

      if (!isSecondChannel) {
        channel.phaseToggle.checked = false;
        channel.phaseToggle.disabled = true;
        channel.phaseToggle.title = isReference
          ? 'Reference channel (fixed in-phase)'
          : 'Phase toggle is only available for Channel 2';
        channel.phaseToggleText.textContent = 'in-phase';
        return;
      }

      const isAntiPhase = channel.phaseMode === PHASE_MODE_ANTI;
      channel.phaseToggle.checked = isAntiPhase;
      channel.phaseToggle.disabled = false;
      channel.phaseToggle.title = 'Toggle in-phase / anti-phase relative to Channel 1';
      channel.phaseToggleText.textContent = isAntiPhase ? 'anti-phase' : 'in-phase';
    }

    function resyncRunningOscillators() {
      if (audioCtx.state !== 'running' || channels.length === 0) return;

      const now = audioCtx.currentTime;
      const startAt = now + 0.012;
      const oldOscillators = channels.map((channel) => channel.oscillator || null);

      channels.forEach((channel) => {
        channel.oscillator = createChannelOscillator(channel, startAt);
      });

      channels.forEach((channel) => {
        const targetGain = getChannelOutputGain(channel);
        try {
          channel.gainNode.gain.cancelScheduledValues(now);
          channel.gainNode.gain.setValueAtTime(channel.gainNode.gain.value, now);
          channel.gainNode.gain.setValueAtTime(channel.gainNode.gain.value, startAt);
          channel.gainNode.gain.linearRampToValueAtTime(targetGain, startAt + 0.008);
        } catch (_) {
          channel.gainNode.gain.setValueAtTime(targetGain, now);
        }
      });

      oldOscillators.forEach((oscillator) => {
        stopAndDisconnectOscillator(oscillator, startAt + 0.02);
      });
    }

    function syncPhaseModesToReference(options = {}) {
      if (channels.length === 0) return;
      const shouldResyncAudio = options.resyncAudio !== false;

      const referenceChannel = channels[0];
      referenceChannel.phaseMode = PHASE_MODE_IN;
      referenceChannel.phaseOffsetRad = 0;
      updateChannelPhaseToggle(referenceChannel, true);
      setChannelOutputGain(referenceChannel);

      for (let i = 1; i < channels.length; i += 1) {
        const channel = channels[i];
        channel.phaseMode = channel.phaseMode === PHASE_MODE_ANTI ? PHASE_MODE_ANTI : PHASE_MODE_IN;
        channel.phaseOffsetRad = getPhaseOffsetForMode(channel.phaseMode);
        updateChannelPhaseToggle(channel, false);
        setChannelOutputGain(channel);
      }

      if (shouldResyncAudio) {
        resyncRunningOscillators();
      }
    }

    function setChannelPhaseModeRelativeToReference(channel, mode) {
      if (!channel) return;
      const referenceChannel = channels[0] || null;
      if (!referenceChannel || channel === referenceChannel) {
        channel.phaseMode = PHASE_MODE_IN;
        channel.phaseOffsetRad = 0;
        updateChannelPhaseToggle(channel, true);
        setChannelOutputGain(channel);
        return;
      }

      channel.phaseMode = mode === PHASE_MODE_ANTI ? PHASE_MODE_ANTI : PHASE_MODE_IN;
      channel.phaseOffsetRad = getPhaseOffsetForMode(channel.phaseMode);
      updateChannelPhaseToggle(channel, false);
      setChannelOutputGain(channel);
      resyncRunningOscillators();
    }

    function setAudioBlockedHint() {
      if (transportHint) {
        transportHint.textContent = AUDIO_BLOCKED_HINT;
      }
    }

    function setAudioReadyHint() {
      if (transportHint) {
        transportHint.textContent = DEFAULT_TRANSPORT_HINT;
      }
    }

    async function ensureAudioContext() {
      if (audioCtx.state === 'running') {
        primeAudioContext();
        if (channels.some((channel) => !channel.oscillator)) {
          syncPhaseModesToReference();
        }
        return true;
      }

      try {
        await audioCtx.resume();
      } catch (_) {
        // Retry once; iPad Safari can transiently reject the first resume attempt.
      }
      if (audioCtx.state !== 'running') {
        try {
          await audioCtx.resume();
        } catch (_) {
          // Ignore and report blocked state below.
        }
      }
      const running = audioCtx.state === 'running';
      if (running) {
        primeAudioContext();
        syncPhaseModesToReference();
      }
      return running;
    }

    function setGain(node, targetValue) {
      const now = audioCtx.currentTime;
      let heldCurrentValue = false;
      if (typeof node.gain.cancelAndHoldAtTime === 'function') {
        try {
          node.gain.cancelAndHoldAtTime(now);
          heldCurrentValue = true;
        } catch (_) {
          heldCurrentValue = false;
        }
      }
      if (!heldCurrentValue) {
        const currentValue = node.gain.value;
        node.gain.cancelScheduledValues(now);
        node.gain.setValueAtTime(currentValue, now);
      }
      try {
        node.gain.linearRampToValueAtTime(targetValue, now + 0.012);
      } catch (_) {
        node.gain.setValueAtTime(targetValue, now);
      }
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function getCssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function getThemeColors() {
      return {
        canvasBg: getCssVar('--canvas-bg'),
        axisLine: getCssVar('--axis-line'),
        textMuted: getCssVar('--text-secondary'),
        pausedOverlay: getCssVar('--paused-overlay'),
        channelLine: getCssVar('--channel-line'),
        channelLinePaused: getCssVar('--channel-line-paused'),
        combinedLine: getCssVar('--combined-line'),
        combinedLinePaused: getCssVar('--combined-line-paused')
      };
    }

    function updateControlReadouts() {
      const volumePercent = Math.round(parseFloat(volumeSlider.value) * 100);
      volumeValue.textContent = `${volumePercent}%`;

      if (stereoPanner) {
        const pan = parseFloat(panningSlider.value);
        panningValue.textContent = pan.toFixed(2);
      } else {
        panningValue.textContent = 'N/A';
      }

      timeScaleValue.textContent = `${timeScale.toFixed(3)}x`;
      zoomScaleValue.textContent = `${zoomScale.toFixed(2)}x`;
    }

    function drawCenterAxis(ctx, width, height, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawWavePath(ctx, width, height, frequency, waveTime, timeWindow, phaseOffset, color) {
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;

      for (let x = 0; x < width; x += 1) {
        const fraction = x / (width - 1 || 1);
        const t = waveTime - fraction * timeWindow;
        const sample = Math.sin(2 * Math.PI * frequency * t + phaseOffset);
        const y = (sample * 0.5 + 0.5) * height;
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }

      ctx.stroke();
    }

    function drawChannelWave(channel, colors) {
      const ctx = channel.ctx;
      const canvas = channel.canvas;
      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = colors.canvasBg;
      ctx.fillRect(0, 0, width, height);
      drawCenterAxis(ctx, width, height, colors.axisLine);

      const timeWindow = BASE_WINDOW * zoomScale;
      const animated = combinedPlaying && channel.isPlaying;
      drawWavePath(
        ctx,
        width,
        height,
        channel.frequency,
        channel.waveTime,
        timeWindow,
        channel.phaseOffsetRad || 0,
        animated ? colors.channelLine : colors.channelLinePaused
      );

      if (!animated) {
        ctx.fillStyle = colors.pausedOverlay;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = colors.textMuted;
        ctx.font = '12px "JetBrains Mono", monospace';
        ctx.textAlign = 'right';
        ctx.fillText(channel.isPlaying ? 'Armed' : 'Paused', width - 10, 16);
      }
    }

    function drawCombinedWave(colors) {
      const width = combinedCanvas.width;
      const height = combinedCanvas.height;

      combinedCtx.fillStyle = colors.canvasBg;
      combinedCtx.fillRect(0, 0, width, height);
      drawCenterAxis(combinedCtx, width, height, colors.axisLine);

      const activeChannels = channels.filter((channel) => channel.isPlaying);
      if (activeChannels.length === 0) {
        combinedCtx.fillStyle = colors.textMuted;
        combinedCtx.textAlign = 'center';
        combinedCtx.font = '13px "JetBrains Mono", monospace';
        combinedCtx.fillText('No active channels', width / 2, height / 2 - 8);
        combinedCtx.fillText('Press Play on a channel to add it to the mix', width / 2, height / 2 + 14);
        return;
      }

      const timeWindow = BASE_WINDOW * zoomScale;
      combinedCtx.beginPath();
      combinedCtx.lineWidth = 2.25;
      combinedCtx.strokeStyle = combinedPlaying ? colors.combinedLine : colors.combinedLinePaused;

      const ampScale = activeChannels.length;

      for (let x = 0; x < width; x += 1) {
        const fraction = x / (width - 1 || 1);
        let sampleSum = 0;

        for (const channel of activeChannels) {
          const t = channel.waveTime - fraction * timeWindow;
          sampleSum += Math.sin(2 * Math.PI * channel.frequency * t + (channel.phaseOffsetRad || 0));
        }

        const y = (sampleSum / ampScale * 0.5 + 0.5) * height;

        if (x === 0) {
          combinedCtx.moveTo(x, y);
        } else {
          combinedCtx.lineTo(x, y);
        }
      }

      combinedCtx.stroke();

      if (!combinedPlaying) {
        combinedCtx.fillStyle = colors.pausedOverlay;
        combinedCtx.fillRect(0, 0, width, height);
        combinedCtx.fillStyle = colors.textMuted;
        combinedCtx.textAlign = 'right';
        combinedCtx.font = '12px "JetBrains Mono", monospace';
        combinedCtx.fillText('Combined paused', width - 10, 18);
      }
    }

    function refreshChannelTitles() {
      channels.forEach((channel, index) => {
        channel.title.textContent = `Channel ${index + 1}`;
      });
    }

    function syncChannelUi(channel) {
      let visualState = 'paused';
      let label = 'Paused';

      if (channel.isPlaying && combinedPlaying) {
        visualState = 'playing';
        label = 'Playing';
      } else if (channel.isPlaying) {
        visualState = 'armed';
        label = 'Armed';
      }

      channel.card.dataset.state = visualState;
      channel.statusChip.className = `status-chip ${visualState}`;
      channel.statusChip.textContent = label;

      channel.toggleBtn.textContent = channel.isPlaying ? 'Pause' : 'Play';
      channel.toggleBtn.setAttribute('aria-pressed', channel.isPlaying ? 'true' : 'false');
    }

    function syncCombinedUi() {
      if (combinedPlaying) {
        combinedStateChip.className = 'status-chip playing';
        combinedStateChip.textContent = 'Playing';
        toggleCombinedBtn.textContent = 'Pause Combined';
      } else {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'Paused';
        toggleCombinedBtn.textContent = 'Play Combined';
      }

      if (channels.length === 0) {
        combinedStateChip.className = 'status-chip paused';
        combinedStateChip.textContent = 'No Channels';
        toggleCombinedBtn.disabled = true;
      }
    }

    function refreshSummary() {
      const activeCount = channels.filter((channel) => channel.isPlaying).length;
      activeSummary.textContent = `${activeCount} active / ${channels.length} channels`;
      channelsList.dataset.channelCount = String(channels.length);

      const normalizedBusGain = activeCount > 0 ? 1 / Math.sqrt(activeCount) : 1;
      setGain(channelBus, normalizedBusGain);

      const reachedMaxChannels = channels.length >= MAX_CHANNELS;
      addChannelBtn.disabled = reachedMaxChannels;
      addChannelBtn.title = reachedMaxChannels
        ? `Maximum ${MAX_CHANNELS} channels reached`
        : 'Add Channel';
      if (addChannelSlot) {
        addChannelSlot.style.display = reachedMaxChannels ? 'none' : 'flex';
      }

      if (channels.length === 0 && combinedPlaying) {
        combinedPlaying = false;
        setGain(combinedGain, 0);
      }

      toggleCombinedBtn.disabled = channels.length === 0;
      syncCombinedUi();

      requestAnimationFrame(() => {
        resizeCanvas(combinedCanvas);
        channels.forEach((channel) => {
          resizeCanvas(channel.canvas);
        });
      });
    }

    function applyFrequency(channel, rawFrequency) {
      const frequency = Math.round(clamp(rawFrequency, MIN_FREQUENCY_HZ, MAX_FREQUENCY_HZ));
      channel.frequency = frequency;
      if (channel.oscillator) {
        channel.oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      }
      channel.freqSlider.value = String(frequency);
      channel.freqNumber.value = String(frequency);

      if (channels[0] === channel) {
        syncPhaseModesToReference();
      } else {
        setChannelPhaseModeRelativeToReference(channel, channel.phaseMode);
      }
    }

    async function toggleChannel(channelId) {
      const channel = channels.find((item) => item.id === channelId);
      if (!channel) {
        return;
      }

      const ready = await ensureAudioContext();
      if (!ready) {
        setAudioBlockedHint();
        return;
      }
      setAudioReadyHint();
      channel.isPlaying = !channel.isPlaying;
      setChannelOutputGain(channel);
      if (channel.isPlaying && channels.length > 1) {
        resyncRunningOscillators();
      }
      syncChannelUi(channel);
      refreshSummary();
    }

    function removeChannel(channelId) {
      const index = channels.findIndex((item) => item.id === channelId);
      if (index === -1) {
        return;
      }

      const [channel] = channels.splice(index, 1);
      stopAndDisconnectOscillator(channel.oscillator);
      channel.gainNode.disconnect();
      channel.card.remove();

      refreshChannelTitles();
      syncPhaseModesToReference();
      refreshSummary();

      if (channels.length === 0) {
        renderEmptyState();
      }
    }

    function renderEmptyState() {
      if (document.getElementById('emptyState')) {
        return;
      }
      const empty = document.createElement('div');
      empty.id = 'emptyState';
      empty.textContent = 'No channels yet. Add a channel to begin mixing.';
      if (addChannelSlot && addChannelSlot.parentNode === channelsList) {
        channelsList.insertBefore(empty, addChannelSlot);
      } else {
        channelsList.appendChild(empty);
      }
    }

    function clearEmptyState() {
      const empty = document.getElementById('emptyState');
      if (empty) {
        empty.remove();
      }
    }

    function addChannel(options = {}) {
      if (channels.length >= MAX_CHANNELS) {
        refreshSummary();
        return false;
      }

      clearEmptyState();

      const now = audioCtx.currentTime;
      const referenceChannel = channels[0] || null;
      const initialFrequency = Number.isFinite(options.frequency) ? options.frequency : 440;
      const initialPhaseMode = PHASE_MODE_IN;
      const initialPhaseOffset = getPhaseOffsetForMode(initialPhaseMode);
      const channel = {
        id: nextChannelId,
        frequency: Math.round(clamp(initialFrequency, MIN_FREQUENCY_HZ, MAX_FREQUENCY_HZ)),
        isPlaying: options.isPlaying === undefined ? true : Boolean(options.isPlaying),
        waveTime: referenceChannel ? referenceChannel.waveTime : 0,
        phaseMode: initialPhaseMode,
        phaseOffsetRad: initialPhaseOffset,
        oscillator: null
      };
      nextChannelId += 1;

      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(0, now);
      gainNode.connect(channelBus);
      channel.gainNode = gainNode;

      const card = document.createElement('article');
      card.className = 'channel-card';
      card.dataset.state = 'paused';

      const header = document.createElement('div');
      header.className = 'channel-header';

      const titleWrap = document.createElement('div');
      titleWrap.className = 'channel-title-wrap';

      const title = document.createElement('h3');
      title.className = 'channel-title';
      title.textContent = 'Channel';

      const statusChip = document.createElement('span');
      statusChip.className = 'status-chip paused';
      statusChip.textContent = 'Paused';

      const phaseToggleInline = document.createElement('div');
      phaseToggleInline.className = 'phase-toggle-inline';

      const phaseToggleSwitch = document.createElement('label');
      phaseToggleSwitch.className = 'phase-toggle-switch';

      const phaseToggle = document.createElement('input');
      phaseToggle.type = 'checkbox';

      const phaseToggleSlider = document.createElement('span');
      phaseToggleSlider.className = 'phase-toggle-slider';

      phaseToggleSwitch.appendChild(phaseToggle);
      phaseToggleSwitch.appendChild(phaseToggleSlider);

      const phaseToggleText = document.createElement('span');
      phaseToggleText.className = 'phase-toggle-text';
      phaseToggleText.textContent = 'in-phase';

      phaseToggleInline.appendChild(phaseToggleSwitch);
      phaseToggleInline.appendChild(phaseToggleText);

      titleWrap.appendChild(title);
      titleWrap.appendChild(statusChip);
      titleWrap.appendChild(phaseToggleInline);

      const actions = document.createElement('div');
      actions.className = 'channel-actions';

      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'btn btn-secondary btn-small';
      toggleBtn.textContent = 'Play';

      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-danger btn-small';
      removeBtn.textContent = 'Remove';

      actions.appendChild(toggleBtn);
      actions.appendChild(removeBtn);

      header.appendChild(titleWrap);
      header.appendChild(actions);

      const frequencyRow = document.createElement('div');
      frequencyRow.className = 'frequency-row';

      const freqLabel = document.createElement('label');
      freqLabel.className = 'freq-label';
      freqLabel.textContent = 'Frequency';

      const freqSlider = document.createElement('input');
      freqSlider.type = 'range';
      freqSlider.min = String(MIN_FREQUENCY_HZ);
      freqSlider.max = String(MAX_FREQUENCY_HZ);
      freqSlider.step = '1';
      freqSlider.value = String(channel.frequency);

      const freqNumber = document.createElement('input');
      freqNumber.className = 'freq-number';
      freqNumber.type = 'number';
      freqNumber.min = String(MIN_FREQUENCY_HZ);
      freqNumber.max = String(MAX_FREQUENCY_HZ);
      freqNumber.step = '1';
      freqNumber.value = String(channel.frequency);

      const canvas = document.createElement('canvas');
      canvas.className = 'channel-canvas';
      const ctx = canvas.getContext('2d');

      frequencyRow.appendChild(freqLabel);
      frequencyRow.appendChild(freqNumber);
      frequencyRow.appendChild(freqSlider);

      card.appendChild(header);
      card.appendChild(frequencyRow);
      card.appendChild(canvas);

      if (addChannelSlot && addChannelSlot.parentNode === channelsList) {
        channelsList.insertBefore(card, addChannelSlot);
      } else {
        channelsList.appendChild(card);
      }

      channel.card = card;
      channel.title = title;
      channel.statusChip = statusChip;
      channel.toggleBtn = toggleBtn;
      channel.freqSlider = freqSlider;
      channel.freqNumber = freqNumber;
      channel.phaseToggleInline = phaseToggleInline;
      channel.phaseToggle = phaseToggle;
      channel.phaseToggleText = phaseToggleText;
      channel.canvas = canvas;
      channel.ctx = ctx;

      freqSlider.addEventListener('input', () => {
        applyFrequency(channel, parseFloat(freqSlider.value));
      });

      freqNumber.addEventListener('change', () => {
        const raw = parseFloat(freqNumber.value);
        applyFrequency(channel, Number.isFinite(raw) ? raw : channel.frequency);
      });

      phaseToggle.addEventListener('change', () => {
        setChannelPhaseModeRelativeToReference(
          channel,
          phaseToggle.checked ? PHASE_MODE_ANTI : PHASE_MODE_IN
        );
      });

      toggleBtn.addEventListener('click', () => {
        toggleChannel(channel.id);
      });

      removeBtn.addEventListener('click', () => {
        removeChannel(channel.id);
      });

      channels.push(channel);

      resizeCanvas(canvas);
      refreshChannelTitles();
      syncPhaseModesToReference();
      syncChannelUi(channel);
      refreshSummary();
      return true;
    }

    async function toggleCombined() {
      if (channels.length === 0) {
        return;
      }

      if (!combinedPlaying) {
        const ready = await ensureAudioContext();
        if (!ready) {
          setAudioBlockedHint();
          syncCombinedUi();
          return;
        }
        setAudioReadyHint();
        if (channels.length > 1) {
          resyncRunningOscillators();
        }
      }

      combinedPlaying = !combinedPlaying;
      setGain(combinedGain, combinedPlaying ? 1 : 0);
      syncCombinedUi();
      channels.forEach((channel) => {
        syncChannelUi(channel);
      });
    }

    function draw(timestamp) {
      requestAnimationFrame(draw);

      if (lastFrameTime === null) {
        lastFrameTime = timestamp;
        return;
      }

      const deltaSeconds = Math.min((timestamp - lastFrameTime) / 1000, 0.1);
      lastFrameTime = timestamp;

      if (combinedPlaying) {
        const step = deltaSeconds * timeScale;
        channels.forEach((channel) => {
          if (channel.isPlaying) {
            channel.waveTime += step;
          }
        });
      }

      const colors = getThemeColors();
      channels.forEach((channel) => {
        drawChannelWave(channel, colors);
      });
      drawCombinedWave(colors);
    }

    function resizeCanvas(canvas) {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width));
      const height = Math.max(1, Math.floor(rect.height));

      if (canvas.width !== width) {
        canvas.width = width;
      }
      if (canvas.height !== height) {
        canvas.height = height;
      }
    }

    function debounce(fn, waitMs) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          fn(...args);
        }, waitMs);
      };
    }

    addChannelBtn.addEventListener('click', async () => {
      const ready = await ensureAudioContext();
      if (!ready) {
        setAudioBlockedHint();
        return;
      }
      setAudioReadyHint();
      addChannel({ frequency: 440, isPlaying: true });
    });

    toggleCombinedBtn.addEventListener('click', async () => {
      await toggleCombined();
    });

    volumeSlider.addEventListener('input', () => {
      const volume = parseFloat(volumeSlider.value);
      setGain(volumeGain, volume);
      updateControlReadouts();
    });

    panningSlider.addEventListener('input', () => {
      if (!stereoPanner) {
        panningSlider.value = '0';
        updateControlReadouts();
        return;
      }
      let pan = parseFloat(panningSlider.value);
      if (Math.abs(pan) < 0.05) {
        pan = 0;
        panningSlider.value = '0';
      }
      stereoPanner.pan.setValueAtTime(pan, audioCtx.currentTime);
      updateControlReadouts();
    });

    timeScaleSlider.addEventListener('input', () => {
      const sliderValue = parseFloat(timeScaleSlider.value);
      timeScale = Math.pow(10, sliderValue);
      updateControlReadouts();
    });

    zoomScaleSlider.addEventListener('input', () => {
      zoomScale = parseFloat(zoomScaleSlider.value);
      updateControlReadouts();
    });

    document.addEventListener('keydown', (event) => {
      if (event.code !== 'Space') {
        return;
      }
      const targetTag = event.target && event.target.tagName ? event.target.tagName.toUpperCase() : '';
      if (INTERACTIVE_TAGS.has(targetTag)) {
        return;
      }
      event.preventDefault();
      toggleCombined();
    });

    window.addEventListener('resize', debounce(() => {
      resizeCanvas(combinedCanvas);
      channels.forEach((channel) => {
        resizeCanvas(channel.canvas);
      });
    }, 180));

    resizeCanvas(combinedCanvas);
    updateControlReadouts();
    syncCombinedUi();
    renderEmptyState();
    addChannel({ frequency: 440, isPlaying: true });
    requestAnimationFrame(draw);
    })();
  </script>
</body>

</html>
