<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graph Digitizer</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
    <script src="/assets/sw-register.js" defer></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

    :root {
      --font-sans: 'Inter', sans-serif;
      --font-display: 'Poppins', 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;

      --bg-color: #f8f9fa;
      --bg-pattern: #e9ecef;
      --text-main: #2d3436;
      --text-secondary: #636e72;
      --brand-primary: #6c5ce7;
      --brand-secondary: #a29bfe;
      --brand-accent: #00cec9;
      --nav-bg: rgba(255, 255, 255, 0.85);
      --nav-border: rgba(255, 255, 255, 0.5);
      --card-bg: #ffffff;
      --card-border: rgba(0, 0, 0, 0.08);
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
      --table-row-odd: #ffffff;
      --table-row-even: #eef1f5;
      --modal-bg: #ffffff;

      /* Customize each button's colors - using brand palette */
      --upload-bg: #6c5ce7;
      --upload-text: #ffffff;
      --calibrate-bg: #00cec9;
      --calibrate-text: #ffffff;
      --digitize-bg: #00b894;
      --digitize-text: #ffffff;
      --undo-bg: #636e72;
      --undo-text: #ffffff;
      --redo-bg: #636e72;
      --redo-text: #ffffff;
      --reset-bg: #fdcb6e;
      --reset-text: #2d3436;
      --remove-bg: #d63031;
      --remove-text: #ffffff;
      --export-bg: #6c5ce7;
      --export-text: #ffffff;
    }

    [data-theme="dark"] {
      --bg-color: #0f1014;
      --bg-pattern: #181a20;
      --text-main: #dfe6e9;
      --text-secondary: #b2bec3;
      --brand-primary: #a29bfe;
      --brand-secondary: #6c5ce7;
      --brand-accent: #81ecec;
      --nav-bg: rgba(22, 24, 29, 0.85);
      --nav-border: rgba(255, 255, 255, 0.08);
      --card-bg: #1e2129;
      --card-border: #2d3436;
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      --table-row-odd: #1f222b;
      --table-row-even: #2a2e38;
      --modal-bg: #1e2129;
    }

    /* Base button style for all buttons */
    * {
      box-sizing: border-box;
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    .btn {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      border: none;
      border-radius: 6px;
      padding: 0 10px;
      height: 32px;
      min-width: auto;
      font-size: 13px;
      font-weight: 500;
      font-family: inherit;
      line-height: 1;
      letter-spacing: 0.01em;
      box-sizing: border-box;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.08);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .btn:focus-visible {
      outline: 2px solid var(--brand-primary);
      outline-offset: 2px;
    }

    .btn:disabled {
      background-color: #9ca3af;
      color: #f3f4f6;
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none;
    }

    /* Specific button classes */
    .btn-upload {
      background-color: var(--upload-bg);
      color: var(--upload-text);
    }

    .btn-calibrate {
      background-color: var(--calibrate-bg);
      color: var(--calibrate-text);
    }

    .btn-digitize {
      background-color: var(--digitize-bg);
      color: var(--digitize-text);
    }

    .btn-undo {
      background-color: var(--undo-bg);
      color: var(--undo-text);
    }

    .btn-redo {
      background-color: var(--redo-bg);
      color: var(--redo-text);
    }

    .btn-reset {
      background-color: var(--reset-bg);
      color: var(--reset-text);
    }

    .btn-remove {
      background-color: var(--remove-bg);
      color: var(--remove-text);
    }

    .btn-export {
      background-color: var(--export-bg);
      color: var(--export-text);
    }

    /* Modal button styling */
    .btn-confirm {
      background-color: var(--brand-primary);
      color: #ffffff;
    }

    /* Button group styling for organized layout */
    .button-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .button-group-separator {
      width: 1px;
      height: 20px;
      background-color: var(--card-border);
      margin: 0 4px;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: var(--font-sans);
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
      background-size: 30px 30px;
      color: var(--text-main);
    }

    header.banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 6px 20px;
      margin: 10px auto 0;
      width: calc(100% - 60px);
      max-width: 1170px;
      background: var(--nav-bg);
      border: 1px solid var(--nav-border);
      border-radius: 16px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      flex-shrink: 0;
    }

    .banner-logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .banner-logo img {
      height: 36px;
      width: auto;
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
    }

    .banner-title {
      font-family: var(--font-display);
      font-size: 1.6rem;
      font-weight: 800;
      text-align: center;
      flex: 1;
      letter-spacing: -0.5px;
      color: var(--brand-primary);
    }

    .banner-title.gradient-text {
      background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .banner-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .theme-toggle button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0.5rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-main);
    }

    .theme-toggle button:hover {
      background-color: rgba(128, 128, 128, 0.2);
      transform: rotate(15deg);
    }

    footer {
      font-size: 13px;
      text-align: center;
      padding: 6px;
      background: transparent;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    footer a {
      color: var(--brand-primary);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    #content {
      display: flex;
      gap: 12px;
      overflow: hidden;
      padding: 10px 15px;
      box-sizing: border-box;
      width: min(1200px, calc(100% - 30px));
      margin: 0 auto;
      flex: 1;
      min-height: 0;
    }

    #main {
      flex: 1;
      background: var(--card-bg);
      padding: 12px;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      box-sizing: border-box;
      overflow: auto;
      position: relative;
      box-shadow: var(--card-shadow);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #sidebar {
      flex: 0 0 260px;
      min-width: 260px;
      background: var(--card-bg);
      padding: 10px;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      box-sizing: border-box;
      overflow-y: auto;
      text-align: center;
      box-shadow: var(--card-shadow);
    }

    #sidebar h3 {
      font-family: var(--font-sans);
      font-size: 20px;
      background-color: rgba(255, 173, 122, 0.35);
      color: var(--text-main);
      padding: 5px;
      border-radius: 4px;
      margin: 0 0 10px;
      text-align: center;
    }

    #dataTable {
      width: auto;
      border-collapse: collapse;
      margin: 10px auto 0;
    }

    #dataTable th,
    #dataTable td {
      border: 1px solid rgba(0, 0, 0, 0.2);
      padding: 5px;
      text-align: center;
    }

    #dataTable th:nth-child(1) {
      width: 50px;
    }

    #dataTable th:nth-child(2),
    #dataTable th:nth-child(3) {
      width: 70px;
    }

    #dataTable tr:nth-child(odd) {
      background-color: var(--table-row-odd);
    }

    #dataTable tr:nth-child(even) {
      background-color: var(--table-row-even);
    }

    #controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
      flex-shrink: 0;
    }

    #controlRow {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: nowrap;
    }

    #imageLoader {
      /*
        Hide the native file input but keep it "clickable" via the label.
        Using display:none can break label-triggered file dialogs on some browsers.
      */
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
      opacity: 0;
    }

    #status {
      display: block;
      width: 100%;
      min-height: 24px;
      font-weight: bold;
      color: var(--text-secondary);
    }

    #canvas {
      display: none;
      margin: 0 auto;
      border: 1px solid var(--card-border);
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #canvasContainer {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      overflow: auto;
    }

    /* Stationary magnifier in the sidebar */
    #magnifierCanvas {
      width: 220px;
      height: 220px;
      border: 1px solid var(--card-border);
      border-radius: 50%;
      background: var(--card-bg);
      pointer-events: none;
      /* So clicks pass through if needed */
    }

    /* Modal styles for selecting plot type */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: var(--modal-bg);
      margin: 15% auto;
      padding: 20px;
      border: 1px solid var(--card-border);
      width: 300px;
      border-radius: 8px;
      text-align: left;
      color: var(--text-main);
    }

    .modal-content h3 {
      margin-top: 0;
    }

    @media (max-width: 1000px) {
      #controlRow {
        flex-wrap: wrap;
      }
    }

    @media (max-width: 900px) {
      body {
        height: auto;
        min-height: 100vh;
        overflow: auto;
      }

      #content {
        flex-direction: column;
        flex: none;
      }

      #sidebar {
        flex: none;
        height: auto;
      }

      #main {
        min-height: 500px;
      }

      header.banner {
        flex-direction: column;
        text-align: center;
      }

      .banner-actions {
        width: 100%;
        justify-content: center;
      }
    }

    @media (pointer: coarse) {
      .btn {
        height: 38px;
        min-height: 38px;
        font-size: 14px;
        padding: 0 14px;
      }

      input,
      select {
        min-height: 44px;
        touch-action: manipulation;
      }

      canvas {
        touch-action: none;
      }
    }
  </style>
</head>

<body>
  <header class="banner">
    <div class="banner-logo">
      <a href="https://panphy.github.io/">
        <img src="/assets/panphy.png" alt="PanPhy logo">
      </a>
    </div>
    <div class="banner-title">Graph Digitizer</div>
    <div class="banner-actions">
      <div class="theme-toggle">
        <button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">‚òÄÔ∏è</button>
      </div>
    </div>
  </header>

  <div id="content">
    <div id="main">
      <div id="controls">
        <div id="controlRow">
          <!-- Group 1: Import -->
          <div class="button-group">
            <label for="imageLoader" class="btn btn-upload" title="Import a graph image from your device">Import Graph</label>
            <input type="file" id="imageLoader" accept="image/*">
          </div>

          <div class="button-group-separator"></div>

          <!-- Group 2: Workflow (Calibrate ‚Üí Digitize) -->
          <div class="button-group">
            <button id="calibrateAxesButton" class="btn btn-calibrate" title="Set axis reference points for the graph" disabled>Calibrate</button>
            <button id="digitizeButton" class="btn btn-digitize" title="Start capturing data points on the graph" disabled>Digitize</button>
          </div>

          <div class="button-group-separator"></div>

          <!-- Group 3: History -->
          <div class="button-group">
            <button id="undoButton" class="btn btn-undo" title="Undo the last action" disabled>Undo</button>
            <button id="redoButton" class="btn btn-redo" title="Redo the last undone action" disabled>Redo</button>
          </div>

          <div class="button-group-separator"></div>

          <!-- Group 4: Reset/Clear -->
          <div class="button-group">
            <button id="resetButton" class="btn btn-reset" title="Clear digitized points (keeps calibration)" disabled>Reset</button>
            <button id="removeGraphButton" class="btn btn-remove" title="Remove the graph and reset everything" disabled>Remove Graph</button>
          </div>
        </div>
        <div id="status"></div>
      </div>
      <div id="canvasContainer">
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <div id="sidebar">
      <h3>Magnifier</h3>
      <!-- The stationary magnifier in the sidebar -->
      <canvas id="magnifierCanvas" width="220" height="220"></canvas><br><br>
      <h3>Data Points</h3>
      <button id="exportButton" class="btn btn-export" title="Download the digitized points as a CSV file">Export Data (.csv)</button>
      <table id="dataTable">
        <thead>
          <tr>
            <th>#</th>
            <th>x</th>
            <th>y</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <footer>
    &copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
    <a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
  </footer>

  <!-- Modal for selecting plot type -->
  <div id="plotTypeModal" class="modal">
    <div class="modal-content">
      <h3>Select Plot Type</h3>
      <form id="plotTypeForm">
        <label><input type="radio" name="plotType" value="1" checked> Linear-Linear</label><br>
        <label><input type="radio" name="plotType" value="2"> Log (base 10)-Linear</label><br>
        <label><input type="radio" name="plotType" value="3"> Linear-Log (base 10)</label><br>
        <label><input type="radio" name="plotType" value="4"> Log (base 10)-Log (base 10)</label><br><br>
      </form>
        <button id="plotTypeConfirm" class="btn btn-confirm" title="Confirm the selected plot type">Confirm</button>
    </div>
  </div>

  <script>
  const themeButton = document.getElementById('theme-button');
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const storedTheme = localStorage.getItem('digitizer-theme');
  const initialTheme = storedTheme || (prefersDark ? 'dark' : 'light');
  document.documentElement.setAttribute('data-theme', initialTheme);
  if (themeButton) {
    themeButton.textContent = initialTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    themeButton.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const nextTheme = currentTheme === 'light' ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', nextTheme);
      localStorage.setItem('digitizer-theme', nextTheme);
      themeButton.textContent = nextTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    });
  }

  const STORAGE_KEY = "digitizer-saved-state";
  let mode = "none",
    calibrationPhase = "";
  let calibrationX = [],
    calibrationY = [];
  let slopeX = null,
    interceptX = null,
    slopeY = null,
    interceptY = null;
  // Variables to store the axis types ("linear" or "log")
  let xAxisType = "linear",
    yAxisType = "linear";
  let digitizedPoints = [],
    activeCalibration = null;
  let actionHistory = [],
    redoHistory = [];
  let pendingRestoreState = null;
  const image = new Image();
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const statusDiv = document.getElementById('status');
  const dataTableBody = document.querySelector("#dataTable tbody");

  // Stationary magnifier in the sidebar
  const magnifierCanvas = document.getElementById('magnifierCanvas');
  const mCtx = magnifierCanvas.getContext('2d');
  const magnification = 4;

  const btnCalibrate = document.getElementById('calibrateAxesButton'),
    btnDigitize = document.getElementById('digitizeButton'),
    btnUndo = document.getElementById('undoButton'),
    btnRedo = document.getElementById('redoButton'),
    btnReset = document.getElementById('resetButton'),
    btnRemoveGraph = document.getElementById('removeGraphButton'),
    exportButton = document.getElementById('exportButton');

  // Add export button event listener
  exportButton.addEventListener('click', exportCSV);

  // Function to handle magnifier drawing in the sidebar canvas
  function updateMagnifier(e) {
    // We only show/draw the magnified region if in calibrate or digitize mode
    if (mode !== "calibrateAxes" && mode !== "digitize") {
      mCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);
      return;
    }

    // Get canvas's bounding rect to convert client coords -> canvas coords
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    // Cursor position in canvas coordinates
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    // The portion of the main canvas we want to draw
    // Our magnifier is 220x220, so the region size in the main canvas is 220 / magnification
    const regionSize = magnifierCanvas.width / magnification;
    let sx = x - regionSize / 2;
    let sy = y - regionSize / 2;

    // Clamp so we don't sample outside the image
    sx = Math.max(0, Math.min(sx, canvas.width - regionSize));
    sy = Math.max(0, Math.min(sy, canvas.height - regionSize));

    // Clear the sidebar magnifier canvas
    mCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);

    // Draw the magnified region from the main canvas into the sidebar magnifier
    mCtx.drawImage(
      canvas,
      sx, sy, regionSize, regionSize,
      0, 0, magnifierCanvas.width, magnifierCanvas.height
    );

    // Optionally, draw crosshairs in the magnifier
    mCtx.beginPath();
    mCtx.moveTo(magnifierCanvas.width / 2, 0);
    mCtx.lineTo(magnifierCanvas.width / 2, magnifierCanvas.height);
    mCtx.moveTo(0, magnifierCanvas.height / 2);
    mCtx.lineTo(magnifierCanvas.width, magnifierCanvas.height / 2);
    mCtx.strokeStyle = "rgba(255,0,0,0.5)";
    mCtx.lineWidth = 2;
    mCtx.stroke();
  }

  function setDefaultMagnifierPosition() {
    // No-op now, because the magnifier is stationary in the sidebar
  }

  function updateMagnifierVisibility() {
    // No-op in this version; the magnifier is always shown in the sidebar
  }

  function getCanvasCoordinates(pointer) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = Math.round((pointer.clientX - rect.left) * scaleX) + 0.5;
    const y = (pointer.clientY - rect.top) * scaleY;
    return { x, y };
  }

  function updateCalibrationParameters() {
    if (calibrationX.length >= 2) {
      if (calibrationX[1].x === calibrationX[0].x) {
        slopeX = interceptX = null;
        alert("Calibration points for the X axis must have different x positions.");
      } else if (xAxisType === "linear") {
        slopeX = (calibrationX[1].data - calibrationX[0].data) /
          (calibrationX[1].x - calibrationX[0].x);
        interceptX = calibrationX[0].data - slopeX * calibrationX[0].x;
      } else {
        slopeX = (Math.log10(calibrationX[1].data) - Math.log10(calibrationX[0].data)) /
          (calibrationX[1].x - calibrationX[0].x);
        interceptX = Math.log10(calibrationX[0].data) - slopeX * calibrationX[0].x;
      }
    } else {
      slopeX = interceptX = null;
    }

    if (calibrationY.length >= 2) {
      if (calibrationY[1].y === calibrationY[0].y) {
        slopeY = interceptY = null;
        alert("Calibration points for the Y axis must have different y positions.");
      } else if (yAxisType === "linear") {
        slopeY = (calibrationY[1].data - calibrationY[0].data) /
          (calibrationY[1].y - calibrationY[0].y);
        interceptY = calibrationY[0].data - slopeY * calibrationY[0].y;
      } else {
        slopeY = (Math.log10(calibrationY[1].data) - Math.log10(calibrationY[0].data)) /
          (calibrationY[1].y - calibrationY[0].y);
        interceptY = Math.log10(calibrationY[0].data) - slopeY * calibrationY[0].y;
      }
    } else {
      slopeY = interceptY = null;
    }
  }

  function updateDataTable() {
    dataTableBody.innerHTML = "";
    digitizedPoints.forEach((pt, index) => {
      const row = document.createElement("tr");
      const cellIndex = document.createElement("td");
      const cellX = document.createElement("td");
      const cellY = document.createElement("td");
      cellIndex.textContent = index + 1;
      cellX.textContent = pt.dataX.toFixed(4);
      cellY.textContent = pt.dataY.toFixed(4);
      row.appendChild(cellIndex);
      row.appendChild(cellX);
      row.appendChild(cellY);
      dataTableBody.appendChild(row);
    });
    exportButton.disabled = digitizedPoints.length === 0;
    saveState();
  }

  function updateDigitizedPointsFromCalibration() {
    if (slopeX === null || slopeY === null) {
      return;
    }
    digitizedPoints = digitizedPoints.map(pt => {
      let dataX;
      let dataY;
      if (xAxisType === "log") {
        dataX = Math.pow(10, slopeX * pt.pixelX + interceptX);
      } else {
        dataX = slopeX * pt.pixelX + interceptX;
      }
      if (yAxisType === "log") {
        dataY = Math.pow(10, slopeY * pt.pixelY + interceptY);
      } else {
        dataY = slopeY * pt.pixelY + interceptY;
      }
      return { ...pt, dataX, dataY };
    });
    updateDataTable();
  }

  function updateStatus(message) {
    statusDiv.textContent = message;
  }

  function hasWorkToWarnAbout() {
    return calibrationX.length > 0 || calibrationY.length > 0 || digitizedPoints.length > 0 || activeCalibration !== null;
  }

  function confirmGraphDataLoss(triggerDescription) {
    if (!hasWorkToWarnAbout()) {
      return true;
    }
    return window.confirm("Warning: " + triggerDescription + " will clear your current calibration and digitized data. Continue?");
  }

  function confirmResetDataLoss() {
    if (digitizedPoints.length === 0) {
      return true;
    }
    return window.confirm("Warning: Reset will clear all digitized points. Continue?");
  }

  function saveState() {
    if (!image.src) {
      localStorage.removeItem(STORAGE_KEY);
      return;
    }
    const state = {
      imageSrc: image.src,
      digitizedPoints,
      calibrationX,
      calibrationY,
      xAxisType,
      yAxisType
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  function clearSavedState() {
    localStorage.removeItem(STORAGE_KEY);
  }

  function applyImageToCanvas() {
    const maxSize = 1000;
    let newWidth = image.width;
    let newHeight = image.height;
    if (newWidth > maxSize || newHeight > maxSize) {
      const scale = Math.min(maxSize / newWidth, maxSize / newHeight);
      newWidth *= scale;
      newHeight *= scale;
    }
    canvas.width = Math.round(newWidth);
    canvas.height = Math.round(newHeight);
    canvas.style.display = "block";
  }

  function loadSavedState() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) {
      return false;
    }
    try {
      const parsed = JSON.parse(saved);
      if (!parsed.imageSrc) {
        return false;
      }
      pendingRestoreState = parsed;
      image.onload = function () {
        applyImageToCanvas();
        if (pendingRestoreState) {
          calibrationX = pendingRestoreState.calibrationX || [];
          calibrationY = pendingRestoreState.calibrationY || [];
          digitizedPoints = pendingRestoreState.digitizedPoints || [];
          xAxisType = pendingRestoreState.xAxisType || "linear";
          yAxisType = pendingRestoreState.yAxisType || "linear";
          updateCalibrationParameters();
          if (slopeX !== null && slopeY !== null) {
            updateDigitizedPointsFromCalibration();
          } else {
            updateDataTable();
          }
          redrawCanvas();
          btnCalibrate.disabled = false;
          btnReset.disabled = false;
          btnRemoveGraph.disabled = false;
          btnDigitize.disabled = !(calibrationX.length === 2 && calibrationY.length === 2);
          exportButton.disabled = digitizedPoints.length === 0;
          updateUndoRedoButtons();
          updateStatus("Restored previous session. Remember to export your data.");
          pendingRestoreState = null;
        }
      };
      image.onerror = function () {
        clearSavedState();
        updateStatus("Saved graph could not be loaded. Please upload again.");
      };
      image.src = parsed.imageSrc;
      return true;
    } catch (error) {
      console.error("Failed to restore saved state:", error);
      clearSavedState();
      return false;
    }
  }

  function updateUndoRedoButtons() {
    btnUndo.disabled = actionHistory.length === 0 && !activeCalibration;
    btnRedo.disabled = redoHistory.length === 0;
  }

  document.getElementById('imageLoader').addEventListener('change', handleImage, false);

  function handleImage(e) {
    const file = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
    if (!file) return;
    if (!confirmGraphDataLoss("Importing a new graph")) {
      e.target.value = "";
      updateStatus("Import cancelled. Current graph preserved.");
      return;
    }

    // IMPORTANT:
    // resetAllState() clears the <input type="file"> value.
    // If we read from e.target.files[0] AFTER resetting, it can become undefined on some browsers.
    resetAllState();

    const reader = new FileReader();
    reader.onerror = function () {
      updateStatus("Failed to read the selected file. Please try a different image.");
      console.error("FileReader error:", reader.error);
    };
    reader.onload = function (event) {
      image.onload = function () {
        applyImageToCanvas();

        redrawCanvas();
        updateStatus("Image loaded. Ready for calibration.");

        btnCalibrate.disabled = false;
        btnDigitize.disabled = true;
        updateUndoRedoButtons();
        btnReset.disabled = false;
        btnRemoveGraph.disabled = false;
        saveState();
      };
      image.onerror = function () {
        updateStatus("Could not load that image. Please try a PNG/JPG screenshot of the graph.");
        console.error("Image decode error");
      };
      image.src = event.target.result;
    };
    reader.readAsDataURL(file);
  }

  // Show modal with a list of plot types (using radio buttons)
  function showPlotTypeModal() {
    const modal = document.getElementById("plotTypeModal");
    modal.style.display = "block";
    const confirmButton = document.getElementById("plotTypeConfirm");
    confirmButton.onclick = function () {
      const selectedValue = document.querySelector('input[name="plotType"]:checked').value;
      if (selectedValue === "2") {
        xAxisType = "log";
        yAxisType = "linear";
      } else if (selectedValue === "3") {
        xAxisType = "linear";
        yAxisType = "log";
      } else if (selectedValue === "4") {
        xAxisType = "log";
        yAxisType = "log";
      } else {
        xAxisType = "linear";
        yAxisType = "linear";
      }
      modal.style.display = "none";
      updateStatus("Calibration (" +
        (xAxisType === "log" ? "log" : "linear") + " x, " +
        (yAxisType === "log" ? "log" : "linear") + " y): Click first point for x axis (x‚ÇÅ).");
      mode = "calibrateAxes";
      calibrationPhase = "x1";
      activeCalibration = null;
      updateMagnifierVisibility();
    };
  }

  function startCalibration() {
    calibrationX = [];
    calibrationY = [];
    slopeX = interceptX = null;
    slopeY = interceptY = null;
    calibrationPhase = "";
    updateStatus("Starting calibration.");
    showPlotTypeModal();
  }

  document.getElementById('calibrateAxesButton').addEventListener('click', function () {
    if (calibrationX.length === 2 && calibrationY.length === 2) {
      if (!confirm("Calibration already done. Recalibrate?")) {
        updateStatus("Using previous calibration.");
        return;
      }
    }
    startCalibration();
  });

  document.getElementById('digitizeButton').addEventListener('click', function () {
    if (calibrationX.length < 2 || calibrationY.length < 2) {
      alert("Please complete calibration (4 points) before digitizing.");
      return;
    }
    mode = "digitize";
    updateStatus("Digitize Mode: Click points on the graph to record data.");
    updateMagnifierVisibility();
  });

  document.getElementById('resetButton').addEventListener('click', function () {
    if (!confirmResetDataLoss()) {
      updateStatus("Reset cancelled. Digitized points preserved.");
      return;
    }
    resetDigitizedData();
  });

  document.getElementById('removeGraphButton').addEventListener('click', function () {
    if (!confirmGraphDataLoss("Removing the graph")) {
      updateStatus("Remove graph cancelled. Current graph preserved.");
      return;
    }
    resetAllState();
  });

  document.getElementById('undoButton').addEventListener('click', function () {
    undoAction();
  });

  document.getElementById('redoButton').addEventListener('click', function () {
    redoAction();
  });

  function promptForCalibrationValue() {
    let promptText = "";
    let isLog = false;
    if (calibrationPhase.startsWith("x")) {
      promptText = "Enter actual value for x (" + (calibrationPhase === "x1" ? "first" : "second") + " point):";
      if (xAxisType === "log") { isLog = true; }
    } else if (calibrationPhase.startsWith("y")) {
      promptText = "Enter actual value for y (" + (calibrationPhase === "y1" ? "first" : "second") + " point):";
      if (yAxisType === "log") { isLog = true; }
    }
    let input = window.prompt(promptText);
    if (input === null || input.trim() === "") {
      updateStatus("Calibration point cancelled.");
      return null;
    }
    let val = parseFloat(input);
    if (isNaN(val) || (isLog && val <= 0)) {
      alert(isLog ? "Invalid number. Please enter a positive number for logarithmic scale." : "Invalid number. Please try again.");
      return promptForCalibrationValue();
    }
    return val;
  }

  function handleCanvasInteraction(x, y) {
    if (mode === "calibrateAxes") {
      activeCalibration = { x: x, y: y };
      redrawCanvas();
      let markerColor = calibrationPhase.startsWith("x") ? "blue" : "green";
      drawMarker(x, y, markerColor);
      let actualValue = promptForCalibrationValue();
      if (actualValue !== null) {
        if (calibrationPhase.startsWith("x")) {
          const point = { x: activeCalibration.x, y: activeCalibration.y, data: actualValue };
          calibrationX.push(point);
          actionHistory.push({ type: "calibrationX", point: point });
          redoHistory = [];
          updateUndoRedoButtons();
          updateStatus("Saved X point " + calibrationX.length + " of 2.");
          if (calibrationPhase === "x1") {
            calibrationPhase = "x2";
            updateStatus("Calibration: Click second point for x axis (x‚ÇÇ).");
          } else {
            calibrationPhase = "y1";
            updateStatus("Calibration: Click first point for y axis (y‚ÇÅ).");
          }
        } else if (calibrationPhase.startsWith("y")) {
          const point = { x: activeCalibration.x, y: activeCalibration.y, data: actualValue };
          calibrationY.push(point);
          actionHistory.push({ type: "calibrationY", point: point });
          redoHistory = [];
          updateUndoRedoButtons();
          updateStatus("Saved Y point " + calibrationY.length + " of 2.");
          if (calibrationPhase === "y1") {
            calibrationPhase = "y2";
            updateStatus("Calibration: Click second point for y axis (y‚ÇÇ).");
          } else {
            updateCalibrationParameters();
            updateDigitizedPointsFromCalibration();
            mode = "digitize";
            calibrationPhase = "";
            updateStatus("Calibration complete. Digitize Mode: Click points on the graph to record data.");
            btnDigitize.disabled = false;
            updateMagnifierVisibility();
          }
        }
      }
      activeCalibration = null;
      redrawCanvas();
      saveState();
    } else if (mode === "digitize") {
      if (slopeX === null || slopeY === null) {
        alert("Calibration incomplete.");
        return;
      }
      let dataX, dataY;
      if (xAxisType === "log") {
        dataX = Math.pow(10, slopeX * x + interceptX);
      } else {
        dataX = slopeX * x + interceptX;
      }
      if (yAxisType === "log") {
        dataY = Math.pow(10, slopeY * y + interceptY);
      } else {
        dataY = slopeY * y + interceptY;
      }
      digitizedPoints.push({ pixelX: x, pixelY: y, dataX: dataX, dataY: dataY });
      actionHistory.push({ type: "digitized", point: { pixelX: x, pixelY: y, dataX: dataX, dataY: dataY } });
      redoHistory = [];
      updateUndoRedoButtons();
      updateStatus("Digitized point (" + dataX.toFixed(4) + ", " + dataY.toFixed(4) + "). Total: " + digitizedPoints.length);
      updateDataTable();
      redrawCanvas();
      saveState();
    }
  }

  let lastEvent = null;
  let touchStartHandled = false;
  canvas.addEventListener('click', function (e) {
    lastEvent = e;
    const coords = getCanvasCoordinates(e);
    handleCanvasInteraction(coords.x, coords.y);
  });
  canvas.addEventListener('touchstart', function (e) {
    e.preventDefault();
    const touch = e.changedTouches[0];
    lastEvent = touch;
    const coords = getCanvasCoordinates(touch);
    touchStartHandled = true;
    handleCanvasInteraction(coords.x, coords.y);
    updateMagnifier(touch);
  }, { passive: false });
  canvas.addEventListener('touchend', function (e) {
    e.preventDefault();
    if (touchStartHandled) {
      touchStartHandled = false;
      return;
    }
    const touch = e.changedTouches[0];
    lastEvent = touch;
    const coords = getCanvasCoordinates(touch);
    handleCanvasInteraction(coords.x, coords.y);
  }, { passive: false });
  canvas.addEventListener('touchmove', function (e) {
    e.preventDefault();
    lastEvent = e.touches[0];
    updateMagnifier(e.touches[0]);
  }, { passive: false });
  canvas.addEventListener('mousemove', function (e) {
    lastEvent = e;
    updateMagnifier(e);
  });

  function drawMarker(x, y, color) {
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.stroke();
  }

  function redrawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (image.src) {
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
    }
    calibrationX.forEach(pt => drawMarker(pt.x, pt.y, "blue"));
    calibrationY.forEach(pt => drawMarker(pt.x, pt.y, "green"));
    digitizedPoints.forEach(pt => drawMarker(pt.pixelX, pt.pixelY, "red"));
    if (activeCalibration) {
      let col = calibrationPhase.startsWith("x") ? "blue" : "green";
      drawMarker(activeCalibration.x, activeCalibration.y, col);
    }
    // If the user is moving the cursor, also update the magnifier
    if (lastEvent) {
      updateMagnifier(lastEvent);
    }
  }

  function undoAction() {
    if (activeCalibration) {
      activeCalibration = null;
      redrawCanvas();
      updateUndoRedoButtons();
      updateStatus("Cleared active calibration marker.");
      return;
    }
    if (actionHistory.length === 0) return;
    const lastAction = actionHistory.pop();
    redoHistory.push(lastAction);
    if (lastAction.type === "calibrationX") {
      calibrationX.pop();
      updateCalibrationParameters();
      updateDigitizedPointsFromCalibration();
    } else if (lastAction.type === "calibrationY") {
      calibrationY.pop();
      updateCalibrationParameters();
      updateDigitizedPointsFromCalibration();
    } else if (lastAction.type === "digitized") {
      digitizedPoints.pop();
      updateDataTable();
    }
    redrawCanvas();
    updateUndoRedoButtons();
    updateStatus("Undid action: " + lastAction.type);
  }

  function redoAction() {
    if (redoHistory.length === 0) return;
    const action = redoHistory.pop();
    actionHistory.push(action);
    if (action.type === "calibrationX") {
      calibrationX.push(action.point);
      updateCalibrationParameters();
      updateDigitizedPointsFromCalibration();
    } else if (action.type === "calibrationY") {
      calibrationY.push(action.point);
      updateCalibrationParameters();
      updateDigitizedPointsFromCalibration();
    } else if (action.type === "digitized") {
      digitizedPoints.push(action.point);
      updateDataTable();
    }
    redrawCanvas();
    updateUndoRedoButtons();
    updateStatus("Redid action: " + action.type);
  }

  function exportCSV() {
    let csvContent = "dataX,dataY\n";
    digitizedPoints.forEach(pt => {
      csvContent += pt.dataX + "," + pt.dataY + "\n";
    });
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'digitized_data.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  function resetAllState(keepImage = false) {
    mode = "none";
    calibrationPhase = "";
    calibrationX = [];
    calibrationY = [];
    slopeX = interceptX = null;
    slopeY = interceptY = null;
    digitizedPoints = [];
    actionHistory = [];
    redoHistory = [];
    activeCalibration = null;
    updateStatus(keepImage ? "Data cleared. Ready to recalibrate." : "Upload a graph and start calibration.");
    updateDataTable();
    redrawCanvas();
    updateMagnifierVisibility();
    setDefaultMagnifierPosition();
    if (!keepImage) {
      document.getElementById('imageLoader').value = "";
      canvas.style.display = "none";
      btnCalibrate.disabled = true;
      btnDigitize.disabled = true;
      btnReset.disabled = true;
      btnRemoveGraph.disabled = true;
      exportButton.disabled = true;
      image.src = "";
      clearSavedState();
    } else {
      btnDigitize.disabled = true;
      btnCalibrate.disabled = false;
      btnReset.disabled = false;
      btnRemoveGraph.disabled = false;
      exportButton.disabled = true;
      saveState();
    }
    updateUndoRedoButtons();
  }

  function resetDigitizedData() {
    digitizedPoints = [];
    actionHistory = actionHistory.filter(action => action.type !== "digitized");
    redoHistory = [];
    updateDataTable();
    redrawCanvas();
    updateMagnifierVisibility();
    setDefaultMagnifierPosition();
    btnDigitize.disabled = !(calibrationX.length === 2 && calibrationY.length === 2);
    updateUndoRedoButtons();
    exportButton.disabled = true;
    updateStatus("Data cleared. Calibration preserved. Ready to digitize.");
  }

  window.addEventListener("beforeunload", function (e) {
    if (!hasWorkToWarnAbout()) {
      return;
    }
    e.preventDefault();
    e.returnValue = "";
  });

  window.addEventListener("load", function () {
    if (!loadSavedState()) {
      resetAllState();
    }
  });
  </script>
  <script>
    // Gradient text: skip on Brave iOS where background-clip:text is broken
    (function() {
      if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
      document.querySelectorAll('.banner-title').forEach(function(el) { el.classList.add('gradient-text'); });
    })();
  </script>

</body>

</html>
