<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>PanPhyPlot</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<!-- Plotly.js for graphing -->
	<script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
	<!-- Math.js for computations -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
	<!-- MathJax v2 for LaTeX rendering -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>

	<style>
		/* Root Variables */
		:root {
			--add-row-btn-color: #6aa84f;
			--clear-all-btn-color: #e06666;
			--import-csv-btn-color: #45818e;
			--export-csv-btn-color: #6fa8dc;
			--tab-bg-color: #f3f3f3;
			--tab-active-bg-color: #ffd966;
			--tab-border-color: #ccc;
			--tab-close-color: #999;
			--tab-close-hover-color: #e06666;
		}

		/* Global Styles */
		html,
		body {
			margin: 0;
			padding: 0;
			overflow-x: hidden;
			font-family: Helvetica, sans-serif;
			background-color: #f4f4f4;
			color: #333;
		}

		/* Banner */
		.banner {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background-color: #333;
			color: #fff;
			padding: 3px;
			font-size: 22px;
			font-weight: bold;
			position: relative;
		}

		.banner-logo {
			display: flex;
			align-items: center;
		}

		.banner-logo img {
			max-height: 35px;
			margin-left: 10px;
			margin-top: 4px;
		}

		.banner-title {
			flex: 1;
			text-align: center;
			font-size: 1.5rem;
		}

		.banner-buttons {
			display: flex;
			width: 60px;
			justify-content: flex-end;
			margin-right: 15px;
		}

		.banner-button {
			background: none;
			border: none;
			color: grey;
			text-decoration: none;
			cursor: pointer;
			font-size: 14px;
			padding: 0;
			transition: color 0.3s;
		}

		.banner-button:hover {
			color: #ddd;
		}

		/* Reminder and Toggle */
		.reminder {
			color: #999;
			margin: 3px 0;
			font-size: 12px;
			position: relative;
			text-align: center;
			padding: 3px 10px;
		}

		.latex-toggle-container {
			position: absolute;
			right: 10px;
			top: 50%;
			transform: translateY(-50%);
			display: flex;
			align-items: center;
			gap: 5px;
		}

		/* Toggle Switch */
		.switch {
			position: relative;
			display: inline-block;
			width: 40px;
			height: 19px;
		}

		.switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: 0.4s;
			border-radius: 24px;
		}

		.slider:before {
			position: absolute;
			content: "";
			height: 15px;
			width: 15px;
			left: 2px;
			bottom: 2px;
			background-color: #fff;
			transition: 0.4s;
			border-radius: 50%;
		}

		.switch input:checked+.slider {
			background-color: #67c399;
		}

		.switch input:checked+.slider:before {
			transform: translateX(21px);
		}

		.toggle-label {
			font-size: 14px;
			color: #333;
		}

		/* Dataset Tabs Bar */
		.dataset-tabs-bar {
			display: flex;
			align-items: center;
			padding: 0 10px;
			background-color: #f4f4f4;
			flex-wrap: nowrap;
			overflow-x: auto;
			-webkit-overflow-scrolling: touch;
			scrollbar-width: thin;
		}

		.dataset-tabs-bar::-webkit-scrollbar {
			height: 6px;
		}

		.dataset-tabs-bar::-webkit-scrollbar-track {
			background: #f1f1f1;
		}

		.dataset-tabs-bar::-webkit-scrollbar-thumb {
			background: #ccc;
			border-radius: 3px;
		}

		.dataset-tabs-bar::-webkit-scrollbar-thumb:hover {
			background: #999;
		}

		/* Dataset Tabs */
		.dataset-tab {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			padding: 8px 16px;
			margin-right: 2px;
			line-height: 1.2;
			background-color: #ddd;
			color: #333;
			border: 1px solid transparent;
			border-bottom: none;
			border-top-left-radius: 6px;
			border-top-right-radius: 6px;
			cursor: pointer;
			transition: background-color 0.2s;
			font-size: 14px;
		}

		.dataset-tab.active {
			background-color: #ffba3b;
			border-color: #aaa;
			font-weight: bold;
		}

		.dataset-tab .tab-label {
			margin-right: 5px;
			white-space: nowrap;
		}

		.dataset-tab .tab-close {
			font-weight: bold;
			color: #888;
			cursor: pointer;
			padding-left: 4px;
			user-select: none;
		}

		.dataset-tab .tab-close:hover {
			color: #e06666;
		}

		.add-dataset-btn {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			padding: 8px 10px;
			margin-left: 0;
			line-height: 1.2;
			background-color: #16537e;
			color: #fff;
			border: 1px solid transparent;
			border-top-left-radius: 6px;
			border-top-right-radius: 6px;
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
			border-bottom: none;
			cursor: pointer;
			transition: background-color 0.2s;
			font-size: 14px;
			flex: none;
			width: 110px;
		}

		.add-dataset-btn:hover {
			background-color: #113d5c;
		}

		/* Layout Sections */
		.container {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}

		.input-section,
		.graph-section {
			background-color: #fff;
			border-radius: 8px;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			padding: 20px;
			box-sizing: border-box;
			height: 80vh;
			overflow-y: auto;
		}

		.input-section {
			flex: 1 1 400px;
			max-width: 400px;
		}

		.graph-section {
			flex: 2 1 600px;
			min-width: 300px;
		}

		/* Section Headings */
		.input-section h2,
		.graph-section h2,
		.global-uncertainty h2,
		.advanced-fit-section h2 {
			font-family: Arial, sans-serif;
			font-size: 20px;
			background-color: #ffad7a;
			color: #222;
			padding: 5px;
			border-radius: 4px;
			margin: 0 0 15px;
			text-align: center;
		}

		/* Data Table */
		.table-container {
			max-height: 300px;
			overflow-y: auto;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.data-table {
			width: 100%;
			margin-bottom: 20px;
			border-collapse: collapse;
			table-layout: auto;
		}

		.data-table th,
		.data-table td {
			text-align: center;
			padding: 8px;
			border: 1px solid #ccc;
			vertical-align: middle;
			white-space: normal;
		}

		.data-table th input {
			width: 90%;
			border: none;
			outline: none;
			font-size: 16px;
			text-align: center;
			background-color: transparent;
			padding: 4px;
		}

		.data-table th input:focus {
			border-bottom: 2px solid #6fa8dc;
		}

		.data-table .latex-display {
			margin-top: 4px;
			background-color: #f0f8ff;
			border: 1px solid #add8e6;
			padding: 6px 8px;
			border-radius: 4px;
			font-size: 14px;
			color: #333;
			max-width: 100%;
			word-wrap: break-word;
		}

		.data-table td input {
			width: 100%;
			border: none;
			outline: none;
			font-size: 14px;
			text-align: center;
			background-color: transparent;
			padding: 4px;
		}

		.data-table td input:focus {
			outline: 1px solid #6fa8dc;
		}

		.data-table tbody tr:nth-child(odd) {
			background-color: #f9f9f9;
		}

		.data-table tbody tr:nth-child(even) {
			background-color: #fff;
		}

		/* Buttons */
		/* Global button styles apply to all button elements */
		button {
			padding: 10px 15px;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			margin: 2px;
			flex: 1;
			transition: background-color 0.3s, filter 0.3s;
		}

		button:hover {
			filter: brightness(90%);
		}

		/* Specific button backgrounds */
		.btn-add-row {
			background-color: var(--add-row-btn-color);
		}

		.btn-clear-all {
			background-color: var(--clear-all-btn-color);
		}

		.btn-copy-x {
			background-color: #6aa84f;
		}

		.btn-import-csv {
			background-color: var(--import-csv-btn-color);
		}

		.btn-export-csv,
		.btn-export-md {
			background-color: var(--export-csv-btn-color);
		}

		/* Fit Buttons (full width, fixed height) */
		.fit-button {
			background-color: #6fa8dc;
			width: 100%;
			height: 40px;
			padding: 0;
			margin: 0;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		.clear-fit-button {
			background-color: #e06666;
			width: 100%;
			height: 40px;
			padding: 0;
			margin: 0;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		/* Button Containers */
		.button-container {
			display: flex;
			flex-direction: column;
			gap: 2px;
			justify-content: center;
			align-items: center;
			margin: 10px 0;
		}

		.button-row {
			display: flex;
			gap: 2px;
			width: 100%;
		}

		/* Global Uncertainty */
		.global-uncertainty {
			margin: 20px 0;
			padding: 10px;
			border-top: 1px solid #ccc;
			border-bottom: 1px solid #ccc;
		}

		.uncertainty-controls {
			display: flex;
			justify-content: center;
			gap: 20px;
		}

		.uncertainty-controls div {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.global-uncertainty-item {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 5px;
		}

		.global-uncertainty-item input {
			flex: 1;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.global-uncertainty-item input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		.global-uncertainty-item button {
			background-color: #80c1c5;
			color: #111;
			padding: 8px 12px;
			border-radius: 4px;
			font-size: 14px;
			cursor: pointer;
			transition: background-color 0.3s, filter 0.3s;
		}

		.global-uncertainty-item button:hover {
			filter: brightness(90%);
		}

		/* Advanced Fit Section */
		.advanced-fit-section {
			margin-top: 20px;
			padding: 10px;
			border-top: 1px solid #ccc;
		}

		.advanced-fit-section select,
		.advanced-fit-section .fit-method-select {
			min-width: 150px;
			max-width: 300px;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
			margin-bottom: 15px;
		}

		.advanced-fit-item {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 10px;
		}

		.advanced-fit-item label {
			white-space: nowrap;
		}

		.advanced-fit-item input {
			max-width: 200px;
			padding: 5px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.advanced-fit-item input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		/* Parameter Section */
		.parameter-section {
			display: none;
		}

		.parameter-section.active {
			display: block;
		}

		/* General Equation */
		.general-equation {
			margin: 20px 0 10px;
			background-color: #e9ecef;
			padding: 10px;
			border: 1px solid #ccc;
			border-radius: 4px;
			font-size: 16px;
			text-align: center;
		}

		/* Tabs */
		.tabs {
			display: flex;
			border-radius: 4px;
			margin-bottom: 5px;
		}

		.tabs button {
			background-color: #f3f3f3;
			border: none;
			cursor: pointer;
			padding: 8px;
			transition: background-color 0.3s, filter 0.3s;
			font-size: 16px;
			border-radius: 4px;
			color: #999;
			width: 50%;
		}

		.tabs button:hover {
			background-color: #eee;
			filter: brightness(95%);
		}

		.tabs button.active {
			background-color: #ffd966;
			color: #000;
		}

		.tab-content {
			display: none;
			padding: 15px 1px;
		}

		.tab-content.active {
			display: block;
		}

		/* Results */
		.result {
			margin-bottom: 20px;
			background-color: #f9f9f9;
			padding: 15px;
			border-radius: 8px;
		}

		.result h3 {
			margin-top: 0;
		}

		.result p {
			margin: 10px 0;
			font-size: 16px;
			overflow-x: auto;
			white-space: nowrap;
		}

		/* Plot */
		#plot {
			width: 100%;
			height: 500px;
			margin-top: 20px;
		}

		.plot-all-container {
			display: flex;
			justify-content: center;
			margin-top: 10px;
		}

		.plot-all-btn {
			padding: 8px 16px;
			background-color: #6fa8dc;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		.plot-all-btn:hover {
			filter: brightness(90%);
		}

		/* Responsive */
		@media (max-width: 900px) {
			.container {
				flex-direction: column;
			}

			.input-section,
			.graph-section {
				max-width: 100%;
				flex: none;
			}

			.banner-logo,
			.banner-buttons {
				width: auto;
			}
		}

		/* Graph Title */
		.graph-title-container {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
		}

		.graph-title-container label {
			font-size: 14px;
			font-weight: bold;
			margin-right: 10px;
		}

		.graph-title-container input {
			flex: 1;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.graph-title-container input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		/* Popup */
		#popup-background {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 1000;
		}

		#popup-container {
			position: fixed;
			top: 2%;
			width: 100%;
			height: 100%;
			background: transparent;
			z-index: 1001;
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 0;
		}

		#popup-content {
			background: #fff;
			padding: 20px;
			border-radius: 5px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			width: 100%;
			max-width: 800px;
			max-height: 90vh;
			overflow: auto;
			position: relative;
			margin: 0 auto;
		}

		#popup-title {
			font-size: 18px;
			font-weight: bold;
			margin-bottom: 3px;
			text-align: center;
		}

		#popup-plot {
			width: 100%;
			min-width: 600px;
			min-height: 400px;
			margin-top: 5px;
		}

		#popup-close {
			position: absolute;
			top: 10px;
			right: 10px;
			background: #e06666;
			color: #fff;
			border: none;
			border-radius: 2px;
			padding: 4px 8px;
			cursor: pointer;
			z-index: 1100;
		}

		#popup-close:hover {
			background: #cc5555;
		}

		/* Combined Plot Controls */
		.combined-plot-controls {
			margin-top: 10px;
			padding: 10px;
			background-color: #f5f5f5;
			border: 1px solid #ddd;
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.control-row-horizontal {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.control-row-horizontal label {
			width: 120px;
			font-weight: bold;
		}

		.control-row-horizontal input[type="text"] {
			padding: 5px;
			font-size: 1rem;
			border: 1px solid #ccc;
			border-radius: 3px;
			flex-grow: 1;
			box-sizing: border-box;
		}

		#popup-plot-container {
			margin-top: 15px;
		}

		/* Footer */
		footer {
			position: static;
			font-size: 15px;
			text-align: center;
			padding: 7px;
			background: #f4f4f4;
			color: #555;
			margin: 4px 0;
			width: 100%;
		}

		footer a {
			color: #ff5f1f;
			text-decoration: none;
		}

		footer a:hover {
			text-decoration: underline;
		}

		footer a:visited {
			color: #ff5f1f;
		}
	</style>
</head>

<body>
	<div class="banner">
		<!-- Logo on the Left -->
		<div class="banner-logo">
			<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">
				<img src="/panphy.png" alt="PanPhy logo" />
			</a>
		</div>

		<!-- Title in the Center -->
		<div class="banner-title">PanPhyPlot</div>

		<!-- Buttons on the Right -->
		<div class="banner-buttons">
			<a href="panphyplot_manual.html" class="banner-button" target="_blank" rel="noopener noreferrer">Manual</a>
		</div>
	</div>

	<div class="reminder">
		<span>Note: Headings and Title accept LaTeX input when LaTeX mode is ON.</span>
		<div class="latex-toggle-container">
			<!-- Toggle switch -->
			<label class="switch">
				<input type="checkbox" id="latex-mode-toggle">
				<span class="slider"></span>
			</label>
			<span class="toggle-label">LaTeX mode</span>
		</div>
	</div>

	<!-- Dataset Tabs Bar with "Add Dataset" button -->
	<div class="dataset-tabs-bar">
		<!-- Example initial tab -->
		<div class="dataset-tab active">
			<span class="tab-label">Dataset 1</span>
			<span class="tab-close" title="Remove dataset">×</span>
		</div>
		<!-- The Add Dataset button looks just like a tab except it keeps its own color -->
		<button class="add-dataset-btn">Add Dataset</button>
	</div>

	<!-- Main container: left = Input section, right = Graph section -->
	<div class="container">
		<!-- Input section -->
		<div class="input-section">
			<h2>Data</h2>
			<div class="table-container">
				<table class="data-table" id="data-table">
					<thead>
						<tr>
							<th>
								<input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
								<div id="x-column-latex" class="latex-display">\( x \)</div>
							</th>
							<th>
								<input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
								<div id="y-column-latex" class="latex-display">\( y \)</div>
							</th>
							<th class="error-column" id="x-error-header" style="display: none;">
								<div id="x-error-header-latex" class="latex-display">\( \pm \Delta x \)</div>
							</th>
							<th class="error-column" id="y-error-header" style="display: none;">
								<div id="y-error-header-latex" class="latex-display">\( \pm \Delta y \)</div>
							</th>
						</tr>
					</thead>
					<tbody>
						<!-- Rows inserted by JS -->
					</tbody>
				</table>
			</div>

			<div class="button-container">
				<div class="button-row">
					<button class="btn-add-row" onclick="addRow()">Add Row</button>
					<button class="btn-copy-x" onclick="copyXFromSet1()">Copy x₁</button>
					<button class="btn-clear-all" onclick="clearRows()">Clear Data</button>
				</div>
				<div class="button-row">
					<button class="btn-import-csv" onclick="document.getElementById('csv-file-input').click()">
						Import .csv
					</button>
					<button class="btn-export-csv" onclick="exportCSV()">Export .csv</button>
					<button class="btn-export-md" onclick="exportPlainText()">Export .md</button>
				</div>
			</div>
			<input type="file" id="csv-file-input" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />

			<div class="global-uncertainty">
				<h2>Uncertainties</h2>
				<div class="uncertainty-controls">
					<div>
						<label>
							<input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
							Δx
						</label>
						<select id="x-error-type" onchange="updateErrorType('x')">
							<option value="absolute">absolute</option>
							<option value="percentage">%</option>
						</select>
					</div>
					<div>
						<label>
							<input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
							Δy
						</label>
						<select id="y-error-type" onchange="updateErrorType('y')">
							<option value="absolute">absolute</option>
							<option value="percentage">%</option>
						</select>
					</div>
				</div>

				<h3>Apply Global Uncertainty</h3>
				<div class="global-uncertainty-item">
					<input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
					<button onclick="applyGlobalUncertainties('x')">Apply Δx</button>
				</div>
				<div class="global-uncertainty-item">
					<input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
					<button onclick="applyGlobalUncertainties('y')">Apply Δy</button>
				</div>
			</div>

			<div class="fit-method-section">
				<h2>Best Fit Line</h2>
				<div class="tabs">
					<button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
					<button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
				</div>

				<!-- Basic Fit -->
				<div id="BasicFit" class="tab-content active">
					<label for="fit-method">Fit Method:</label>
					<select id="fit-method" onchange="updateBasicFitEquation()">
						<option value="Linear">Linear</option>
						<option value="Polynomial-2">Quadratic</option>
						<option value="Polynomial-3">Cubic</option>
						<!-- <option value="Polynomial-4">Polynomial (4th Degree)</option> -->
						<!-- Disabled 4th Degree Polynomial due to lack of applications -->
						<option value="Exponential">Exponential</option>
						<option value="Power">Power</option>
					</select>
					<div id="basic-fit-equation" class="general-equation">
						\( y = mx + c \)
					</div>
					<div style="display: flex; gap: 6px;">
						<button class="fit-button" onclick="fitCurve()">Fit Curve</button>
						<button class="clear-fit-button" onclick="clearFittedCurve()">Clear Fit</button>
					</div>
				</div>

				<!-- Advanced Fit -->
				<div id="AdvancedFit" class="tab-content">
					<label for="advanced-fit-method">Advanced Fit Method:</label>
					<select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
						<option value="Sinusoidal">Sinusoidal</option>
						<option value="Gaussian">Gaussian</option>
					</select>
					<div id="advanced-fit-general-equation" class="general-equation">
						\( y = A e^{bx} \sin(kx - \phi) + c \)
					</div>
					<p class="table-prompt">Enter initial fitting parameters below.</p>

					<!-- Sinusoidal -->
					<div id="Sinusoidal-parameters" class="parameter-section active">
						<div class="advanced-fit-item">
							<label for="initial-A">A:</label>
							<input type="number" id="initial-A" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-b">b:</label>
							<input type="number" id="initial-b" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-k">k:</label>
							<input type="number" id="initial-k" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-phi">φ:</label>
							<input type="number" id="initial-phi" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-c">c:</label>
							<input type="number" id="initial-c" value="0" step="any" />
						</div>
					</div>

					<!-- Gaussian -->
					<div id="Gaussian-parameters" class="parameter-section">
						<div class="advanced-fit-item">
							<label for="initial-A-gaussian">A:</label>
							<input type="number" id="initial-A-gaussian" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-mu">μ:</label>
							<input type="number" id="initial-mu" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-sigma">σ:</label>
							<input type="number" id="initial-sigma" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-c-gaussian">c:</label>
							<input type="number" id="initial-c-gaussian" value="0" step="any" />
						</div>
					</div>

					<div style="display: flex; gap: 6px;">
						<button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
						<button class="clear-fit-button" onclick="clearFittedCurve()">Clear Fit</button>
					</div>
				</div>
			</div>
		</div><!-- end input-section -->

		<!-- Graph section -->
		<div class="graph-section">
			<h2>Graph</h2>
			<div class="graph-title-container">
				<label for="graph-title">Title:</label>
				<input type="text" id="graph-title" placeholder="Enter graph title" oninput="debouncedUpdatePlotAndRenderLatex()">
			</div>
			<div id="plot"></div>

			<div class="result">
				<h3>Fitting Result</h3>
				<p id="fit-equation" style="display: none;"></p>
				<p id="r-squared-container" style="display: none;"></p>
			</div>

			<div class="plot-all-container">
				<button class="plot-all-btn" onclick="plotAllDatasets()">Plot ALL Datasets</button>
			</div>
		</div><!-- end graph-section -->
	</div><!-- end container -->

	<!-- Transparent background for the popup -->
	<div id="popup-background" style="display: none;"></div>

	<div id="popup-container" style="display: none;">
		<div id="popup-content">
			<button id="popup-close" onclick="closePopup()">Close</button>
			<div id="popup-title">Combined Plot of All Datasets</div>
			<div id="popup-plot-container">
				<div id="popup-plot"></div>
			</div>
			<div id="combined-plot-controls" class="combined-plot-controls">
				<div class="control-row-horizontal">
					<label for="combined-title">Title:</label>
					<input type="text" id="combined-title" placeholder="Enter a new Title here" />
				</div>
				<div class="control-row-horizontal">
					<label for="combined-x-label">x-axis Label:</label>
					<input type="text" id="combined-x-label" placeholder="Enter a new x-axis label here" />
				</div>
				<div class="control-row-horizontal">
					<label for="combined-y-label">y-axis Label:</label>
					<input type="text" id="combined-y-label" placeholder="Enter a new y-axis label here" />
				</div>
			</div>
		</div>
	</div>

	<footer>
		&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

<script>
	let rawData = []; // Each element will be an array of data points
	let activeSet = 0; // Index of the current active dataset
	let datasetHeaders = {}; // Object to store headers per dataset, e.g. {0: {x: 'x', y: 'y'}, 1: {x: 'Time', y: 'Distance'}}
	let datasetToggles = {}; // Global object to hold fitted curves by dataset index.
	let datasetErrorTypes = {}; // stores the error type per axis per dataset, e.g. { 0: { x: 'absolute', y: 'absolute' }, 1: { x: 'percentage', y: 'percentage' } }
	let fittedCurves = {};
	let datasetFitResults = {}; // e.g. { 0: { equation: "...", rSquared: "..." }, 1: { ... } }
	let dataset1XValues = [];
	let latexMode = false; // false by default: plain text mode
	let titleWasAuto = true; // track whether graph title should auto-update

	let lastPlotState = {
		data: null,
		layout: null
	};

	rawData.push([]);
	datasetHeaders[0] = { x: 'x', y: 'y' }; // At initialization, for dataset 0:
	datasetToggles[0] = { x: false, y: false };
	datasetErrorTypes[0] = { x: 'absolute', y: 'absolute' };

	let isSyncing = false;

	function debounce(func, wait) {
		let timeout;
		return function(...args) {
			const later = () => {
				clearTimeout(timeout);
				func.apply(this, args);
			};
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
		};
	}

	const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);
	const debouncedUpdateData = debounce(updateData, 300);


	function processLabel(label) {
		if (!label) return '';
		if (!latexMode) return label;
		// Plotly/MathJax rendering uses $...$ delimiters.
		return '$' + formatLabelForLatex(label) + '$';
	}


	function initializeTable(initialRows = 7) {
		const tableBody = document.querySelector('#data-table tbody');
		// Create the default empty rows
		for (let i = 0; i < initialRows; i++) {
			const newRow = tableBody.insertRow();
			newRow.innerHTML = `
            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0"></td>
            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0"></td>
            <td class="error-column" style="display: none;">
                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()" />
            </td>
            <td class="error-column" style="display: none;">
                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()" />
            </td>
        `;
		}
		// Update the active dataset with the new (empty) rows.
		updateData();
	}

	// Function to update the tabs bar UI
	function updateDatasetTabsBar() {
		const tabsBar = document.querySelector('.dataset-tabs-bar');
		if (!tabsBar) return;

		// Clear all tabs except the Add Dataset button.
		const existingTabs = Array.from(tabsBar.querySelectorAll('.dataset-tab'));
		existingTabs.forEach(tab => tab.remove());

		// For each dataset, create a tab element.
		rawData.forEach((dataset, index) => {
			const tab = document.createElement('div');
			tab.classList.add('dataset-tab');
			if (index === activeSet) {
				tab.classList.add('active');
			}
			// Create a span for the label (e.g., "Dataset 1")
			const labelSpan = document.createElement('span');
			labelSpan.classList.add('tab-label');
			labelSpan.textContent = `Dataset ${index + 1}`;
			tab.appendChild(labelSpan);

			// Create the close button. (Do not add a close icon if there is only one dataset.)
			if (rawData.length > 1) {
				const closeSpan = document.createElement('span');
				closeSpan.classList.add('tab-close');
				closeSpan.textContent = '×';
				// When the close button is clicked, remove this dataset.
				closeSpan.addEventListener('click', function(e) {
					// prevent the click from also firing the tab-switch event
					e.stopPropagation();
					removeDataset(index);
				});
				tab.appendChild(closeSpan);
			}

			// Clicking on a tab should switch to that dataset.
			tab.addEventListener('click', function() {
				switchDataset(index);
			});

			// Insert the new tab before the Add Dataset button.
			// (We assume the Add Dataset button remains as the last element.)
			const addBtn = tabsBar.querySelector('.add-dataset-btn');
			tabsBar.insertBefore(tab, addBtn);
		});
	}

	function switchDataset(index) {
		if (index < 0 || index >= rawData.length) {
			console.error("Invalid dataset index.");
			return;
		}
		activeSet = index;
		titleWasAuto = true;
		updateDatasetTabsBar();

		// Repopulate the table UI with data from the active dataset.
		populateTableFromActiveDataset();

		// Load header values for this dataset.
		loadHeaders();

		// Restore uncertainty toggle state.
		loadToggles();

		// Restore error type settings.
		loadErrorTypes();

		// Update the graph and LaTeX-rendered labels.
		updatePlotAndRenderLatex();
		updateLabels('x');
		updateLabels('y');

		// Update the combined plot input boxes with the active dataset’s header values.
		updateCombinedPlotInputsToActive();

		// Restore or clear the fitting result for the current dataset.
		const fitEquationElement = document.getElementById('fit-equation');
		const rSquaredElement = document.getElementById('r-squared-container');
		if (datasetFitResults.hasOwnProperty(activeSet)) {
			const result = datasetFitResults[activeSet];
			fitEquationElement.innerHTML = `\\(${result.equation}\\)`;
			fitEquationElement.style.display = 'block';
			rSquaredElement.innerHTML = `\\( R^2 = ${result.rSquared} \\)`;
			rSquaredElement.style.display = 'block';
			safeTypeset(fitEquationElement);
			safeTypeset(rSquaredElement);
		} else {
			fitEquationElement.style.display = 'none';
			fitEquationElement.innerHTML = '';
			rSquaredElement.style.display = 'none';
			rSquaredElement.innerHTML = '';
		}
	}

	function populateTableFromActiveDataset() {
		const tableBody = document.querySelector('#data-table tbody');
		tableBody.innerHTML = ''; // Clear current table

		// For the active dataset, get its stored raw data.
		let dataset = rawData[activeSet] || [];

		// For Dataset 1: if rawData is empty but we have stored x-values, rebuild the table from them.
		if (activeSet === 0 && dataset.length === 0 && dataset1XValues && dataset1XValues.length > 0) {
			dataset1XValues.forEach(xVal => {
				const newRow = tableBody.insertRow();
				newRow.innerHTML = `
                <td>
                    <input type="text" class="x-input"
                           onkeydown="navigateTable(event)"
                           oninput="debouncedUpdateData()"
                           placeholder="0"
                           value="${xVal}">
                </td>
                <td>
                    <input type="text" class="y-input"
                           onkeydown="navigateTable(event)"
                           oninput="debouncedUpdateData()"
                           placeholder="0"
                           value="">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="x-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="debouncedUpdateData()"
                           value="">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="y-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="debouncedUpdateData()"
                           value="">
                </td>
            `;
			});
			return;
		}

		// For other datasets (or if set 1 already has valid data), build rows from rawData.
		if (dataset.length > 0) {
			dataset.forEach(point => {
				const newRow = tableBody.insertRow();
				newRow.innerHTML = `
                <td>
                    <input type="text" class="x-input"
                           onkeydown="navigateTable(event)"
                           oninput="debouncedUpdateData()"
                           placeholder="0"
                           value="${point.x}">
                </td>
                <td>
                    <input type="text" class="y-input"
                           onkeydown="navigateTable(event)"
                           oninput="debouncedUpdateData()"
                           placeholder="0"
                           value="${point.y !== null ? point.y : ''}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="x-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="debouncedUpdateData()"
                           value="${point.xErrorRaw || ''}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="y-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="debouncedUpdateData()"
                           value="${point.yErrorRaw || ''}">
                </td>
            `;
			});
		} else {
			// If there is no data in the active dataset, initialize default rows.
			initializeTable();
		}
	}

	// Function to add a new dataset
	function addDataset() {
		// Add a new empty dataset to rawData.
		rawData.push([]);

		// Then switch to the newly added dataset.
		activeSet = rawData.length - 1;
		updateDatasetTabsBar();

		// Now clear the UI for the active dataset 
		// (clearRows() will create new empty rows since rawData[activeSet] is empty)
		clearRows();

		// Update the rest of the UI to reflect the new active dataset.
		updateData();
		updatePlotAndRenderLatex();
	}

	function removeDataset(index) {
		if (rawData.length <= 1) {
			alert("You must keep at least one dataset.");
			return;
		}

		// Remove this dataset from rawData.
		rawData.splice(index, 1);

		// Reindex the global objects so they match the new rawData order.
		// IMPORTANT: Pass the removed index.
		reindexDatasets(index);

		// Fix activeSet if it's now out of range
		if (activeSet >= rawData.length) {
			activeSet = rawData.length - 1;
		}

		// Rebuild UI and re-plot
		updateDatasetTabsBar();
		switchDataset(activeSet);
		updatePlotAndRenderLatex();
	}

	// Attach the Add Dataset button click event
	function initializeDatasetTabsBar() {
		const addBtn = document.querySelector('.add-dataset-btn');
		if (addBtn) {
			addBtn.addEventListener('click', addDataset);
		}
		// Build the initial tabs UI.
		updateDatasetTabsBar();
	}

	function addRow() {
		const tableBody = document.querySelector('#data-table tbody');
		const newRow = tableBody.insertRow();
		newRow.innerHTML = `
                <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0"></td>
                <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0"></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()" /></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()" /></td>
            `;
		updateData();
	}

	function clearRows(resetHeaders = true) {
		const tableBody = document.querySelector('#data-table tbody');
		tableBody.innerHTML = '';

		// Empty out the active dataset’s raw data
		rawData[activeSet] = [];

		if (resetHeaders) {
			isSyncing = true;
			// Reset header inputs to defaults
			document.getElementById('x-column-name').value = 'x';
			document.getElementById('y-column-name').value = 'y';
			// Keep per-dataset headers in sync
			if (!datasetHeaders[activeSet]) datasetHeaders[activeSet] = { x: 'x', y: 'y' };
			datasetHeaders[activeSet].x = 'x';
			datasetHeaders[activeSet].y = 'y';
			document.getElementById('graph-title').value = 'y vs x';
			titleWasAuto = true;
			renderLatex('#x-column-latex', 'x');
			renderLatex('#y-column-latex', 'y');
			updateGraphTitle();
			isSyncing = false;

			// Only re-initialize default rows if we truly want a full reset
			initializeTable();
		}

		// Turn off uncertainties and hide their columns
		document.getElementById('toggle-x-error').checked = false;
		toggleErrorColumn('x');
		document.getElementById('toggle-y-error').checked = false;
		toggleErrorColumn('y');

		// Reset advanced-fit parameters
		setInitialParameters(getCurrentAdvancedFitMethod());

		// Update the combined-plot inputs to default headings
		updateCombinedPlotInputsToActive();

		// Re-draw the plot (with no data points). The old fit may still appear
		updatePlotAndRenderLatex();
	}

	function copyXFromSet1() {
		if (!dataset1XValues || dataset1XValues.length === 0) {
			alert("Dataset 1 does not contain any valid x values yet.");
			return;
		}
		const sourceX = dataset1XValues;
		const tableBody = document.querySelector('#data-table tbody');
		let rows = tableBody.querySelectorAll('tr');
		const missingCount = sourceX.length - rows.length;

		// If there are missing rows, create them in one batch.
		if (missingCount > 0) {
			let newRowsHTML = '';
			const toggleXError = document.getElementById('toggle-x-error').checked;
			const toggleYError = document.getElementById('toggle-y-error').checked;
			// Build the HTML string for the missing rows.
			for (let i = 0; i < missingCount; i++) {
				newRowsHTML += `
                <tr>
                    <td>
                        <input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0">
                    </td>
                    <td>
                        <input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="debouncedUpdateData()" placeholder="0">
                    </td>
                    <td class="error-column" style="display: ${toggleXError ? 'table-cell' : 'none'};">
                        <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()">
                    </td>
                    <td class="error-column" style="display: ${toggleYError ? 'table-cell' : 'none'};">
                        <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="debouncedUpdateData()">
                    </td>
                </tr>
            `;
			}
			// Insert all missing rows at once.
			tableBody.insertAdjacentHTML('beforeend', newRowsHTML);
			// Requery the rows after insertion.
			rows = tableBody.querySelectorAll('tr');
		}

		// Update all x-inputs in one go.
		const xInputs = tableBody.querySelectorAll('.x-input');
		for (let i = 0; i < sourceX.length; i++) {
			if (xInputs[i]) {
				xInputs[i].value = sourceX[i];
			}
		}

		// Update the underlying data and replot.
		updateData();
		updatePlotAndRenderLatex();
	}

	function clearFittedCurve() {
		// Remove any stored fit results from datasetFitResults
		if (datasetFitResults.hasOwnProperty(activeSet)) {
			delete datasetFitResults[activeSet];
		}

		// Remove the fitted curve from fittedCurves
		if (fittedCurves.hasOwnProperty(activeSet)) {
			delete fittedCurves[activeSet];
		}

		// Clear any displayed equation/R² from the UI
		const fitEquationElement = document.getElementById('fit-equation');
		const rSquaredElement = document.getElementById('r-squared-container');
		if (fitEquationElement) {
			fitEquationElement.style.display = 'none';
			fitEquationElement.innerHTML = '';
		}
		if (rSquaredElement) {
			rSquaredElement.style.display = 'none';
			rSquaredElement.innerHTML = '';
		}

		// Force a re-plot so that the old line is removed
		lastPlotState.data = null;
		lastPlotState.layout = null;

		// Now re-draw with no line but the same data
		updatePlotAndRenderLatex();
	}

	/**
	 * Synchronize the combined-plot input boxes (Title, x-label, y-label)
	 * with the current active dataset's raw headings. No extra '$' delimiter.
	 */
	function updateCombinedPlotInputsToActive() {
		const rawTitle = document.getElementById('graph-title').value || 'y vs x';
		const rawXLabel = document.getElementById('x-column-name').value || 'x';
		const rawYLabel = document.getElementById('y-column-name').value || 'y';

		const titleInput = document.getElementById('combined-title');
		const xLabelInput = document.getElementById('combined-x-label');
		const yLabelInput = document.getElementById('combined-y-label');

		if (titleInput) {
			titleInput.value = rawTitle;
		}
		if (xLabelInput) {
			xLabelInput.value = rawXLabel;
		}
		if (yLabelInput) {
			yLabelInput.value = rawYLabel;
		}
	}

	function navigateTable(event) {
		const key = event.key;
		const currentInput = event.target;

		const currentCell = currentInput.parentElement;
		const currentRow = currentCell.parentElement;
		const table = currentRow.parentElement.parentElement;
		const rows = Array.from(table.querySelectorAll('tbody tr'));
		const rowIndex = rows.indexOf(currentRow);
		const cells = Array.from(currentRow.children);
		const colIndex = cells.indexOf(currentCell);

		let targetRow = rowIndex;
		let targetCol = colIndex;

		switch (key) {
			case 'Enter':
				event.preventDefault();
				targetRow = rowIndex + 1;
				targetCol = colIndex;
				break;
			case 'ArrowRight':
				event.preventDefault();
				targetCol = colIndex + 1;
				break;
			case 'ArrowLeft':
				event.preventDefault();
				targetCol = colIndex - 1;
				break;
			case 'ArrowDown':
				event.preventDefault();
				targetRow = rowIndex + 1;
				break;
			case 'ArrowUp':
				event.preventDefault();
				targetRow = rowIndex - 1;
				break;
			default:
				return;
		}

		if (targetRow < 0) targetRow = 0;
		if (targetRow >= rows.length) targetRow = rows.length - 1;
		if (targetCol < 0) targetCol = 0;
		if (targetCol >= cells.length) targetCol = cells.length - 1;

		const targetCell = rows[targetRow].children[targetCol];
		const targetInput = targetCell.querySelector('input');

		if (targetInput && targetInput.offsetParent !== null) {
			targetInput.focus();
		}
	}

	function toggleErrorColumn(axis) {
		// Get the checkbox element and its state.
		const checkBox = document.getElementById(`toggle-${axis}-error`);
		const state = checkBox.checked;

		// Ensure the toggles object exists for the current dataset.
		if (!datasetToggles[activeSet]) {
			datasetToggles[activeSet] = { x: false, y: false };
		}
		datasetToggles[activeSet][axis] = state;

		// Update the UI for the active dataset.
		const errorHeader = document.getElementById(`${axis}-error-header`);
		const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

		if (state) {
			errorHeader.style.display = 'table-cell';
			updateUncertaintyHeaders(axis);
			errorInputs.forEach((input) => {
				const errorCell = input.parentElement;
				if (errorCell) {
					errorCell.style.display = 'table-cell';
				}
			});
		} else {
			errorHeader.style.display = 'none';
			errorInputs.forEach((input) => {
				const errorCell = input.parentElement;
				if (errorCell) {
					errorCell.style.display = 'none';
					input.value = '';
				}
			});
		}

		updateData();
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function loadToggles() {
		const toggles = datasetToggles[activeSet] || { x: false, y: false };

		document.getElementById('toggle-x-error').checked = toggles.x;
		document.getElementById('toggle-y-error').checked = toggles.y;

		// Update x error column:
		const xErrorHeader = document.getElementById('x-error-header');
		const xErrorInputs = document.querySelectorAll('.x-error-input');
		if (toggles.x) {
			xErrorHeader.style.display = 'table-cell';
			xErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'table-cell';
				}
			});
		} else {
			xErrorHeader.style.display = 'none';
			xErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'none';
				}
			});
		}

		// Update y error column:
		const yErrorHeader = document.getElementById('y-error-header');
		const yErrorInputs = document.querySelectorAll('.y-error-input');
		if (toggles.y) {
			yErrorHeader.style.display = 'table-cell';
			yErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'table-cell';
				}
			});
		} else {
			yErrorHeader.style.display = 'none';
			yErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'none';
				}
			});
		}
	}

	function reindexDatasets(removedIndex) {
		// SHIFT each object from j+1 to j, for all j >= removedIndex
		for (let j = removedIndex; j < rawData.length; j++) {

			// datasetHeaders
			if (datasetHeaders.hasOwnProperty(j + 1)) {
				datasetHeaders[j] = datasetHeaders[j + 1];
			} else {
				delete datasetHeaders[j];
			}

			// datasetToggles
			if (datasetToggles.hasOwnProperty(j + 1)) {
				datasetToggles[j] = datasetToggles[j + 1];
			} else {
				delete datasetToggles[j];
			}

			// datasetErrorTypes
			if (datasetErrorTypes.hasOwnProperty(j + 1)) {
				datasetErrorTypes[j] = datasetErrorTypes[j + 1];
			} else {
				delete datasetErrorTypes[j];
			}

			// datasetFitResults
			if (datasetFitResults.hasOwnProperty(j + 1)) {
				datasetFitResults[j] = datasetFitResults[j + 1];
			} else {
				delete datasetFitResults[j];
			}

			// fittedCurves
			if (fittedCurves.hasOwnProperty(j + 1)) {
				fittedCurves[j] = fittedCurves[j + 1];
			} else {
				delete fittedCurves[j];
			}
		}

		// Then delete the old "last" index which no longer corresponds to a dataset
		const lastIndex = rawData.length;
		delete datasetHeaders[lastIndex];
		delete datasetToggles[lastIndex];
		delete datasetErrorTypes[lastIndex];
		delete datasetFitResults[lastIndex];
		delete fittedCurves[lastIndex];
	}

	function updateUncertaintyHeaders(axis) {
		const columnName = document.getElementById(`${axis}-column-name`).value.trim() || (axis === 'x' ? 'x' : 'y');
		const errorType = document.getElementById(`${axis}-error-type`).value;

		let headerLatex = `\\pm \\Delta ${formatLabelForLatex(columnName)}`;
		let headerText = `\\( ${headerLatex} \\)`;
		if (errorType === 'percentage') {
			headerText += ' (%)';
		}

		const headerElement = document.getElementById(`${axis}-error-header-latex`);
		if (headerElement) {
			headerElement.textContent = headerText;
			safeTypeset(headerElement);
		}
	}


	function updateErrorType(axis) {
		// Get the selected error type from the dropdown.
		const errorType = document.getElementById(`${axis}-error-type`).value;

		// Ensure the error type object exists for the current dataset.
		if (!datasetErrorTypes[activeSet]) {
			datasetErrorTypes[activeSet] = { x: 'absolute', y: 'absolute' };
		}
		datasetErrorTypes[activeSet][axis] = errorType;

		// If uncertainty is enabled for this axis, update the uncertainty header.
		if (document.getElementById(`toggle-${axis}-error`).checked) {
			updateUncertaintyHeaders(axis);
		}

		updateData();
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function loadErrorTypes() {
		const xErrorTypeElement = document.getElementById('x-error-type');
		const yErrorTypeElement = document.getElementById('y-error-type');

		// Use stored error types or fallback to 'absolute'
		const currentXErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].x) || 'absolute';
		const currentYErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].y) || 'absolute';

		if (xErrorTypeElement) {
			xErrorTypeElement.value = currentXErrorType;
		}
		if (yErrorTypeElement) {
			yErrorTypeElement.value = currentYErrorType;
		}

		// Ensure the uncertainty header is updated accordingly.
		updateUncertaintyHeaders('x');
		updateUncertaintyHeaders('y');
	}

	function isPlotStateEqual(newData, newLayout) {
		// Simple approach: compare JSON strings.
		// Note: This works fine for small to moderate data sets.
		const currentDataStr = JSON.stringify(lastPlotState.data);
		const newDataStr = JSON.stringify(newData);
		const currentLayoutStr = JSON.stringify(lastPlotState.layout);
		const newLayoutStr = JSON.stringify(newLayout);
		return currentDataStr === newDataStr && currentLayoutStr === newLayoutStr;
	}

	function handleCSVUpload(event) {
		const file = event.target.files[0];
		if (!file) return;

		const reader = new FileReader();
		reader.onload = function(e) {
			const text = e.target.result;

			// **Clear the fitted curve for the active dataset**
			if (fittedCurves.hasOwnProperty(activeSet)) {
				delete fittedCurves[activeSet];
				console.log(`Fitted curve for Dataset ${activeSet + 1} has been cleared.`);
			}

			// **Parse the CSV and update the data**
			parseCSV(text);
		};
		reader.onerror = function() {
			alert('Error reading the file!');
		};
		reader.readAsText(file);
	}

	function parseCSVLine(line) {
		const result = [];
		let current = '';
		let inQuotes = false;

		for (let i = 0; i < line.length; i++) {
			const char = line[i];
			if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
				inQuotes = !inQuotes;
			} else if (char === ',' && !inQuotes) {
				result.push(current.trim());
				current = '';
			} else {
				current += char;
			}
		}
		result.push(current.trim());
		return result;
	}

	function parseCSV(text) {
		const lines = text.trim().split(/\r?\n/).filter(l => l.trim() !== '');
		if (lines.length < 2) {
			alert('CSV file must contain at least two rows (headers and one data row).');
			return;
		}

		// 1) Parse headers
		const headers = parseCSVLine(lines[0]);
		if (headers.length < 2) {
			alert('CSV file must have at least two columns.');
			return;
		}

		// Determine if the CSV has X and Y errors
		const hasXError = headers.length >= 3;
		const hasYError = headers.length >= 4;

		// 2) Store headers for the active dataset and update the UI
		isSyncing = true;
		if (!datasetHeaders[activeSet]) datasetHeaders[activeSet] = { x: 'x', y: 'y' };
		datasetHeaders[activeSet].x = headers[0];
		datasetHeaders[activeSet].y = headers[1];
		loadHeaders();
		isSyncing = false;

		// Clear existing rows for this dataset without resetting headers
		clearRows(false);

		// Set the uncertainty toggles to match the CSV's columns
		document.getElementById('toggle-x-error').checked = hasXError;
		document.getElementById('toggle-y-error').checked = hasYError;

		if (!datasetToggles[activeSet]) datasetToggles[activeSet] = { x: false, y: false };
		datasetToggles[activeSet].x = hasXError;
		datasetToggles[activeSet].y = hasYError;

		// 3) Build the new rows
		const dataRows = lines.slice(1);
		const tableBody = document.querySelector('#data-table tbody');
		const fragment = document.createDocumentFragment();

		const makeInput = (className, value, placeholder) => {
			const input = document.createElement('input');
			input.type = 'text';
			input.className = className;
			input.placeholder = placeholder;
			input.value = value || '';
			input.addEventListener('keydown', navigateTable);
			input.addEventListener('input', debouncedUpdateData);
			return input;
		};

		for (let i = 0; i < dataRows.length; i++) {
			const rowData = parseCSVLine(dataRows[i]);
			const tr = document.createElement('tr');

			// x cell
			const tdX = document.createElement('td');
			tdX.appendChild(makeInput('x-input', rowData[0], '0'));
			tr.appendChild(tdX);

			// y cell
			const tdY = document.createElement('td');
			tdY.appendChild(makeInput('y-input', rowData[1], '0'));
			tr.appendChild(tdY);

			// X-error cell
			const tdXErr = document.createElement('td');
			tdXErr.className = 'error-column x-error-td';
			if (!hasXError) tdXErr.style.display = 'none';
			tdXErr.appendChild(makeInput('x-error-input', rowData[2], '±0'));
			tr.appendChild(tdXErr);

			// Y-error cell
			const tdYErr = document.createElement('td');
			tdYErr.className = 'error-column y-error-td';
			if (!hasYError) tdYErr.style.display = 'none';
			tdYErr.appendChild(makeInput('y-error-input', rowData[3], '±0'));
			tr.appendChild(tdYErr);

			fragment.appendChild(tr);
		}

		// 4) Replace the old table rows with our newly built fragment
		tableBody.innerHTML = '';
		tableBody.appendChild(fragment);

		// 5) Re-apply uncertainty toggle display logic and update plot
		toggleErrorColumn('x');
		toggleErrorColumn('y');
		updateData();
		setInitialParameters(getCurrentAdvancedFitMethod());
	}


	function loadHeaders() {
		// Use stored headers for the active dataset if available; otherwise, use defaults.
		const headers = datasetHeaders[activeSet] || { x: 'x', y: 'y' };

		document.getElementById('x-column-name').value = headers.x;
		document.getElementById('y-column-name').value = headers.y;

		// Render headings according to current LaTeX mode.
		renderLatex('#x-column-latex', headers.x);
		renderLatex('#y-column-latex', headers.y);

		updateGraphTitle();
	}


	function updateLabels(type) {
		if (isSyncing) return;
		isSyncing = true;

		const value = document.getElementById(`${type}-column-name`).value;

		// Persist headers per dataset.
		if (!datasetHeaders[activeSet]) datasetHeaders[activeSet] = { x: 'x', y: 'y' };
		datasetHeaders[activeSet][type] = value;

		// Update the displayed label (plain or LaTeX).
		renderLatex(`#${type}-column-latex`, value);

		// Debounced update of the plot.
		debouncedUpdatePlotAndRenderLatex();
		isSyncing = false;

		// Dynamically update the graph title, but do not override a user-edited title.
		updateGraphTitle();

		// Update any other elements that depend on the headers.
		setInitialParameters(getCurrentAdvancedFitMethod());
		updateCombinedPlotInputsToActive();
	}


	function safeTypeset(target) {
		try {
			if (typeof MathJax === 'undefined' || !MathJax.Hub || !MathJax.Hub.Queue) return;
			const el = (typeof target === 'string') ? document.querySelector(target) : target;
			if (!el) return;
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, el]);
		} catch (e) {
			console.warn('MathJax typeset skipped:', e);
		}
	}

	function renderLatex(elementId, rawString) {
		const element = document.querySelector(elementId);
		if (!element) return;

		const str = (rawString === undefined || rawString === null) ? '' : String(rawString);

		if (!latexMode) {
			// Plain mode: show raw text exactly.
			element.textContent = str;
			return;
		}

		// LaTeX mode: format spacing and typeset.
		const latex = formatLabelForLatex(str);
		element.textContent = `\\(${latex}\\)`;
		safeTypeset(element);
	}


	function updatePlotAndRenderLatex() {
		if (isSyncing) return;
		isSyncing = true;

		// Replot the graph.
		plotGraph();

		// Retrieve current column names.
		const xColumnName = document.getElementById('x-column-name').value || 'x';
		const yColumnName = document.getElementById('y-column-name').value || 'y';

		// Update the axis label elements according to current mode.
		renderLatex('#x-column-latex', xColumnName);
		renderLatex('#y-column-latex', yColumnName);

		isSyncing = false;
	}


	function openTab(evt, tabName) {
		const tablinks = document.getElementsByClassName("tablink");
		const tabContents = document.getElementsByClassName("tab-content");

		for (let i = 0; i < tablinks.length; i++) {
			tablinks[i].classList.remove("active");
		}

		for (let i = 0; i < tabContents.length; i++) {
			tabContents[i].classList.remove("active");
		}

		document.getElementById(tabName).classList.add("active");
		evt.currentTarget.classList.add("active");

		if (tabName === 'BasicFit') {
			safeTypeset(document.getElementById('basic-fit-equation'));
		} else if (tabName === 'AdvancedFit') {
			changeAdvancedFitMethod();
			safeTypeset(document.getElementById('advanced-fit-general-equation'));
		}
	}


	function updateGraphTitle(force = false) {
		const xColumn = document.getElementById('x-column-name').value || 'x';
		const yColumn = document.getElementById('y-column-name').value || 'y';
		const autoTitle = latexMode ? `${yColumn} \\text{vs} ${xColumn}` : `${yColumn} vs ${xColumn}`;

		const titleInput = document.getElementById('graph-title');
		if (!titleInput) return;

		const current = (titleInput.value || '').trim();
		if (force || titleWasAuto || current === '') {
			titleInput.value = autoTitle;
			titleWasAuto = true;
		}
	}


	function plotGraph(fittedX = null, fittedY = null) {
		// If fitted data is not provided and a fit exists, use that.
		if ((fittedX === null || fittedY === null) && fittedCurves.hasOwnProperty(activeSet)) {
			fittedX = fittedCurves[activeSet].x;
			fittedY = fittedCurves[activeSet].y;
		}

		// Build the data arrays based on the active dataset.
		const x = rawData[activeSet].map(point => point.x);
		const y = rawData[activeSet].map(point => point.y);
		const xErrorRaw = rawData[activeSet].map(point => point.xErrorRaw || 0);
		const yErrorRaw = rawData[activeSet].map(point => point.yErrorRaw || 0);
		const xErrorType = document.getElementById('toggle-x-error').checked ?
			document.getElementById('x-error-type').value :
			'absolute';
		const yErrorType = document.getElementById('toggle-y-error').checked ?
			document.getElementById('y-error-type').value :
			'absolute';

		// Convert errors if using percentage uncertainties.
		const convertedXError = x.map((xi, idx) =>
			xErrorType === 'percentage' ? (xErrorRaw[idx] / 100) * (xi || 0) : xErrorRaw[idx]
		);
		const convertedYError = y.map((yi, idx) =>
			yErrorType === 'percentage' ? (yErrorRaw[idx] / 100) * (yi || 0) : yErrorRaw[idx]
		);

		// Build the primary data trace.
		const data = [{
			x: x,
			y: y,
			mode: 'markers',
			name: 'Data',
			marker: {
				color: '#ff7c23',
				symbol: 'circle',
				size: 6.5,
				line: { width: 0 }
			},
			error_x: {
				type: 'data',
				array: convertedXError,
				visible: document.getElementById('toggle-x-error').checked,
				color: '#5b5b5b',
				thickness: 0.8,
				width: 2
			},
			error_y: {
				type: 'data',
				array: convertedYError,
				visible: document.getElementById('toggle-y-error').checked,
				color: '#5b5b5b',
				thickness: 0.8,
				width: 2
			}
		}];

		// Add fitted curve trace if available.
		if (fittedX && fittedY) {
			data.push({
				x: fittedX,
				y: fittedY,
				mode: 'lines',
				name: 'Fit',
				line: { color: '#35a8ff' }
			});
		}

		// Retrieve the title from the input; if blank, use an empty string.
		const rawTitle = document.getElementById('graph-title').value.trim();
		const titleText = rawTitle === '' ? '' : processLabel(rawTitle);

		// Build the layout.
		const layout = {
			xaxis: {
				title: processLabel(document.getElementById('x-column-name').value || 'x')
			},
			yaxis: {
				title: {
					text: processLabel(document.getElementById('y-column-name').value || 'y'),
					standoff: 25
				},
				titlefont: { size: 14 },
				automargin: true
			},
			title: titleText,
			margin: {
				t: rawTitle === '' ? 50 : 100, // Optionally reduce top margin when title is blank.
				b: 80,
				l: 85,
				r: 30
			}
		};

		// Only replot if the new state is different.
		if (isPlotStateEqual(data, layout)) {
			console.log("No changes in plot state; skipping update.");
			return;
		}

		// Update the plot.
		Plotly.react('plot', data, layout, {
			toImageButtonOptions: {
				format: 'svg',
				filename: 'data_plot',
				scale: 1
			}
		});

		// Cache the current state.
		lastPlotState.data = data;
		lastPlotState.layout = layout;
	}

	function plotAllDatasets() {
		const traces = [];

		// Define colors for datasets and fitted curves.
		const datasetColors = ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e74c3c', '#1abc9c'];
		const fitColors = ['#a7d7f2', '#a2e4b8', '#d5a4e2', '#f9e79f', '#f5a4a4', '#a0e7d1'];

		// Helper: get the per-dataset y label (raw), with a sensible fallback.
		function getDatasetYLabelRaw(i) {
			const raw = (datasetHeaders[i] && datasetHeaders[i].y != null) ? String(datasetHeaders[i].y).trim() : '';
			return raw !== '' ? raw : `Dataset ${i + 1}`;
		}

		// Helper: build fit legend label that also supports LaTeX mode.
		function getFitLegendName(i, yRaw) {
			if (!latexMode) return `Fit: ${yRaw}`;
			// Put "Fit:" in text mode, then the y label in math mode (still inside the same $...$).
			return '$\\text{Fit: }' + formatLabelForLatex(yRaw) + '$';
		}

		// Build traces for each dataset.
		rawData.forEach((dataset, index) => {
			const xVals = dataset.map(point => point.x).filter(v => Number.isFinite(v));
			const yVals = dataset.map(point => point.y).filter(v => Number.isFinite(v));

			// Convert uncertainties.
			const xErrorsRaw = dataset.map(point => point.xErrorRaw || 0);
			const yErrorsRaw = dataset.map(point => point.yErrorRaw || 0);
			const errorTypes = datasetErrorTypes[index] || { x: 'absolute', y: 'absolute' };

			const xErrorsConverted = xVals.map((xVal, i) =>
				errorTypes.x === 'percentage' ? (xErrorsRaw[i] / 100) * (xVal || 0) : xErrorsRaw[i]
			);
			const yErrorsConverted = yVals.map((yVal, i) =>
				errorTypes.y === 'percentage' ? (yErrorsRaw[i] / 100) * (yVal || 0) : yErrorsRaw[i]
			);

			const toggles = datasetToggles[index] || { x: false, y: false };

			// Legend label for this dataset should be its y label (supports LaTeX).
			const yLabelRaw = getDatasetYLabelRaw(index);
			const legendName = processLabel(yLabelRaw);

			// Marker trace.
			traces.push({
				x: xVals,
				y: yVals,
				mode: 'markers',
				name: legendName,
				marker: {
					size: 6.5,
					color: datasetColors[index % datasetColors.length]
				},
				error_x: {
					type: 'data',
					array: xErrorsConverted,
					visible: !!toggles.x,
					color: datasetColors[index % datasetColors.length],
					thickness: 0.8,
					width: 2
				},
				error_y: {
					type: 'data',
					array: yErrorsConverted,
					visible: !!toggles.y,
					color: datasetColors[index % datasetColors.length],
					thickness: 0.8,
					width: 2
				}
			});

			// Fitted curve trace, if available.
			if (fittedCurves.hasOwnProperty(index)) {
				const fitColor = fitColors[index % fitColors.length];
				const fitName = latexMode ? getFitLegendName(index, yLabelRaw) : `Fit: ${yLabelRaw}`;

				traces.push({
					x: fittedCurves[index].x,
					y: fittedCurves[index].y,
					mode: 'lines',
					name: fitName,
					line: { color: fitColor }
				});
			}
		});

		// Retrieve and process input for combined plot title and axis labels.
		const titleInput = document.getElementById('combined-title');
		const xLabelInput = document.getElementById('combined-x-label');
		const yLabelInput = document.getElementById('combined-y-label');

		const rawTitle = titleInput ? titleInput.value.trim() : '';
		const rawXLabel = xLabelInput ? xLabelInput.value.trim() : '';
		const rawYLabel = yLabelInput ? yLabelInput.value.trim() : '';

		const processedTitle = rawTitle === '' ? '' : processLabel(rawTitle);
		const processedXLabel = rawXLabel === '' ? '' : processLabel(rawXLabel);
		const processedYLabel = rawYLabel === '' ? '' : processLabel(rawYLabel);

		// Build the layout using the processed labels.
		const layout = {
			title: { text: processedTitle, font: { size: 16 } },
			xaxis: { title: processedXLabel },
			yaxis: { title: { text: processedYLabel, standoff: 25 } },
			margin: { t: rawTitle === '' ? 50 : 100, b: 70, l: 140, r: 0 }
		};

		if (isPlotStateEqual(traces, layout)) {
			console.log("No changes detected in combined plot; skipping update.");
			showPopup();
			return;
		}

		Plotly.newPlot('popup-plot', traces, layout, {
			toImageButtonOptions: { format: 'svg', filename: 'combined_plot', scale: 1 }
		});

		lastPlotState.data = traces;
		lastPlotState.layout = layout;

		showPopup();
		safeTypeset(document.getElementById('popup-plot'));
	}


	// Function to initialize the combined plot input boxes.
	function initCombinedPlotInputs() {
		let controlsContainer = document.getElementById('combined-plot-controls');
		if (!controlsContainer) {
			controlsContainer = document.createElement('div');
			controlsContainer.id = 'combined-plot-controls';
			document.body.appendChild(controlsContainer);
		}

		let titleInput = document.getElementById('combined-title');
		if (!titleInput) {
			titleInput = document.createElement('input');
			titleInput.type = 'text';
			titleInput.id = 'combined-title';
			titleInput.placeholder = 'Title';
			controlsContainer.appendChild(titleInput);
		}

		let xLabelInput = document.getElementById('combined-x-label');
		if (!xLabelInput) {
			xLabelInput = document.createElement('input');
			xLabelInput.type = 'text';
			xLabelInput.id = 'combined-x-label';
			xLabelInput.placeholder = 'x-axis Label';
			controlsContainer.appendChild(xLabelInput);
		}

		let yLabelInput = document.getElementById('combined-y-label');
		if (!yLabelInput) {
			yLabelInput = document.createElement('input');
			yLabelInput.type = 'text';
			yLabelInput.id = 'combined-y-label';
			yLabelInput.placeholder = 'y-axis Label';
			controlsContainer.appendChild(yLabelInput);
		}

		// Initialise with raw text (no extra $ delimiters).
		titleInput.value = document.getElementById('graph-title').value || '';
		xLabelInput.value = document.getElementById('x-column-name').value || 'x';
		yLabelInput.value = document.getElementById('y-column-name').value || 'y';

		// Add event listeners: whenever any input value changes, update the combined plot.
		// Avoid adding duplicates.
		if (!titleInput.dataset.listenerAdded) {
			titleInput.addEventListener('input', updateCombinedPlotFromInputs);
			xLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
			yLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
			titleInput.dataset.listenerAdded = '1';
		}
	}


	// Function to update the combined plot using the values from the new input boxes.
	function updateCombinedPlotFromInputs() {
		// Simply call plotAllDatasets; the updated version will check the input box values.
		plotAllDatasets();
	}

	// This function makes both the popup and the background visible.
	function showPopup() {
		const popupBackground = document.getElementById('popup-background');
		const popupContainer = document.getElementById('popup-container');

		if (popupBackground) {
			popupBackground.style.display = 'block'; // Show the transparent background
		}

		if (popupContainer) {
			popupContainer.style.display = 'block'; // Show the popup content
		}
	}

	// This function hides both the popup and the background.
	function closePopup() {
		const popupBackground = document.getElementById('popup-background');
		const popupContainer = document.getElementById('popup-container');

		if (popupBackground) {
			popupBackground.style.display = 'none'; // Hide the transparent background
		}

		if (popupContainer) {
			popupContainer.style.display = 'none'; // Hide the popup content
		}
	}

	function fitCurve() {
		const filteredData = rawData[activeSet].filter(
			point => Number.isFinite(point.x) && Number.isFinite(point.y)
		);
		const xValues = filteredData.map(point => point.x);
		const yValues = filteredData.map(point => point.y);
		const fitMethod = document.getElementById('fit-method').value;

		// For fitting methods where you need x and y arrays,
		// we are mapping the filtered dataset to extract the x and y values.
		if (fitMethod === 'Linear') {
			if (filteredData.length < 2) {
				alert('Please enter at least two data points.');
				return;
			}
			performLinearFit(xValues, yValues);
		} else if (fitMethod.startsWith('Polynomial')) {
			const degree = parseInt(fitMethod.split('-')[1]);
			const minimumPoints = degree + 1;
			if (filteredData.length < minimumPoints) {
				alert(`Please enter at least ${minimumPoints} data points for a degree ${degree} polynomial fit.`);
				return;
			}
			performPolynomialFit(xValues, yValues, degree);
		} else if (fitMethod === 'Exponential') {
			performExponentialFit();
		} else if (fitMethod === 'Power') {
			performPowerFit();
		}
	}

	function updateBasicFitEquation() {
		const fitMethod = document.getElementById('fit-method').value;
		let equation = '';

		if (fitMethod === 'Linear') {
			equation = 'y = mx + c';
		} else if (fitMethod.startsWith('Polynomial')) {
			const degree = parseInt(fitMethod.split('-')[1]);
			let terms = [];
			for (let i = degree; i >= 0; i--) {
				terms.push(`a_${i}x^{${i}}`);
			}
			equation = 'y = ' + terms.join(' + ');
		} else if (fitMethod === 'Exponential') {
			equation = 'y = A e^{b(x-x_0)} + c';
		} else if (fitMethod === 'Power') {
			equation = 'y = A (x-x_0)^{b} + c';
		}

		const equationElement = document.getElementById('basic-fit-equation');
		if (equationElement) {
			equationElement.textContent = `\\( ${equation} \\)`;
			safeTypeset(equationElement);
		}
	}


	function changeAdvancedFitMethod() {
		const selectedMethod = document.getElementById('advanced-fit-method').value;
		const methods = ['Sinusoidal', 'Gaussian'];

		methods.forEach(method => {
			const section = document.getElementById(`${method}-parameters`);
			if (method === selectedMethod) {
				section.classList.add('active');
			} else {
				section.classList.remove('active');
			}
		});

		updateAdvancedFitEquation(selectedMethod);
		setInitialParameters(selectedMethod);
	}

	function updateAdvancedFitEquation(selectedMethod) {
		let equation = '';
		if (selectedMethod === 'Sinusoidal') {
			equation = 'y = A e^{bx} \sin(kx - \\phi) + c';
		} else if (selectedMethod === 'Gaussian') {
			equation = 'y = A e^{-\frac{(x - \\mu)^2}{2 \\sigma^2}} + c';
		}

		const equationElement = document.getElementById('advanced-fit-general-equation');
		if (equationElement) {
			equationElement.textContent = `\\(${equation}\\)`;
			safeTypeset(equationElement);
		}
	}


	// Helper function to calculate FWHM for Gaussian Fit (optional, not used here)
	function calculateFWHM(x, y, maxY) {
		const halfMax = maxY / 2;
		let left = null,
			right = null;

		// Sort data by x (use only finite x and y)
		const sortedData = rawData[activeSet]
			.slice()
			.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
			.sort((a, b) => a.x - b.x);

		if (sortedData.length < 2) {
			return 1; // fallback
		}

		// Find left crossing
		for (let i = 1; i < sortedData.length; i++) {
			if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
				const x1 = sortedData[i - 1].x;
				const y1 = sortedData[i - 1].y;
				const x2 = sortedData[i].x;
				const y2 = sortedData[i].y;
				left = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
				break;
			}
		}

		// Find right crossing
		for (let i = sortedData.length - 1; i > 0; i--) {
			if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
				const x1 = sortedData[i - 1].x;
				const y1 = sortedData[i - 1].y;
				const x2 = sortedData[i].x;
				const y2 = sortedData[i].y;
				right = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
				break;
			}
		}

		if (left !== null && right !== null && right > left) {
			return right - left;
		} else {
			const xs = sortedData.map(p => p.x);
			const minX = Math.min(...xs);
			const maxX = Math.max(...xs);
			return (maxX - minX) / 4;
		}
	}


	// Function to set initial parameters based on selected method and data
	function setInitialParameters(method) {
		if (!method) return;
		if (!rawData[activeSet] || rawData[activeSet].length === 0) return;

		// Use only finite points (avoid null/blank cells corrupting guesses)
		const pts = rawData[activeSet].filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
		if (pts.length < 4) return;

		const x = pts.map(p => p.x);
		const y = pts.map(p => p.y);

		const meanX = x.reduce((sum, val) => sum + val, 0) / x.length;
		const meanY = y.reduce((sum, val) => sum + val, 0) / y.length;

		const maxY = Math.max(...y);
		const minY = Math.min(...y);

		// For Gaussian
		const FWHM = calculateFWHM(x, y, maxY);

		if (method === 'Gaussian') {
			document.getElementById('initial-A-gaussian').value = maxY.toFixed(3);
			document.getElementById('initial-mu').value = meanX.toFixed(3);
			document.getElementById('initial-sigma').value = (FWHM / (2 * Math.sqrt(2 * Math.log(2))) || 1).toFixed(3);
			document.getElementById('initial-c-gaussian').value = '0';
			return;
		}

		if (method === 'Sinusoidal') {
			// Heuristic guesses that work well for ordinary (non-damped) sinusoids:
			//   y ≈ A * sin(kx - phi) + c   (with b ≈ 0)
			// Note: Our model includes exp(bx); setting b=0 is the safe default.
			const Aguess = (maxY - minY) / 2;
			const cguess = meanY;
			const bguess = 0;
			const phiguess = 0;

			let kguess = estimateKFromData();
			if (kguess === null || !isFinite(kguess) || kguess <= 0) {
				const span = Math.max(...x) - Math.min(...x);
				// fallback: assume ~1 cycle across the span
				kguess = span > 0 ? (2 * Math.PI) / span : 1;
			}

			document.getElementById('initial-A').value = (isFinite(Aguess) && Aguess !== 0 ? Aguess : 1).toFixed(3);
			document.getElementById('initial-b').value = bguess.toFixed(3);
			document.getElementById('initial-k').value = kguess.toFixed(3);
			document.getElementById('initial-phi').value = phiguess.toFixed(3);
			document.getElementById('initial-c').value = cguess.toFixed(3);
		}
	}


	function getCurrentAdvancedFitMethod() {
		return document.getElementById('advanced-fit-method').value;
	}

	function computeLinearFit(x, y) {
		try {
			const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
			const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

			let numerator = 0,
				denominator = 0;
			for (let i = 0; i < x.length; i++) {
				numerator += (x[i] - xMean) * (y[i] - yMean);
				denominator += (x[i] - xMean) ** 2;
			}

			// If all x values are identical, fall back to a constant model.
			if (Math.abs(denominator) < 1e-15) {
				return { slope: 0, intercept: yMean };
			}

			const slope = numerator / denominator;
			const intercept = yMean - slope * xMean;

			return { slope, intercept };
		} catch (error) {
			console.error('Error computing linear fit:', error);
			throw error;
		}
	}



	// ===== Exponential helpers (auto-pick) =====
	function computeRSq(xArr, yArr, f) {
		try {
			const yhat = xArr.map(f);
			const meanY = yArr.reduce((s, v) => s + v, 0) / yArr.length;
			let ssTot = 0,
				ssRes = 0;
			for (let i = 0; i < yArr.length; i++) {
				const ri = yArr[i] - yhat[i];
				ssRes += ri * ri;
				const di = yArr[i] - meanY;
				ssTot += di * di;
			}
			return 1 - (ssRes / ssTot);
		} catch (e) {
			console.error('R² error:', e);
			return -Infinity;
		}
	}

	// Display: y = ±A e^{...} ± c   (constant at the END)
	function formatExpEquation(A, b, c, useShift = false, x0 = 0) {
		const Aabs = Math.abs(A).toFixed(3);
		const bStr = Number(b).toFixed(3);
		const base = useShift ?
			`y = ${A >= 0 ? '' : '-'}${Aabs} e^{${bStr}(x ${x0 >= 0 ? '- ' + x0.toFixed(3) : '+ ' + Math.abs(x0).toFixed(3)})}` :
			`y = ${A >= 0 ? '' : '-'}${Aabs} e^{${bStr} x}`;
		const cNum = Number(c);
		if (!isFinite(cNum) || Math.abs(cNum) < 1e-12) return base;
		return cNum > 0 ? `${base} + ${cNum.toFixed(3)}` : `${base} - ${Math.abs(cNum).toFixed(3)}`;
	}

	// Non-linear fit: y = c + A e^{b x}  (robust; allows A<0, negative/noisy y)
	function exponentialFit_cAbx(raw) {
		const data = raw.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
		if (data.length < 3) return null;
		// Exponential-specific: ignore non-positive y (noise) for fitting
		const posData = data.filter(p => p.y > 0);
		const pts = (posData.length >= 3 ? posData : data);
		const x = pts.map(p => p.x);
		const y = pts.map(p => p.y);

		// Initial guesses: c0 from upper tail; A0,b0 from ln|y-c0| vs x
		const ys = [...y].sort((a, b) => a - b);
		const kTop = Math.max(1, Math.floor(0.2 * ys.length));
		const c0 = ys.slice(-kTop)[Math.floor(kTop / 2)];
		const z = y.map(v => v - c0);
		const signZ = Math.sign(z.reduce((s, v) => s + v, 0)) || 1;
		const X = [],
			L = [];
		for (let i = 0; i < z.length; i++)
			if (Math.abs(z[i]) > 1e-12) {
				X.push(x[i]);
				L.push(Math.log(Math.abs(z[i])));
			}
		let A0 = signZ * 1,
			b0 = -1;
		if (X.length >= 2) {
			const { slope, intercept } = computeLinearFit(X, L);
			b0 = slope;
			A0 = signZ * Math.exp(intercept);
		}

		// Tiny LM on [A,b,c]
		function residuals([A, b, c]) { return data.map(({ x, y }) => (c + A * Math.exp(b * x)) - y); }

		function jacobian([A, b, c]) {
			return data.map(({ x }) => {
				const e = Math.exp(b * x);
				return [e, A * x * e, 1];
			});
		}

		function lm(init, it = 200) {
			let p = init.slice(),
				lam = 1e-3,
				nu = 2;
			const T = M => M[0].map((_, j) => M.map(r => r[j]));
			const dot = (a, b) => a.reduce((s, v, i) => s + v * b[i], 0);
			const mm = (A, B) => A.map(r => B[0].map((_, j) => dot(r, B.map(rr => rr[j]))));
			const mv = (A, v) => A.map(r => dot(r, v));
			const solve = (M, b) => {
				const n = M.length;
				const A = M.map((r, i) => r.concat([b[i]]));
				for (let i = 0; i < n; i++) {
					let p = i;
					for (let r = i + 1; r < n; r++)
						if (Math.abs(A[r][i]) > Math.abs(A[p][i])) p = r;
					const tmp = A[i];
					A[i] = A[p];
					A[p] = tmp;
					const piv = A[i][i];
					if (Math.abs(piv) < 1e-18) return null;
					for (let c = i; c <= n; c++) A[i][c] /= piv;
					for (let r = 0; r < n; r++)
						if (r !== i) { const f = A[r][i]; for (let c = i; c <= n; c++) A[r][c] -= f * A[i][c]; }
				}
				return A.map(r => r[n]);
			};

			for (let k = 0; k < it; k++) {
				const r = residuals(p),
					J = jacobian(p);
				const JT = T(J),
					JTJ = mm(JT, J),
					JTr = mv(JT, r);
				const A = JTJ.map((row, i) => row.map((v, j) => v + (i === j ? lam : 0)));
				const b = JTr.map(v => -v);
				const delta = solve(A, b);
				if (!delta) { lam *= nu; continue; }
				const trial = p.map((pi, i) => pi + delta[i]);
				const rNew = residuals(trial);
				const oldCost = r.reduce((s, v) => s + v * v, 0);
				const newCost = rNew.reduce((s, v) => s + v * v, 0);
				if (newCost < oldCost) {
					p = trial;
					lam *= 0.3;
				} else { lam *= nu; }
			}
			return p;
		}

		const [A, b, c] = lm([A0, b0, c0]);
		const xMin = Math.min(...x),
			xMax = Math.max(...x);
		const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
		const fitFn = xi => c + A * Math.exp(b * xi);
		const yFit = xFit.map(fitFn);
		const r2 = computeRSq(x, y, fitFn);
		const eq = formatExpEquation(A, b, c, false);
		return { ok: true, model: 'cAbx', r2, params: { A, b, c }, xFit, yFit, fitFn, eq };
	}

	// Log-linear with shift: y = A e^{b(x - x0)} + c  (preserves original behaviour)
	function exponentialFit_logLinear(raw) {
		const data = raw.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
		if (data.length < 3) return null;
		// Exponential-specific: ignore non-positive y (noise) for fitting
		const posData = data.filter(p => p.y > 0);
		const pts = (posData.length >= 3 ? posData : data);
		const x = pts.map(p => p.x);
		const y = pts.map(p => p.y);

		// c from min(y) to keep original behaviour (works with negative noise)
		const c = Math.min(...y);

		const xMin = Math.min(...x),
			xMax = Math.max(...x);
		const steps = 100;
		const x0Cands = Array.from({ length: steps }, (_, i) => xMin + i * (xMax - xMin) / (steps - 1));

		let best = { mse: Infinity, A: 1, b: 0, x0: 0 };

		for (const x0 of x0Cands) {
			const yAdj = y.map(v => v - c);
			const X = [],
				L = [];
			for (let i = 0; i < yAdj.length; i++) {
				const val = yAdj[i];
				if (val > 0) { // only log valid
					X.push(x[i] - x0); // <-- critical: regress on (x - x0)
					L.push(Math.log(val));
				}
			}
			if (X.length < 2) continue;

			const { slope: b, intercept: lnA } = computeLinearFit(X, L);
			const A = Math.exp(lnA);
			// MSE in log space for this x0
			const preds = X.map(xx => b * xx + lnA);
			const mse = preds.reduce((s, p, i) => s + (L[i] - p) * (L[i] - p), 0) / preds.length;
			if (mse < best.mse) best = { mse, A, b, x0 };
		}

		if (!isFinite(best.mse)) return null;
		const { A, b, x0 } = best;
		const fitFn = xi => A * Math.exp(b * (xi - x0)) + c;
		const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
		const yFit = xFit.map(fitFn);
		const r2 = computeRSq(x, y, fitFn);
		const eq = formatExpEquation(A, b, c, true, x0);
		return { ok: true, model: 'shifted', r2, params: { A, b, x0, c }, xFit, yFit, fitFn, eq };
	}


	function updateResults(equation, x, y, fitFunction) {
		try {
			const yPredicted = x.map(point => fitFunction(point));
			const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

			let ssTotal = 0,
				ssResidual = 0;
			for (let i = 0; i < y.length; i++) {
				ssTotal += Math.pow(y[i] - meanY, 2);
				ssResidual += Math.pow(y[i] - yPredicted[i], 2);
			}

			const rSquared = 1 - ssResidual / ssTotal;

			// Update the UI (fitting result container)
			const fitEquationElement = document.getElementById('fit-equation');
			if (fitEquationElement) {
				fitEquationElement.innerHTML = `\\(${equation}\\)`;
				fitEquationElement.style.display = 'block';
			}

			const rSquaredElement = document.getElementById('r-squared-container');
			if (rSquaredElement) {
				rSquaredElement.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
				rSquaredElement.style.display = 'block';
			}

			// Trigger MathJax typesetting if available.
			safeTypeset(fitEquationElement);
			safeTypeset(rSquaredElement);

			// Store this result for the current dataset.
			datasetFitResults[activeSet] = {
				equation: equation,
				rSquared: rSquared.toFixed(5)
			};
		} catch (error) {
			console.error('Error updating results:', error);
		}
	}

	function polyfit(x, y, degree) {
		try {
			const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
			const Xt = math.transpose(X);
			const XtX = math.multiply(Xt, X);
			const XtY = math.multiply(Xt, y);
			const coefficients = math.lusolve(XtX, XtY).flat();
			return coefficients;
		} catch (error) {
			console.error('Error performing polynomial fit:', error);
			throw error;
		}
	}

	function polyEval(coefficients, x) {
		try {
			return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
		} catch (error) {
			console.error('Error evaluating polynomial:', error);
			throw error;
		}
	}

	function updateData() {
		try {
			const xInputs = document.querySelectorAll('.x-input');
			const yInputs = document.querySelectorAll('.y-input');
			const xErrorInputs = document.querySelectorAll('.x-error-input');
			const yErrorInputs = document.querySelectorAll('.y-error-input');

			// For Dataset 1, store all x-values even if y is missing.
			if (activeSet === 0) {
				dataset1XValues = [];
				for (let i = 0; i < xInputs.length; i++) {
					const xVal = parseFloat(xInputs[i].value);
					if (!isNaN(xVal)) {
						dataset1XValues.push(xVal);
					}
				}
			}

			// Clear the current active dataset and repopulate it from the table inputs.
			rawData[activeSet] = [];
			for (let i = 0; i < xInputs.length; i++) {
				const x = parseFloat(xInputs[i].value);
				const y = parseFloat(yInputs[i].value);
				const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
				const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

				// Save the row if x is a valid number, regardless of y.
				if (!isNaN(x)) {
					rawData[activeSet].push({
						x: x,
						y: (!isNaN(y) ? y : null), // If y is not valid, store it as null.
						xErrorRaw: xErrorRaw,
						yErrorRaw: yErrorRaw
					});
				}
			}

			// Update the plot using only the active dataset.
			plotGraph();
		} catch (error) {
			console.error('Error updating data:', error);
		}
	}

	function formatDataForExport(valueStr, errorStr, errorEnabled, errorType, val, rowVal, rowErr) {
		if (!errorEnabled) {
			return valueStr;
		}

		if (isNaN(rowErr)) return valueStr;

		if (errorType === 'absolute') {
			const dp = countDecimalPlaces(errorStr);
			return val.toFixed(dp);
		} else if (errorType === 'percentage') {
			const perc = parseFloat(errorStr);
			if (isNaN(perc)) {
				return valueStr;
			}

			// Use 1 significant figure if percentage uncertainty is >= 50%
			let sigFigs;
			if (perc >= 50) {
				sigFigs = 1;
			} else if (perc <= 10) {
				sigFigs = 3;
			} else {
				sigFigs = 2;
			}

			const sfVal = toSigFigs(val, sigFigs);
			return sfVal;
		} else {
			return valueStr;
		}
	}

	/**
	 * Formats labels for LaTeX by replacing spaces with \space.
	 * @param {string} label - The label to format.
	 * @returns {string} - The LaTeX-formatted label.
	 */
	function formatLabelForLatex(label) {
		return label ? label.replace(/ /g, '\\space ') : '';
	}

	/**
	 * Counts the number of decimal places in a number string.s
	 * @param {string} numStr - The number as a string.
	 * @returns {number} - The number of decimal places.
	 */
	function countDecimalPlaces(numStr) {
		if (!numStr.includes('.')) return 0;
		return numStr.length - numStr.indexOf('.') - 1;
	}

	/**
	 * Formats a number to the specified number of significant figures without using scientific notation.
	 * Preserves trailing zeros by returning a string.
	 * @param {number} num - The number to format.
	 * @param {number} sigFigs - The number of significant figures.
	 * @returns {string} - The formatted number as a string.
	 */
	function toSigFigs(num, sigFigs) {
		if (num === 0) return '0';

		if (sigFigs === 1) {
			const order = Math.floor(Math.log10(Math.abs(num)));
			const factor = Math.pow(10, order);
			const rounded = Math.floor(num / factor) * factor;
			return order >= 0 ? rounded.toString() : rounded.toFixed(Math.abs(order));
		}

		let numStr = num.toPrecision(sigFigs);
		if (numStr.includes('e') || numStr.includes('E')) {
			const [mantissa, exponent] = numStr.split(/e/i);
			const exponentVal = parseInt(exponent, 10);
			let fixedNum = parseFloat(mantissa) * Math.pow(10, exponentVal);
			const decimalPlaces = sigFigs - 1 - Math.floor(Math.log10(Math.abs(num)));
			return fixedNum.toFixed(decimalPlaces > 0 ? decimalPlaces : 0);
		}
		return numStr;
	}

	/**
	 * Formats a number into scientific notation for LaTeX with specified significant figures.
	 * @param {number} num - The number to format.
	 * @param {number} sigFigs - The number of significant figures.
	 * @returns {string} - The LaTeX-formatted scientific notation string.
	 */
	function formatScientificNotation(num, sigFigs) {
		if (sigFigs === 1) {
			return toSigFigs(num, sigFigs);
		}
		let numStr = num.toExponential(sigFigs - 1);
		return numStr;
	}

	/**
	 * Formats data values based on the uncertainty type.
	 *
	 * For 'absolute' uncertainty:
	 *   - If the absolute uncertainty is ≥ 1, the data value is rounded down (via Math.floor)
	 *     to the nearest multiple determined by the order of magnitude of the uncertainty.
	 *     For example, 1455 with an uncertainty of 40 becomes 1450.
	 *   - If the absolute uncertainty is < 1, the data value is formatted to the same number of
	 *     decimal places as the uncertainty (preserving trailing zeros).
	 *
	 * For 'percentage' uncertainty:
	 *   - When the percentage uncertainty is greater than or equal to 50%, the data value is formatted
	 *     to 1 significant figure.
	 *   - Otherwise, the data value is formatted to a fixed number of significant figures:
	 *       * 3 significant figures if the uncertainty is less than 10,
	 *       * 2 significant figures otherwise.
	 *   - Scientific notation is applied if indicated.
	 *
	 * If no uncertainty is provided, the data value is simply returned as a string.
	 *
	 * @param {number} dataVal - The data value.
	 * @param {number} uncertaintyVal - The uncertainty value.
	 * @param {string} uncertaintyType - The type of uncertainty ('absolute' or 'percentage').
	 * @param {boolean} useSciNotation - Whether to apply scientific notation.
	 * @returns {string} - The formatted data value.
	 */
	function formatDataValue(dataVal, uncertaintyVal, uncertaintyType, useSciNotation) {
		if (uncertaintyType === 'absolute') {
			if (Math.abs(uncertaintyVal) >= 1) {
				const order = Math.floor(Math.log10(Math.abs(uncertaintyVal)));
				const factor = Math.pow(10, order);
				const roundedValue = Math.floor(dataVal / factor) * factor;
				return roundedValue.toFixed(0);
			} else {
				const dp = countDecimalPlaces(uncertaintyVal.toString());
				// Simply return the data value formatted with 'dp' decimal places,
				// preserving all trailing zeros.
				return dataVal.toFixed(dp);
			}
		} else if (uncertaintyType === 'percentage') {
			const perc = parseFloat(uncertaintyVal);
			if (isNaN(perc)) return dataVal.toString();
			// Use 1 s.f. if percentage uncertainty is >= 50, else use 3 s.f. if error < 10, otherwise 2 s.f.
			const sigFigs = perc >= 50 ? 1 : (perc < 10 ? 3 : 2);
			if (useSciNotation) {
				return formatScientificNotation(dataVal, sigFigs);
			} else {
				return toSigFigs(dataVal, sigFigs);
			}
		} else {
			return dataVal.toString();
		}
	}

	/**
	 * Formats uncertainties based on their type.
	 * - For percentage uncertainties: preserves the exact input (optionally add '\\%' if needed).
	 * - For absolute uncertainties: preserves trailing zeros based on the number of decimal places.
	 * @param {string} errStr - The uncertainty value as a string.
	 * @param {string} errorType - The type of uncertainty ('absolute' or 'percentage').
	 * @returns {string} - The formatted uncertainty string.
	 */
	function formatUncertainty(errStr, errorType) {
		if (errorType === 'percentage') {
			return errStr; // Optionally: return errStr + '\\%' if desired.
		} else if (errorType === 'absolute') {
			const dp = countDecimalPlaces(errStr);
			const errVal = parseFloat(errStr);
			if (isNaN(errVal)) return errStr;
			return errVal.toFixed(dp);
		} else {
			return errStr;
		}
	}

	/**
	 * Exports the data as a Markdown (.md) file with LaTeX formatting.
	 */
	function exportPlainText() {
		try {
			// Retrieve axis headings
			const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
			const yHeader = document.getElementById('y-column-name').value.trim() || 'y';

			// Check if uncertainties are enabled
			const xErrorEnabled = document.getElementById('toggle-x-error').checked;
			const yErrorEnabled = document.getElementById('toggle-y-error').checked;

			// Get uncertainty types
			const xErrorType = document.getElementById('x-error-type').value;
			const yErrorType = document.getElementById('y-error-type').value;

			// Get all rows from the data table's tbody
			const table = document.getElementById('data-table');
			const rows = table.querySelectorAll('tbody tr');

			// Initialize arrays to collect all x and y values
			let xValues = [];
			let yValues = [];

			// Collect all x and y values for notation decision
			rows.forEach(row => {
				const xInputElem = row.querySelector('.x-input');
				const yInputElem = row.querySelector('.y-input');

				if (!xInputElem || !yInputElem) return;

				const xValStr = xInputElem.value.trim();
				const yValStr = yInputElem.value.trim();

				if (xValStr !== '') {
					const xVal = parseFloat(xValStr);
					if (!isNaN(xVal)) xValues.push(xVal);
				}
				if (yValStr !== '') {
					const yVal = parseFloat(yValStr);
					if (!isNaN(yVal)) yValues.push(yVal);
				}
			});

			// Determine if scientific notation is needed for x and y
			const xUseSciNotation = xErrorEnabled && xErrorType === 'percentage' &&
				xValues.some(val => val < -10000 || val > 10000);
			const yUseSciNotation = yErrorEnabled && yErrorType === 'percentage' &&
				yValues.some(val => val < -10000 || val > 10000);

			// Initialize headers with LaTeX formatting
			let headers = [
				`$${formatLabelForLatex(xHeader)}$`,
				`$${formatLabelForLatex(yHeader)}$`
			];

			if (xErrorEnabled) {
				let xUncHeading = `\\pm \\Delta ${formatLabelForLatex(xHeader)}`;
				if (xErrorType === 'percentage') xUncHeading += ' \\space (\\%)';
				headers.push(`$${xUncHeading}$`);
			}
			if (yErrorEnabled) {
				let yUncHeading = `\\pm \\Delta ${formatLabelForLatex(yHeader)}`;
				if (yErrorType === 'percentage') yUncHeading += ' \\space (\\%)';
				headers.push(`$${yUncHeading}$`);
			}

			let markdown = `| ${headers.join(' | ')} |\n`;
			markdown += `|${headers.map(() => ':---:').join('|')}|\n`;

			// Process each row
			rows.forEach(row => {
				const xInputElem = row.querySelector('.x-input');
				const yInputElem = row.querySelector('.y-input');
				if (!xInputElem || !yInputElem) return;

				const xValStr = xInputElem.value.trim();
				const yValStr = yInputElem.value.trim();
				if (xValStr === '' && yValStr === '') return;

				const xVal = parseFloat(xValStr);
				const yVal = parseFloat(yValStr);

				const xErrInput = row.querySelector('.x-error-input');
				const yErrInput = row.querySelector('.y-error-input');
				const xErrStr = xErrInput ? xErrInput.value.trim() : '';
				const yErrStr = yErrInput ? yErrInput.value.trim() : '';
				const xErrVal = parseFloat(xErrStr);
				const yErrVal = parseFloat(yErrStr);
				const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
				const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

				let rowData = [];

				// Format X value
				let xFormatted = xValStr;
				if (!isNaN(xVal)) {
					if (xUseSciNotation && xErrorEnabledThisRow && xErrorType === 'percentage') {
						const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
						const sciFormatted = formatScientificNotation(xVal, sigFigs);
						xFormatted = `$${sciFormatted}$`;
					} else if (xErrorEnabledThisRow && xErrorType === 'percentage') {
						const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
						const sigFormatted = toSigFigs(xVal, sigFigs);
						xFormatted = `$${sigFormatted}$`;
					} else if (xErrorEnabledThisRow && xErrorType === 'absolute') {
						const formattedData = formatDataValue(xVal, xErrVal, 'absolute', false);
						xFormatted = `$${formattedData}$`;
					} else {
						xFormatted = `$${xValStr}$`;
					}
				}

				// Format Y value
				let yFormatted = yValStr;
				if (!isNaN(yVal)) {
					if (yUseSciNotation && yErrorEnabledThisRow && yErrorType === 'percentage') {
						const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
						const sciFormatted = formatScientificNotation(yVal, sigFigs);
						yFormatted = `$${sciFormatted}$`;
					} else if (yErrorEnabledThisRow && yErrorType === 'percentage') {
						const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
						const sigFormatted = toSigFigs(yVal, sigFigs);
						yFormatted = `$${sigFormatted}$`;
					} else if (yErrorEnabledThisRow && yErrorType === 'absolute') {
						const formattedData = formatDataValue(yVal, yErrVal, 'absolute', false);
						yFormatted = `$${formattedData}$`;
					} else {
						yFormatted = `$${yValStr}$`;
					}
				}

				rowData.push(xFormatted);
				rowData.push(yFormatted);
				if (xErrorEnabled) {
					let xErrorFormatted = xErrorEnabledThisRow ? formatUncertainty(xErrStr, xErrorType) : '';
					if (xErrorFormatted !== '') xErrorFormatted = `$${xErrorFormatted}$`;
					rowData.push(xErrorFormatted);
				}
				if (yErrorEnabled) {
					let yErrorFormatted = yErrorEnabledThisRow ? formatUncertainty(yErrStr, yErrorType) : '';
					if (yErrorFormatted !== '') yErrorFormatted = `$${yErrorFormatted}$`;
					rowData.push(yErrorFormatted);
				}
				markdown += `| ${rowData.join(' | ')} |\n`;
			});

			console.log("Final Markdown Content:\n", markdown);
			const blob = new Blob([markdown], { type: 'text/plain;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.setAttribute('href', url);
			link.setAttribute('download', 'data.md');
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} catch (error) {
			console.error('Error exporting plain text:', error);
			alert('An error occurred while exporting the Markdown file. Please check the console for details.');
		}
	}

	function exportCSV() {
		try {
			const table = document.getElementById('data-table');
			const rows = table.querySelectorAll('tr');
			let csvContent = '';

			const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
			const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
			const xErrorEnabled = document.getElementById('toggle-x-error').checked;
			const yErrorEnabled = document.getElementById('toggle-y-error').checked;

			const headers = [xHeader, yHeader];
			if (xErrorEnabled) {
				const xErrorType = document.getElementById('x-error-type').value;
				const xErrorHead = xErrorType === 'percentage' ? `delta ${xHeader} (%)` : `delta ${xHeader}`;
				headers.push(xErrorHead);
			}
			if (yErrorEnabled) {
				const yErrorType = document.getElementById('y-error-type').value;
				const yErrorHead = yErrorType === 'percentage' ? `delta ${yHeader} (%)` : `delta ${yHeader}`;
				headers.push(yErrorHead);
			}

			csvContent += headers.join(',') + '\n';

			const dataRows = table.querySelectorAll('tbody tr');

			for (let i = 0; i < dataRows.length; i++) {
				const xValStr = dataRows[i].querySelector('.x-input')?.value.trim() || '';
				const yValStr = dataRows[i].querySelector('.y-input')?.value.trim() || '';
				if (xValStr === '' && yValStr === '') continue;

				let xVal = parseFloat(xValStr);
				let yVal = parseFloat(yValStr);

				const xErrInput = dataRows[i].querySelector('.x-error-input');
				const yErrInput = dataRows[i].querySelector('.y-error-input');

				const xErrStr = xErrInput ? xErrInput.value.trim() : '';
				const yErrStr = yErrInput ? yErrInput.value.trim() : '';
				const xErrVal = parseFloat(xErrStr);
				const yErrVal = parseFloat(yErrStr);

				const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
				const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

				const xErrorType = document.getElementById('x-error-type').value;
				const yErrorType = document.getElementById('y-error-type').value;

				let rowData = [];

				let xFormatted = xValStr;
				if (!isNaN(xVal)) {
					xFormatted = formatDataForExport(
						xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
					);
				}

				let yFormatted = yValStr;
				if (!isNaN(yVal)) {
					yFormatted = formatDataForExport(
						yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
					);
				}

				rowData.push(xFormatted);
				rowData.push(yFormatted);

				if (xErrorEnabled) {
					rowData.push(xErrorEnabledThisRow ? xErrStr : '');
				}

				if (yErrorEnabled) {
					rowData.push(yErrorEnabledThisRow ? yErrStr : '');
				}

				csvContent += rowData.join(',') + '\n';
			}

			const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.setAttribute('href', url);
			link.setAttribute('download', 'data.csv');
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} catch (error) {
			console.error('Error exporting CSV:', error);
			alert('An error occurred while exporting the CSV. Please check the console for details.');
		}
	}

	function applyGlobalUncertainties(axis) {
		const globalVal = document.getElementById(`global-${axis}-uncertainty`).value.trim();
		const tableBody = document.querySelector('#data-table tbody');
		const rows = tableBody.querySelectorAll('tr');

		rows.forEach((row) => {
			const xInput = row.querySelector('.x-input').value.trim();
			const yInput = row.querySelector('.y-input').value.trim();

			if (xInput !== '' && yInput !== '') {
				const errorInput = row.querySelector(`.${axis}-error-input`);
				if (document.getElementById(`toggle-${axis}-error`).checked && errorInput) {
					errorInput.value = globalVal !== '' ? globalVal : '';
				}
			}
		});

		updateData();
		document.getElementById(`global-${axis}-uncertainty`).value = '';

		// Update initial parameters based on the selected advanced fit method
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function fitAdvancedCurve() {
		if (rawData[activeSet].length < 4) { // Increased to 4 for more complex fits
			alert('Please enter at least four data points for advanced fitting.');
			return;
		}

		const fitMethod = document.getElementById('advanced-fit-method').value;

		if (fitMethod === 'Sinusoidal') {
			performSinusoidalFit();
		} else if (fitMethod === 'Gaussian') {
			performGaussianFit();
		}
	}

	function performLinearFit(x, y) {
		try {
			const { slope, intercept } = computeLinearFit(x, y);

			const xFit = [Math.min(...x), Math.max(...x)];
			const yFit = xFit.map(xi => slope * xi + intercept);

			const fitFunction = xi => slope * xi + intercept;

			let equation = `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
			if (intercept < 0) {
				equation = `y = ${slope.toFixed(3)}x - ${Math.abs(intercept).toFixed(3)}`;
			}

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, x, y, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing linear fit:', error);
			alert('An error occurred during linear fitting. Please check the console for details.');
		}
	}

	function performPolynomialFit(x, y, degree) {
		try {
			const coefficients = polyfit(x, y, degree);
			const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
			const yFit = xFit.map(xi => polyEval(coefficients, xi));

			const fitFunction = xi => polyEval(coefficients, xi);

			let equation = 'y = ';
			coefficients.forEach((c, i) => {
				const power = degree - i;
				if (c === 0) return;

				const absC = Math.abs(c).toFixed(3);
				const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

				let term = '';
				if (power === 0) {
					term = `${absC}`;
				} else if (power === 1) {
					term = `${absC}x`;
				} else {
					term = `${absC}x^{${power}}`;
				}

				equation += `${sign}${term}`;
			});

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, x, y, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing polynomial fit:', error);
			alert('An error occurred during polynomial fitting. Please check the console for details.');
		}
	}


	function performExponentialFit() {
		try {
			const data = (rawData && rawData[activeSet]) ? rawData[activeSet].filter(p => Number.isFinite(p.x) && Number.isFinite(p.y)) : [];
			if (data.length < 3) {
				alert('Exponential fit requires at least three valid data points.');
				return;
			}

			// Try both
			const cand1 = exponentialFit_cAbx(data);
			const cand2 = exponentialFit_logLinear(data);

			// choose by R², fallback gracefully
			let best = null;
			if (cand1 && cand2) best = (cand1.r2 >= cand2.r2) ? cand1 : cand2;
			else best = cand1 || cand2;

			if (!best) {
				alert('Exponential fit could not converge on this dataset.');
				return;
			}

			// Store & render
			fittedCurves[activeSet] = { x: best.xFit, y: best.yFit, equation: best.eq };
			const xAll = data.map(p => p.x);
			const yAll = data.map(p => p.y);
			updateResults(best.eq, xAll, yAll, best.fitFn);
			plotGraph(best.xFit, best.yFit);

			console.log(`Exponential (auto) chose: ${best.model}, R² = ${best.r2.toFixed(5)}`);
		} catch (error) {
			console.error('Error performing exponential fit:', error);
			alert('An error occurred during exponential fitting. Please check the console for details.');
		}
	}

	function performPowerFit() {
		try {
			// 1. Filter and validate input data
			const validData = rawData[activeSet].filter(point =>
				Number.isFinite(point.x) && Number.isFinite(point.y)
			);
			if (validData.length < 4) {
				alert("Power fit requires at least 4 data points.");
				return;
			}

			const xValues = validData.map(p => p.x);
			const yValues = validData.map(p => p.y);

			// 2. Generate multiple initial guesses for x0 and c
			//    We'll sample around (xMin - a bit, yMin - a bit) and also near medians.
			const xMin = Math.min(...xValues);
			const xMed = median(xValues);
			const yMin = Math.min(...yValues);
			const yMed = median(yValues);

			const guessPairs = [
				// Minimal offset guess
				[xMin - 1e-3, yMin - 1e-3],
				// Slightly bigger offset
				[xMed - 0.01, yMed - 0.01],
				// Another guess further
				[xMin - 0.1, yMin - 0.1],
			];

			let bestParams = null;
			let bestCost = Infinity;

			// 3. Try each (x0, c) guess
			for (const [x0Guess, cGuess] of guessPairs) {
				// 3a. Shift x0 or c if needed so that all (x - x0) > 0 and (y - c) > 0 for the log approach
				let shiftedX0 = x0Guess;
				let shiftedC = cGuess;

				// Ensure (x - x0) > 0 for all x if we want to do an initial log transform
				// (Avoid potentially huge while-loops for large domains.)
				const minX = Math.min(...xValues);
				if (!(minX - shiftedX0 > 0)) shiftedX0 = minX - 1e-6;
				let z = xValues.map(x => x - shiftedX0);

				// Ensure (y - c) > 0 for initial log transform
				const minY = Math.min(...yValues);
				if (!(minY - shiftedC > 0)) shiftedC = minY - 1e-6;
				let w = yValues.map(y => y - shiftedC);

				// 3b. Compute initial A, b via linear regression on log-log
				const lnZ = z.map(zi => Math.log(zi));
				const lnW = w.map(wi => Math.log(wi));
				const { slope: bInitial, intercept: lnAInitial } = computeLinearFit(lnZ, lnW);
				const AInitial = Math.exp(lnAInitial);

				const initialParams = [AInitial, bInitial, shiftedX0, shiftedC];

				// 3c. Run LM from this initial guess
				const { params, cost } = levenbergMarquardt(validData, initialParams, computeResiduals, computeJacobian);

				// 3d. Check if it's the best so far
				if (cost < bestCost) {
					bestCost = cost;
					bestParams = params;
				}
			}

			// 4. Use the best parameters found
			if (!bestParams) {
				alert("Unable to find a suitable power-law fit.");
				return;
			}
			const [A, b, x0, c] = bestParams;

			// 5. Generate fitted curve
			const xMinFit = Math.min(...xValues);
			const xMaxFit = Math.max(...xValues);
			const N = 100;
			const xFit = Array.from({ length: N }, (_, i) => {
				return xMinFit + (i * (xMaxFit - xMinFit)) / (N - 1);
			});

			// Build y-fit, but skip invalid points if (x - x0) is negative and b non-integer
			const yFit = xFit.map(xi => {
				const term = xi - x0;
				try {
					if (term <= 0 && !Number.isInteger(b)) {
						// for non-integer b, (x - x0) <= 0 is invalid
						return NaN;
					}
					return A * Math.pow(term, b) + c;
				} catch {
					return NaN;
				}
			});

			// 6. Define a fit function for interactive queries
			const fitFunction = xi => {
				const term = xi - x0;
				if (term <= 0 && !Number.isInteger(b)) return NaN;
				return A * Math.pow(term, b) + c;
			};

			// 7. Construct the equation string
			// 7.1. Determine sign for x0 and c
			const x0Sign = (x0 >= 0) ?
				` - ${x0.toFixed(3)}` // Example: (x - 2.500)
				:
				` + ${Math.abs(x0).toFixed(3)}`; // Example: (x + 0.004) if x0 is -0.004

			const cSign = (c >= 0) ?
				` + ${c.toFixed(3)}` :
				` - ${Math.abs(c).toFixed(3)}`;

			// 7.2. Construct the equation string
			const equation = `y = ${A.toFixed(3)}(x${x0Sign})^{${b.toFixed(3)}}${cSign}`;

			// 8. Store the fitted curve
			fittedCurves[activeSet] = {
				x: xFit,
				y: yFit,
				equation: equation
			};

			// 9. Update results and plot
			updateResults(equation, xValues, yValues, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error("Error performing power fit:", error);
			alert("An error occurred during power fitting. Please check the console for details.");
		}
	}

	/**
	 * Enhanced Levenberg–Marquardt Implementation.
	 * Returns the optimized params and final cost.
	 *
	 * @param {Array} data - array of points {x, y}
	 * @param {Array} initialParams - [A, b, x0, c]
	 * @param {number} maxIterations
	 * @param {number} tolerance
	 */
	function levenbergMarquardt(data, initialParams, residualFn, jacobianFn, options = {}) {
		// Generic Levenberg-Marquardt solver.
		// residualFn(params, data) -> Array<number> of residuals (y_pred - y)
		// jacobianFn(params, data) -> Array<Array<number>> Jacobian rows matching residuals
		const maxIterations = Number.isFinite(options.maxIterations) ? options.maxIterations : 200;
		const tolerance = Number.isFinite(options.tolerance) ? options.tolerance : 1e-8;

		let params = initialParams.slice();
		let lambda = Number.isFinite(options.initialLambda) ? options.initialLambda : 1e-3; // initial damping
		let nu = 2; // factor to adjust lambda
		let prevCost = Infinity;

		let bestParams = params.slice();
		let bestCost = Infinity;

		const PENALTY = 1e6;

		function safeResiduals(p) {
			let r;
			try {
				r = residualFn(p, data);
			} catch {
				r = null;
			}
			if (!Array.isArray(r) || r.length !== data.length) {
				r = new Array(data.length).fill(PENALTY);
			}
			for (let i = 0; i < r.length; i++) {
				if (!Number.isFinite(r[i])) r[i] = PENALTY;
			}
			return r;
		}

		function safeJacobian(p, nParams) {
			let J;
			try {
				J = jacobianFn(p, data);
			} catch {
				J = null;
			}
			if (!Array.isArray(J) || J.length !== data.length) {
				J = new Array(data.length).fill(null).map(() => new Array(nParams).fill(0));
			}
			for (let i = 0; i < J.length; i++) {
				const row = Array.isArray(J[i]) ? J[i] : [];
				if (row.length !== nParams) {
					J[i] = new Array(nParams).fill(0);
					continue;
				}
				for (let j = 0; j < nParams; j++) {
					if (!Number.isFinite(J[i][j])) J[i][j] = 0;
				}
			}
			return J;
		}

		function costFromResiduals(r) {
			let s = 0;
			for (let i = 0; i < r.length; i++) {
				const v = r[i];
				s += v * v;
				if (!Number.isFinite(s)) return Number.MAX_VALUE;
			}
			return s;
		}

		for (let iter = 0; iter < maxIterations; iter++) {
			// 1. Compute residuals & cost
			const residuals = safeResiduals(params);
			const cost = costFromResiduals(residuals);

			// 2. Convergence check
			if (Math.abs(prevCost - cost) < tolerance) {
				return { params, cost };
			}
			prevCost = cost;

			// 3. Jacobian
			const J = safeJacobian(params, params.length);
			const JT = transpose(J);
			const JTJ = multiply(JT, J);
			const JTr = multiplyMatrixVector(JT, residuals);

			// 4. Build damped matrix
			const n = JTJ.length;
			let A_lm = new Array(n).fill(null).map(() => new Array(n).fill(0));
			for (let i = 0; i < n; i++) {
				for (let j = 0; j < n; j++) {
					A_lm[i][j] = JTJ[i][j];
					if (i === j) {
						const diag = (Number.isFinite(A_lm[i][j]) && Math.abs(A_lm[i][j]) > 0) ? Math.abs(A_lm[i][j]) : 1;
						A_lm[i][j] += lambda * diag;
					}
				}
			}

			// 5. Solve for delta
			let delta;
			try {
				const negJTr = JTr.map(v => -v);
				delta = solve(A_lm, negJTr);
			} catch {
				lambda *= nu;
				continue;
			}

			if (!Array.isArray(delta) || delta.length !== params.length || delta.some(v => !Number.isFinite(v))) {
				lambda *= nu;
				continue;
			}

			// 6. Check new parameters
			const newParams = params.map((p, i) => p + delta[i]);
			const newRes = safeResiduals(newParams);
			const newCost = costFromResiduals(newRes);

			if (newCost < cost) {
				params = newParams;
				if (newCost < bestCost) {
					bestCost = newCost;
					bestParams = params.slice();
				}
				lambda *= 0.3;
				if (lambda < 1e-20) lambda = 1e-20;
			} else {
				lambda *= nu;
				if (lambda > 1e20) {
					return { params: bestParams, cost: bestCost };
				}
			}
		}

		return { params: bestParams, cost: bestCost };
	}

	/**
	 * Compute the residuals array for the current parameters.
	 * If (x - x0) <= 0 and b not integer, we penalize heavily (return large residual).
	 */
	function computeResiduals(params, data) {
		const [A, b, x0, c] = params;
		return data.map(({ x, y }) => {
			const term = x - x0;
			if (term <= 0 && !Number.isInteger(b)) {
				// For non-integer b, negative base is invalid -> large penalty
				return 1e6;
			}
			let yPred;
			try {
				yPred = A * Math.pow(term, b) + c;
				if (!Number.isFinite(yPred)) {
					return 1e6;
				}
			} catch {
				return 1e6;
			}
			return yPred - y;
		});
	}

	/**
	 * Compute the Jacobian for [A, b, x0, c].
	 * J[i][k] = derivative of residual_i w.r.t. param_k
	 */
	function computeJacobian(params, data) {
		const [A, b, x0, c] = params;
		return data.map(({ x, y }) => {
			const term = x - x0;
			// Default partial derivatives
			let dA = 0,
				db = 0,
				dx0 = 0,
				dc = 0;

			if (term <= 0 && !Number.isInteger(b)) {
				// invalid region -> residual ~ 1e6 w.r.t. everything
				// For continuity, let's set derivatives near zero (or 0.0)
				return [0, 0, 0, 0];
			}

			// yPred = A * term^b + c
			// residual = yPred - y
			// => partial residual / partial param = partial yPred / partial param
			// partial wrt A = term^b
			// partial wrt b = A * term^b * ln(term)
			// partial wrt x0 = -A * b * term^(b-1)
			// partial wrt c = 1

			try {
				// term^b
				const basePow = Math.pow(term, b);
				const lnTerm = Math.log(term);

				dA = basePow;
				db = A * basePow * lnTerm;
				dx0 = -A * b * Math.pow(term, b - 1);
				dc = 1;

				// If any are NaN or infinite, set to 0
				if (!Number.isFinite(dA)) dA = 0;
				if (!Number.isFinite(db)) db = 0;
				if (!Number.isFinite(dx0)) dx0 = 0;
			} catch {
				// In case of domain errors
				dA = dA = dx0 = dc = 0;
			}

			return [dA, db, dx0, dc];
		});
	}

	// ---------- Matrix Helpers ----------

	function transpose(matrix) {
		return matrix[0].map((_, i) => matrix.map(row => row[i]));
	}

	function multiply(a, b) {
		// matrix x matrix
		const m = a.length;
		const n = b[0].length;
		const result = new Array(m).fill(null).map(() => new Array(n).fill(0));
		for (let i = 0; i < m; i++) {
			for (let j = 0; j < n; j++) {
				let sum = 0;
				for (let k = 0; k < b.length; k++) {
					sum += a[i][k] * b[k][j];
				}
				result[i][j] = sum;
			}
		}
		return result;
	}

	function multiplyMatrixVector(matrix, vector) {
		return matrix.map(row => {
			let sum = 0;
			for (let i = 0; i < row.length; i++) {
				sum += row[i] * vector[i];
			}
			return sum;
		});
	}

	/**
	 * Solve a system Ax = b using Gaussian elimination
	 * 
	 * @param {Array<Array<number>>} matrix - 2D array (A)
	 * @param {Array<number>} vector - 1D array (b)
	 */
	function solve(matrix, vector) {
		const n = matrix.length;
		const augmented = matrix.map((row, i) => row.concat([vector[i]]));

		for (let i = 0; i < n; i++) {
			// Find pivot
			let maxRow = i;
			for (let r = i + 1; r < n; r++) {
				if (Math.abs(augmented[r][i]) > Math.abs(augmented[maxRow][i])) {
					maxRow = r;
				}
			}
			if (maxRow !== i) {
				[augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
			}

			const pivot = augmented[i][i];
			if (Math.abs(pivot) < 1e-14) {
				throw new Error("Singular matrix");
			}

			// Normalize pivot row
			for (let c = i; c <= n; c++) {
				augmented[i][c] /= pivot;
			}

			// Eliminate in other rows
			for (let r = 0; r < n; r++) {
				if (r !== i) {
					const factor = augmented[r][i];
					for (let c = i; c <= n; c++) {
						augmented[r][c] -= factor * augmented[i][c];
					}
				}
			}
		}

		return augmented.map(row => row[n]);
	}

	/**
	 * Simple median function
	 */
	function median(arr) {
		if (!arr.length) return NaN;
		const sorted = [...arr].sort((a, b) => a - b);
		const mid = Math.floor(sorted.length / 2);
		if (sorted.length % 2 === 0) {
			return 0.5 * (sorted[mid - 1] + sorted[mid]);
		}
		return sorted[mid];
	}

	function estimateKFromData() {
		if (!rawData[activeSet] || rawData[activeSet].length < 4) {
			console.warn("Not enough data points to estimate k.");
			return null;
		}

		// === 1. Sort & detrend ===
		const sortedData = [...rawData[activeSet]].sort((a, b) => a.x - b.x);
		const x = sortedData.map(p => p.x);
		const y = sortedData.map(p => p.y);

		const N = x.length;
		const xMin = x[0];
		const xMax = x[N - 1];
		const dataSpan = xMax - xMin;
		if (dataSpan <= 0) {
			console.warn("Degenerate or invalid X range.");
			return null;
		}

		// Mean of y for detrending
		const meanY = y.reduce((acc, val) => acc + val, 0) / N;
		const yDetrended = y.map(val => val - meanY);

		// We'll also need an approximate sampling step to gauge a "Nyquist" limit
		//   (roughly valid if data is close to uniform in x).
		const avgDx = dataSpan / (N - 1);
		// A naive Nyquist frequency ~ π / avgDx
		const nyquist = Math.PI / avgDx;

		// === 2. Optional: Peak-detection for rough kGuess ===
		let peaks = [];
		for (let i = 1; i < N - 1; i++) {
			if (y[i] > y[i - 1] && y[i] > y[i + 1]) {
				peaks.push(x[i]);
			}
		}
		let kGuess = null;
		if (peaks.length >= 2) {
			const intervals = [];
			for (let i = 1; i < peaks.length; i++) {
				intervals.push(peaks[i] - peaks[i - 1]);
			}
			const avgPeriod = intervals.reduce((a, b) => a + b, 0) / intervals.length;
			kGuess = (2 * Math.PI) / avgPeriod;
			console.log(
				`Peak-detect guess => period ~ ${avgPeriod.toFixed(4)}, kGuess ~ ${kGuess.toFixed(4)}`
			);
		} else {
			console.log("Not enough peaks for a peak-based guess.");
		}

		// === 3. Define an initial log-spaced frequency range ===
		// We'll define a broad range, but not infinite.
		// Lower bound: say 2π / (5 * dataSpan) => up to ~5 cycles across the entire domain
		// or 1e-3 if that is bigger, just to avoid going too close to zero.
		const minCandidate = Math.max(1e-3, (2 * Math.PI) / (5 * dataSpan));

		// Upper bound: let's pick something around 5 × the naive Nyquist as a default
		// (i.e. 5 × π / avgDx), but not less than, say, 10 if the data is extremely well-sampled.
		let maxCandidate = Math.max(10, nyquist * 5);

		// If we do have a kGuess, ensure that we include it by possibly expanding the range:
		if (kGuess && Number.isFinite(kGuess) && kGuess > 0) {
			if (kGuess < minCandidate) {
				// expand downward
				console.log(
					`kGuess < minCandidate => adjusting minCandidate from ${minCandidate.toFixed(4)} to ~${kGuess / 5}`
				);
				minCandidate <= 1e-7 ?
					(minCandidate = 1e-7) :
					(minCandidate = Math.max(1e-7, kGuess / 5));
			}
			if (kGuess > maxCandidate) {
				console.log(
					`kGuess > maxCandidate => adjusting maxCandidate from ${maxCandidate.toFixed(4)} to ~${kGuess * 5}`
				);
				maxCandidate = kGuess * 5;
			}
		}

		console.log(
			`Log-search range: [${minCandidate.toFixed(4)}, ${maxCandidate.toFixed(4)}]`
		);

		// === 4. Coarse search in log space ===
		// We'll sample frequencies log-spaced from minCandidate to maxCandidate
		const numLogSamples = 200; // ~200 log steps
		const logMin = Math.log(minCandidate);
		const logMax = Math.log(maxCandidate);

		let bestCoarseOmega = 0;
		let bestCoarseScore = -Infinity;

		for (let i = 0; i < numLogSamples; i++) {
			// Log spacing
			const frac = i / (numLogSamples - 1);
			const omega = Math.exp(logMin + frac * (logMax - logMin));

			let sumSin = 0;
			let sumCos = 0;
			for (let j = 0; j < N; j++) {
				const val = yDetrended[j];
				const phase = omega * x[j];
				sumSin += val * Math.sin(phase);
				sumCos += val * Math.cos(phase);
			}
			const score = sumSin * sumSin + sumCos * sumCos;
			if (score > bestCoarseScore) {
				bestCoarseScore = score;
				bestCoarseOmega = omega;
			}
		}
		console.log(
			`Log-coarse best => omega = ${bestCoarseOmega.toFixed(4)}, score = ${bestCoarseScore.toExponential(3)}`
		);

		// === 5. Fine local linear search around bestCoarseOmega ===
		// We'll do ± 30% in linear space (adjust as desired)
		const fineFactor = 0.3;
		const fineMin = Math.max(minCandidate, bestCoarseOmega * (1 - fineFactor));
		const fineMax = Math.min(maxCandidate, bestCoarseOmega * (1 + fineFactor));

		let bestFineOmega = bestCoarseOmega;
		let bestFineScore = bestCoarseScore;

		if (fineMax <= fineMin) {
			console.warn(
				`Fine search range is degenerate => [${fineMin}, ${fineMax}]. Returning coarse result.`
			);
			return bestCoarseOmega;
		}

		const numFine = 3000; // ~3k linear steps
		const step = (fineMax - fineMin) / (numFine - 1);

		for (let i = 0; i < numFine; i++) {
			const omega = fineMin + i * step;
			let sumSin = 0;
			let sumCos = 0;
			for (let j = 0; j < N; j++) {
				const val = yDetrended[j];
				const phase = omega * x[j];
				sumSin += val * Math.sin(phase);
				sumCos += val * Math.cos(phase);
			}
			const score = sumSin * sumSin + sumCos * sumCos;
			if (score > bestFineScore) {
				bestFineScore = score;
				bestFineOmega = omega;
			}
		}
		console.log(
			`Fine search best => omega = ${bestFineOmega.toFixed(4)}, score = ${bestFineScore.toExponential(3)}`
		);

		// === 6. Final sanity check vs. Nyquist? ===
		if (bestFineOmega > 2 * nyquist) {
			console.warn(
				`Warning: best freq = ${bestFineOmega.toFixed(4)} is > 2 × Nyquist (~${(2 * nyquist).toFixed(4)}). Data may be under-sampled.`
			);
		}

		console.log(
			`Final estimated k = ${bestFineOmega.toFixed(4)}`
		);
		return bestFineOmega;
	}

	function performSinusoidalFit() {
		try {
			let A0 = parseFloat(document.getElementById('initial-A').value);
			let b0 = parseFloat(document.getElementById('initial-b').value);
			let k0 = parseFloat(document.getElementById('initial-k').value);
			let phi0 = parseFloat(document.getElementById('initial-phi').value);
			let c0 = parseFloat(document.getElementById('initial-c').value);

			if (!Number.isFinite(k0) || k0 <= 0) {
				const estimatedK = estimateKFromData();
				if (estimatedK !== null && Number.isFinite(estimatedK) && estimatedK > 0) {
					k0 = estimatedK;
					document.getElementById('initial-k').value = k0.toFixed(3);
					console.log(`Using estimated k: ${k0}`);
				} else {
					alert('Failed to estimate k. Please provide an initial value.');
					return;
				}
			}

			if (!Number.isFinite(A0) || !Number.isFinite(b0) || !Number.isFinite(phi0) || !Number.isFinite(c0)) {
				alert('Please provide valid initial parameters for Sinusoidal fit.');
				return;
			}

			const data = rawData[activeSet].filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
			if (data.length < 4) {
				alert('Sinusoidal fit requires at least four valid data points.');
				return;
			}

			// Model: y = A e^{b x} sin(k x - phi) + c
			function residualFn(params, pts) {
				const [A, b, k, phi, c] = params;
				const PEN = 1e6;
				return pts.map(({ x, y }) => {
					try {
						const expTerm = Math.exp(b * x);
						const ang = k * x - phi;
						const yPred = A * expTerm * Math.sin(ang) + c;
						if (!Number.isFinite(yPred)) return PEN;
						return yPred - y;
					} catch {
						return PEN;
					}
				});
			}

			function jacobianFn(params, pts) {
				const [A, b, k, phi, c] = params;
				return pts.map(({ x, y }) => {
					let expTerm, sinTerm, cosTerm;
					try {
						expTerm = Math.exp(b * x);
						const ang = k * x - phi;
						sinTerm = Math.sin(ang);
						cosTerm = Math.cos(ang);
					} catch {
						return [0, 0, 0, 0, 0];
					}
					let dA = expTerm * sinTerm;
					let db = A * x * expTerm * sinTerm;
					let dk = A * expTerm * x * cosTerm;
					let dphi = -A * expTerm * cosTerm;
					let dc = 1;

					if (!Number.isFinite(dA)) dA = 0;
					if (!Number.isFinite(db)) db = 0;
					if (!Number.isFinite(dk)) dk = 0;
					if (!Number.isFinite(dphi)) dphi = 0;

					return [dA, db, dk, dphi, dc];
				});
			}

			const initialParams = [A0, b0, k0, phi0, c0];
			const { params } = levenbergMarquardt(data, initialParams, residualFn, jacobianFn, { maxIterations: 300, tolerance: 1e-10 });

			const [A, b, k, phi, c] = params;

			const xMin = Math.min(...data.map(p => p.x));
			const xMax = Math.max(...data.map(p => p.x));
			const xFit = Array.from({ length: 300 }, (_, i) => xMin + i * (xMax - xMin) / 299);
			const fitFunction = xi => A * Math.exp(b * xi) * Math.sin(k * xi - phi) + c;
			const yFit = xFit.map(fitFunction);

			let equation = `y = ${A.toFixed(3)} e^{${b.toFixed(3)}x} \sin(${k.toFixed(3)}x`;
			if (phi > 0) equation += ` - ${phi.toFixed(3)}`;
			else if (phi < 0) equation += ` + ${Math.abs(phi).toFixed(3)}`;
			equation += `)`;
			if (c > 0) equation += ` + ${c.toFixed(3)}`;
			else if (c < 0) equation += ` - ${Math.abs(c).toFixed(3)}`;

			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, data.map(p => p.x), data.map(p => p.y), fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing sinusoidal fit:', error);
			alert('An error occurred during sinusoidal fitting. Please check the console for details.');
		}
	}


	function performGaussianFit() {
		try {
			let A0 = parseFloat(document.getElementById('initial-A-gaussian').value);
			let mu0 = parseFloat(document.getElementById('initial-mu').value);
			let sigma0 = parseFloat(document.getElementById('initial-sigma').value);
			let c0 = parseFloat(document.getElementById('initial-c-gaussian').value);

			if (!Number.isFinite(A0) || !Number.isFinite(mu0) || !Number.isFinite(sigma0) || !Number.isFinite(c0)) {
				alert('Please provide valid initial parameters for Gaussian fit.');
				return;
			}

			if (sigma0 === 0) sigma0 = 1e-6;
			if (sigma0 < 0) sigma0 = Math.abs(sigma0);

			const data = rawData[activeSet].filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
			if (data.length < 4) {
				alert('Gaussian fit requires at least four valid data points.');
				return;
			}

			// Model: y = A exp(- (x-mu)^2 / (2 sigma^2)) + c
			function residualFn(params, pts) {
				const [A, mu, sigma, c] = params;
				const PEN = 1e6;
				if (!Number.isFinite(sigma) || sigma <= 0) {
					return new Array(pts.length).fill(PEN);
				}
				const s2 = sigma * sigma;
				return pts.map(({ x, y }) => {
					try {
						const d = x - mu;
						const expo = -(d * d) / (2 * s2);
						const e = Math.exp(expo);
						const yPred = A * e + c;
						if (!Number.isFinite(yPred)) return PEN;
						return yPred - y;
					} catch {
						return PEN;
					}
				});
			}

			function jacobianFn(params, pts) {
				const [A, mu, sigma, c] = params;
				if (!Number.isFinite(sigma) || sigma <= 0) {
					return pts.map(() => [0, 0, 0, 0]);
				}
				const s2 = sigma * sigma;
				const s3 = s2 * sigma;
				return pts.map(({ x, y }) => {
					const d = x - mu;
					let e;
					try {
						e = Math.exp(-(d * d) / (2 * s2));
					} catch {
						return [0, 0, 0, 0];
					}
					let dA = e;
					let dMu = A * e * (d / s2);
					let dSigma = A * e * ((d * d) / s3);
					let dC = 1;

					if (!Number.isFinite(dA)) dA = 0;
					if (!Number.isFinite(dMu)) dMu = 0;
					if (!Number.isFinite(dSigma)) dSigma = 0;

					return [dA, dMu, dSigma, dC];
				});
			}

			const initialParams = [A0, mu0, sigma0, c0];
			const { params } = levenbergMarquardt(data, initialParams, residualFn, jacobianFn, { maxIterations: 300, tolerance: 1e-10 });

			let [A, mu, sigma, c] = params;
			if (!Number.isFinite(sigma) || sigma <= 0) sigma = Math.max(1e-6, Math.abs(sigma0));

			const xMin = Math.min(...data.map(p => p.x));
			const xMax = Math.max(...data.map(p => p.x));
			const xFit = Array.from({ length: 300 }, (_, i) => xMin + i * (xMax - xMin) / 299);

			const fitFunction = xi => A * Math.exp(-((xi - mu) ** 2) / (2 * sigma * sigma)) + c;
			const yFit = xFit.map(fitFunction);

			let equation = `y = ${A.toFixed(3)} e^{-\frac{(x - ${mu.toFixed(3)})^2}{2(${sigma.toFixed(3)})^2}}`;
			if (c > 0) equation += ` + ${c.toFixed(3)}`;
			else if (c < 0) equation += ` - ${Math.abs(c).toFixed(3)}`;

			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, data.map(p => p.x), data.map(p => p.y), fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing Gaussian fit:', error);
			alert('An error occurred during Gaussian fitting. Please check the console for details.');
		}
	}


	document.addEventListener("DOMContentLoaded", function() {
		// Ensure base dataset structures exist.
		if (!datasetHeaders[0]) datasetHeaders[0] = { x: 'x', y: 'y' };
		if (!datasetToggles[0]) datasetToggles[0] = { x: false, y: false };
		if (!datasetErrorTypes[0]) datasetErrorTypes[0] = { x: 'absolute', y: 'absolute' };

		// Initialise a clean table with defaults.
		clearRows(true);

		// Persist initial headers.
		datasetHeaders[0].x = document.getElementById('x-column-name').value || 'x';
		datasetHeaders[0].y = document.getElementById('y-column-name').value || 'y';

		// If the user edits the title manually, stop auto-updating it.
		const titleInput = document.getElementById('graph-title');
		if (titleInput) {
			titleInput.addEventListener('input', function() {
				titleWasAuto = false;
			});
		}

		// Fit UI initialisation.
		updateBasicFitEquation();
		const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
		changeAdvancedFitMethod();
		setInitialParameters(initialAdvancedFitMethod);

		// Dataset tabs.
		initializeDatasetTabsBar();

		// Combined plot inputs.
		initCombinedPlotInputs();

		// LaTeX mode toggle.
		const latexToggle = document.getElementById('latex-mode-toggle');
		if (latexToggle) {
			latexToggle.checked = false; // default off
			latexToggle.addEventListener('change', function() {
				latexMode = this.checked;
				updatePlotAndRenderLatex();
				// Re-render headers and uncertainty headings.
				loadHeaders();
				updateUncertaintyHeaders('x');
				updateUncertaintyHeaders('y');
				// Convert auto-title formatting if it has not been manually edited.
				updateGraphTitle();
			});
		}
	});
</script>

</html>
