<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>PanPhyPlot</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<!-- Plotly.js for graphing -->
	<script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
	<!-- Math.js for computations -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
	<!-- MathJax v2 for LaTeX rendering -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>

	<style>
		/* Root Variables */
		:root {
			--add-row-btn-color: #6aa84f;
			--clear-all-btn-color: #e06666;
			--import-csv-btn-color: #45818e;
			--export-csv-btn-color: #6fa8dc;
			--tab-bg-color: #f3f3f3;
			--tab-active-bg-color: #ffd966;
			--tab-border-color: #ccc;
			--tab-close-color: #999;
			--tab-close-hover-color: #e06666;
		}

		/* Global Styles */
		html,
		body {
			margin: 0;
			padding: 0;
			overflow-x: hidden;
			font-family: Helvetica, sans-serif;
			background-color: #f4f4f4;
			color: #333;
		}

		/* Banner */
		.banner {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background-color: #333;
			color: #fff;
			padding: 3px;
			font-size: 22px;
			font-weight: bold;
			position: relative;
		}

		.banner-logo {
			display: flex;
			align-items: center;
		}

		.banner-logo img {
			max-height: 35px;
			margin-left: 10px;
			margin-top: 4px;
		}

		.banner-title {
			flex: 1;
			text-align: center;
			font-size: 1.5rem;
		}

		.banner-buttons {
			display: flex;
			width: 60px;
			justify-content: flex-end;
			margin-right: 15px;
		}

		.banner-button {
			background: none;
			border: none;
			color: grey;
			text-decoration: none;
			cursor: pointer;
			font-size: 14px;
			padding: 0;
			transition: color 0.3s;
		}

		.banner-button:hover {
			color: #ddd;
		}

		/* Reminder and Toggle */
		.reminder {
			color: #999;
			margin: 3px 0;
			font-size: 12px;
			position: relative;
			text-align: center;
			padding: 3px 10px;
		}

		.latex-toggle-container {
			position: absolute;
			right: 10px;
			top: 50%;
			transform: translateY(-50%);
			display: flex;
			align-items: center;
			gap: 5px;
		}

		/* Toggle Switch */
		.switch {
			position: relative;
			display: inline-block;
			width: 40px;
			height: 19px;
		}

		.switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: 0.4s;
			border-radius: 24px;
		}

		.slider:before {
			position: absolute;
			content: "";
			height: 15px;
			width: 15px;
			left: 2px;
			bottom: 2px;
			background-color: #fff;
			transition: 0.4s;
			border-radius: 50%;
		}

		.switch input:checked+.slider {
			background-color: #67c399;
		}

		.switch input:checked+.slider:before {
			transform: translateX(21px);
		}

		.toggle-label {
			font-size: 14px;
			color: #333;
		}

		/* Dataset Tabs Bar */
		.dataset-tabs-bar {
			display: flex;
			align-items: center;
			padding: 0 10px;
			background-color: #f4f4f4;
			flex-wrap: nowrap;
			overflow-x: auto;
			-webkit-overflow-scrolling: touch;
			scrollbar-width: thin;
		}

		.dataset-tabs-bar::-webkit-scrollbar {
			height: 6px;
		}

		.dataset-tabs-bar::-webkit-scrollbar-track {
			background: #f1f1f1;
		}

		.dataset-tabs-bar::-webkit-scrollbar-thumb {
			background: #ccc;
			border-radius: 3px;
		}

		.dataset-tabs-bar::-webkit-scrollbar-thumb:hover {
			background: #999;
		}

		/* Dataset Tabs */
		.dataset-tab {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			padding: 8px 16px;
			margin-right: 2px;
			line-height: 1.2;
			background-color: #ddd;
			color: #333;
			border: 1px solid transparent;
			border-bottom: none;
			border-top-left-radius: 6px;
			border-top-right-radius: 6px;
			cursor: pointer;
			transition: background-color 0.2s;
			font-size: 14px;
		}

		.dataset-tab.active {
			background-color: #ffba3b;
			border-color: #aaa;
			font-weight: bold;
		}

		.dataset-tab .tab-label {
			margin-right: 5px;
			white-space: nowrap;
		}

		.dataset-tab .tab-close {
			font-weight: bold;
			color: #888;
			cursor: pointer;
			padding-left: 4px;
			user-select: none;
		}

		.dataset-tab .tab-close:hover {
			color: #e06666;
		}

		.add-dataset-btn {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			padding: 8px 10px;
			margin-left: 0;
			line-height: 1.2;
			background-color: #16537e;
			color: #fff;
			border: 1px solid transparent;
			border-top-left-radius: 6px;
			border-top-right-radius: 6px;
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
			border-bottom: none;
			cursor: pointer;
			transition: background-color 0.2s;
			font-size: 14px;
			flex: none;
			width: 110px;
		}

		.add-dataset-btn:hover {
			background-color: #113d5c;
		}

		/* Layout Sections */
		.container {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}

		.input-section,
		.graph-section {
			background-color: #fff;
			border-radius: 8px;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			padding: 20px;
			box-sizing: border-box;
			height: 80vh;
			overflow-y: auto;
		}

		.input-section {
			flex: 1 1 400px;
			max-width: 400px;
		}

		.graph-section {
			flex: 2 1 600px;
			min-width: 300px;
		}

		/* Section Headings */
		.input-section h2,
		.graph-section h2,
		.global-uncertainty h2,
		.advanced-fit-section h2 {
			font-family: Arial, sans-serif;
			font-size: 20px;
			background-color: #ffad7a;
			color: #222;
			padding: 5px;
			border-radius: 4px;
			margin: 0 0 15px;
			text-align: center;
		}

		/* Data Table */
		.table-container {
			max-height: 300px;
			overflow-y: auto;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.data-table {
			width: 100%;
			margin-bottom: 20px;
			border-collapse: collapse;
			table-layout: auto;
		}

		.data-table th,
		.data-table td {
			text-align: center;
			padding: 8px;
			border: 1px solid #ccc;
			vertical-align: middle;
			white-space: normal;
		}

		.data-table th input {
			width: 90%;
			border: none;
			outline: none;
			font-size: 16px;
			text-align: center;
			background-color: transparent;
			padding: 4px;
		}

		.data-table th input:focus {
			border-bottom: 2px solid #6fa8dc;
		}

		.data-table .latex-display {
			margin-top: 4px;
			background-color: #f0f8ff;
			border: 1px solid #add8e6;
			padding: 6px 8px;
			border-radius: 4px;
			font-size: 14px;
			color: #333;
			max-width: 100%;
			word-wrap: break-word;
		}

		.data-table td input {
			width: 100%;
			border: none;
			outline: none;
			font-size: 14px;
			text-align: center;
			background-color: transparent;
			padding: 4px;
		}

		.data-table td input:focus {
			outline: 1px solid #6fa8dc;
		}

		.data-table tbody tr:nth-child(odd) {
			background-color: #f9f9f9;
		}

		.data-table tbody tr:nth-child(even) {
			background-color: #fff;
		}

		/* Buttons */
		/* Global button styles apply to all button elements */
		button {
			padding: 10px 15px;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			margin: 2px;
			flex: 1;
			transition: background-color 0.3s, filter 0.3s;
		}

		button:hover {
			filter: brightness(90%);
		}

		/* Specific button backgrounds */
		.btn-add-row {
			background-color: var(--add-row-btn-color);
		}

		.btn-clear-all {
			background-color: var(--clear-all-btn-color);
		}

		.btn-copy-x {
			background-color: #6aa84f;
		}

		.btn-import-csv {
			background-color: var(--import-csv-btn-color);
		}

		.btn-export-csv,
		.btn-export-md {
			background-color: var(--export-csv-btn-color);
		}

		/* Fit Buttons (full width, fixed height) */
		.fit-button {
			background-color: #6fa8dc;
			width: 100%;
			height: 40px;
			padding: 0;
			margin: 0;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		.clear-fit-button {
			background-color: #e06666;
			width: 100%;
			height: 40px;
			padding: 0;
			margin: 0;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		/* Button Containers */
		.button-container {
			display: flex;
			flex-direction: column;
			gap: 2px;
			justify-content: center;
			align-items: center;
			margin: 10px 0;
		}

		.button-row {
			display: flex;
			gap: 2px;
			width: 100%;
		}

		/* Global Uncertainty */
		.global-uncertainty {
			margin: 20px 0;
			padding: 10px;
			border-top: 1px solid #ccc;
			border-bottom: 1px solid #ccc;
		}

		.uncertainty-controls {
			display: flex;
			justify-content: center;
			gap: 20px;
		}

		.uncertainty-controls div {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.global-uncertainty-item {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 5px;
		}

		.global-uncertainty-item input {
			flex: 1;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.global-uncertainty-item input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		.global-uncertainty-item button {
			background-color: #80c1c5;
			color: #111;
			padding: 8px 12px;
			border-radius: 4px;
			font-size: 14px;
			cursor: pointer;
			transition: background-color 0.3s, filter 0.3s;
		}

		.global-uncertainty-item button:hover {
			filter: brightness(90%);
		}

		/* Advanced Fit Section */
		.advanced-fit-section {
			margin-top: 20px;
			padding: 10px;
			border-top: 1px solid #ccc;
		}

		.advanced-fit-section select,
		.advanced-fit-section .fit-method-select {
			min-width: 150px;
			max-width: 300px;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
			margin-bottom: 15px;
		}

		.advanced-fit-item {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 10px;
		}

		.advanced-fit-item label {
			white-space: nowrap;
		}

		.advanced-fit-item input {
			max-width: 200px;
			padding: 5px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.advanced-fit-item input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		/* Parameter Section */
		.parameter-section {
			display: none;
		}

		.parameter-section.active {
			display: block;
		}

		/* General Equation */
		.general-equation {
			margin: 20px 0 10px;
			background-color: #e9ecef;
			padding: 10px;
			border: 1px solid #ccc;
			border-radius: 4px;
			font-size: 16px;
			text-align: center;
		}

		/* Tabs */
		.tabs {
			display: flex;
			border-radius: 4px;
			margin-bottom: 5px;
		}

		.tabs button {
			background-color: #f3f3f3;
			border: none;
			cursor: pointer;
			padding: 8px;
			transition: background-color 0.3s, filter 0.3s;
			font-size: 16px;
			border-radius: 4px;
			color: #999;
			width: 50%;
		}

		.tabs button:hover {
			background-color: #eee;
			filter: brightness(95%);
		}

		.tabs button.active {
			background-color: #ffd966;
			color: #000;
		}

		.tab-content {
			display: none;
			padding: 15px 1px;
		}

		.tab-content.active {
			display: block;
		}

		/* Results */
		.result {
			margin-bottom: 20px;
			background-color: #f9f9f9;
			padding: 15px;
			border-radius: 8px;
		}

		.result h3 {
			margin-top: 0;
		}

		.result p {
			margin: 10px 0;
			font-size: 16px;
		}

		/* Plot */
		#plot {
			width: 100%;
			height: 500px;
			margin-top: 20px;
		}

		.plot-all-container {
			display: flex;
			justify-content: center;
			margin-top: 10px;
		}

		.plot-all-btn {
			padding: 8px 16px;
			background-color: #6fa8dc;
			color: #fff;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.3s, filter 0.3s;
		}

		.plot-all-btn:hover {
			filter: brightness(90%);
		}

		/* Responsive */
		@media (max-width: 900px) {
			.container {
				flex-direction: column;
			}

			.input-section,
			.graph-section {
				max-width: 100%;
				flex: none;
			}

			.banner-logo,
			.banner-buttons {
				width: auto;
			}
		}

		/* Graph Title */
		.graph-title-container {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
		}

		.graph-title-container label {
			font-size: 14px;
			font-weight: bold;
			margin-right: 10px;
		}

		.graph-title-container input {
			flex: 1;
			padding: 8px;
			font-size: 14px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.graph-title-container input:focus {
			border-color: #6fa8dc;
			outline: none;
		}

		/* Popup */
		#popup-background {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			z-index: 1000;
		}

		#popup-container {
			position: fixed;
			top: 2%;
			width: 100%;
			height: 100%;
			background: transparent;
			z-index: 1001;
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 0;
		}

		#popup-content {
			background: #fff;
			padding: 20px;
			border-radius: 5px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			width: 100%;
			max-width: 800px;
			max-height: 90vh;
			overflow: auto;
			position: relative;
			margin: 0 auto;
		}

		#popup-title {
			font-size: 18px;
			font-weight: bold;
			margin-bottom: 3px;
			text-align: center;
		}

		#popup-plot {
			width: 100%;
			min-width: 600px;
			min-height: 400px;
			margin-top: 5px;
		}

		#popup-close {
			position: absolute;
			top: 10px;
			right: 10px;
			background: #e06666;
			color: #fff;
			border: none;
			border-radius: 2px;
			padding: 4px 8px;
			cursor: pointer;
			z-index: 1100;
		}

		#popup-close:hover {
			background: #cc5555;
		}

		/* Combined Plot Controls */
		.combined-plot-controls {
			margin-top: 10px;
			padding: 10px;
			background-color: #f5f5f5;
			border: 1px solid #ddd;
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.control-row-horizontal {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.control-row-horizontal label {
			width: 120px;
			font-weight: bold;
		}

		.control-row-horizontal input[type="text"] {
			padding: 5px;
			font-size: 1rem;
			border: 1px solid #ccc;
			border-radius: 3px;
			flex-grow: 1;
			box-sizing: border-box;
		}

		#popup-plot-container {
			margin-top: 15px;
		}

		/* Footer */
		footer {
			position: static;
			font-size: 15px;
			text-align: center;
			padding: 7px;
			background: #f4f4f4;
			color: #555;
			margin: 4px 0;
			width: 100%;
		}

		footer a {
			color: #ff5f1f;
			text-decoration: none;
		}

		footer a:hover {
			text-decoration: underline;
		}

		footer a:visited {
			color: #ff5f1f;
		}
	</style>
</head>

<body>
	<div class="banner">
		<!-- Logo on the Left -->
		<div class="banner-logo">
			<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">
				<img src="/panphy.png" alt="PanPhy logo" />
			</a>
		</div>

		<!-- Title in the Center -->
		<div class="banner-title">PanPhyPlot</div>

		<!-- Buttons on the Right -->
		<div class="banner-buttons">
			<a href="panphyplot_manual.html" class="banner-button" target="_blank" rel="noopener noreferrer">Manual</a>
		</div>
	</div>

	<div class="reminder">
		<span>Note: Headings and Title accept LaTeX input when LaTeX mode is ON.</span>
		<div class="latex-toggle-container">
			<!-- Toggle switch -->
			<label class="switch">
				<input type="checkbox" id="latex-mode-toggle">
				<span class="slider"></span>
			</label>
			<span class="toggle-label">LaTeX mode</span>
		</div>
	</div>

	<!-- Dataset Tabs Bar with "Add Dataset" button -->
	<div class="dataset-tabs-bar">
		<!-- Example initial tab -->
		<div class="dataset-tab active">
			<span class="tab-label">Dataset 1</span>
			<span class="tab-close" title="Remove dataset">×</span>
		</div>
		<!-- The Add Dataset button looks just like a tab except it keeps its own color -->
		<button class="add-dataset-btn">Add Dataset</button>
	</div>

	<!-- Main container: left = Input section, right = Graph section -->
	<div class="container">
		<!-- Input section -->
		<div class="input-section">
			<h2>Data</h2>
			<div class="table-container">
				<table class="data-table" id="data-table">
					<thead>
						<tr>
							<th>
								<input type="text" id="x-column-name" value="x" oninput="updateLabels('x')" />
								<div id="x-column-latex" class="latex-display">\( x \)</div>
							</th>
							<th>
								<input type="text" id="y-column-name" value="y" oninput="updateLabels('y')" />
								<div id="y-column-latex" class="latex-display">\( y \)</div>
							</th>
							<th class="error-column" id="x-error-header" style="display: none;">
								<div id="x-error-header-latex" class="latex-display">\( \pm \Delta x \)</div>
							</th>
							<th class="error-column" id="y-error-header" style="display: none;">
								<div id="y-error-header-latex" class="latex-display">\( \pm \Delta y \)</div>
							</th>
						</tr>
					</thead>
					<tbody>
						<!-- Rows inserted by JS -->
					</tbody>
				</table>
			</div>

			<div class="button-container">
				<div class="button-row">
					<button class="btn-add-row" onclick="addRow()">Add Row</button>
					<button class="btn-copy-x" onclick="copyXFromSet1()">Copy x₁</button>
					<button class="btn-clear-all" onclick="clearRows()">Clear Data</button>
				</div>
				<div class="button-row">
					<button class="btn-import-csv" onclick="document.getElementById('csv-file-input').click()">
						Import .csv
					</button>
					<button class="btn-export-csv" onclick="exportCSV()">Export .csv</button>
					<button class="btn-export-md" onclick="exportPlainText()">Export .md</button>
				</div>
			</div>
			<input type="file" id="csv-file-input" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)" />

			<div class="global-uncertainty">
				<h2>Uncertainties</h2>
				<div class="uncertainty-controls">
					<div>
						<label>
							<input type="checkbox" id="toggle-x-error" onclick="toggleErrorColumn('x')" />
							Δx
						</label>
						<select id="x-error-type" onchange="updateErrorType('x')">
							<option value="absolute">absolute</option>
							<option value="percentage">%</option>
						</select>
					</div>
					<div>
						<label>
							<input type="checkbox" id="toggle-y-error" onclick="toggleErrorColumn('y')" />
							Δy
						</label>
						<select id="y-error-type" onchange="updateErrorType('y')">
							<option value="absolute">absolute</option>
							<option value="percentage">%</option>
						</select>
					</div>
				</div>

				<h3>Apply Global Uncertainty</h3>
				<div class="global-uncertainty-item">
					<input type="text" id="global-x-uncertainty" placeholder="Enter Δx" />
					<button onclick="applyGlobalUncertainties('x')">Apply Δx</button>
				</div>
				<div class="global-uncertainty-item">
					<input type="text" id="global-y-uncertainty" placeholder="Enter Δy" />
					<button onclick="applyGlobalUncertainties('y')">Apply Δy</button>
				</div>
			</div>

			<div class="fit-method-section">
				<h2>Best Fit Line</h2>
				<div class="tabs">
					<button class="tablink active" onclick="openTab(event, 'BasicFit')">Basic Fit</button>
					<button class="tablink" onclick="openTab(event, 'AdvancedFit')">Advanced Fit</button>
				</div>

				<!-- Basic Fit -->
				<div id="BasicFit" class="tab-content active">
					<label for="fit-method">Fit Method:</label>
					<select id="fit-method" onchange="updateBasicFitEquation()">
						<option value="Linear">Linear</option>
						<option value="Polynomial-2">Quadratic</option>
						<option value="Polynomial-3">Cubic</option>
						<!-- <option value="Polynomial-4">Polynomial (4th Degree)</option> -->
						<!-- Disabled 4th Degree Polynomial due to lack of applications -->
						<option value="Exponential">Exponential</option>
						<option value="Power">Power</option>
					</select>
					<div id="basic-fit-equation" class="general-equation">
						\( y = mx + c \)
					</div>
					<div style="display: flex; gap: 6px;">
						<button class="fit-button" onclick="fitCurve()">Fit Curve</button>
						<button class="clear-fit-button" onclick="clearFittedCurve()">Clear Fit</button>
					</div>
				</div>

				<!-- Advanced Fit -->
				<div id="AdvancedFit" class="tab-content">
					<label for="advanced-fit-method">Advanced Fit Method:</label>
					<select id="advanced-fit-method" class="fit-method-select" onchange="changeAdvancedFitMethod()">
						<option value="Sinusoidal">Sinusoidal</option>
						<option value="Gaussian">Gaussian</option>
					</select>
					<div id="advanced-fit-general-equation" class="general-equation">
						\( y = A e^{bx} \sin(kx - \phi) + c \)
					</div>
					<p class="table-prompt">Enter initial fitting parameters below.</p>

					<!-- Sinusoidal -->
					<div id="Sinusoidal-parameters" class="parameter-section active">
						<div class="advanced-fit-item">
							<label for="initial-A">A:</label>
							<input type="number" id="initial-A" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-b">b:</label>
							<input type="number" id="initial-b" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-k">k:</label>
							<input type="number" id="initial-k" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-phi">φ:</label>
							<input type="number" id="initial-phi" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-c">c:</label>
							<input type="number" id="initial-c" value="0" step="any" />
						</div>
					</div>

					<!-- Gaussian -->
					<div id="Gaussian-parameters" class="parameter-section">
						<div class="advanced-fit-item">
							<label for="initial-A-gaussian">A:</label>
							<input type="number" id="initial-A-gaussian" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-mu">μ:</label>
							<input type="number" id="initial-mu" value="0" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-sigma">σ:</label>
							<input type="number" id="initial-sigma" value="1" step="any" />
						</div>
						<div class="advanced-fit-item">
							<label for="initial-c-gaussian">c:</label>
							<input type="number" id="initial-c-gaussian" value="0" step="any" />
						</div>
					</div>

					<div style="display: flex; gap: 6px;">
						<button class="fit-button" onclick="fitAdvancedCurve()">Fit Curve</button>
						<button class="clear-fit-button" onclick="clearFittedCurve()">Clear Fit</button>
					</div>
				</div>
			</div>
		</div><!-- end input-section -->

		<!-- Graph section -->
		<div class="graph-section">
			<h2>Graph</h2>
			<div class="graph-title-container">
				<label for="graph-title">Title:</label>
				<input type="text" id="graph-title" placeholder="Enter graph title" oninput="debouncedUpdatePlotAndRenderLatex()">
			</div>
			<div id="plot"></div>

			<div class="result">
				<h3>Fitting Result</h3>
				<p id="fit-equation" style="display: none;"></p>
				<p id="r-squared-container" style="display: none;"></p>
			</div>

			<div class="plot-all-container">
				<button class="plot-all-btn" onclick="plotAllDatasets()">Plot ALL Datasets</button>
			</div>
		</div><!-- end graph-section -->
	</div><!-- end container -->

	<!-- Transparent background for the popup -->
	<div id="popup-background" style="display: none;"></div>

	<div id="popup-container" style="display: none;">
		<div id="popup-content">
			<button id="popup-close" onclick="closePopup()">Close</button>
			<div id="popup-title">Combined Plot of All Datasets</div>
			<div id="popup-plot-container">
				<div id="popup-plot"></div>
			</div>
			<div id="combined-plot-controls" class="combined-plot-controls">
				<div class="control-row-horizontal">
					<label for="combined-title">Title:</label>
					<input type="text" id="combined-title" placeholder="Enter a new Title here" />
				</div>
				<div class="control-row-horizontal">
					<label for="combined-x-label">x-axis Label:</label>
					<input type="text" id="combined-x-label" placeholder="Enter a new x-axis label here" />
				</div>
				<div class="control-row-horizontal">
					<label for="combined-y-label">y-axis Label:</label>
					<input type="text" id="combined-y-label" placeholder="Enter a new y-axis label here" />
				</div>
			</div>
		</div>
	</div>

	<footer>
		&copy; 2025 <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>
</body>

<script>
	let rawData = []; // Each element will be an array of data points
	let activeSet = 0; // Index of the current active dataset
	let datasetHeaders = {}; // Object to store headers per dataset, e.g. {0: {x: 'x', y: 'y'}, 1: {x: 'Time', y: 'Distance'}}
	let datasetToggles = {}; // Global object to hold fitted curves by dataset index.
	let datasetErrorTypes = {}; // stores the error type per axis per dataset, e.g. { 0: { x: 'absolute', y: 'absolute' }, 1: { x: 'percentage', y: 'percentage' } }
	let fittedCurves = {};
	let datasetFitResults = {}; // e.g. { 0: { equation: "...", rSquared: "..." }, 1: { ... } }
	let dataset1XValues = [];
	let latexMode = false; // false by default: plain text mode

	let lastPlotState = {
		data: null,
		layout: null
	};

	rawData.push([]);
	datasetHeaders[0] = { x: 'x', y: 'y' }; // At initialization, for dataset 0:
	datasetToggles[0] = { x: false, y: false };
	datasetErrorTypes[0] = { x: 'absolute', y: 'absolute' };

	let isSyncing = false;

	function debounce(func, wait) {
		let timeout;
		return function(...args) {
			const later = () => {
				clearTimeout(timeout);
				func.apply(this, args);
			};
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
		};
	}

	const debouncedUpdatePlotAndRenderLatex = debounce(updatePlotAndRenderLatex, 150);

	function processLabel(label) {
		if (!label) return '';
		// If LaTeX mode is off, return the plain label.
		if (!latexMode) {
			return label;
		}
		// Otherwise, format it for LaTeX.
		return `$${formatLabelForLatex(label)}$`;
	}

	function initializeTable(initialRows = 7) {
		const tableBody = document.querySelector('#data-table tbody');
		// Create the default empty rows
		for (let i = 0; i < initialRows; i++) {
			const newRow = tableBody.insertRow();
			newRow.innerHTML = `
            <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
            <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
            <td class="error-column" style="display: none;">
                <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
            </td>
            <td class="error-column" style="display: none;">
                <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" />
            </td>
        `;
		}
		// Update the active dataset with the new (empty) rows.
		updateData();
	}

	// Function to update the tabs bar UI
	function updateDatasetTabsBar() {
		const tabsBar = document.querySelector('.dataset-tabs-bar');
		if (!tabsBar) return;

		// Clear all tabs except the Add Dataset button.
		const existingTabs = Array.from(tabsBar.querySelectorAll('.dataset-tab'));
		existingTabs.forEach(tab => tab.remove());

		// For each dataset, create a tab element.
		rawData.forEach((dataset, index) => {
			const tab = document.createElement('div');
			tab.classList.add('dataset-tab');
			if (index === activeSet) {
				tab.classList.add('active');
			}
			// Create a span for the label (e.g., "Dataset 1")
			const labelSpan = document.createElement('span');
			labelSpan.classList.add('tab-label');
			labelSpan.textContent = `Dataset ${index + 1}`;
			tab.appendChild(labelSpan);

			// Create the close button. (Do not add a close icon if there is only one dataset.)
			if (rawData.length > 1) {
				const closeSpan = document.createElement('span');
				closeSpan.classList.add('tab-close');
				closeSpan.textContent = '×';
				// When the close button is clicked, remove this dataset.
				closeSpan.addEventListener('click', function(e) {
					// prevent the click from also firing the tab-switch event
					e.stopPropagation();
					removeDataset(index);
				});
				tab.appendChild(closeSpan);
			}

			// Clicking on a tab should switch to that dataset.
			tab.addEventListener('click', function() {
				switchDataset(index);
			});

			// Insert the new tab before the Add Dataset button.
			// (We assume the Add Dataset button remains as the last element.)
			const addBtn = tabsBar.querySelector('.add-dataset-btn');
			tabsBar.insertBefore(tab, addBtn);
		});
	}

	function switchDataset(index) {
		if (index < 0 || index >= rawData.length) {
			console.error("Invalid dataset index.");
			return;
		}
		activeSet = index;
		updateDatasetTabsBar();

		// Repopulate the table UI with data from the active dataset.
		populateTableFromActiveDataset();

		// Load header values for this dataset.
		loadHeaders();

		// Restore uncertainty toggle state.
		loadToggles();

		// Restore error type settings.
		loadErrorTypes();

		// Update the graph and LaTeX-rendered labels.
		updatePlotAndRenderLatex();
		updateLabels('x');
		updateLabels('y');

		// Update the combined plot input boxes with the active dataset’s header values.
		updateCombinedPlotInputsToActive();

		// Restore or clear the fitting result for the current dataset.
		const fitEquationElement = document.getElementById('fit-equation');
		const rSquaredElement = document.getElementById('r-squared-container');
		if (datasetFitResults.hasOwnProperty(activeSet)) {
			const result = datasetFitResults[activeSet];
			fitEquationElement.innerHTML = `\\(${result.equation}\\)`;
			fitEquationElement.style.display = 'block';
			rSquaredElement.innerHTML = `\\( R^2 = ${result.rSquared} \\)`;
			rSquaredElement.style.display = 'block';
			if (typeof MathJax !== 'undefined') {
				MathJax.Hub.Queue(["Typeset", MathJax.Hub, fitEquationElement]);
				MathJax.Hub.Queue(["Typeset", MathJax.Hub, rSquaredElement]);
			}
		} else {
			fitEquationElement.style.display = 'none';
			fitEquationElement.innerHTML = '';
			rSquaredElement.style.display = 'none';
			rSquaredElement.innerHTML = '';
		}
	}

	function populateTableFromActiveDataset() {
		const tableBody = document.querySelector('#data-table tbody');
		tableBody.innerHTML = ''; // Clear current table

		// For the active dataset, get its stored raw data.
		let dataset = rawData[activeSet] || [];

		// For Dataset 1: if rawData is empty but we have stored x-values, rebuild the table from them.
		if (activeSet === 0 && dataset.length === 0 && dataset1XValues && dataset1XValues.length > 0) {
			dataset1XValues.forEach(xVal => {
				const newRow = tableBody.insertRow();
				newRow.innerHTML = `
                <td>
                    <input type="text" class="x-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="${xVal}">
                </td>
                <td>
                    <input type="text" class="y-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="x-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="y-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="">
                </td>
            `;
			});
			return;
		}

		// For other datasets (or if set 1 already has valid data), build rows from rawData.
		if (dataset.length > 0) {
			dataset.forEach(point => {
				const newRow = tableBody.insertRow();
				newRow.innerHTML = `
                <td>
                    <input type="text" class="x-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="${point.x}">
                </td>
                <td>
                    <input type="text" class="y-input"
                           onkeydown="navigateTable(event)"
                           oninput="updateData()"
                           placeholder="0"
                           value="${point.y !== null ? point.y : ''}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="x-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="${point.xErrorRaw || ''}">
                </td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};">
                    <input type="text" class="y-error-input"
                           onkeydown="navigateTable(event)"
                           placeholder="±0"
                           oninput="updateData()"
                           value="${point.yErrorRaw || ''}">
                </td>
            `;
			});
		} else {
			// If there is no data in the active dataset, initialize default rows.
			initializeTable();
		}
	}

	// Function to add a new dataset
	function addDataset() {
		// Add a new empty dataset to rawData.
		rawData.push([]);

		// Then switch to the newly added dataset.
		activeSet = rawData.length - 1;
		updateDatasetTabsBar();

		// Now clear the UI for the active dataset 
		// (clearRows() will create new empty rows since rawData[activeSet] is empty)
		clearRows();

		// Update the rest of the UI to reflect the new active dataset.
		updateData();
		updatePlotAndRenderLatex();
	}

	function removeDataset(index) {
		if (rawData.length <= 1) {
			alert("You must keep at least one dataset.");
			return;
		}

		// Remove this dataset from rawData.
		rawData.splice(index, 1);

		// Reindex the global objects so they match the new rawData order.
		// IMPORTANT: Pass the removed index.
		reindexDatasets(index);

		// Fix activeSet if it's now out of range
		if (activeSet >= rawData.length) {
			activeSet = rawData.length - 1;
		}

		// Rebuild UI and re-plot
		updateDatasetTabsBar();
		switchDataset(activeSet);
		updatePlotAndRenderLatex();
	}

	// Attach the Add Dataset button click event
	function initializeDatasetTabsBar() {
		const addBtn = document.querySelector('.add-dataset-btn');
		if (addBtn) {
			addBtn.addEventListener('click', addDataset);
		}
		// Build the initial tabs UI.
		updateDatasetTabsBar();
	}

	function addRow() {
		const tableBody = document.querySelector('#data-table tbody');
		const newRow = tableBody.insertRow();
		newRow.innerHTML = `
                <td><input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td><input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0"></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-x-error').checked ? 'table-cell' : 'none'};"><input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
                <td class="error-column" style="display: ${document.getElementById('toggle-y-error').checked ? 'table-cell' : 'none'};"><input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()" /></td>
            `;
		updateData();
	}

	function clearRows(resetHeaders = true) {
		const tableBody = document.querySelector('#data-table tbody');
		tableBody.innerHTML = '';

		// Empty out the active dataset’s raw data
		rawData[activeSet] = [];

		if (resetHeaders) {
			isSyncing = true;
			// Reset header inputs to defaults
			document.getElementById('x-column-name').value = 'x';
			document.getElementById('y-column-name').value = 'y';
			document.getElementById('graph-title').value = 'y vs x';
			renderLatex('#x-column-latex', formatLabelForLatex('x'));
			renderLatex('#y-column-latex', formatLabelForLatex('y'));
			updateGraphTitle();
			isSyncing = false;

			// Only re-initialize default rows if we truly want a full reset
			initializeTable();
		}

		// Turn off uncertainties and hide their columns
		document.getElementById('toggle-x-error').checked = false;
		toggleErrorColumn('x');
		document.getElementById('toggle-y-error').checked = false;
		toggleErrorColumn('y');

		// Reset advanced-fit parameters
		setInitialParameters(getCurrentAdvancedFitMethod());

		// Update the combined-plot inputs to default headings
		updateCombinedPlotInputsToActive();

		// Re-draw the plot (with no data points). The old fit may still appear
		updatePlotAndRenderLatex();
	}

	function copyXFromSet1() {
		if (!dataset1XValues || dataset1XValues.length === 0) {
			alert("Dataset 1 does not contain any valid x values yet.");
			return;
		}
		const sourceX = dataset1XValues;
		const tableBody = document.querySelector('#data-table tbody');
		let rows = tableBody.querySelectorAll('tr');
		const missingCount = sourceX.length - rows.length;

		// If there are missing rows, create them in one batch.
		if (missingCount > 0) {
			let newRowsHTML = '';
			const toggleXError = document.getElementById('toggle-x-error').checked;
			const toggleYError = document.getElementById('toggle-y-error').checked;
			// Build the HTML string for the missing rows.
			for (let i = 0; i < missingCount; i++) {
				newRowsHTML += `
                <tr>
                    <td>
                        <input type="text" class="x-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">
                    </td>
                    <td>
                        <input type="text" class="y-input" onkeydown="navigateTable(event)" oninput="updateData()" placeholder="0">
                    </td>
                    <td class="error-column" style="display: ${toggleXError ? 'table-cell' : 'none'};">
                        <input type="text" class="x-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()">
                    </td>
                    <td class="error-column" style="display: ${toggleYError ? 'table-cell' : 'none'};">
                        <input type="text" class="y-error-input" onkeydown="navigateTable(event)" placeholder="±0" oninput="updateData()">
                    </td>
                </tr>
            `;
			}
			// Insert all missing rows at once.
			tableBody.insertAdjacentHTML('beforeend', newRowsHTML);
			// Requery the rows after insertion.
			rows = tableBody.querySelectorAll('tr');
		}

		// Update all x-inputs in one go.
		const xInputs = tableBody.querySelectorAll('.x-input');
		for (let i = 0; i < sourceX.length; i++) {
			if (xInputs[i]) {
				xInputs[i].value = sourceX[i];
			}
		}

		// Update the underlying data and replot.
		updateData();
		updatePlotAndRenderLatex();
	}

	function clearFittedCurve() {
		// Remove any stored fit results from datasetFitResults
		if (datasetFitResults.hasOwnProperty(activeSet)) {
			delete datasetFitResults[activeSet];
		}

		// Remove the fitted curve from fittedCurves
		if (fittedCurves.hasOwnProperty(activeSet)) {
			delete fittedCurves[activeSet];
		}

		// Clear any displayed equation/R² from the UI
		const fitEquationElement = document.getElementById('fit-equation');
		const rSquaredElement = document.getElementById('r-squared-container');
		if (fitEquationElement) {
			fitEquationElement.style.display = 'none';
			fitEquationElement.innerHTML = '';
		}
		if (rSquaredElement) {
			rSquaredElement.style.display = 'none';
			rSquaredElement.innerHTML = '';
		}

		// Force a re-plot so that the old line is removed
		lastPlotState.data = null;
		lastPlotState.layout = null;

		// Now re-draw with no line but the same data
		updatePlotAndRenderLatex();
	}

	/**
	 * Synchronize the combined-plot input boxes (Title, x-label, y-label)
	 * with the current active dataset's raw headings. No extra '$' delimiter.
	 */
	function updateCombinedPlotInputsToActive() {
		const rawTitle = document.getElementById('graph-title').value || 'y vs x';
		const rawXLabel = document.getElementById('x-column-name').value || 'x';
		const rawYLabel = document.getElementById('y-column-name').value || 'y';

		const titleInput = document.getElementById('combined-title');
		const xLabelInput = document.getElementById('combined-x-label');
		const yLabelInput = document.getElementById('combined-y-label');

		if (titleInput) {
			titleInput.value = rawTitle;
		}
		if (xLabelInput) {
			xLabelInput.value = rawXLabel;
		}
		if (yLabelInput) {
			yLabelInput.value = rawYLabel;
		}
	}

	function navigateTable(event) {
		const key = event.key;
		const currentInput = event.target;

		const currentCell = currentInput.parentElement;
		const currentRow = currentCell.parentElement;
		const table = currentRow.parentElement.parentElement;
		const rows = Array.from(table.querySelectorAll('tbody tr'));
		const rowIndex = rows.indexOf(currentRow);
		const cells = Array.from(currentRow.children);
		const colIndex = cells.indexOf(currentCell);

		let targetRow = rowIndex;
		let targetCol = colIndex;

		switch (key) {
			case 'Enter':
				event.preventDefault();
				targetRow = rowIndex + 1;
				targetCol = colIndex;
				break;
			case 'ArrowRight':
				event.preventDefault();
				targetCol = colIndex + 1;
				break;
			case 'ArrowLeft':
				event.preventDefault();
				targetCol = colIndex - 1;
				break;
			case 'ArrowDown':
				event.preventDefault();
				targetRow = rowIndex + 1;
				break;
			case 'ArrowUp':
				event.preventDefault();
				targetRow = rowIndex - 1;
				break;
			default:
				return;
		}

		if (targetRow < 0) targetRow = 0;
		if (targetRow >= rows.length) targetRow = rows.length - 1;
		if (targetCol < 0) targetCol = 0;
		if (targetCol >= cells.length) targetCol = cells.length - 1;

		const targetCell = rows[targetRow].children[targetCol];
		const targetInput = targetCell.querySelector('input');

		if (targetInput && targetInput.offsetParent !== null) {
			targetInput.focus();
		}
	}

	function toggleErrorColumn(axis) {
		// Get the checkbox element and its state.
		const checkBox = document.getElementById(`toggle-${axis}-error`);
		const state = checkBox.checked;

		// Ensure the toggles object exists for the current dataset.
		if (!datasetToggles[activeSet]) {
			datasetToggles[activeSet] = { x: false, y: false };
		}
		datasetToggles[activeSet][axis] = state;

		// Update the UI for the active dataset.
		const errorHeader = document.getElementById(`${axis}-error-header`);
		const errorInputs = document.querySelectorAll(`.${axis}-error-input`);

		if (state) {
			errorHeader.style.display = 'table-cell';
			updateUncertaintyHeaders(axis);
			errorInputs.forEach((input) => {
				const errorCell = input.parentElement;
				if (errorCell) {
					errorCell.style.display = 'table-cell';
				}
			});
		} else {
			errorHeader.style.display = 'none';
			errorInputs.forEach((input) => {
				const errorCell = input.parentElement;
				if (errorCell) {
					errorCell.style.display = 'none';
					input.value = '';
				}
			});
		}

		updateData();
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function loadToggles() {
		const toggles = datasetToggles[activeSet] || { x: false, y: false };

		document.getElementById('toggle-x-error').checked = toggles.x;
		document.getElementById('toggle-y-error').checked = toggles.y;

		// Update x error column:
		const xErrorHeader = document.getElementById('x-error-header');
		const xErrorInputs = document.querySelectorAll('.x-error-input');
		if (toggles.x) {
			xErrorHeader.style.display = 'table-cell';
			xErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'table-cell';
				}
			});
		} else {
			xErrorHeader.style.display = 'none';
			xErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'none';
				}
			});
		}

		// Update y error column:
		const yErrorHeader = document.getElementById('y-error-header');
		const yErrorInputs = document.querySelectorAll('.y-error-input');
		if (toggles.y) {
			yErrorHeader.style.display = 'table-cell';
			yErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'table-cell';
				}
			});
		} else {
			yErrorHeader.style.display = 'none';
			yErrorInputs.forEach(input => {
				const cell = input.parentElement;
				if (cell) {
					cell.style.display = 'none';
				}
			});
		}
	}

	function reindexDatasets(removedIndex) {
		// SHIFT each object from j+1 to j, for all j >= removedIndex
		for (let j = removedIndex; j < rawData.length; j++) {

			// datasetHeaders
			if (datasetHeaders.hasOwnProperty(j + 1)) {
				datasetHeaders[j] = datasetHeaders[j + 1];
			} else {
				delete datasetHeaders[j];
			}

			// datasetToggles
			if (datasetToggles.hasOwnProperty(j + 1)) {
				datasetToggles[j] = datasetToggles[j + 1];
			} else {
				delete datasetToggles[j];
			}

			// datasetErrorTypes
			if (datasetErrorTypes.hasOwnProperty(j + 1)) {
				datasetErrorTypes[j] = datasetErrorTypes[j + 1];
			} else {
				delete datasetErrorTypes[j];
			}

			// datasetFitResults
			if (datasetFitResults.hasOwnProperty(j + 1)) {
				datasetFitResults[j] = datasetFitResults[j + 1];
			} else {
				delete datasetFitResults[j];
			}

			// fittedCurves
			if (fittedCurves.hasOwnProperty(j + 1)) {
				fittedCurves[j] = fittedCurves[j + 1];
			} else {
				delete fittedCurves[j];
			}
		}

		// Then delete the old "last" index which no longer corresponds to a dataset
		const lastIndex = rawData.length;
		delete datasetHeaders[lastIndex];
		delete datasetToggles[lastIndex];
		delete datasetErrorTypes[lastIndex];
		delete datasetFitResults[lastIndex];
		delete fittedCurves[lastIndex];
	}

	function updateUncertaintyHeaders(axis) {
		const columnName = document.getElementById(`${axis}-column-name`).value.trim() || (axis === 'x' ? 'x' : 'y');
		const errorType = document.getElementById(`${axis}-error-type`).value;
		let headerLatex = `\\pm \\Delta ${formatLabelForLatex(columnName)}`;
		let headerFull = `\\( ${headerLatex} \\)`;
		if (errorType === 'percentage') {
			headerFull += ' (%)';
		}

		const headerElement = document.getElementById(`${axis}-error-header-latex`);
		if (headerElement) {
			headerElement.innerHTML = headerFull;
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, headerElement]);
		}
	}

	function updateErrorType(axis) {
		// Get the selected error type from the dropdown.
		const errorType = document.getElementById(`${axis}-error-type`).value;

		// Ensure the error type object exists for the current dataset.
		if (!datasetErrorTypes[activeSet]) {
			datasetErrorTypes[activeSet] = { x: 'absolute', y: 'absolute' };
		}
		datasetErrorTypes[activeSet][axis] = errorType;

		// If uncertainty is enabled for this axis, update the uncertainty header.
		if (document.getElementById(`toggle-${axis}-error`).checked) {
			updateUncertaintyHeaders(axis);
		}

		updateData();
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function loadErrorTypes() {
		const xErrorTypeElement = document.getElementById('x-error-type');
		const yErrorTypeElement = document.getElementById('y-error-type');

		// Use stored error types or fallback to 'absolute'
		const currentXErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].x) || 'absolute';
		const currentYErrorType = (datasetErrorTypes[activeSet] && datasetErrorTypes[activeSet].y) || 'absolute';

		if (xErrorTypeElement) {
			xErrorTypeElement.value = currentXErrorType;
		}
		if (yErrorTypeElement) {
			yErrorTypeElement.value = currentYErrorType;
		}

		// Ensure the uncertainty header is updated accordingly.
		updateUncertaintyHeaders('x');
		updateUncertaintyHeaders('y');
	}

	function isPlotStateEqual(newData, newLayout) {
		// Simple approach: compare JSON strings.
		// Note: This works fine for small to moderate data sets.
		const currentDataStr = JSON.stringify(lastPlotState.data);
		const newDataStr = JSON.stringify(newData);
		const currentLayoutStr = JSON.stringify(lastPlotState.layout);
		const newLayoutStr = JSON.stringify(newLayout);
		return currentDataStr === newDataStr && currentLayoutStr === newLayoutStr;
	}

	function handleCSVUpload(event) {
		const file = event.target.files[0];
		if (!file) return;

		const reader = new FileReader();
		reader.onload = function(e) {
			const text = e.target.result;

			// **Clear the fitted curve for the active dataset**
			if (fittedCurves.hasOwnProperty(activeSet)) {
				delete fittedCurves[activeSet];
				console.log(`Fitted curve for Dataset ${activeSet + 1} has been cleared.`);
			}

			// **Parse the CSV and update the data**
			parseCSV(text);
		};
		reader.onerror = function() {
			alert('Error reading the file!');
		};
		reader.readAsText(file);
	}

	function parseCSVLine(line) {
		const result = [];
		let current = '';
		let inQuotes = false;

		for (let i = 0; i < line.length; i++) {
			const char = line[i];
			if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
				inQuotes = !inQuotes;
			} else if (char === ',' && !inQuotes) {
				result.push(current.trim());
				current = '';
			} else {
				current += char;
			}
		}
		result.push(current.trim());
		return result;
	}

	function parseCSV(text) {
		const lines = text.trim().split('\n');
		if (lines.length < 2) {
			alert('CSV file must contain at least two rows (headers and one data row).');
			return;
		}

		// 1) Parse headers
		const headers = parseCSVLine(lines[0]);
		if (headers.length < 2) {
			alert('CSV file must have at least two columns.');
			return;
		}
		// Determine if the CSV initially has X and Y errors
		const hasXError = headers.length >= 3;
		const hasYError = headers.length >= 4;

		// 2) Store headers for the active dataset and update the UI via loadHeaders()
		isSyncing = true;
		datasetHeaders[activeSet] = {
			x: headers[0],
			y: headers[1]
		};
		loadHeaders(); // This function sets the header input values and renders LaTeX.
		isSyncing = false;

		// Clear existing rows for this dataset without resetting headers
		clearRows(false);

		// Set the uncertainty toggles to match the CSV's columns
		document.getElementById('toggle-x-error').checked = hasXError;
		document.getElementById('toggle-y-error').checked = hasYError;

		// 3) Build the new rows in memory based on the CSV data.
		const dataRows = lines.slice(1);
		const tableBody = document.querySelector('#data-table tbody');
		const fragment = document.createDocumentFragment();

		for (let i = 0; i < dataRows.length; i++) {
			const rowData = parseCSVLine(dataRows[i]);
			const tr = document.createElement('tr');

			// x cell
			const tdX = document.createElement('td');
			tdX.innerHTML = `
            <input type="text" class="x-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[0] || ''}">
        `;
			tr.appendChild(tdX);

			// y cell
			const tdY = document.createElement('td');
			tdY.innerHTML = `
            <input type="text" class="y-input"
                   onkeydown="navigateTable(event)"
                   oninput="updateData()"
                   placeholder="0"
                   value="${rowData[1] || ''}">
        `;
			tr.appendChild(tdY);

			// X-error cell
			const tdXErr = document.createElement('td');
			tdXErr.className = 'error-column x-error-td';
			tdXErr.innerHTML = `
            <input type="text" class="x-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[2] || ''}">
        `;
			if (!hasXError) tdXErr.style.display = 'none';
			tr.appendChild(tdXErr);

			// Y-error cell
			const tdYErr = document.createElement('td');
			tdYErr.className = 'error-column y-error-td';
			tdYErr.innerHTML = `
            <input type="text" class="y-error-input"
                   onkeydown="navigateTable(event)"
                   placeholder="±0"
                   oninput="updateData()"
                   value="${rowData[3] || ''}">
        `;
			if (!hasYError) tdYErr.style.display = 'none';
			tr.appendChild(tdYErr);

			fragment.appendChild(tr);
		}

		// 4) Replace the old table rows with our newly built fragment
		tableBody.innerHTML = '';
		tableBody.appendChild(fragment);

		// 5) Update data in the active dataset, re-plot, etc.
		updateData();
		updatePlotAndRenderLatex();
		setInitialParameters(getCurrentAdvancedFitMethod());

		// Re-apply uncertainty toggle display logic.
		toggleErrorColumn('x');
		toggleErrorColumn('y');
	}

	function loadHeaders() {
		// Use stored headers for the active dataset if available;
		// otherwise, use defaults.
		const headers = datasetHeaders[activeSet] || { x: 'x', y: 'y' };

		document.getElementById('x-column-name').value = headers.x;
		document.getElementById('y-column-name').value = headers.y;
		renderLatex('#x-column-latex', formatLabelForLatex(headers.x));
		renderLatex('#y-column-latex', formatLabelForLatex(headers.y));
		updateGraphTitle();
	}

	function updateLabels(type) {
		if (isSyncing) return;
		isSyncing = true;

		const value = document.getElementById(`${type}-column-name`).value;

		// Update the label element based on the latexMode.
		if (latexMode) {
			renderLatex(`#${type}-column-latex`, formatLabelForLatex(value));
		} else {
			document.querySelector(`#${type}-column-latex`).textContent = value;
		}

		// Debounced update of the plot (if applicable).
		debouncedUpdatePlotAndRenderLatex();
		isSyncing = false;

		// Dynamically update the graph title.
		const xColumn = document.getElementById('x-column-name').value || 'x';
		const yColumn = document.getElementById('y-column-name').value || 'y';
		if (latexMode) {
			document.getElementById('graph-title').value = `${yColumn} \\text{vs} ${xColumn}`;
		} else {
			document.getElementById('graph-title').value = `${yColumn} vs ${xColumn}`;
		}

		// Update any other elements that depend on the headers.
		setInitialParameters(getCurrentAdvancedFitMethod());
		updateCombinedPlotInputsToActive();
	}

	function renderLatex(elementId, latexString) {
		const element = document.querySelector(elementId);
		if (!element) return;
		if (!latexMode) {
			// If LaTeX mode is off, just set the plain text.
			element.textContent = latexString;
			return;
		}
		// Otherwise, render using MathJax.
		element.innerHTML = `\\(${latexString}\\)`;
		MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
	}

	function updatePlotAndRenderLatex() {
		if (isSyncing) return;
		isSyncing = true;

		// Replot the graph as usual.
		plotGraph();

		// Retrieve current column names.
		const xColumnName = document.getElementById('x-column-name').value || 'x';
		const yColumnName = document.getElementById('y-column-name').value || 'y';

		// Update the axis label elements conditionally.
		if (latexMode) {
			renderLatex('#x-column-latex', formatLabelForLatex(xColumnName));
			renderLatex('#y-column-latex', formatLabelForLatex(yColumnName));
		} else {
			document.querySelector('#x-column-latex').textContent = xColumnName;
			document.querySelector('#y-column-latex').textContent = yColumnName;
		}
		isSyncing = false;
	}

	function openTab(evt, tabName) {
		const tablinks = document.getElementsByClassName("tablink");
		const tabContents = document.getElementsByClassName("tab-content");

		for (let i = 0; i < tablinks.length; i++) {
			tablinks[i].classList.remove("active");
		}

		for (let i = 0; i < tabContents.length; i++) {
			tabContents[i].classList.remove("active");
		}

		document.getElementById(tabName).classList.add("active");
		evt.currentTarget.classList.add("active");

		if (tabName === 'BasicFit') {
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('basic-fit-equation')]);
		} else if (tabName === 'AdvancedFit') {
			changeAdvancedFitMethod();
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('advanced-fit-general-equation')]);
		}
	}

	function updateGraphTitle() {
		const xColumn = document.getElementById('x-column-name').value || 'x';
		const yColumn = document.getElementById('y-column-name').value || 'y';
		const titleText = `${yColumn} vs ${xColumn}`;

		if (latexMode) {
			document.getElementById('graph-title').value = `${yColumn} \\text{vs} ${xColumn}`;
		} else {
			document.getElementById('graph-title').value = titleText;
		}
	}

	function plotGraph(fittedX = null, fittedY = null) {
		// If fitted data is not provided and a fit exists, use that.
		if ((fittedX === null || fittedY === null) && fittedCurves.hasOwnProperty(activeSet)) {
			fittedX = fittedCurves[activeSet].x;
			fittedY = fittedCurves[activeSet].y;
		}

		// Build the data arrays based on the active dataset.
		const x = rawData[activeSet].map(point => point.x);
		const y = rawData[activeSet].map(point => point.y);
		const xErrorRaw = rawData[activeSet].map(point => point.xErrorRaw || 0);
		const yErrorRaw = rawData[activeSet].map(point => point.yErrorRaw || 0);
		const xErrorType = document.getElementById('toggle-x-error').checked ?
			document.getElementById('x-error-type').value :
			'absolute';
		const yErrorType = document.getElementById('toggle-y-error').checked ?
			document.getElementById('y-error-type').value :
			'absolute';

		// Convert errors if using percentage uncertainties.
		const convertedXError = x.map((xi, idx) =>
			xErrorType === 'percentage' ? (xErrorRaw[idx] / 100) * (xi || 0) : xErrorRaw[idx]
		);
		const convertedYError = y.map((yi, idx) =>
			yErrorType === 'percentage' ? (yErrorRaw[idx] / 100) * (yi || 0) : yErrorRaw[idx]
		);

		// Build the primary data trace.
		const data = [{
			x: x,
			y: y,
			mode: 'markers',
			name: 'Data',
			marker: {
				color: '#ff7c23',
				symbol: 'circle',
				size: 6.5,
				line: { width: 0 }
			},
			error_x: {
				type: 'data',
				array: convertedXError,
				visible: document.getElementById('toggle-x-error').checked,
				color: '#5b5b5b',
				thickness: 0.8,
				width: 2
			},
			error_y: {
				type: 'data',
				array: convertedYError,
				visible: document.getElementById('toggle-y-error').checked,
				color: '#5b5b5b',
				thickness: 0.8,
				width: 2
			}
		}];

		// Add fitted curve trace if available.
		if (fittedX && fittedY) {
			data.push({
				x: fittedX,
				y: fittedY,
				mode: 'lines',
				name: 'Fit',
				line: { color: '#35a8ff' }
			});
		}

		// Retrieve the title from the input; if blank, use an empty string.
		const rawTitle = document.getElementById('graph-title').value.trim();
		const titleText = rawTitle === '' ? '' : processLabel(rawTitle);

		// Build the layout.
		const layout = {
			xaxis: {
				title: processLabel(document.getElementById('x-column-name').value || 'x')
			},
			yaxis: {
				title: {
					text: processLabel(document.getElementById('y-column-name').value || 'y'),
					standoff: 25
				},
				titlefont: { size: 14 },
				automargin: true
			},
			title: titleText,
			margin: {
				t: rawTitle === '' ? 50 : 100, // Optionally reduce top margin when title is blank.
				b: 80,
				l: 85,
				r: 30
			}
		};

		// Only replot if the new state is different.
		if (isPlotStateEqual(data, layout)) {
			console.log("No changes in plot state; skipping update.");
			return;
		}

		// Update the plot.
		Plotly.react('plot', data, layout, {
			toImageButtonOptions: {
				format: 'svg',
				filename: 'data_plot',
				scale: 1
			}
		});

		// Cache the current state.
		lastPlotState.data = data;
		lastPlotState.layout = layout;
	}

	function plotAllDatasets() {
		const traces = [];

		// Define colors for datasets and fitted curves.
		const datasetColors = ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e74c3c', '#1abc9c'];
		const fitColors = ['#a7d7f2', '#a2e4b8', '#d5a4e2', '#f9e79f', '#f5a4a4', '#a0e7d1'];

		// Build traces for each dataset.
		rawData.forEach((dataset, index) => {
			const xVals = dataset.map(point => point.x);
			const yVals = dataset.map(point => point.y);

			// Convert uncertainties.
			const xErrorsRaw = dataset.map(point => point.xErrorRaw || 0);
			const yErrorsRaw = dataset.map(point => point.yErrorRaw || 0);
			const errorTypes = datasetErrorTypes[index] || { x: 'absolute', y: 'absolute' };

			const xErrorsConverted = xVals.map((xVal, i) =>
				errorTypes.x === 'percentage' ? (xErrorsRaw[i] / 100) * (xVal || 0) : xErrorsRaw[i]
			);
			const yErrorsConverted = yVals.map((yVal, i) =>
				errorTypes.y === 'percentage' ? (yErrorsRaw[i] / 100) * (yVal || 0) : yErrorsRaw[i]
			);

			// Marker trace.
			traces.push({
				x: xVals,
				y: yVals,
				mode: 'markers',
				name: `Dataset ${index + 1}`,
				marker: {
					size: 6.5,
					color: datasetColors[index % datasetColors.length]
				},
				error_x: {
					type: 'data',
					array: xErrorsConverted,
					visible: true,
					color: datasetColors[index % datasetColors.length],
					thickness: 0.8,
					width: 2
				},
				error_y: {
					type: 'data',
					array: yErrorsConverted,
					visible: true,
					color: datasetColors[index % datasetColors.length],
					thickness: 0.8,
					width: 2
				}
			});

			// Fitted curve trace, if available.
			if (fittedCurves.hasOwnProperty(index)) {
				const fitColor = fitColors[index % fitColors.length];
				traces.push({
					x: fittedCurves[index].x,
					y: fittedCurves[index].y,
					mode: 'lines',
					name: `Fit ${index + 1}`,
					line: { color: fitColor }
				});
			}
		});

		// Retrieve and process input for combined plot title and axis labels.
		const titleInput = document.getElementById('combined-title');
		const xLabelInput = document.getElementById('combined-x-label');
		const yLabelInput = document.getElementById('combined-y-label');

		const rawTitle = titleInput ? titleInput.value.trim() : '';
		const rawXLabel = xLabelInput ? xLabelInput.value.trim() : '';
		const rawYLabel = yLabelInput ? yLabelInput.value.trim() : '';

		const processedTitle = rawTitle === '' ? '' : processLabel(rawTitle);
		const processedXLabel = rawXLabel === '' ? '' : processLabel(rawXLabel);
		const processedYLabel = rawYLabel === '' ? '' : processLabel(rawYLabel);

		// Build the layout using the processed labels.
		const layout = {
			title: {
				text: processedTitle,
				font: { size: 16 }
			},
			xaxis: {
				title: processedXLabel
			},
			yaxis: {
				title: {
					text: processedYLabel,
					standoff: 25
				}
			},
			margin: {
				t: rawTitle === '' ? 50 : 100, // Reduce top margin when title is blank.
				b: 70,
				l: 140,
				r: 0
			}
		};

		if (isPlotStateEqual(traces, layout)) {
			console.log("No changes detected in combined plot; skipping update.");
			return;
		}

		// Render the combined plot.
		Plotly.newPlot('popup-plot', traces, layout, {
			toImageButtonOptions: {
				format: 'svg',
				filename: 'combined_plot',
				scale: 1
			}
		});

		lastPlotState.data = traces;
		lastPlotState.layout = layout;

		showPopup();

		if (typeof MathJax !== 'undefined' && latexMode) {
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('popup-plot')]);
		}
	}

	// Function to initialize the combined plot input boxes.
	function initCombinedPlotInputs() {
		// Assume there is a container element in your HTML with id "combined-plot-controls"
		// If it doesn't exist yet, create and append it below the combined plot container.
		let controlsContainer = document.getElementById('combined-plot-controls');
		if (!controlsContainer) {
			controlsContainer = document.createElement('div');
			controlsContainer.id = 'combined-plot-controls';
			// Optionally style the container here.
			document.body.appendChild(controlsContainer);
		}

		// Create or select the title input.
		let titleInput = document.getElementById('combined-title');
		if (!titleInput) {
			titleInput = document.createElement('input');
			titleInput.type = 'text';
			titleInput.id = 'combined-title';
			titleInput.placeholder = 'Title';
			controlsContainer.appendChild(titleInput);
		}

		// Create or select the x-axis label input.
		let xLabelInput = document.getElementById('combined-x-label');
		if (!xLabelInput) {
			xLabelInput = document.createElement('input');
			xLabelInput.type = 'text';
			xLabelInput.id = 'combined-x-label';
			xLabelInput.placeholder = 'x-axis Label';
			controlsContainer.appendChild(xLabelInput);
		}

		// Create or select the y-axis label input.
		let yLabelInput = document.getElementById('combined-y-label');
		if (!yLabelInput) {
			yLabelInput = document.createElement('input');
			yLabelInput.type = 'text';
			yLabelInput.id = 'combined-y-label';
			yLabelInput.placeholder = 'y-axis Label';
			controlsContainer.appendChild(yLabelInput);
		}

		// Initialize the input boxes with the active dataset’s labels.
		// For title, take the value from the active graph title input.
		titleInput.value = document.getElementById('graph-title').value || `${document.getElementById('y-column-name').value || 'y'} \\text{vs} ${document.getElementById('x-column-name').value || 'x'}`;
		xLabelInput.value = processLabel(document.getElementById('x-column-name').value || 'x');
		yLabelInput.value = processLabel(document.getElementById('y-column-name').value || 'y');

		// Add event listeners: whenever any input value changes, update the combined plot.
		titleInput.addEventListener('input', updateCombinedPlotFromInputs);
		xLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
		yLabelInput.addEventListener('input', updateCombinedPlotFromInputs);
	}

	// Function to update the combined plot using the values from the new input boxes.
	function updateCombinedPlotFromInputs() {
		// Simply call plotAllDatasets; the updated version will check the input box values.
		plotAllDatasets();
	}

	// This function makes both the popup and the background visible.
	function showPopup() {
		const popupBackground = document.getElementById('popup-background');
		const popupContainer = document.getElementById('popup-container');

		if (popupBackground) {
			popupBackground.style.display = 'block'; // Show the transparent background
		}

		if (popupContainer) {
			popupContainer.style.display = 'block'; // Show the popup content
		}
	}

	// This function hides both the popup and the background.
	function closePopup() {
		const popupBackground = document.getElementById('popup-background');
		const popupContainer = document.getElementById('popup-container');

		if (popupBackground) {
			popupBackground.style.display = 'none'; // Hide the transparent background
		}

		if (popupContainer) {
			popupContainer.style.display = 'none'; // Hide the popup content
		}
	}

	function fitCurve() {
		// Ensure there are at least two data points in the active dataset.
		if (rawData[activeSet].length < 2) {
			alert('Please enter at least two data points.');
			return;
		}

		const fitMethod = document.getElementById('fit-method').value;

		// For fitting methods where you need x and y arrays,
		// we are mapping rawData[activeSet] to extract the x and y values.
		if (fitMethod === 'Linear') {
			performLinearFit(rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y));
		} else if (fitMethod.startsWith('Polynomial')) {
			const degree = parseInt(fitMethod.split('-')[1]);
			performPolynomialFit(rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y), degree);
		} else if (fitMethod === 'Exponential') {
			performExponentialFit();
		} else if (fitMethod === 'Power') {
			performPowerFit();
		}
	}

	function updateBasicFitEquation() {
		const fitMethod = document.getElementById('fit-method').value;
		let equation = '';

		if (fitMethod === 'Linear') {
			equation = 'y = mx + c';
		} else if (fitMethod.startsWith('Polynomial')) {
			const degree = parseInt(fitMethod.split('-')[1]);
			let terms = [];
			for (let i = degree; i >= 0; i--) {
				terms.push(`a_${i}x^{${i}}`);
			}
			equation = 'y = ' + terms.join(' + ');
		} else if (fitMethod === 'Exponential') {
			equation = 'y = A e^{b(x-x_0)} + c';
		} else if (fitMethod === 'Power') {
			equation = 'y = A (x-x_0)^{b} + c';
		}

		const equationElement = document.getElementById('basic-fit-equation');
		if (equationElement) {
			equationElement.innerHTML = `\\( ${equation} \\)`;
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
		}
	}

	function changeAdvancedFitMethod() {
		const selectedMethod = document.getElementById('advanced-fit-method').value;
		const methods = ['Sinusoidal', 'Gaussian'];

		methods.forEach(method => {
			const section = document.getElementById(`${method}-parameters`);
			if (method === selectedMethod) {
				section.classList.add('active');
			} else {
				section.classList.remove('active');
			}
		});

		updateAdvancedFitEquation(selectedMethod);
		setInitialParameters(selectedMethod);
	}

	function updateAdvancedFitEquation(selectedMethod) {
		let equation = '';
		if (selectedMethod === 'Sinusoidal') {
			equation = 'y = A e^{bx} \\sin(kx - \\phi) + c';
		} else if (selectedMethod === 'Gaussian') {
			equation = 'y = A e^{-\\frac{(x - \\mu)^2}{2 \\sigma^2}} + c';
		}

		const equationElement = document.getElementById('advanced-fit-general-equation');
		if (equationElement) {
			equationElement.innerHTML = `\\(${equation}\\)`;
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationElement]);
		}
	}

	// Helper function to calculate FWHM for Gaussian Fit (optional, not used here)
	function calculateFWHM(x, y, maxY) {
		const halfMax = maxY / 2;
		let left = null,
			right = null;

		// Sort data by x
		const sortedData = rawData[activeSet].slice().sort((a, b) => a.x - b.x);

		// Find left crossing
		for (let i = 1; i < sortedData.length; i++) {
			if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
				const x1 = sortedData[i - 1].x;
				const y1 = sortedData[i - 1].y;
				const x2 = sortedData[i].x;
				const y2 = sortedData[i].y;
				left = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
				break;
			}
		}

		// Find right crossing
		for (let i = sortedData.length - 1; i > 0; i--) {
			if (sortedData[i - 1].y < halfMax && sortedData[i].y >= halfMax) {
				const x1 = sortedData[i - 1].x;
				const y1 = sortedData[i - 1].y;
				const x2 = sortedData[i].x;
				const y2 = sortedData[i].y;
				right = x1 + (halfMax - y1) * (x2 - x1) / (y2 - y1);
				break;
			}
		}

		if (left !== null && right !== null && right > left) {
			return right - left;
		} else {
			const minX = Math.min(...x);
			const maxX = Math.max(...x);
			return (maxX - minX) / 4;
		}
	}

	// Function to set initial parameters based on selected method and data
	function setInitialParameters(method) {
		if (!method) return; // If method is undefined, do nothing

		if (rawData[activeSet].length === 0) return;

		const x = rawData[activeSet].map(p => p.x);
		const y = rawData[activeSet].map(p => p.y);
		const meanX = x.reduce((sum, val) => sum + val, 0) / x.length;
		const stdX = Math.sqrt(x.reduce((sum, val) => sum + Math.pow(val - meanX, 2), 0) / x.length);
		const maxY = Math.max(...y);
		const FWHM = calculateFWHM(x, y, maxY);

		if (method === 'Gaussian') {
			document.getElementById('initial-A-gaussian').value = maxY.toFixed(3);
			document.getElementById('initial-mu').value = meanX.toFixed(3);
			document.getElementById('initial-sigma').value = (FWHM / (2 * Math.sqrt(2 * Math.log(2)))).toFixed(3);
			document.getElementById('initial-c-gaussian').value = '0';
		} else if (method === 'Sinusoidal') {
			// Set A to maxY, b to slope from linear fit, phi to 0, c to meanY
			const meanY = y.reduce((sum, val) => sum + val, 0) / y.length;
			const linearFit = computeLinearFit(x, y);
			const A = maxY - meanY;
			const b = linearFit.slope;
			const phi = 0;
			const c = meanY;

			// Estimate k from data and set it
			const estimatedK = estimateKFromData();
			if (estimatedK !== null) {
				document.getElementById('initial-k').value = estimatedK.toFixed(3);
			} else {
				document.getElementById('initial-k').value = '1'; // Default value if estimation fails
			}

			document.getElementById('initial-A').value = A.toFixed(3);
			document.getElementById('initial-b').value = b.toFixed(3);
			document.getElementById('initial-phi').value = phi.toFixed(3);
			document.getElementById('initial-c').value = c.toFixed(3);
		}
	}

	function getCurrentAdvancedFitMethod() {
		return document.getElementById('advanced-fit-method').value;
	}

	function computeLinearFit(x, y) {
		try {
			const xMean = x.reduce((sum, val) => sum + val, 0) / x.length;
			const yMean = y.reduce((sum, val) => sum + val, 0) / y.length;

			let numerator = 0,
				denominator = 0;
			for (let i = 0; i < x.length; i++) {
				numerator += (x[i] - xMean) * (y[i] - yMean);
				denominator += (x[i] - xMean) ** 2;
			}

			const slope = numerator / denominator;
			const intercept = yMean - slope * xMean;

			return { slope, intercept };
		} catch (error) {
			console.error('Error computing linear fit:', error);
			throw error;
		}
	}

	function updateResults(equation, x, y, fitFunction) {
		try {
			const yPredicted = x.map(point => fitFunction(point));
			const meanY = y.reduce((sum, yi) => sum + yi, 0) / y.length;

			let ssTotal = 0,
				ssResidual = 0;
			for (let i = 0; i < y.length; i++) {
				ssTotal += Math.pow(y[i] - meanY, 2);
				ssResidual += Math.pow(y[i] - yPredicted[i], 2);
			}

			const rSquared = 1 - ssResidual / ssTotal;

			// Update the UI (fitting result container)
			const fitEquationElement = document.getElementById('fit-equation');
			if (fitEquationElement) {
				fitEquationElement.innerHTML = `\\(${equation}\\)`;
				fitEquationElement.style.display = 'block';
			}

			const rSquaredElement = document.getElementById('r-squared-container');
			if (rSquaredElement) {
				rSquaredElement.innerHTML = `\\( R^2 = ${rSquared.toFixed(5)} \\)`;
				rSquaredElement.style.display = 'block';
			}

			// Trigger MathJax typesetting if available.
			if (typeof MathJax !== 'undefined') {
				MathJax.Hub.Queue(["Typeset", MathJax.Hub, fitEquationElement]);
				MathJax.Hub.Queue(["Typeset", MathJax.Hub, rSquaredElement]);
			}

			// Store this result for the current dataset.
			datasetFitResults[activeSet] = {
				equation: equation,
				rSquared: rSquared.toFixed(5)
			};
		} catch (error) {
			console.error('Error updating results:', error);
		}
	}

	function polyfit(x, y, degree) {
		try {
			const X = x.map(xi => Array.from({ length: degree + 1 }, (_, j) => xi ** (degree - j)));
			const Xt = math.transpose(X);
			const XtX = math.multiply(Xt, X);
			const XtY = math.multiply(Xt, y);
			const coefficients = math.lusolve(XtX, XtY).flat();
			return coefficients;
		} catch (error) {
			console.error('Error performing polynomial fit:', error);
			throw error;
		}
	}

	function polyEval(coefficients, x) {
		try {
			return coefficients.reduce((sum, coef, i) => sum + coef * Math.pow(x, coefficients.length - i - 1), 0);
		} catch (error) {
			console.error('Error evaluating polynomial:', error);
			throw error;
		}
	}

	function updateData() {
		try {
			const xInputs = document.querySelectorAll('.x-input');
			const yInputs = document.querySelectorAll('.y-input');
			const xErrorInputs = document.querySelectorAll('.x-error-input');
			const yErrorInputs = document.querySelectorAll('.y-error-input');

			// For Dataset 1, store all x-values even if y is missing.
			if (activeSet === 0) {
				dataset1XValues = [];
				for (let i = 0; i < xInputs.length; i++) {
					const xVal = parseFloat(xInputs[i].value);
					if (!isNaN(xVal)) {
						dataset1XValues.push(xVal);
					}
				}
			}

			// Clear the current active dataset and repopulate it from the table inputs.
			rawData[activeSet] = [];
			for (let i = 0; i < xInputs.length; i++) {
				const x = parseFloat(xInputs[i].value);
				const y = parseFloat(yInputs[i].value);
				const xErrorRaw = parseFloat(xErrorInputs[i]?.value) || 0;
				const yErrorRaw = parseFloat(yErrorInputs[i]?.value) || 0;

				// Save the row if x is a valid number, regardless of y.
				if (!isNaN(x)) {
					rawData[activeSet].push({
						x: x,
						y: (!isNaN(y) ? y : null), // If y is not valid, store it as null.
						xErrorRaw: xErrorRaw,
						yErrorRaw: yErrorRaw
					});
				}
			}

			// Update the plot using only the active dataset.
			plotGraph();
		} catch (error) {
			console.error('Error updating data:', error);
		}
	}

	function formatDataForExport(valueStr, errorStr, errorEnabled, errorType, val, rowVal, rowErr) {
		if (!errorEnabled) {
			return valueStr;
		}

		if (isNaN(rowErr)) return valueStr;

		if (errorType === 'absolute') {
			const dp = countDecimalPlaces(errorStr);
			return val.toFixed(dp);
		} else if (errorType === 'percentage') {
			const perc = parseFloat(errorStr);
			if (isNaN(perc)) {
				return valueStr;
			}

			// Use 1 significant figure if percentage uncertainty is >= 50%
			let sigFigs;
			if (perc >= 50) {
				sigFigs = 1;
			} else if (perc <= 10) {
				sigFigs = 3;
			} else {
				sigFigs = 2;
			}

			const sfVal = toSigFigs(val, sigFigs);
			return sfVal;
		} else {
			return valueStr;
		}
	}

	/**
	 * Formats labels for LaTeX by replacing spaces with \space.
	 * @param {string} label - The label to format.
	 * @returns {string} - The LaTeX-formatted label.
	 */
	function formatLabelForLatex(label) {
		return label ? label.replace(/ /g, '\\space ') : '';
	}

	/**
	 * Counts the number of decimal places in a number string.s
	 * @param {string} numStr - The number as a string.
	 * @returns {number} - The number of decimal places.
	 */
	function countDecimalPlaces(numStr) {
		if (!numStr.includes('.')) return 0;
		return numStr.length - numStr.indexOf('.') - 1;
	}

	/**
	 * Formats a number to the specified number of significant figures without using scientific notation.
	 * Preserves trailing zeros by returning a string.
	 * @param {number} num - The number to format.
	 * @param {number} sigFigs - The number of significant figures.
	 * @returns {string} - The formatted number as a string.
	 */
	function toSigFigs(num, sigFigs) {
		if (num === 0) return '0';

		if (sigFigs === 1) {
			const order = Math.floor(Math.log10(Math.abs(num)));
			const factor = Math.pow(10, order);
			const rounded = Math.floor(num / factor) * factor;
			return order >= 0 ? rounded.toString() : rounded.toFixed(Math.abs(order));
		}

		let numStr = num.toPrecision(sigFigs);
		if (numStr.includes('e') || numStr.includes('E')) {
			const [mantissa, exponent] = numStr.split(/e/i);
			const exponentVal = parseInt(exponent, 10);
			let fixedNum = parseFloat(mantissa) * Math.pow(10, exponentVal);
			const decimalPlaces = sigFigs - 1 - Math.floor(Math.log10(Math.abs(num)));
			return fixedNum.toFixed(decimalPlaces > 0 ? decimalPlaces : 0);
		}
		return numStr;
	}

	/**
	 * Formats a number into scientific notation for LaTeX with specified significant figures.
	 * @param {number} num - The number to format.
	 * @param {number} sigFigs - The number of significant figures.
	 * @returns {string} - The LaTeX-formatted scientific notation string.
	 */
	function formatScientificNotation(num, sigFigs) {
		if (sigFigs === 1) {
			return toSigFigs(num, sigFigs);
		}
		let numStr = num.toExponential(sigFigs - 1);
		return numStr;
	}

	/**
	 * Formats data values based on the uncertainty type.
	 *
	 * For 'absolute' uncertainty:
	 *   - If the absolute uncertainty is ≥ 1, the data value is rounded down (via Math.floor)
	 *     to the nearest multiple determined by the order of magnitude of the uncertainty.
	 *     For example, 1455 with an uncertainty of 40 becomes 1450.
	 *   - If the absolute uncertainty is < 1, the data value is formatted to the same number of
	 *     decimal places as the uncertainty (preserving trailing zeros).
	 *
	 * For 'percentage' uncertainty:
	 *   - When the percentage uncertainty is greater than or equal to 50%, the data value is formatted
	 *     to 1 significant figure.
	 *   - Otherwise, the data value is formatted to a fixed number of significant figures:
	 *       * 3 significant figures if the uncertainty is less than 10,
	 *       * 2 significant figures otherwise.
	 *   - Scientific notation is applied if indicated.
	 *
	 * If no uncertainty is provided, the data value is simply returned as a string.
	 *
	 * @param {number} dataVal - The data value.
	 * @param {number} uncertaintyVal - The uncertainty value.
	 * @param {string} uncertaintyType - The type of uncertainty ('absolute' or 'percentage').
	 * @param {boolean} useSciNotation - Whether to apply scientific notation.
	 * @returns {string} - The formatted data value.
	 */
	function formatDataValue(dataVal, uncertaintyVal, uncertaintyType, useSciNotation) {
		if (uncertaintyType === 'absolute') {
			if (Math.abs(uncertaintyVal) >= 1) {
				const order = Math.floor(Math.log10(Math.abs(uncertaintyVal)));
				const factor = Math.pow(10, order);
				const roundedValue = Math.floor(dataVal / factor) * factor;
				return roundedValue.toFixed(0);
			} else {
				const dp = countDecimalPlaces(uncertaintyVal.toString());
				// Simply return the data value formatted with 'dp' decimal places,
				// preserving all trailing zeros.
				return dataVal.toFixed(dp);
			}
		} else if (uncertaintyType === 'percentage') {
			const perc = parseFloat(uncertaintyVal);
			if (isNaN(perc)) return dataVal.toString();
			// Use 1 s.f. if percentage uncertainty is >= 50, else use 3 s.f. if error < 10, otherwise 2 s.f.
			const sigFigs = perc >= 50 ? 1 : (perc < 10 ? 3 : 2);
			if (useSciNotation) {
				return formatScientificNotation(dataVal, sigFigs);
			} else {
				return toSigFigs(dataVal, sigFigs);
			}
		} else {
			return dataVal.toString();
		}
	}

	/**
	 * Formats uncertainties based on their type.
	 * - For percentage uncertainties: preserves the exact input (optionally add '\\%' if needed).
	 * - For absolute uncertainties: preserves trailing zeros based on the number of decimal places.
	 * @param {string} errStr - The uncertainty value as a string.
	 * @param {string} errorType - The type of uncertainty ('absolute' or 'percentage').
	 * @returns {string} - The formatted uncertainty string.
	 */
	function formatUncertainty(errStr, errorType) {
		if (errorType === 'percentage') {
			return errStr; // Optionally: return errStr + '\\%' if desired.
		} else if (errorType === 'absolute') {
			const dp = countDecimalPlaces(errStr);
			const errVal = parseFloat(errStr);
			if (isNaN(errVal)) return errStr;
			return errVal.toFixed(dp);
		} else {
			return errStr;
		}
	}

	/**
	 * Exports the data as a Markdown (.md) file with LaTeX formatting.
	 */
	function exportPlainText() {
		try {
			// Retrieve axis headings
			const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
			const yHeader = document.getElementById('y-column-name').value.trim() || 'y';

			// Check if uncertainties are enabled
			const xErrorEnabled = document.getElementById('toggle-x-error').checked;
			const yErrorEnabled = document.getElementById('toggle-y-error').checked;

			// Get uncertainty types
			const xErrorType = document.getElementById('x-error-type').value;
			const yErrorType = document.getElementById('y-error-type').value;

			// Get all rows from the data table's tbody
			const table = document.getElementById('data-table');
			const rows = table.querySelectorAll('tbody tr');

			// Initialize arrays to collect all x and y values
			let xValues = [];
			let yValues = [];

			// Collect all x and y values for notation decision
			rows.forEach(row => {
				const xInputElem = row.querySelector('.x-input');
				const yInputElem = row.querySelector('.y-input');

				if (!xInputElem || !yInputElem) return;

				const xValStr = xInputElem.value.trim();
				const yValStr = yInputElem.value.trim();

				if (xValStr !== '') {
					const xVal = parseFloat(xValStr);
					if (!isNaN(xVal)) xValues.push(xVal);
				}
				if (yValStr !== '') {
					const yVal = parseFloat(yValStr);
					if (!isNaN(yVal)) yValues.push(yVal);
				}
			});

			// Determine if scientific notation is needed for x and y
			const xUseSciNotation = xErrorEnabled && xErrorType === 'percentage' &&
				xValues.some(val => val < -10000 || val > 10000);
			const yUseSciNotation = yErrorEnabled && yErrorType === 'percentage' &&
				yValues.some(val => val < -10000 || val > 10000);

			// Initialize headers with LaTeX formatting
			let headers = [
				`$${formatLabelForLatex(xHeader)}$`,
				`$${formatLabelForLatex(yHeader)}$`
			];

			if (xErrorEnabled) {
				let xUncHeading = `\\pm \\Delta ${formatLabelForLatex(xHeader)}`;
				if (xErrorType === 'percentage') xUncHeading += ' \\space (\\%)';
				headers.push(`$${xUncHeading}$`);
			}
			if (yErrorEnabled) {
				let yUncHeading = `\\pm \\Delta ${formatLabelForLatex(yHeader)}`;
				if (yErrorType === 'percentage') yUncHeading += ' \\space (\\%)';
				headers.push(`$${yUncHeading}$`);
			}

			let markdown = `| ${headers.join(' | ')} |\n`;
			markdown += `|${headers.map(() => ':---:').join('|')}|\n`;

			// Process each row
			rows.forEach(row => {
				const xInputElem = row.querySelector('.x-input');
				const yInputElem = row.querySelector('.y-input');
				if (!xInputElem || !yInputElem) return;

				const xValStr = xInputElem.value.trim();
				const yValStr = yInputElem.value.trim();
				if (xValStr === '' && yValStr === '') return;

				const xVal = parseFloat(xValStr);
				const yVal = parseFloat(yValStr);

				const xErrInput = row.querySelector('.x-error-input');
				const yErrInput = row.querySelector('.y-error-input');
				const xErrStr = xErrInput ? xErrInput.value.trim() : '';
				const yErrStr = yErrInput ? yErrInput.value.trim() : '';
				const xErrVal = parseFloat(xErrStr);
				const yErrVal = parseFloat(yErrStr);
				const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
				const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

				let rowData = [];

				// Format X value
				let xFormatted = xValStr;
				if (!isNaN(xVal)) {
					if (xUseSciNotation && xErrorEnabledThisRow && xErrorType === 'percentage') {
						const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
						const sciFormatted = formatScientificNotation(xVal, sigFigs);
						xFormatted = `$${sciFormatted}$`;
					} else if (xErrorEnabledThisRow && xErrorType === 'percentage') {
						const sigFigs = xErrVal >= 50 ? 1 : (xErrVal < 10 ? 3 : 2);
						const sigFormatted = toSigFigs(xVal, sigFigs);
						xFormatted = `$${sigFormatted}$`;
					} else if (xErrorEnabledThisRow && xErrorType === 'absolute') {
						const formattedData = formatDataValue(xVal, xErrVal, 'absolute', false);
						xFormatted = `$${formattedData}$`;
					} else {
						xFormatted = `$${xValStr}$`;
					}
				}

				// Format Y value
				let yFormatted = yValStr;
				if (!isNaN(yVal)) {
					if (yUseSciNotation && yErrorEnabledThisRow && yErrorType === 'percentage') {
						const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
						const sciFormatted = formatScientificNotation(yVal, sigFigs);
						yFormatted = `$${sciFormatted}$`;
					} else if (yErrorEnabledThisRow && yErrorType === 'percentage') {
						const sigFigs = yErrVal >= 50 ? 1 : (yErrVal < 10 ? 3 : 2);
						const sigFormatted = toSigFigs(yVal, sigFigs);
						yFormatted = `$${sigFormatted}$`;
					} else if (yErrorEnabledThisRow && yErrorType === 'absolute') {
						const formattedData = formatDataValue(yVal, yErrVal, 'absolute', false);
						yFormatted = `$${formattedData}$`;
					} else {
						yFormatted = `$${yValStr}$`;
					}
				}

				rowData.push(xFormatted);
				rowData.push(yFormatted);
				if (xErrorEnabled) {
					let xErrorFormatted = xErrorEnabledThisRow ? formatUncertainty(xErrStr, xErrorType) : '';
					if (xErrorFormatted !== '') xErrorFormatted = `$${xErrorFormatted}$`;
					rowData.push(xErrorFormatted);
				}
				if (yErrorEnabled) {
					let yErrorFormatted = yErrorEnabledThisRow ? formatUncertainty(yErrStr, yErrorType) : '';
					if (yErrorFormatted !== '') yErrorFormatted = `$${yErrorFormatted}$`;
					rowData.push(yErrorFormatted);
				}
				markdown += `| ${rowData.join(' | ')} |\n`;
			});

			console.log("Final Markdown Content:\n", markdown);
			const blob = new Blob([markdown], { type: 'text/plain;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.setAttribute('href', url);
			link.setAttribute('download', 'data.md');
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} catch (error) {
			console.error('Error exporting plain text:', error);
			alert('An error occurred while exporting the Markdown file. Please check the console for details.');
		}
	}

	function exportCSV() {
		try {
			const table = document.getElementById('data-table');
			const rows = table.querySelectorAll('tr');
			let csvContent = '';

			const xHeader = document.getElementById('x-column-name').value.trim() || 'x';
			const yHeader = document.getElementById('y-column-name').value.trim() || 'y';
			const xErrorEnabled = document.getElementById('toggle-x-error').checked;
			const yErrorEnabled = document.getElementById('toggle-y-error').checked;

			const headers = [xHeader, yHeader];
			if (xErrorEnabled) {
				const xErrorType = document.getElementById('x-error-type').value;
				const xErrorHead = xErrorType === 'percentage' ? `delta ${xHeader} (%)` : `delta ${xHeader}`;
				headers.push(xErrorHead);
			}
			if (yErrorEnabled) {
				const yErrorType = document.getElementById('y-error-type').value;
				const yErrorHead = yErrorType === 'percentage' ? `delta ${yHeader} (%)` : `delta ${yHeader}`;
				headers.push(yErrorHead);
			}

			csvContent += headers.join(',') + '\n';

			const dataRows = table.querySelectorAll('tbody tr');

			for (let i = 0; i < dataRows.length; i++) {
				const xValStr = dataRows[i].querySelector('.x-input')?.value.trim() || '';
				const yValStr = dataRows[i].querySelector('.y-input')?.value.trim() || '';
				if (xValStr === '' && yValStr === '') continue;

				let xVal = parseFloat(xValStr);
				let yVal = parseFloat(yValStr);

				const xErrInput = dataRows[i].querySelector('.x-error-input');
				const yErrInput = dataRows[i].querySelector('.y-error-input');

				const xErrStr = xErrInput ? xErrInput.value.trim() : '';
				const yErrStr = yErrInput ? yErrInput.value.trim() : '';
				const xErrVal = parseFloat(xErrStr);
				const yErrVal = parseFloat(yErrStr);

				const xErrorEnabledThisRow = xErrorEnabled && xErrStr !== '' && !isNaN(xErrVal);
				const yErrorEnabledThisRow = yErrorEnabled && yErrStr !== '' && !isNaN(yErrVal);

				const xErrorType = document.getElementById('x-error-type').value;
				const yErrorType = document.getElementById('y-error-type').value;

				let rowData = [];

				let xFormatted = xValStr;
				if (!isNaN(xVal)) {
					xFormatted = formatDataForExport(
						xValStr, xErrStr, xErrorEnabledThisRow, xErrorType, xVal, xVal, xErrVal
					);
				}

				let yFormatted = yValStr;
				if (!isNaN(yVal)) {
					yFormatted = formatDataForExport(
						yValStr, yErrStr, yErrorEnabledThisRow, yErrorType, yVal, yVal, yErrVal
					);
				}

				rowData.push(xFormatted);
				rowData.push(yFormatted);

				if (xErrorEnabled) {
					rowData.push(xErrorEnabledThisRow ? xErrStr : '');
				}

				if (yErrorEnabled) {
					rowData.push(yErrorEnabledThisRow ? yErrStr : '');
				}

				csvContent += rowData.join(',') + '\n';
			}

			const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.setAttribute('href', url);
			link.setAttribute('download', 'data.csv');
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} catch (error) {
			console.error('Error exporting CSV:', error);
			alert('An error occurred while exporting the CSV. Please check the console for details.');
		}
	}

	function applyGlobalUncertainties(axis) {
		const globalVal = document.getElementById(`global-${axis}-uncertainty`).value.trim();
		const tableBody = document.querySelector('#data-table tbody');
		const rows = tableBody.querySelectorAll('tr');

		rows.forEach((row) => {
			const xInput = row.querySelector('.x-input').value.trim();
			const yInput = row.querySelector('.y-input').value.trim();

			if (xInput !== '' && yInput !== '') {
				const errorInput = row.querySelector(`.${axis}-error-input`);
				if (document.getElementById(`toggle-${axis}-error`).checked && errorInput) {
					errorInput.value = globalVal !== '' ? globalVal : '';
				}
			}
		});

		updateData();
		document.getElementById(`global-${axis}-uncertainty`).value = '';

		// Update initial parameters based on the selected advanced fit method
		setInitialParameters(getCurrentAdvancedFitMethod());
	}

	function fitAdvancedCurve() {
		if (rawData[activeSet].length < 4) { // Increased to 4 for more complex fits
			alert('Please enter at least four data points for advanced fitting.');
			return;
		}

		const fitMethod = document.getElementById('advanced-fit-method').value;

		if (fitMethod === 'Sinusoidal') {
			performSinusoidalFit();
		} else if (fitMethod === 'Gaussian') {
			performGaussianFit();
		}
	}

	function performLinearFit(x, y) {
		try {
			const { slope, intercept } = computeLinearFit(x, y);

			const xFit = [Math.min(...x), Math.max(...x)];
			const yFit = xFit.map(xi => slope * xi + intercept);

			const fitFunction = xi => slope * xi + intercept;

			let equation = `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
			if (intercept < 0) {
				equation = `y = ${slope.toFixed(3)}x - ${Math.abs(intercept).toFixed(3)}`;
			}

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, x, y, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing linear fit:', error);
			alert('An error occurred during linear fitting. Please check the console for details.');
		}
	}

	function performPolynomialFit(x, y, degree) {
		try {
			const coefficients = polyfit(x, y, degree);
			const xFit = Array.from({ length: 100 }, (_, i) => Math.min(...x) + i * (Math.max(...x) - Math.min(...x)) / 99);
			const yFit = xFit.map(xi => polyEval(coefficients, xi));

			const fitFunction = xi => polyEval(coefficients, xi);

			let equation = 'y = ';
			coefficients.forEach((c, i) => {
				const power = degree - i;
				if (c === 0) return;

				const absC = Math.abs(c).toFixed(3);
				const sign = c >= 0 ? (i === 0 ? '' : ' + ') : (i === 0 ? '-' : ' - ');

				let term = '';
				if (power === 0) {
					term = `${absC}`;
				} else if (power === 1) {
					term = `${absC}x`;
				} else {
					term = `${absC}x^{${power}}`;
				}

				equation += `${sign}${term}`;
			});

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, x, y, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing polynomial fit:', error);
			alert('An error occurred during polynomial fitting. Please check the console for details.');
		}
	}

	function performExponentialFit() {
		try {
			// Access and filter the active dataset to ensure positive y-values
			const data = rawData[activeSet].filter(point => point.y > 0);
			if (data.length < 4) { // Minimum points needed for four parameters
				alert('Exponential fit requires at least four data points with positive y-values.');
				return;
			}

			const xData = data.map(p => p.x);
			const yData = data.map(p => p.y);

			// Step 1: Estimate c as the minimum y-value
			const c = Math.min(...yData);

			// Define the range for x0 based on the data
			const xMin = Math.min(...xData);
			const xMax = Math.max(...xData);
			const gridSteps = 100; // Number of grid points for x0
			const x0Candidates = Array.from({ length: gridSteps }, (_, i) => xMin + i * (xMax - xMin) / (gridSteps - 1));

			let bestX0 = x0Candidates[0];
			let bestA = 1;
			let bestB = 1;
			let lowestMSE = Infinity;

			// Function to perform linear fit and compute MSE
			const evaluateFit = (xValid, logYValid, slope, intercept) => {
				const predictions = xValid.map(x => slope * x + intercept);
				const residuals = logYValid.map((y, idx) => y - predictions[idx]);
				const mse = residuals.reduce((sum, res) => sum + res * res, 0) / residuals.length;
				return mse;
			};

			// Step 2: Grid Search for x0
			for (let i = 0; i < x0Candidates.length; i++) {
				const x0 = x0Candidates[i];

				// Adjust y-values by subtracting c
				const yAdjusted = yData.map(y => y - c);

				// Ensure all adjusted y-values are positive
				const xValid = [];
				const yValid = [];
				for (let j = 0; j < yAdjusted.length; j++) {
					if (yAdjusted[j] > 0) {
						xValid.push(xData[j]);
						yValid.push(yAdjusted[j]);
					}
				}

				if (xValid.length < 2) {
					// Not enough points for this x0
					continue;
				}

				// Linearize the model by taking the natural log of adjusted y-values
				const logY = yValid.map(y => Math.log(y));

				// Perform linear regression to find slope (b) and intercept (lnA)
				const { slope, intercept } = computeLinearFit(xValid, logY);

				// Compute MSE for this fit
				const mse = evaluateFit(xValid, logY, slope, intercept);

				// Update best parameters if this fit is better
				if (mse < lowestMSE) {
					lowestMSE = mse;
					bestX0 = x0;
					bestB = slope;
					bestA = Math.exp(intercept);
				}

				// Optional: Early termination if MSE is below a threshold
				// const mseThreshold = 0.001;
				// if (mse < mseThreshold) break;
			}

			// Step 3: Final Fit with best parameters
			// Adjust y-values by subtracting c
			const finalYAdjusted = yData.map(y => y - c);
			const finalXValid = [];
			const finalYValid = [];
			for (let i = 0; i < finalYAdjusted.length; i++) {
				if (finalYAdjusted[i] > 0) {
					finalXValid.push(xData[i]);
					finalYValid.push(finalYAdjusted[i]);
				}
			}

			// Linearize and perform linear regression with best x0
			const finalLogY = finalYValid.map(y => Math.log(y));
			const { slope: finalB, intercept: finalIntercept } = computeLinearFit(finalXValid, finalLogY);
			const finalA = Math.exp(finalIntercept);

			// Calculate MSE for the final fit (optional)
			const finalPredictionsLog = finalXValid.map(x => finalB * x + finalIntercept);
			const finalResiduals = finalLogY.map((y, idx) => y - finalPredictionsLog[idx]);
			const finalMSE = finalResiduals.reduce((sum, res) => sum + res * res, 0) / finalResiduals.length;

			// Step 4: Generate fitted curve data
			const fittedX = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
			const fittedY = fittedX.map(xi => finalA * Math.exp(finalB * (xi - bestX0)) + c);

			const fitFunction = xi => finalA * Math.exp(finalB * (xi - bestX0)) + c;

			// Construct the equation string
			const equation = `y = ${finalA.toFixed(3)} e^{${finalB.toFixed(3)}(x - ${bestX0.toFixed(3)})} + ${c.toFixed(3)}`;

			// Step 5: Compute R² for fit quality
			const meanY = finalYValid.reduce((sum, y) => sum + y, 0) / finalYValid.length;
			const ssTot = finalYValid.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
			const ssRes = finalYValid.reduce((sum, y, idx) => {
				const predictedY = finalA * Math.exp(finalB * (finalXValid[idx] - bestX0)) + c;
				return sum + Math.pow(y - predictedY, 2);
			}, 0);
			const rSquared = 1 - (ssRes / ssTot);

			console.log(`R²: ${rSquared.toFixed(3)}`);

			// Step 6: Store the fitted curve for this dataset
			fittedCurves[activeSet] = { x: fittedX, y: fittedY, equation: equation };

			// Step 7: Update results and plot
			updateResults(equation, finalXValid, finalYValid.map((y, idx) => y + c), fitFunction, rSquared);
			plotGraph(fittedX, fittedY);
		} catch (error) {
			console.error('Error performing exponential fit:', error);
			alert('An error occurred during exponential fitting. Please check the console for details.');
		}
	}

	/**
	 * Perform a power-law fit of the form:
	 *   y = A (x - x0)^b + c
	 * 
	 * This version attempts multiple initial guesses for (x0, c)
	 * and runs a Levenberg–Marquardt optimization from each guess.
	 * The best result (lowest sum of squared residuals) is retained.
	 */
	function performPowerFit() {
		try {
			// 1. Filter and validate input data
			const validData = rawData[activeSet].filter(point =>
				Number.isFinite(point.x) && Number.isFinite(point.y)
			);
			if (validData.length < 4) {
				alert("Power fit requires at least 4 data points.");
				return;
			}

			const xValues = validData.map(p => p.x);
			const yValues = validData.map(p => p.y);

			// 2. Generate multiple initial guesses for x0 and c
			//    We'll sample around (xMin - a bit, yMin - a bit) and also near medians.
			const xMin = Math.min(...xValues);
			const xMed = median(xValues);
			const yMin = Math.min(...yValues);
			const yMed = median(yValues);

			const guessPairs = [
				// Minimal offset guess
				[xMin - 1e-3, yMin - 1e-3],
				// Slightly bigger offset
				[xMed - 0.01, yMed - 0.01],
				// Another guess further
				[xMin - 0.1, yMin - 0.1],
			];

			let bestParams = null;
			let bestCost = Infinity;

			// 3. Try each (x0, c) guess
			for (const [x0Guess, cGuess] of guessPairs) {
				// 3a. Shift x0 or c if needed so that all (x - x0) > 0 and (y - c) > 0 for the log approach
				let shiftedX0 = x0Guess;
				let shiftedC = cGuess;

				// Ensure (x - x0) > 0 for all x if we want to do an initial log transform
				let z = xValues.map(x => x - shiftedX0);
				while (z.some(zi => zi <= 0)) {
					shiftedX0 -= 1e-3;
					z = xValues.map(x => x - shiftedX0);
				}

				// Ensure (y - c) > 0 for initial log transform
				let w = yValues.map(y => y - shiftedC);
				while (w.some(wi => wi <= 0)) {
					shiftedC -= 1e-3;
					w = yValues.map(y => y - shiftedC);
				}

				// 3b. Compute initial A, b via linear regression on log-log
				const lnZ = z.map(zi => Math.log(zi));
				const lnW = w.map(wi => Math.log(wi));
				const { slope: bInitial, intercept: lnAInitial } = computeLinearFit(lnZ, lnW);
				const AInitial = Math.exp(lnAInitial);

				const initialParams = [AInitial, bInitial, shiftedX0, shiftedC];

				// 3c. Run LM from this initial guess
				const { params, cost } = levenbergMarquardt(validData, initialParams);

				// 3d. Check if it's the best so far
				if (cost < bestCost) {
					bestCost = cost;
					bestParams = params;
				}
			}

			// 4. Use the best parameters found
			if (!bestParams) {
				alert("Unable to find a suitable power-law fit.");
				return;
			}
			const [A, b, x0, c] = bestParams;

			// 5. Generate fitted curve
			const xMinFit = Math.min(...xValues);
			const xMaxFit = Math.max(...xValues);
			const N = 100;
			const xFit = Array.from({ length: N }, (_, i) => {
				return xMinFit + (i * (xMaxFit - xMinFit)) / (N - 1);
			});

			// Build y-fit, but skip invalid points if (x - x0) is negative and b non-integer
			const yFit = xFit.map(xi => {
				const term = xi - x0;
				try {
					if (term <= 0 && !Number.isInteger(b)) {
						// for non-integer b, (x - x0) <= 0 is invalid
						return NaN;
					}
					return A * Math.pow(term, b) + c;
				} catch {
					return NaN;
				}
			});

			// 6. Define a fit function for interactive queries
			const fitFunction = xi => {
				const term = xi - x0;
				if (term <= 0 && !Number.isInteger(b)) return NaN;
				return A * Math.pow(term, b) + c;
			};

			// 7. Construct the equation string
			// 7.1. Determine sign for x0 and c
			const x0Sign = (x0 >= 0) ?
				` - ${x0.toFixed(3)}` // Example: (x - 2.500)
				:
				` + ${Math.abs(x0).toFixed(3)}`; // Example: (x + 0.004) if x0 is -0.004

			const cSign = (c >= 0) ?
				` + ${c.toFixed(3)}` :
				` - ${Math.abs(c).toFixed(3)}`;

			// 7.2. Construct the equation string
			const equation = `y = ${A.toFixed(3)}(x${x0Sign})^{${b.toFixed(3)}}${cSign}`;

			// 8. Store the fitted curve
			fittedCurves[activeSet] = {
				x: xFit,
				y: yFit,
				equation: equation
			};

			// 9. Update results and plot
			updateResults(equation, xValues, yValues, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error("Error performing power fit:", error);
			alert("An error occurred during power fitting. Please check the console for details.");
		}
	}

	/**
	 * Enhanced Levenberg–Marquardt Implementation.
	 * Returns the optimized params and final cost.
	 *
	 * @param {Array} data - array of points {x, y}
	 * @param {Array} initialParams - [A, b, x0, c]
	 * @param {number} maxIterations
	 * @param {number} tolerance
	 */
	function levenbergMarquardt(data, initialParams, maxIterations = 200, tolerance = 1e-8) {
		let params = initialParams.slice();
		let lambda = 1e-3; // initial damping
		let nu = 2; // factor to adjust lambda
		let prevCost = Infinity;

		let bestParams = params.slice();
		let bestCost = Infinity;

		for (let iter = 0; iter < maxIterations; iter++) {
			// 1. Compute residuals & cost
			const residuals = computeResiduals(params, data);
			const cost = residuals.reduce((sum, r) => sum + r * r, 0);

			// 2. Convergence check
			if (Math.abs(prevCost - cost) < tolerance) {
				return { params, cost };
			}
			prevCost = cost;

			// 3. Jacobian
			const J = computeJacobian(params, data);
			const JT = transpose(J);
			const JTJ = multiply(JT, J);
			const JTr = multiplyMatrixVector(JT, residuals);

			// 4. Build damped matrix
			const n = JTJ.length;
			let A_lm = new Array(n).fill(null).map(() => new Array(n).fill(0));
			for (let i = 0; i < n; i++) {
				for (let j = 0; j < n; j++) {
					A_lm[i][j] = JTJ[i][j];
					if (i === j) {
						A_lm[i][j] += lambda * (A_lm[i][j] || 1);
					}
				}
			}

			// 5. Solve for delta
			let delta;
			try {
				const negJTr = JTr.map(v => -v);
				delta = solve(A_lm, negJTr);
			} catch (err) {
				// If solve fails, increase lambda and continue
				lambda *= nu;
				continue;
			}

			// 6. Check new parameters
			const newParams = params.map((p, i) => p + delta[i]);
			const newRes = computeResiduals(newParams, data);
			const newCost = newRes.reduce((s, r) => s + r * r, 0);

			if (newCost < cost) {
				// Improvement
				params = newParams;
				if (newCost < bestCost) {
					bestCost = newCost;
					bestParams = params.slice();
				}
				lambda *= 0.3; // reduce damping
				if (lambda < 1e-20) lambda = 1e-20;
			} else {
				// No improvement, increase damping
				lambda *= nu;
				if (lambda > 1e20) {
					// If lambda is huge, bail out
					return { params: bestParams, cost: bestCost };
				}
			}
		}

		return { params: bestParams, cost: bestCost };
	}

	/**
	 * Compute the residuals array for the current parameters.
	 * If (x - x0) <= 0 and b not integer, we penalize heavily (return large residual).
	 */
	function computeResiduals(params, data) {
		const [A, b, x0, c] = params;
		return data.map(({ x, y }) => {
			const term = x - x0;
			if (term <= 0 && !Number.isInteger(b)) {
				// For non-integer b, negative base is invalid -> large penalty
				return 1e6;
			}
			let yPred;
			try {
				yPred = A * Math.pow(term, b) + c;
				if (!Number.isFinite(yPred)) {
					return 1e6;
				}
			} catch {
				return 1e6;
			}
			return yPred - y;
		});
	}

	/**
	 * Compute the Jacobian for [A, b, x0, c].
	 * J[i][k] = derivative of residual_i w.r.t. param_k
	 */
	function computeJacobian(params, data) {
		const [A, b, x0, c] = params;
		return data.map(({ x, y }) => {
			const term = x - x0;
			// Default partial derivatives
			let dA = 0,
				db = 0,
				dx0 = 0,
				dc = 0;

			if (term <= 0 && !Number.isInteger(b)) {
				// invalid region -> residual ~ 1e6 w.r.t. everything
				// For continuity, let's set derivatives near zero (or 0.0)
				return [0, 0, 0, 0];
			}

			// yPred = A * term^b + c
			// residual = yPred - y
			// => partial residual / partial param = partial yPred / partial param
			// partial wrt A = term^b
			// partial wrt b = A * term^b * ln(term)
			// partial wrt x0 = -A * b * term^(b-1)
			// partial wrt c = 1

			try {
				// term^b
				const basePow = Math.pow(term, b);
				const lnTerm = Math.log(term);

				dA = basePow;
				db = A * basePow * lnTerm;
				dx0 = -A * b * Math.pow(term, b - 1);
				dc = 1;

				// If any are NaN or infinite, set to 0
				if (!Number.isFinite(dA)) dA = 0;
				if (!Number.isFinite(db)) db = 0;
				if (!Number.isFinite(dx0)) dx0 = 0;
			} catch {
				// In case of domain errors
				dA = dA = dx0 = dc = 0;
			}

			return [dA, db, dx0, dc];
		});
	}

	// ---------- Matrix Helpers ----------

	function transpose(matrix) {
		return matrix[0].map((_, i) => matrix.map(row => row[i]));
	}

	function multiply(a, b) {
		// matrix x matrix
		const m = a.length;
		const n = b[0].length;
		const result = new Array(m).fill(null).map(() => new Array(n).fill(0));
		for (let i = 0; i < m; i++) {
			for (let j = 0; j < n; j++) {
				let sum = 0;
				for (let k = 0; k < b.length; k++) {
					sum += a[i][k] * b[k][j];
				}
				result[i][j] = sum;
			}
		}
		return result;
	}

	function multiplyMatrixVector(matrix, vector) {
		return matrix.map(row => {
			let sum = 0;
			for (let i = 0; i < row.length; i++) {
				sum += row[i] * vector[i];
			}
			return sum;
		});
	}

	/**
	 * Solve a system Ax = b using Gaussian elimination
	 * 
	 * @param {Array<Array<number>>} matrix - 2D array (A)
	 * @param {Array<number>} vector - 1D array (b)
	 */
	function solve(matrix, vector) {
		const n = matrix.length;
		const augmented = matrix.map((row, i) => row.concat([vector[i]]));

		for (let i = 0; i < n; i++) {
			// Find pivot
			let maxRow = i;
			for (let r = i + 1; r < n; r++) {
				if (Math.abs(augmented[r][i]) > Math.abs(augmented[maxRow][i])) {
					maxRow = r;
				}
			}
			if (maxRow !== i) {
				[augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
			}

			const pivot = augmented[i][i];
			if (Math.abs(pivot) < 1e-14) {
				throw new Error("Singular matrix");
			}

			// Normalize pivot row
			for (let c = i; c <= n; c++) {
				augmented[i][c] /= pivot;
			}

			// Eliminate in other rows
			for (let r = 0; r < n; r++) {
				if (r !== i) {
					const factor = augmented[r][i];
					for (let c = i; c <= n; c++) {
						augmented[r][c] -= factor * augmented[i][c];
					}
				}
			}
		}

		return augmented.map(row => row[n]);
	}

	/**
	 * Simple median function
	 */
	function median(arr) {
		if (!arr.length) return NaN;
		const sorted = [...arr].sort((a, b) => a - b);
		const mid = Math.floor(sorted.length / 2);
		if (sorted.length % 2 === 0) {
			return 0.5 * (sorted[mid - 1] + sorted[mid]);
		}
		return sorted[mid];
	}

	function estimateKFromData() {
		if (!rawData[activeSet] || rawData[activeSet].length < 4) {
			console.warn("Not enough data points to estimate k.");
			return null;
		}

		// === 1. Sort & detrend ===
		const sortedData = [...rawData[activeSet]].sort((a, b) => a.x - b.x);
		const x = sortedData.map(p => p.x);
		const y = sortedData.map(p => p.y);

		const N = x.length;
		const xMin = x[0];
		const xMax = x[N - 1];
		const dataSpan = xMax - xMin;
		if (dataSpan <= 0) {
			console.warn("Degenerate or invalid X range.");
			return null;
		}

		// Mean of y for detrending
		const meanY = y.reduce((acc, val) => acc + val, 0) / N;
		const yDetrended = y.map(val => val - meanY);

		// We'll also need an approximate sampling step to gauge a "Nyquist" limit
		//   (roughly valid if data is close to uniform in x).
		const avgDx = dataSpan / (N - 1);
		// A naive Nyquist frequency ~ π / avgDx
		const nyquist = Math.PI / avgDx;

		// === 2. Optional: Peak-detection for rough kGuess ===
		let peaks = [];
		for (let i = 1; i < N - 1; i++) {
			if (y[i] > y[i - 1] && y[i] > y[i + 1]) {
				peaks.push(x[i]);
			}
		}
		let kGuess = null;
		if (peaks.length >= 2) {
			const intervals = [];
			for (let i = 1; i < peaks.length; i++) {
				intervals.push(peaks[i] - peaks[i - 1]);
			}
			const avgPeriod = intervals.reduce((a, b) => a + b, 0) / intervals.length;
			kGuess = (2 * Math.PI) / avgPeriod;
			console.log(
				`Peak-detect guess => period ~ ${avgPeriod.toFixed(4)}, kGuess ~ ${kGuess.toFixed(4)}`
			);
		} else {
			console.log("Not enough peaks for a peak-based guess.");
		}

		// === 3. Define an initial log-spaced frequency range ===
		// We'll define a broad range, but not infinite.
		// Lower bound: say 2π / (5 * dataSpan) => up to ~5 cycles across the entire domain
		// or 1e-3 if that is bigger, just to avoid going too close to zero.
		const minCandidate = Math.max(1e-3, (2 * Math.PI) / (5 * dataSpan));

		// Upper bound: let's pick something around 5 × the naive Nyquist as a default
		// (i.e. 5 × π / avgDx), but not less than, say, 10 if the data is extremely well-sampled.
		let maxCandidate = Math.max(10, nyquist * 5);

		// If we do have a kGuess, ensure that we include it by possibly expanding the range:
		if (kGuess && Number.isFinite(kGuess) && kGuess > 0) {
			if (kGuess < minCandidate) {
				// expand downward
				console.log(
					`kGuess < minCandidate => adjusting minCandidate from ${minCandidate.toFixed(4)} to ~${kGuess / 5}`
				);
				minCandidate <= 1e-7 ?
					(minCandidate = 1e-7) :
					(minCandidate = Math.max(1e-7, kGuess / 5));
			}
			if (kGuess > maxCandidate) {
				console.log(
					`kGuess > maxCandidate => adjusting maxCandidate from ${maxCandidate.toFixed(4)} to ~${kGuess * 5}`
				);
				maxCandidate = kGuess * 5;
			}
		}

		console.log(
			`Log-search range: [${minCandidate.toFixed(4)}, ${maxCandidate.toFixed(4)}]`
		);

		// === 4. Coarse search in log space ===
		// We'll sample frequencies log-spaced from minCandidate to maxCandidate
		const numLogSamples = 200; // ~200 log steps
		const logMin = Math.log(minCandidate);
		const logMax = Math.log(maxCandidate);

		let bestCoarseOmega = 0;
		let bestCoarseScore = -Infinity;

		for (let i = 0; i < numLogSamples; i++) {
			// Log spacing
			const frac = i / (numLogSamples - 1);
			const omega = Math.exp(logMin + frac * (logMax - logMin));

			let sumSin = 0;
			let sumCos = 0;
			for (let j = 0; j < N; j++) {
				const val = yDetrended[j];
				const phase = omega * x[j];
				sumSin += val * Math.sin(phase);
				sumCos += val * Math.cos(phase);
			}
			const score = sumSin * sumSin + sumCos * sumCos;
			if (score > bestCoarseScore) {
				bestCoarseScore = score;
				bestCoarseOmega = omega;
			}
		}
		console.log(
			`Log-coarse best => omega = ${bestCoarseOmega.toFixed(4)}, score = ${bestCoarseScore.toExponential(3)}`
		);

		// === 5. Fine local linear search around bestCoarseOmega ===
		// We'll do ± 30% in linear space (adjust as desired)
		const fineFactor = 0.3;
		const fineMin = Math.max(minCandidate, bestCoarseOmega * (1 - fineFactor));
		const fineMax = Math.min(maxCandidate, bestCoarseOmega * (1 + fineFactor));

		let bestFineOmega = bestCoarseOmega;
		let bestFineScore = bestCoarseScore;

		if (fineMax <= fineMin) {
			console.warn(
				`Fine search range is degenerate => [${fineMin}, ${fineMax}]. Returning coarse result.`
			);
			return bestCoarseOmega;
		}

		const numFine = 3000; // ~3k linear steps
		const step = (fineMax - fineMin) / (numFine - 1);

		for (let i = 0; i < numFine; i++) {
			const omega = fineMin + i * step;
			let sumSin = 0;
			let sumCos = 0;
			for (let j = 0; j < N; j++) {
				const val = yDetrended[j];
				const phase = omega * x[j];
				sumSin += val * Math.sin(phase);
				sumCos += val * Math.cos(phase);
			}
			const score = sumSin * sumSin + sumCos * sumCos;
			if (score > bestFineScore) {
				bestFineScore = score;
				bestFineOmega = omega;
			}
		}
		console.log(
			`Fine search best => omega = ${bestFineOmega.toFixed(4)}, score = ${bestFineScore.toExponential(3)}`
		);

		// === 6. Final sanity check vs. Nyquist? ===
		if (bestFineOmega > 2 * nyquist) {
			console.warn(
				`Warning: best freq = ${bestFineOmega.toFixed(4)} is > 2 × Nyquist (~${(2 * nyquist).toFixed(4)}). Data may be under-sampled.`
			);
		}

		console.log(
			`Final estimated k = ${bestFineOmega.toFixed(4)}`
		);
		return bestFineOmega;
	}

	function performSinusoidalFit() {
		try {
			let A = parseFloat(document.getElementById('initial-A').value);
			let b = parseFloat(document.getElementById('initial-b').value);
			let k = parseFloat(document.getElementById('initial-k').value);
			let phi = parseFloat(document.getElementById('initial-phi').value);
			let c = parseFloat(document.getElementById('initial-c').value);

			if (isNaN(k) || k <= 0) {
				const estimatedK = estimateKFromData();
				if (estimatedK !== null) {
					k = estimatedK;
					console.log(`Using estimated k: ${k}`);
					document.getElementById('initial-k').value = k.toFixed(3);
				} else {
					alert('Failed to estimate k. Please provide an initial value.');
					return;
				}
			}

			if (isNaN(A) || isNaN(b) || isNaN(phi) || isNaN(c)) {
				alert('Please provide valid initial parameters for Sinusoidal fit.');
				return;
			}

			let params = { A: A, b: b, k: k, phi: phi, c: c };

			let learningRate = 1e-5;
			const maxIterations = 100000;
			const tolerance = 1e-6;
			let previousError = Infinity;
			let iterationsCount = 0;

			const decayRate = 0.99995;
			const delta = 1.0;

			while (iterationsCount < maxIterations) {
				let totalLoss = 0;
				let dA = 0,
					db = 0,
					dk = 0,
					dphi = 0,
					dc = 0;

				for (let i = 0; i < rawData[activeSet].length; i++) {
					const xi = rawData[activeSet][i].x;
					const yi = rawData[activeSet][i].y;

					const expTerm = Math.exp(params.b * xi);
					const sinTerm = Math.sin(params.k * xi - params.phi);
					const cosTerm = Math.cos(params.k * xi - params.phi);

					const prediction = params.A * expTerm * sinTerm + params.c;
					const error = yi - prediction;

					let huberGrad;
					if (Math.abs(error) <= delta) {
						totalLoss += error ** 2;
						huberGrad = 2 * error;
					} else {
						totalLoss += 2 * delta * Math.abs(error) - delta ** 2;
						huberGrad = 2 * delta * Math.sign(error);
					}

					dA += -huberGrad * expTerm * sinTerm;
					db += -huberGrad * params.A * xi * expTerm * sinTerm;
					dk += -huberGrad * params.A * expTerm * xi * cosTerm;
					dphi += huberGrad * params.A * expTerm * cosTerm;
					dc += -huberGrad;
				}

				const mse = totalLoss / rawData[activeSet].length;
				if (Math.abs(previousError - mse) < tolerance) {
					console.log(`Convergence reached after ${iterationsCount} iterations.`);
					break;
				}
				previousError = mse;

				params.A -= learningRate * dA;
				params.b -= learningRate * db;
				params.k -= learningRate * dk;
				params.phi -= learningRate * dphi;
				params.c -= learningRate * dc;
				learningRate *= decayRate;
				iterationsCount++;
			}

			if (iterationsCount === maxIterations) {
				alert('Sinusoidal fitting did not converge. Please try different initial parameters.');
				return;
			}

			const xMin = Math.min(...rawData[activeSet].map(p => p.x));
			const xMax = Math.max(...rawData[activeSet].map(p => p.x));
			const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
			const yFit = xFit.map(xi =>
				params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c
			);

			const fitFunction = xi =>
				params.A * Math.exp(params.b * xi) * Math.sin(params.k * xi - params.phi) + params.c;

			let equation = `y = ${params.A.toFixed(3)} e^{${params.b.toFixed(3)}x} \\sin(${params.k.toFixed(3)}x`;
			if (params.phi > 0) {
				equation += ` - ${params.phi.toFixed(3)}`;
			} else if (params.phi < 0) {
				equation += ` + ${Math.abs(params.phi).toFixed(3)}`;
			}
			equation += `)`;
			if (params.c > 0) {
				equation += ` + ${params.c.toFixed(3)}`;
			} else if (params.c < 0) {
				equation += ` - ${Math.abs(params.c).toFixed(3)}`;
			}

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, rawData[activeSet].map(p => p.x), rawData[activeSet].map(p => p.y), fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing sinusoidal fit:', error);
			alert('An error occurred during sinusoidal fitting. Please check the console for details.');
		}
	}

	function performGaussianFit() {
		try {
			let A = parseFloat(document.getElementById('initial-A-gaussian').value);
			let mu = parseFloat(document.getElementById('initial-mu').value);
			let sigma = parseFloat(document.getElementById('initial-sigma').value);
			let c = parseFloat(document.getElementById('initial-c-gaussian').value);

			if (isNaN(A) || isNaN(mu) || isNaN(sigma) || isNaN(c)) {
				alert('Please provide valid initial parameters for Gaussian fit.');
				return;
			}

			const params = { A, mu, sigma, c };

			const learningRateA = 1e-7;
			const learningRateMu = 1e-7;
			const learningRateSigma = 1e-7;
			const learningRateC = 1e-7;

			const maxIterations = 50000;
			const tolerance = 1e-8;

			function gaussian(x, p) {
				return p.A * Math.exp(-((x - p.mu) ** 2) / (2 * p.sigma ** 2)) + p.c;
			}

			function computeMSE(p) {
				let mseSum = 0;
				for (let i = 0; i < rawData[activeSet].length; i++) {
					const { x, y } = rawData[activeSet][i];
					const prediction = gaussian(x, p);
					const error = y - prediction;
					mseSum += error * error;
				}
				return mseSum / rawData[activeSet].length;
			}

			let previousError = computeMSE(params);

			for (let iteration = 0; iteration < maxIterations; iteration++) {
				let dA = 0,
					dMu = 0,
					dSigma = 0,
					dC = 0;

				for (let i = 0; i < rawData[activeSet].length; i++) {
					const { x, y } = rawData[activeSet][i];
					const expTerm = Math.exp(-((x - params.mu) ** 2) / (2 * params.sigma ** 2));
					const prediction = params.A * expTerm + params.c;
					const error = y - prediction;

					dA += error * expTerm;
					dMu += error * params.A * expTerm * ((x - params.mu) / (params.sigma ** 2));
					dSigma += error * params.A * expTerm * ((x - params.mu) ** 2) / (params.sigma ** 3);
					dC += error;
				}

				const N = rawData[activeSet].length;
				dA = -2 * dA / N;
				dMu = -2 * dMu / N;
				dSigma = -2 * dSigma / N;
				dC = -2 * dC / N;

				params.A -= learningRateA * dA;
				params.mu -= learningRateMu * dMu;
				params.sigma -= learningRateSigma * dSigma;
				params.c -= learningRateC * dC;

				if (params.sigma <= 0) {
					params.sigma = Math.abs(params.sigma) || 1e-6;
				}

				const currentError = computeMSE(params);
				if (Math.abs(previousError - currentError) < tolerance) {
					break;
				}
				previousError = currentError;
			}

			const xValues = rawData[activeSet].map(p => p.x);
			const yValues = rawData[activeSet].map(p => p.y);
			const xMin = Math.min(...xValues);
			const xMax = Math.max(...xValues);
			const xFit = Array.from({ length: 100 }, (_, i) => xMin + i * (xMax - xMin) / 99);
			const yFit = xFit.map(xi => gaussian(xi, params));

			let muTerm;
			if (params.mu < 0) {
				muTerm = `(x + ${Math.abs(params.mu).toFixed(3)})`;
			} else {
				muTerm = `(x - ${params.mu.toFixed(3)})`;
			}
			let equation = `y = ${params.A.toFixed(3)} \\; e^{-\\frac{${muTerm}^2}{2 \\; (${params.sigma.toFixed(3)})^2}}`;
			if (params.c > 0) {
				equation += ` \\; + \\; ${params.c.toFixed(3)}`;
			} else if (params.c < 0) {
				equation += ` \\; - \\; ${Math.abs(params.c).toFixed(3)}`;
			};

			const fitFunction = xi => gaussian(xi, params);

			// Store the fitted curve for this dataset.
			fittedCurves[activeSet] = { x: xFit, y: yFit, equation: equation };

			updateResults(equation, xValues, yValues, fitFunction);
			plotGraph(xFit, yFit);
		} catch (error) {
			console.error('Error performing Gaussian fit:', error);
			alert('An error occurred during Gaussian fitting. Please check the console for details.');
		}
	}

	window.onload = function() {
		initializeTable();
		['x-column-name', 'y-column-name'].forEach(id => {
			const value = document.getElementById(id).value;
			renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
		});

		clearRows();

		// Update the graph title based on the current column headings:
		updateGraphTitle();

		// Trigger typesetting for the new graph title if necessary.
		MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);

		updateBasicFitEquation();
		const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
		changeAdvancedFitMethod();
	};

	document.addEventListener("DOMContentLoaded", function() {
		// Render LaTeX for column headings.
		['x-column-name', 'y-column-name'].forEach(id => {
			const value = document.getElementById(id).value;
			renderLatex(`#${id}-column-latex`, formatLabelForLatex(value));
		});

		// Update the graph title based on the current column headings.
		updateGraphTitle();

		// Trigger MathJax typesetting for the graph title.
		if (typeof MathJax !== 'undefined') {
			MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('graph-title')]);
		}

		// Update the basic fit equation and advanced fit method.
		updateBasicFitEquation();
		const initialAdvancedFitMethod = document.getElementById('advanced-fit-method').value;
		changeAdvancedFitMethod();

		// Initialize the dataset tabs bar.
		initializeDatasetTabsBar();

		// Initialize the combined plot inputs.
		initCombinedPlotInputs();

		// Set up the LaTeX mode toggle
		const latexToggle = document.getElementById('latex-mode-toggle');
		if (latexToggle) {
			latexToggle.checked = false; // default off
			latexToggle.addEventListener('change', function() {
				latexMode = this.checked;
				// Optionally, re-run update routines so that headings, labels, and titles re-render
				updatePlotAndRenderLatex();
				updateLabels('x');
				updateLabels('y');
				updateGraphTitle();
			});
		}

	});
</script>

</html>