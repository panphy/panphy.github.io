<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Motion Tracker</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		:root {
			--btn-open-color: #0079b1;
			--btn-play-color: #3ec786;
			--btn-calibration-color: #f0bd37;
			--btn-set-origin-color: #f0bd37;
			--btn-export-color: #23a5d0;
			--btn-clear-data-color: #ee4c4c;
			--btn-clear-calibration-color: #ec7070;
			--btn-clear-origin-color: #ec7070;
			--btn-confirm-color: #28a745;
			--btn-cancel-color: #dc3545;
			--btn-plot-vx-color: #48c8a8;
			--btn-plot-vy-color: #48c8a8;
			--btn-backToPosition-color: #48c8a8;
		}

		body {
			font-family: Arial, sans-serif;
			margin: 0;
			background: #f9f9f9;
			color: #333
		}

		#titleBanner {
			display: grid;
			grid-template-columns: auto 1fr auto;
			align-items: center;
			background: #333;
			color: #fff;
			padding: 5px 0
		}

		.banner-logo img {
			max-height: 38px;
			height: auto;
			width: auto;
			margin: 3px 10px
		}

		.banner-title {
			margin: 0;
			text-align: center;
			font-size: 1.8em;
			font-weight: bold
		}

		.banner-placeholder {
			width: 70px
		}

		a {
			color: #ff5f1f;
			text-decoration: none
		}

		a:hover {
			text-decoration: underline
		}

		h1 {
			display: none
		}

		#warningBanner {
			font-size: .9em;
			background: #fff8e3;
			color: #856404;
			padding: 5px;
			text-align: center
		}

		#message {
			font-size: 1.2em;
			font-weight: bold;
			text-align: center;
			margin: 15px auto;
			color: #333;
			max-width: 800px;
			line-height: 1.5
		}

		#topControls {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			grid-template-rows: repeat(2, auto);
			gap: 10px;
			padding: 20px;
			max-width: 800px;
			margin: 0 auto
		}

		.control-button {
			padding: 10px 20px;
			border: none;
			border-radius: 5px;
			color: #fff;
			font-size: 1em;
			font-weight: bold;
			cursor: pointer;
			transition: filter .3s ease;
			width: 100%
		}

		.btn-open {
			background: var(--btn-open-color)
		}

		.btn-play {
			background: var(--btn-play-color)
		}

		.btn-calibration {
			background: var(--btn-calibration-color)
		}

		.btn-set-origin {
			background: var(--btn-set-origin-color)
		}

		.btn-export {
			background: var(--btn-export-color)
		}

		.btn-clear-data {
			background: var(--btn-clear-data-color)
		}

		.btn-clear-calibration {
			background: var(--btn-clear-calibration-color)
		}

		.btn-clear-origin {
			background: var(--btn-clear-origin-color)
		}

		.btn-plot-vx {
			background: var(--btn-plot-vx-color)
		}

		.btn-plot-vy {
			background: var(--btn-plot-vy-color)
		}

		.btn-backToPosition {
			background: var(--btn-backToPosition-color)
		}

		.control-button:hover:not(:disabled) {
			filter: brightness(90%)
		}

		.control-button:disabled {
			background: #a9a9a9 !important;
			cursor: not-allowed
		}

		#analysisContainer {
			display: flex;
			justify-content: space-evenly;
			align-items: flex-start;
			flex-wrap: wrap;
			margin: 20px auto;
			padding: 20px;
			gap: 20px;
			max-width: 1200px
		}

		#videoSection {
			display: flex;
			flex-direction: column;
			align-items: center;
			width: 48%;
			max-width: 600px;
			min-width: 300px
		}

		#videoWrapper {
			position: relative;
			width: 100%;
			min-height: 200px
		}

		video,
		canvas {
			border: 2px solid #ddd;
			border-radius: 8px;
			max-width: 100%;
			height: auto;
			background: #f5f5f5;
			display: block
		}

		#hiddenVideo {
			display: none
		}

		#overlayCanvas {
			position: absolute;
			top: 0;
			left: 0;
			background: transparent;
			z-index: 2;
			pointer-events: none
		}

		#frameCanvas {
			display: none
		}

		#controlsContainer {
			display: flex;
			justify-content: space-between;
			align-items: center;
			width: 100%;
			max-width: 800px;
			margin-top: 10px
		}

		#videoControls {
			display: flex;
			align-items: center;
			gap: 15px;
			width: 100%
		}

		#slider {
			appearance: none;
			background: #007bff;
			height: 5px;
			border-radius: 5px;
			outline: none;
			margin: 0 10px;
			cursor: pointer;
			width: 100%
		}

		#slider::-webkit-slider-thumb {
			appearance: none;
			width: 15px;
			height: 15px;
			border-radius: 50%;
			background: #fff;
			border: 2px solid #007bff;
			cursor: pointer;
			margin-top: -5px
		}

		#slider::-moz-range-thumb {
			width: 15px;
			height: 15px;
			border-radius: 50%;
			background: #fff;
			border: 2px solid #007bff;
			cursor: pointer
		}

		#plotSection {
			display: flex;
			flex-direction: column;
			align-items: center;
			width: 48%;
			min-width: 300px;
			max-width: 600px
		}

		#chartCanvasContainer {
			width: 100%;
			height: 400px
		}

		#chartCanvasContainer canvas {
			width: 100%;
			height: 100%
		}

		#plotButtons {
			display: flex;
			gap: 10px;
			margin-top: 10px;
			width: 100%
		}

		#calibrationPrompt,
		#exportPrompt,
		#frameRatePrompt {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: #fff;
			border: 2px solid #333;
			padding: 20px;
			border-radius: 8px;
			display: none;
			z-index: 10;
			box-shadow: 0 4px 8px rgba(0, 0, 0, .2);
			width: 300px;
			box-sizing: border-box
		}

		.crosshair {
			position: absolute;
			width: 20px;
			height: 20px;
			pointer-events: none;
			z-index: 3;
			display: none
		}

		.crosshair::before,
		.crosshair::after {
			content: '';
			position: absolute;
			background: red
		}

		.crosshair::before {
			top: 50%;
			left: 0;
			width: 100%;
			height: 1px;
			transform: translateY(-50%)
		}

		.crosshair::after {
			left: 50%;
			top: 0;
			width: 1px;
			height: 100%;
			transform: translateX(-50%)
		}

		footer {
			position: static;
			bottom: 0;
			text-align: center;
			padding: 10px;
			background: #f9f9f900;
			color: #555;
			margin-top: 10px
		}
	</style>
</head>

<body>
	<div id="titleBanner">
		<div class="banner-logo">
			<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer"><img src="/panphy.png" alt="PanPhy logo" /></a>
		</div>
		<h1 class="banner-title">Motion Tracker</h1>
		<div class="banner-placeholder"></div>
	</div>

	<div id="warningBanner"><strong>Note:</strong> Files are opened locally. Nothing is uploaded.</div>

	<div id="topControls">
		<button id="openVideo" class="control-button btn-open" aria-label="Open Video">Open Video</button>
		<button id="playPause" class="control-button btn-play" disabled>Play</button>
		<button id="calibrate" class="control-button btn-calibration" disabled>Calibration</button>
		<button id="setOrigin" class="control-button btn-set-origin" disabled>Set Origin</button>
		<button id="exportData" class="control-button btn-export" disabled>Export .csv</button>
		<button id="clearDataPoints" class="control-button btn-clear-data" disabled>Clear Data</button>
		<button id="clearCalibration" class="control-button btn-clear-calibration" disabled>Clear Calibration</button>
		<button id="clearOrigin" class="control-button btn-clear-origin" disabled>Clear Origin</button>
		<input type="file" id="videoUploadInput" accept="video/*" style="display:none">
	</div>

	<div id="frameRateContainer" style="text-align:center;margin-top:10px;">
		<button id="frameRateButton" class="control-button" style="width:auto;padding:10px 15px;background:#a75908;" title="Click to change the frame rate (typical: 24, 25, 30, 50, 60, 120)" disabled>
			Frame Rate: 30 fps
		</button>
	</div>

	<div id="calibrationPrompt">
		<h2>Calibration</h2>
		<p>Enter the Length and its Unit:</p>
		<form autocomplete="off">
			<input type="number" id="actualLength" placeholder="Actual Length" min="0.0001" step="any" autocomplete="off">
			<input type="text" id="actualUnit" placeholder="Unit (e.g., meters, cm)" autocomplete="off">
			<div style="display:flex;gap:10px;justify-content:center;">
				<button type="button" id="confirmCalibration">Confirm</button>
				<button type="button" id="cancelCalibration">Cancel</button>
			</div>
		</form>
	</div>

	<div id="exportPrompt">
		<h2>Export Data</h2>
		<p>Enter the desired filename for the exported data:</p>
		<form autocomplete="off">
			<input type="text" id="exportFilename" placeholder="Filename" value="motion_tracker_data" autocomplete="off">
			<div style="display:flex;gap:10px;justify-content:center;">
				<button type="button" id="confirmExport">Export</button>
				<button type="button" id="cancelExport">Cancel</button>
			</div>
		</form>
	</div>

	<div id="frameRatePrompt">
		<h2>Set Frame Rate</h2>
		<p>Enter the correct frame rate: <br>(e.g. 24, 30, 60, 240 fps)</p>
		<form autocomplete="off">
			<input type="number" id="userFrameRate" value="30" min="1" step="any" autocomplete="off" />
			<div style="display:flex;gap:10px;justify-content:center;">
				<button type="button" id="confirmFrameRate">Confirm</button>
				<button type="button" id="cancelFrameRate">Cancel</button>
			</div>
		</form>
	</div>

	<div id="message">
		<p>Open a video to start analysis.</p>
	</div>

	<div id="analysisContainer">
		<div id="videoSection">
			<div id="videoWrapper">
				<!-- Keep the real video in DOM for Safari -->
				<video id="hiddenVideo" playsinline webkit-playsinline muted preload="auto" crossorigin="anonymous"></video>
				<canvas id="frameCanvas" style="display:none"></canvas>
				<canvas id="overlayCanvas"></canvas>
				<div class="crosshair" id="crosshair"></div>
			</div>
			<div id="controlsContainer">
				<div id="videoControls">
					<input type="range" id="slider" min="0" max="0" step="0.01" value="0" disabled>
					<span id="timeDisplay">0:00.000</span>
				</div>
			</div>
		</div>
		<div id="plotSection">
			<div id="chartCanvasContainer"><canvas id="positionChart"></canvas></div>
			<div id="plotButtons">
				<button id="plotVx" class="control-button btn-plot-vx" disabled>vₓ vs t</button>
				<button id="plotVy" class="control-button btn-plot-vy" disabled>vᵧ vs t</button>
				<button id="backToPosition" class="control-button btn-backToPosition" disabled>x-t and y-t</button>
			</div>
		</div>
	</div>

	<footer>
		&copy; 2025 <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>

	<script>
		// ===== State =====
		let frameRate = 30;
		const dataPointColors = { x: '#ac57fb', y: '#ff7331', vx: '#2e9cff', vy: '#ff75f9' };
		let frameData = [];
		let isPlaying = false;
		let positionChart;
		let skippingFrame = false;
		let blobUrl = null;

		let calibrationMode = false;
		let calibrationStart = null;
		let calibrationEnd = null;
		let scaleFactor = 1;
		let scaleUnit = "pixels";
		let isDrawingCalibration = false;

		let originMode = false;
		let originSet = false;
		let originPoint = { x: 0, y: 0 };

		const gridSizeDisplay = 40;
		const originDotRadiusDisplay = 5;
		const axisLineWidthDisplay = 2;

		// ===== DOM =====
		const hiddenVideo = document.getElementById('hiddenVideo');
		const openVideoButton = document.getElementById('openVideo');
		const videoUploadInput = document.getElementById('videoUploadInput');
		const playPauseButton = document.getElementById('playPause');
		const calibrateButton = document.getElementById('calibrate');
		const setOriginButton = document.getElementById('setOrigin');
		const exportDataButton = document.getElementById('exportData');
		const clearDataPointsButton = document.getElementById('clearDataPoints');
		const clearCalibrationButton = document.getElementById('clearCalibration');
		const clearOriginButton = document.getElementById('clearOrigin');
		const plotVxButton = document.getElementById('plotVx');
		const plotVyButton = document.getElementById('plotVy');
		const backToPositionButton = document.getElementById('backToPosition');

		const slider = document.getElementById('slider');
		const timeDisplay = document.getElementById('timeDisplay');
		const frameCanvas = document.getElementById('frameCanvas');
		const overlayCanvas = document.getElementById('overlayCanvas');
		const ctx = frameCanvas.getContext('2d');
		const overlayCtx = overlayCanvas.getContext('2d');

		const calibrationPrompt = document.getElementById('calibrationPrompt');
		const actualLengthInput = document.getElementById('actualLength');
		const actualUnitInput = document.getElementById('actualUnit');
		const confirmCalibrationButton = document.getElementById('confirmCalibration');
		const cancelCalibrationButton = document.getElementById('cancelCalibration');

		const exportPrompt = document.getElementById('exportPrompt');
		const exportFilenameInput = document.getElementById('exportFilename');
		const confirmExportButton = document.getElementById('confirmExport');
		const cancelExportButton = document.getElementById('cancelExport');

		const frameRatePrompt = document.getElementById('frameRatePrompt');
		const userFrameRateInput = document.getElementById('userFrameRate');
		const confirmFrameRateButton = document.getElementById('confirmFrameRate');
		const cancelFrameRateButton = document.getElementById('cancelFrameRate');
		const frameRateButton = document.getElementById('frameRateButton');

		function canvasYToCartesianY(y) { return frameCanvas.height - y; }

		function cartesianYToCanvasY(y) { return frameCanvas.height - y; }

		function formatTime(t) { const m = Math.floor(t / 60),
				s = Math.floor(t % 60),
				ms = Math.floor((t - Math.floor(t)) * 1000); return `${m}:${s.toString().padStart(2,"0")}.${ms.toString().padStart(3,"0")}`; }

		// Seekable helpers
		function getSeekableEnd() {
			const s = hiddenVideo.seekable;
			if (s && s.length > 0) return s.end(s.length - 1);
			const d = hiddenVideo.duration;
			if (Number.isFinite(d) && d > 0) return d;
			return 0;
		}

		function updateSliderDomain() {
			const end = getSeekableEnd();
			if (end > 0) {
				const currentMax = parseFloat(slider.max) || 0;
				if (end > currentMax - 1e-3) {
					slider.max = end.toString();
					slider.disabled = false;
				}
			}
		}

		function disableControls(state) {
			playPauseButton.disabled = state;
			calibrateButton.disabled = state;
			setOriginButton.disabled = state;
			plotVxButton.disabled = state;
			plotVyButton.disabled = state;
			backToPositionButton.disabled = state;
			clearDataPointsButton.disabled = state;
			clearCalibrationButton.disabled = state;
			clearOriginButton.disabled = state;
			exportDataButton.disabled = state;
			frameRateButton.disabled = state;
			slider.disabled = state;
		}

		// Init
		document.addEventListener('DOMContentLoaded', () => {
			disableControls(true);
			frameRateButton.textContent = `Frame Rate: ${frameRate} fps`;
			document.getElementById('analysisContainer').style.display = "none";
			document.getElementById('chartCanvasContainer').style.display = "none";
			frameCanvas.style.display = "none";
		});

		// Open video (local only)
		openVideoButton.addEventListener('click', () => videoUploadInput.click());
		videoUploadInput.addEventListener('change', (e) => {
			const file = e.target.files?.[0];
			if (!file) return;

			if (blobUrl) URL.revokeObjectURL(blobUrl);
			blobUrl = URL.createObjectURL(file);
			hiddenVideo.src = blobUrl;
			hiddenVideo.load();

			// allow selecting the same file again
			e.target.value = '';
		});

		// Metadata
		hiddenVideo.addEventListener('loadedmetadata', () => {
			slider.min = "0";
			slider.max = "0";
			slider.step = Math.max(1 / frameRate / 2, 0.001).toString();
			slider.value = "0";
			hiddenVideo.currentTime = 0;
			updateSliderDomain();
		});

		// Keep domain fresh as the browser reveals it
		hiddenVideo.addEventListener('durationchange', updateSliderDomain);
		hiddenVideo.addEventListener('loadeddata', updateSliderDomain);
		hiddenVideo.addEventListener('canplay', updateSliderDomain);
		hiddenVideo.addEventListener('canplaythrough', updateSliderDomain);

		// First frame ready
		hiddenVideo.addEventListener('loadeddata', () => {
			frameCanvas.width = hiddenVideo.videoWidth || 1280;
			frameCanvas.height = hiddenVideo.videoHeight || 720;
			frameCanvas.style.display = "block";
			document.getElementById('analysisContainer').style.display = "flex";
			document.getElementById('chartCanvasContainer').style.display = "flex";
			disableControls(false);
			drawFrame();
			resizeOverlay();
			drawOverlay();
			plotPosition();
			document.getElementById('message').innerHTML =
				"<ul style='text-align:left;padding-left:20px;'>" +
				"<li>Set frame rate if needed. Default is 30 fps.</li>" +
				"<li>Use the slider to scrub. It follows the seekable range.</li>" +
				"<li>Click to record a point. It will advance one frame.</li>" +
				"</ul>";
		}, { once: true });

		// Playback sync
		hiddenVideo.addEventListener('timeupdate', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
			}
		});

		// Redraw on seek completion
		hiddenVideo.addEventListener('seeked', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
			}
		});

		// Scrubbing
		function scrubToSlider() {
			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "Play";
			}
			const end = getSeekableEnd();
			let t = parseFloat(slider.value);
			if (!Number.isFinite(t)) return;
			if (end > 0) t = Math.min(t, end - 0.02);
			if (t < 0) t = 0;
			const EPS = Math.max(1e-3, (1 / frameRate) * 0.15);
			if (Math.abs(hiddenVideo.currentTime - t) < EPS) t += EPS;
			hiddenVideo.currentTime = t;
			timeDisplay.textContent = formatTime(t);
		}
		slider.addEventListener('input', scrubToSlider);
		slider.addEventListener('change', scrubToSlider);

		// Play/Pause
		playPauseButton.addEventListener('click', () => {
			if (isPlaying) { hiddenVideo.pause();
				playPauseButton.textContent = "Play"; } else { hiddenVideo.play().catch(() => {});
				playPauseButton.textContent = "Pause"; }
			isPlaying = !isPlaying;
		});

		// Click to add point and step
		frameCanvas.addEventListener('click', (event) => {
			if (!calibrationMode && !originMode && !skippingFrame) {
				const rect = frameCanvas.getBoundingClientRect();
				const scaleX = frameCanvas.width / rect.width;
				const scaleY = frameCanvas.height / rect.height;
				const canvasX = (event.clientX - rect.left) * scaleX;
				const canvasY = (event.clientY - rect.top) * scaleY;
				const cartesianY = canvasYToCartesianY(canvasY);

				frameData.push({ x: canvasX, y: cartesianY, time: hiddenVideo.currentTime });
				plotPosition();
				skipToNextFrame();
			}
		});

		// Origin selection
		overlayCanvas.addEventListener('click', (event) => {
			if (originMode && !calibrationMode) {
				const rect = overlayCanvas.getBoundingClientRect();
				const scaleX = overlayCanvas.width / rect.width;
				const scaleY = overlayCanvas.height / rect.height;
				const x = (event.clientX - rect.left) * scaleX;
				const y = (event.clientY - rect.top) * scaleY;
				const cartesianY = canvasYToCartesianY(y);
				originPoint = { x, y: cartesianY };
				originSet = true;
				originMode = false;
				frameCanvas.style.cursor = "default";
				document.getElementById('crosshair').style.display = "none";
				overlayCanvas.style.pointerEvents = "none";
				drawOverlay();
				plotPosition();
				document.getElementById('message').innerHTML = "<p>Origin set. Data will now be plotted relative to the chosen origin.</p>";
			}
		});

		// Frame rate dialog
		frameRateButton.addEventListener('click', () => {
			userFrameRateInput.value = frameRate;
			frameRatePrompt.style.display = "block";
		});
		confirmFrameRateButton.addEventListener('click', () => {
			const v = parseFloat(userFrameRateInput.value);
			if (Number.isFinite(v) && v > 0) frameRate = v;
			frameRatePrompt.style.display = "none";
			frameRateButton.textContent = `Frame Rate: ${frameRate} fps`;
			slider.step = Math.max(1 / frameRate / 2, 0.001).toString();
		});
		cancelFrameRateButton.addEventListener('click', () => { frameRatePrompt.style.display = "none"; });

		// Robust frame step for WebM
		function skipToNextFrame() {
			if (!Number.isFinite(frameRate) || frameRate <= 0) return;
			if (skippingFrame) return;
			skippingFrame = true;

			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "Play";
			}

			const dt = 1 / frameRate;
			const EPS = Math.max(1e-3, dt * 0.15);
			const now = hiddenVideo.currentTime;

			const end = getSeekableEnd();
			const maxTarget = Math.max(0, (end || now + dt) - dt - 1e-3);
			let target = Math.min(now + dt + EPS, maxTarget);

			let done = false;
			const finish = () => {
				if (done) return;
				done = true;
				skippingFrame = false;
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
				hiddenVideo.removeEventListener('seeked', onSeeked);
				hiddenVideo.removeEventListener('timeupdate', onTU);
				if (fallbackTimer) clearTimeout(fallbackTimer);
			};

			const onSeeked = () => finish();
			const onTU = () => { if (hiddenVideo.currentTime >= now + dt * 0.5) finish(); };
			const fallbackTimer = setTimeout(finish, 250);

			hiddenVideo.addEventListener('seeked', onSeeked, { once: true });
			hiddenVideo.addEventListener('timeupdate', onTU);
			try { hiddenVideo.currentTime = target; } catch (e) { finish(); }
		}

		// Plotting
		const positionChartCanvas = document.getElementById('positionChart');

		function plotPosition() {
			const xData = frameData.map(p => parseFloat(p.time.toFixed(3)));
			const yDataX = frameData.map(p => parseFloat(((p.x - (originSet ? originPoint.x : 0)) * scaleFactor).toFixed(3)));
			const yDataY = frameData.map(p => parseFloat(((p.y - (originSet ? originPoint.y : 0)) * scaleFactor).toFixed(3)));

			if (!positionChart) {
				positionChart = new Chart(positionChartCanvas.getContext("2d"), {
					type: "scatter",
					data: {
						datasets: [
							{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
							{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
						],
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							x: {
								type: "linear",
								position: "bottom",
								title: { display: true, text: "Time (s)" },
								grid: { color: (c) => c.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)' }
							},
							y: {
								type: "linear",
								position: "left",
								title: { display: true, text: `Position (${scaleUnit})` },
								grid: { color: (c) => c.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)' }
							}
						},
						plugins: { legend: { display: true, position: 'top' } }
					},
				});
			} else {
				positionChart.data.datasets = [
					{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
					{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
				];
				positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				positionChart.update();
			}
		}

		function plotVelocity(axis) {
			const windowSize = 3;
			if (frameData.length < windowSize) { alert(`Insufficient data. At least ${windowSize} points are needed.`); return; }
			const velocityEstimates = [];
			const velocityTimes = [];
			for (let i = 1; i < frameData.length; i++) {
				const dt = frameData[i].time - frameData[i - 1].time;
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const d = axis === 'x' ? (p2.x - p1.x) : (p2.y - p1.y);
				const v = dt > 0 ? (d * scaleFactor) / dt : 0;
				if (dt > 0) { velocityEstimates.push(v);
					velocityTimes.push(frameData[i].time); }
			}
			const smoothed = [];
			const times = [];
			for (let i = 2; i < velocityEstimates.length; i++) {
				const avg = (velocityEstimates[i - 2] + velocityEstimates[i - 1] + velocityEstimates[i]) / 3;
				smoothed.push(parseFloat(avg.toFixed(3)));
				times.push(parseFloat(((velocityTimes[i - 2] + velocityTimes[i]) / 2).toFixed(3)));
			}
			if (!positionChart) return;
			positionChart.data.datasets = [{
				label: axis === "x" ? "x-velocity" : "y-velocity",
				data: times.map((t, i) => ({ x: t, y: smoothed[i] })),
				borderColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				backgroundColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				showLine: false,
				pointRadius: 4
			}];
			positionChart.options.scales.y.title.text = `Velocity (${scaleUnit}/s)`;
			positionChart.update();
		}

		plotVxButton.addEventListener("click", () => plotVelocity("x"));
		plotVyButton.addEventListener("click", () => plotVelocity("y"));
		backToPositionButton.addEventListener("click", plotPosition);

		// Clear / Export
		clearDataPointsButton.addEventListener("click", () => {
			frameData = [];
			if (positionChart) { positionChart.data.datasets.forEach(d => d.data = []);
				positionChart.update(); }
			drawFrame();
			drawOverlay();
			document.getElementById('message').innerHTML = "<p>Data points cleared.</p>";
		});

		clearCalibrationButton.addEventListener("click", () => {
			scaleFactor = 1;
			scaleUnit = "pixels";
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			if (positionChart) { positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				plotPosition(); }
			document.getElementById('message').innerHTML = "<p>Calibration cleared. Positions are now in pixel units.</p>";
		});

		clearOriginButton.addEventListener("click", () => {
			originSet = false;
			originPoint = { x: 0, y: 0 };
			drawOverlay();
			plotPosition();
			document.getElementById('message').innerHTML = "<p>Origin cleared. Default origin is used.</p>";
		});

		exportDataButton.addEventListener("click", () => {
			if (frameData.length === 0) { alert("No data to export."); return; }
			exportFilenameInput.value = "motion_tracker_data";
			exportPrompt.style.display = "block";
		});

		confirmExportButton.addEventListener("click", () => {
			const desired = exportFilenameInput.value.trim();
			if (!desired) { alert("Please enter a valid filename."); return; }
			const sanitized = desired.replace(/[^a-zA-Z0-9-_.]/g, "_");
			const finalName = sanitized.toLowerCase().endsWith(".csv") ? sanitized : sanitized + ".csv";
			exportCSV(finalName);
			exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = `<p>Data exported as ${finalName}.</p>`;
		});
		cancelExportButton.addEventListener("click", () => { exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = "<p>Export cancelled.</p>"; });

		function exportCSV(filename) {
			const velocityData = [];
			for (let i = 1; i < frameData.length; i++) {
				const dt = frameData[i].time - frameData[i - 1].time;
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const dX = p2.x - p1.x,
					dY = p2.y - p1.y;
				const v_x = dt > 0 ? (dX * scaleFactor) / dt : 0;
				const v_y = dt > 0 ? (dY * scaleFactor) / dt : 0;
				velocityData.push({ v_x, v_y });
			}
			let csv = `Time (s),x (${scaleUnit}),y (${scaleUnit}),v_x (${scaleUnit}/s),v_y (${scaleUnit}/s)\n`;
			for (let i = 0; i < frameData.length; i++) {
				const xAdj = (frameData[i].x - (originSet ? originPoint.x : 0)) * scaleFactor;
				const yAdj = (frameData[i].y - (originSet ? originPoint.y : 0)) * scaleFactor;
				const time = frameData[i].time.toFixed(3);
				const x = xAdj.toFixed(3);
				const y = yAdj.toFixed(3);
				const v_x = i > 0 ? velocityData[i - 1].v_x.toFixed(3) : "";
				const v_y = i > 0 ? velocityData[i - 1].v_y.toFixed(3) : "";
				csv += `${time},${x},${y},${v_x},${v_y}\n`;
			}
			const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		// Drawing
		function resizeOverlay() { overlayCanvas.width = frameCanvas.width;
			overlayCanvas.height = frameCanvas.height; }

		function drawFrame() {
			ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
			ctx.drawImage(hiddenVideo, 0, 0, frameCanvas.width, frameCanvas.height);
			frameData.forEach((p) => {
				const x = p.x,
					y = cartesianYToCanvasY(p.y);
				drawDataPoint(x, y);
			});
		}

		function drawDataPoint(x, y) {
			const circleRadius = originDotRadiusDisplay,
				crossSize = 10;
			ctx.fillStyle = 'rgba(255,0,0,.3)';
			ctx.beginPath();
			ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
			ctx.fill();
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(x - crossSize, y);
			ctx.lineTo(x + crossSize, y);
			ctx.moveTo(x, y - crossSize);
			ctx.lineTo(x, y + crossSize);
			ctx.stroke();
		}

		function drawOverlay() {
			resizeOverlay();
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
			overlayCtx.save();
			overlayCtx.shadowColor = "black";
			overlayCtx.shadowBlur = 2;
			overlayCtx.strokeStyle = "white";
			overlayCtx.lineWidth = .5;
			for (let x = 0; x <= overlayCanvas.width; x += gridSizeDisplay) { overlayCtx.beginPath();
				overlayCtx.moveTo(x, 0);
				overlayCtx.lineTo(x, overlayCanvas.height);
				overlayCtx.stroke(); }
			for (let y = 0; y <= overlayCanvas.height; y += gridSizeDisplay) { overlayCtx.beginPath();
				overlayCtx.moveTo(0, y);
				overlayCtx.lineTo(overlayCanvas.width, y);
				overlayCtx.stroke(); }
			overlayCtx.restore();
			const ox = originSet ? originPoint.x : 0;
			const oy = originSet ? originPoint.y : 0;
			const originCanvasX = ox;
			const originCanvasY = cartesianYToCanvasY(oy);
			overlayCtx.save();
			overlayCtx.lineWidth = axisLineWidthDisplay;
			overlayCtx.shadowColor = "black";
			overlayCtx.shadowBlur = 2;
			overlayCtx.strokeStyle = 'white';
			overlayCtx.beginPath();
			overlayCtx.moveTo(0, originCanvasY);
			overlayCtx.lineTo(overlayCanvas.width, originCanvasY);
			overlayCtx.stroke();
			overlayCtx.beginPath();
			overlayCtx.moveTo(originCanvasX, 0);
			overlayCtx.lineTo(originCanvasX, overlayCanvas.height);
			overlayCtx.stroke();
			overlayCtx.restore();
			overlayCtx.fillStyle = "cyan";
			overlayCtx.beginPath();
			overlayCtx.arc(originCanvasX, originCanvasY, originDotRadiusDisplay, 0, 2 * Math.PI);
			overlayCtx.fill();
			if (calibrationStart && calibrationEnd) {
				overlayCtx.save();
				overlayCtx.lineWidth = 2;
				overlayCtx.strokeStyle = "orange";
				overlayCtx.shadowColor = "black";
				overlayCtx.shadowBlur = 2;
				overlayCtx.setLineDash([5, 5]);
				overlayCtx.beginPath();
				overlayCtx.moveTo(calibrationStart.x, calibrationStart.y);
				overlayCtx.lineTo(calibrationEnd.x, calibrationEnd.y);
				overlayCtx.stroke();
				overlayCtx.setLineDash([]);
				overlayCtx.restore();
			}
		}
		window.addEventListener('resize', () => { drawOverlay();
			drawFrame(); });

		// Calibration
		calibrateButton.addEventListener('click', () => {
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "auto";
			calibrationMode = true;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('message').innerHTML = "<p>Drag on the video to draw a line with a known length.</p>";
		});

		function startCalibrationDraw(x, y) { isDrawingCalibration = true;
			calibrationStart = { x, y };
			calibrationEnd = { x, y }; }

		function updateCalibrationDraw(x, y) { if (isDrawingCalibration) { calibrationEnd = { x, y };
				drawOverlay(); } }

		function endCalibrationDraw() {
			if (!isDrawingCalibration) return;
			isDrawingCalibration = false;
			calibrationMode = false;
			overlayCanvas.style.pointerEvents = "none";
			frameCanvas.style.cursor = "default";
			document.getElementById('message').innerHTML = "<p>Calibration line drawn. Enter actual length and unit.</p>";
			calibrationPrompt.style.display = "block";
		}

		overlayCanvas.addEventListener('mousedown', (e) => {
			if (!calibrationMode) return;
			const r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mousemove', (e) => {
			if (!calibrationMode || !isDrawingCalibration) return;
			const r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mouseup', () => { if (calibrationMode) endCalibrationDraw(); });

		overlayCanvas.addEventListener('touchstart', (e) => {
			if (!calibrationMode || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchmove', (e) => {
			if (!calibrationMode || !isDrawingCalibration || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchend', (e) => { if (calibrationMode) { e.preventDefault();
				endCalibrationDraw(); } }, { passive: false });

		confirmCalibrationButton.addEventListener('click', () => {
			const actualLength = parseFloat(actualLengthInput.value);
			const actualUnit = actualUnitInput.value.trim();
			if (!Number.isFinite(actualLength) || actualLength <= 0 || !actualUnit) { alert("Enter a positive length and a unit."); return; }
			const dx = calibrationEnd.x - calibrationStart.x,
				dy = calibrationEnd.y - calibrationStart.y;
			const pxLen = Math.hypot(dx, dy);
			if (pxLen === 0) { alert("Calibration line length cannot be zero."); return; }
			scaleFactor = actualLength / pxLen;
			scaleUnit = actualUnit;
			calibrationPrompt.style.display = "none";
			drawOverlay();
			drawFrame();
			plotPosition();
			document.getElementById('message').innerHTML = `<p>Calibration successful: 1 pixel = ${scaleFactor.toFixed(4)} ${scaleUnit}</p>`;
		});
		cancelCalibrationButton.addEventListener('click', () => {
			calibrationPrompt.style.display = "none";
			calibrationMode = false;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			document.getElementById('message').innerHTML = "<p>Calibration cancelled.</p>";
		});

		// Origin button
		setOriginButton.addEventListener('click', () => {
			calibrationMode = false;
			isDrawingCalibration = false;
			originMode = true;
			overlayCanvas.style.pointerEvents = "auto";
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('crosshair').style.display = "block";
			document.getElementById('message').innerHTML = "<p>Click on the video to set the new origin.</p>";
		});

		// Cleanup blob URL on exit
		window.addEventListener('beforeunload', () => {
			if (blobUrl) URL.revokeObjectURL(blobUrl);
		});
	</script>
</body>

</html>