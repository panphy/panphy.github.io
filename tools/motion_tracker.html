<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Motion Tracker</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		:root {
			--primary: #2563eb;
			/* Modern Blue */
			--primary-hover: #1d4ed8;
			--success: #10b981;
			/* Soft Green */
			--warning: #f59e0b;
			/* Amber */
			--danger: #ef4444;
			/* Red */
			--bg-color: #f3f4f6;
			/* Light Gray */
			--card-bg: #ffffff;
			--text-main: #1f2937;
			--text-muted: #6b7280;
			--border-radius: 8px;
			--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
		}

		body {
			font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
			margin: 0;
			background: var(--bg-color);
			color: var(--text-main);
			line-height: 1.5;
		}

		/* --- Header (Dark Grey) --- */
		#titleBanner {
			background: #1f2937;
			/* Dark Grey */
			color: #ffffff;
			border-bottom: 1px solid #111827;
			padding: 15px 20px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		.banner-title {
			font-size: 1.5rem;
			color: #ffffff;
			margin: 0;
			font-weight: 700;
		}

		.banner-logo img {
			height: 32px;
			width: auto;
		}

		.banner-placeholder {
			width: 50px;
		}

		#warningBanner {
			background: #fffbeb;
			color: #92400e;
			text-align: center;
			padding: 8px;
			font-size: 0.85rem;
			border-bottom: 1px solid #fcd34d;
		}

		/* --- Main Toolbar (File & Data Ops) --- */
		.toolbar {
			display: flex;
			gap: 10px;
			padding: 20px;
			max-width: 1200px;
			margin: 0 auto;
			flex-wrap: wrap;
			justify-content: center;
			align-items: center;
		}

		/* --- Buttons --- */
		button {
			padding: 8px 16px;
			border-radius: var(--border-radius);
			border: 1px solid transparent;
			font-weight: 600;
			cursor: pointer;
			font-size: 0.9rem;
			transition: all 0.2s;
			background: white;
			color: var(--text-main);
			border-color: #d1d5db;
			box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
		}

		button:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			filter: brightness(95%);
		}

		button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			background: #f3f4f6;
			border-color: #e5e7eb;
			color: #9ca3af;
			box-shadow: none;
			transform: none;
		}

		/* Button Variants */
		.btn-primary {
			background: var(--primary);
			color: white;
			border: none;
		}

		.btn-primary:hover:not(:disabled) {
			background: var(--primary-hover);
		}

		.btn-danger {
			color: var(--danger);
			border-color: #fecaca;
			background: #fef2f2;
		}

		.btn-danger:hover:not(:disabled) {
			background: #fee2e2;
		}

		.btn-tool {
			color: var(--primary);
			border-color: #bfdbfe;
			background: #eff6ff;
		}

		.btn-tool:hover:not(:disabled) {
			background: #dbeafe;
		}

		/* --- Plot Buttons (Colorful) --- */
		#backToPosition {
			background-color: #10b981;
			/* Green */
			color: white;
			border: none;
		}

		#backToPosition:hover:not(:disabled) {
			background-color: #059669;
		}

		#plotVx {
			background-color: #3b82f6;
			/* Blue */
			color: white;
			border: none;
		}

		#plotVx:hover:not(:disabled) {
			background-color: #2563eb;
		}

		#plotVy {
			background-color: #d946ef;
			/* Pink/Purple */
			color: white;
			border: none;
		}

		#plotVy:hover:not(:disabled) {
			background-color: #c026d3;
		}


		/* --- Layout Grid --- */
		#analysisContainer {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			max-width: 1200px;
			margin: 0 auto;
			padding: 0 20px 40px 20px;
		}

		/* --- Cards (Video & Plot) --- */
		.card {
			background: var(--card-bg);
			border-radius: var(--border-radius);
			box-shadow: var(--shadow);
			padding: 15px;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		/* --- Video Section --- */
		#videoWrapper {
			position: relative;
			width: 100%;
			background: #000;
			border-radius: 4px;
			overflow: hidden;
			margin-bottom: 15px;
			/* Enforce aspect ratio or limits */
			max-height: 500px;
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 300px;
		}

		video,
		canvas {
			display: block;
			max-width: 100%;
			height: auto;
		}

		#hiddenVideo {
			display: none;
		}

		#frameCanvas {
			display: none;
		}

		#overlayCanvas {
			position: absolute;
			top: 0;
			left: 0;
			background: transparent;
			z-index: 2;
			pointer-events: none;
		}

		.crosshair {
			position: absolute;
			width: 20px;
			height: 20px;
			pointer-events: none;
			z-index: 3;
			display: none;
		}

		.crosshair::before,
		.crosshair::after {
			content: '';
			position: absolute;
			background: red;
		}

		.crosshair::before {
			top: 50%;
			left: 0;
			width: 100%;
			height: 1px;
			transform: translateY(-50%);
		}

		.crosshair::after {
			left: 50%;
			top: 0;
			width: 1px;
			height: 100%;
			transform: translateX(-50%);
		}


		/* Playback Controls (Under Video) */
		.playback-controls {
			display: flex;
			align-items: center;
			gap: 15px;
			width: 100%;
			background: #f9fafb;
			padding: 10px;
			border-radius: var(--border-radius);
			border: 1px solid #e5e7eb;
			box-sizing: border-box;
		}

		#slider {
			flex-grow: 1;
			cursor: pointer;
			appearance: none;
			background: #bfdbfe;
			height: 6px;
			border-radius: 3px;
		}

		#slider::-webkit-slider-thumb {
			appearance: none;
			width: 16px;
			height: 16px;
			background: var(--primary);
			border-radius: 50%;
			cursor: pointer;
		}

		#timeDisplay {
			font-variant-numeric: tabular-nums;
			font-size: 0.9rem;
			color: var(--text-muted);
			width: 80px;
			text-align: right;
		}

		/* --- Chart Section --- */
		#chartCanvasContainer {
			width: 100%;
			height: 400px;
			position: relative;
		}

		.chart-controls {
			display: flex;
			gap: 10px;
			margin-top: 15px;
			width: 100%;
			justify-content: center;
		}

		/* --- Message Box --- */
		#message {
			background: #e0f2fe;
			color: #0369a1;
			padding: 10px 15px;
			border-radius: var(--border-radius);
			margin: 0 auto 20px auto;
			max-width: 1160px;
			text-align: center;
			border: 1px solid #bae6fd;
		}

		/* --- Responsive --- */
		@media (max-width: 900px) {
			#analysisContainer {
				grid-template-columns: 1fr;
			}
		}

		/* --- Dialogs --- */
		#calibrationPrompt,
		#exportPrompt,
		#frameRatePrompt {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: min(92vw, 420px);
			max-width: 92vw;
			box-sizing: border-box;
			z-index: 9999;
			padding: 20px;
			border-radius: 10px;
			border: 1px solid #d1d5db;
			background: #fff;
			box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
			display: none;
		}

		#calibrationPrompt h2,
		#exportPrompt h2,
		#frameRatePrompt h2 {
			margin: 0 0 8px 0;
			font-size: 1.1rem;
			color: var(--text-main);
		}

		#calibrationPrompt p,
		#exportPrompt p,
		#frameRatePrompt p {
			margin: 0 0 15px 0;
			color: var(--text-muted);
		}

		#calibrationPrompt form,
		#exportPrompt form,
		#frameRatePrompt form {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		#calibrationPrompt input[type="number"],
		#calibrationPrompt input[type="text"],
		#exportPrompt input[type="text"],
		#frameRatePrompt input[type="number"] {
			width: 100%;
			min-height: 38px;
			padding: 8px 10px;
			box-sizing: border-box;
			border: 1px solid #d1d5db;
			border-radius: 6px;
			font-size: 0.95rem;
		}

		#calibrationPrompt form>div,
		#exportPrompt form>div,
		#frameRatePrompt form>div {
			display: grid !important;
			grid-template-columns: 1fr 1fr;
			gap: 10px;
		}

		footer {
			color: var(--text-muted);
			font-size: 0.85rem;
			margin-top: 40px;
			padding-bottom: 20px;
			text-align: center;
		}

		body.modal-open {
			overflow: hidden;
		}
	</style>
</head>

<body>
	<div id="titleBanner">
		<div class="banner-logo">
			<a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer"><img src="/panphy.png" alt="PanPhy logo" /></a>
		</div>
		<h1 class="banner-title">Motion Tracker</h1>
		<div class="banner-placeholder"></div>
	</div>

	<div id="warningBanner"><strong>Note:</strong> Files are opened locally. Nothing is uploaded.</div>

	<div class="toolbar">
		<div style="display:flex; gap:10px;">
			<button id="openVideo" class="btn-primary">üìÇ Open Video</button>
			<button id="exportData" disabled>üì• Export CSV</button>
		</div>

		<div style="width:1px; height: 30px; background:#d1d5db; margin:0 10px;"></div>

		<div style="display:flex; gap:10px;">
			<button id="calibrate" class="btn-tool" disabled>üìè Calibrate</button>
			<button id="setOrigin" class="btn-tool" disabled>üéØ Set Origin</button>
		</div>

		<div style="width:1px; height: 30px; background:#d1d5db; margin:0 10px;"></div>

		<div style="display:flex; gap:10px;">
			<button id="clearDataPoints" class="btn-danger" disabled>Clear Data</button>
			<button id="clearCalibration" class="btn-danger" disabled>Clear Calib</button>
			<button id="clearOrigin" class="btn-danger" disabled>Clear Origin</button>
		</div>

		<input type="file" id="videoUploadInput" accept="video/*" style="display:none">
	</div>

	<div id="message">
		<p>Open a video to start analysis.</p>
	</div>

	<div id="analysisContainer">

		<div class="card">
			<div style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
				<h3 style="margin:0; font-size:1.1rem;">Video Source</h3>
				<button id="frameRateButton" style="font-size:0.8rem; padding:4px 8px; background:#e5e7eb; color:#374151; border:1px solid #d1d5db;" disabled>FPS: 30</button>
			</div>

			<div id="videoWrapper">
				<video id="hiddenVideo" playsinline webkit-playsinline muted preload="auto" crossorigin="anonymous"></video>
				<canvas id="frameCanvas" style="display:none"></canvas>
				<canvas id="overlayCanvas"></canvas>
				<div class="crosshair" id="crosshair"></div>
			</div>

			<div class="playback-controls">
				<button id="playPause" class="btn-primary" style="min-width: 80px;" disabled>‚ñ∂ Play</button>
				<input type="range" id="slider" min="0" max="0" step="0.01" value="0" disabled>
				<span id="timeDisplay">0:00.000</span>
			</div>
		</div>

		<div class="card">
			<div style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
				<h3 style="margin:0; font-size:1.1rem;">Data Analysis</h3>
			</div>

			<div id="chartCanvasContainer">
				<canvas id="positionChart"></canvas>
			</div>

			<div class="chart-controls">
				<button id="backToPosition" disabled>Position (x,y)</button>
				<button id="plotVx" disabled>Velocity (v‚Çì)</button>
				<button id="plotVy" disabled>Velocity (v·µß)</button>
			</div>
		</div>
	</div>

	<div id="calibrationPrompt">
		<h2>Calibration</h2>
		<p>Enter the Length and its Unit:</p>
		<form autocomplete="off">
			<input type="number" id="actualLength" placeholder="Actual Length" min="0.0001" step="any" autocomplete="off">
			<input type="text" id="actualUnit" placeholder="Unit (e.g., meters, cm)" autocomplete="off">
			<div>
				<button type="button" id="confirmCalibration" class="btn-primary">Confirm</button>
				<button type="button" id="cancelCalibration">Cancel</button>
			</div>
		</form>
	</div>

	<div id="exportPrompt">
		<h2>Export Data</h2>
		<p>Enter the desired filename for the exported data:</p>
		<form autocomplete="off">
			<input type="text" id="exportFilename" placeholder="Filename" value="motion_tracker_data" autocomplete="off">
			<div>
				<button type="button" id="confirmExport" class="btn-primary">Export</button>
				<button type="button" id="cancelExport">Cancel</button>
			</div>
		</form>
	</div>

	<div id="frameRatePrompt">
		<h2>Set Frame Rate</h2>
		<p>Enter the correct frame rate: <br>(e.g. 24, 30, 60, 120, 240 fps)</p>
		<form autocomplete="off">
			<input type="number" id="userFrameRate" value="30" min="1" step="any" autocomplete="off" />
			<div>
				<button type="button" id="confirmFrameRate" class="btn-primary">Confirm</button>
				<button type="button" id="cancelFrameRate">Cancel</button>
			</div>
		</form>
	</div>

	<footer>
		&copy; 2025 <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>


	<script>
		/* ===== State ===== */
		let frameRate = 30;
		const dataPointColors = { x: '#ac57fb', y: '#ff7331', vx: '#2e9cff', vy: '#ff75f9' };
		let frameData = [];
		let isPlaying = false;
		let positionChart = null;
		let skippingFrame = false;
		let blobUrl = null;
		let currentPlotMode = 'pos'; // Tracks 'pos', 'vx', or 'vy'

		let calibrationMode = false;
		let calibrationStart = null;
		let calibrationEnd = null;
		let scaleFactor = 1;
		let scaleUnit = "pixels";
		let isDrawingCalibration = false;

		let originMode = false;
		let originSet = false;
		let originPoint = { x: 0, y: 0 };

		const baseResolutionWidth = 1280; // Reference width (720p)

		/* ===== DOM ===== */
		const hiddenVideo = document.getElementById('hiddenVideo');
		const openVideoButton = document.getElementById('openVideo');
		const videoUploadInput = document.getElementById('videoUploadInput');
		const playPauseButton = document.getElementById('playPause');
		const calibrateButton = document.getElementById('calibrate');
		const setOriginButton = document.getElementById('setOrigin');
		const exportDataButton = document.getElementById('exportData');
		const clearDataPointsButton = document.getElementById('clearDataPoints');
		const clearCalibrationButton = document.getElementById('clearCalibration');
		const clearOriginButton = document.getElementById('clearOrigin');
		const plotVxButton = document.getElementById('plotVx');
		const plotVyButton = document.getElementById('plotVy');
		const backToPositionButton = document.getElementById('backToPosition');

		const slider = document.getElementById('slider');
		const timeDisplay = document.getElementById('timeDisplay');
		const frameCanvas = document.getElementById('frameCanvas');
		const overlayCanvas = document.getElementById('overlayCanvas');
		const ctx = frameCanvas.getContext('2d');
		const overlayCtx = overlayCanvas.getContext('2d');

		const calibrationPrompt = document.getElementById('calibrationPrompt');
		const actualLengthInput = document.getElementById('actualLength');
		const actualUnitInput = document.getElementById('actualUnit');
		const confirmCalibrationButton = document.getElementById('confirmCalibration');
		const cancelCalibrationButton = document.getElementById('cancelCalibration');

		const exportPrompt = document.getElementById('exportPrompt');
		const exportFilenameInput = document.getElementById('exportFilename');
		const confirmExportButton = document.getElementById('confirmExport');
		const cancelExportButton = document.getElementById('cancelExport');

		const frameRatePrompt = document.getElementById('frameRatePrompt');
		const userFrameRateInput = document.getElementById('userFrameRate');
		const confirmFrameRateButton = document.getElementById('confirmFrameRate');
		const cancelFrameRateButton = document.getElementById('cancelFrameRate');
		const frameRateButton = document.getElementById('frameRateButton');

		function canvasYToCartesianY(y) { return frameCanvas.height - y; }

		function cartesianYToCanvasY(y) { return frameCanvas.height - y; }

		function formatTime(t) {
			const m = Math.floor(t / 60),
				s = Math.floor(t % 60),
				ms = Math.floor((t - Math.floor(t)) * 1000);
			return `${m}:${s.toString().padStart(2, "0")}.${ms.toString().padStart(3, "0")}`;
		}

		// Scale helper
		function getVisualScale() {
			if (!frameCanvas.width) return 1;
			return Math.max(0.5, frameCanvas.width / baseResolutionWidth);
		}

		/* Seekable helpers */
		function getSeekableEnd() {
			const s = hiddenVideo.seekable;
			if (s && s.length > 0) return s.end(s.length - 1);
			const d = hiddenVideo.duration;
			if (Number.isFinite(d) && d > 0) return d;
			return 0;
		}

		function updateSliderDomain() {
			const end = getSeekableEnd();
			if (end > 0) {
				const currentMax = parseFloat(slider.max) || 0;
				if (end > currentMax - 1e-3) {
					slider.max = end.toString();
					slider.disabled = false;
				}
			}
		}

		function disableControls(state) {
			playPauseButton.disabled = state;
			calibrateButton.disabled = state;
			setOriginButton.disabled = state;
			plotVxButton.disabled = state;
			plotVyButton.disabled = state;
			backToPositionButton.disabled = state;
			clearDataPointsButton.disabled = state;
			clearCalibrationButton.disabled = state;
			clearOriginButton.disabled = state;
			exportDataButton.disabled = state;
			frameRateButton.disabled = state;
			slider.disabled = state;
		}

		/* ===== RESET FUNCTION ===== */
		function resetApp() {
			// 1. Clear data
			frameData = [];
			calibrationMode = false;
			originMode = false;
			isDrawingCalibration = false;
			skippingFrame = false;
			isPlaying = false;

			// 2. Reset Calibration/Origin defaults
			scaleFactor = 1;
			scaleUnit = "pixels";
			calibrationStart = null;
			calibrationEnd = null;
			originSet = false;
			originPoint = { x: 0, y: 0 };

			// 3. Reset Chart
			if (positionChart) {
				positionChart.destroy();
				positionChart = null;
			}

			// 4. Clear Canvases
			ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

			// 5. Reset UI elements
			playPauseButton.textContent = "‚ñ∂ Play";
			frameCanvas.style.cursor = "default";
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "none";
			document.getElementById('message').innerHTML = "<p>Opening new video...</p>";

			// 6. Hide any open prompts
			calibrationPrompt.style.display = 'none';
			exportPrompt.style.display = 'none';
			frameRatePrompt.style.display = 'none';

			// 7. Disable controls until loaded
			disableControls(true);
		}

		/* Init */
		document.addEventListener('DOMContentLoaded', () => {
			disableControls(true);
			frameRateButton.textContent = `FPS: ${frameRate}`;
			document.getElementById('analysisContainer').style.display = "none"; // Hide grid until loaded
			frameCanvas.style.display = "none";
		});

		/* Open video */
		openVideoButton.addEventListener('click', () => videoUploadInput.click());

		videoUploadInput.addEventListener('change', (e) => {
			const file = e.target.files?.[0];
			if (!file) return; // User cancelled

			// Perform full reset before loading new file
			if (blobUrl) URL.revokeObjectURL(blobUrl);
			resetApp();

			blobUrl = URL.createObjectURL(file);
			hiddenVideo.src = blobUrl;
			hiddenVideo.load();
			e.target.value = '';
		});

		/* Metadata */
		hiddenVideo.addEventListener('loadedmetadata', () => {
			slider.min = "0";
			slider.max = "0";
			slider.step = Math.max(1 / frameRate / 2, 0.001).toString();
			slider.value = "0";
			hiddenVideo.currentTime = 0;
			updateSliderDomain();
		});
		hiddenVideo.addEventListener('durationchange', updateSliderDomain);
		hiddenVideo.addEventListener('loadeddata', updateSliderDomain);
		hiddenVideo.addEventListener('canplay', updateSliderDomain);
		hiddenVideo.addEventListener('canplaythrough', updateSliderDomain);

		/* First frame ready */
		hiddenVideo.addEventListener('loadeddata', () => {
			frameCanvas.width = hiddenVideo.videoWidth || 1280;
			frameCanvas.height = hiddenVideo.videoHeight || 720;
			frameCanvas.style.display = "block";
			document.getElementById('analysisContainer').style.display = "grid"; // Show grid
			disableControls(false);
			drawFrame();
			resizeOverlay();
			drawOverlay();
			plotPosition();

			if (frameData.length === 0) {
				document.getElementById('message').innerHTML =
					"<ul style='text-align:left;padding-left:20px; margin:0;'>" +
					"<li>Set frame rate if needed. Default is 30 fps.</li>" +
					"<li>Click the video to record a data point.</li>" +
					"</ul>";
			}
		});

		/* Playback sync */
		hiddenVideo.addEventListener('timeupdate', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
			}
		});
		hiddenVideo.addEventListener('seeked', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
			}
		});
		// Reset play button if video ends naturally
		hiddenVideo.addEventListener('ended', () => {
			isPlaying = false;
			playPauseButton.textContent = "‚ñ∂ Play";
		});

		/* Scrubbing */
		function scrubToSlider() {
			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "‚ñ∂ Play";
			}
			const end = getSeekableEnd();
			let t = parseFloat(slider.value);
			if (!Number.isFinite(t)) return;
			if (end > 0) t = Math.min(t, end - 0.02);
			if (t < 0) t = 0;
			const EPS = Math.max(1e-3, (1 / frameRate) * 0.15);
			if (Math.abs(hiddenVideo.currentTime - t) < EPS) t += EPS;
			hiddenVideo.currentTime = t;
			timeDisplay.textContent = formatTime(t);
		}
		slider.addEventListener('input', scrubToSlider);
		slider.addEventListener('change', scrubToSlider);

		/* Play/Pause */
		playPauseButton.addEventListener('click', () => {
			if (isPlaying) {
				hiddenVideo.pause();
				playPauseButton.textContent = "‚ñ∂ Play";
			} else {
				hiddenVideo.play().catch(() => {});
				playPauseButton.textContent = "‚è∏ Pause";
			}
			isPlaying = !isPlaying;
		});

		/* Click to add point and step */
		frameCanvas.addEventListener('click', (event) => {
			if (!calibrationMode && !originMode && !skippingFrame) {
				const rect = frameCanvas.getBoundingClientRect();
				const scaleX = frameCanvas.width / rect.width;
				const scaleY = frameCanvas.height / rect.height;
				const canvasX = (event.clientX - rect.left) * scaleX;
				const canvasY = (event.clientY - rect.top) * scaleY;
				const cartesianY = canvasYToCartesianY(canvasY);

				frameData.push({ x: canvasX, y: cartesianY, time: hiddenVideo.currentTime });

				// Update the specific plot user is viewing
				if (currentPlotMode === 'vx') {
					plotVelocity('x');
				} else if (currentPlotMode === 'vy') {
					plotVelocity('y');
				} else {
					plotPosition();
				}

				stepOneFrame();
			}
		});

		/* Origin selection on overlay */
		overlayCanvas.addEventListener('click', (event) => {
			if (originMode && !calibrationMode) {
				const rect = overlayCanvas.getBoundingClientRect();
				const scaleX = overlayCanvas.width / rect.width;
				const scaleY = overlayCanvas.height / rect.height;
				const x = (event.clientX - rect.left) * scaleX;
				const y = (event.clientY - rect.top) * scaleY;
				const cartesianY = canvasYToCartesianY(y);
				originPoint = { x, y: cartesianY };
				originSet = true;
				originMode = false;
				frameCanvas.style.cursor = "default";
				document.getElementById('crosshair').style.display = "none";
				overlayCanvas.style.pointerEvents = "none";
				drawOverlay();
				plotPosition(); // Resets to position view on new origin
				document.getElementById('message').innerHTML = "<p>Origin set. Data will now be plotted relative to the chosen origin.</p>";
			}
		});

		/* Frame rate dialog */
		frameRateButton.addEventListener('click', () => {
			userFrameRateInput.value = frameRate;
			frameRatePrompt.style.display = "block";
		});
		confirmFrameRateButton.addEventListener('click', () => {
			const v = parseFloat(userFrameRateInput.value);
			if (Number.isFinite(v) && v > 0) frameRate = v;
			frameRatePrompt.style.display = "none";
			frameRateButton.textContent = `FPS: ${frameRate}`;
			slider.step = Math.max(1 / frameRate / 2, 0.001).toString();
		});
		cancelFrameRateButton.addEventListener('click', () => { frameRatePrompt.style.display = "none"; });

		/* ===== Robust frame stepping ===== */
		function stepOneFrame() {
			if (skippingFrame) return;
			skippingFrame = true;

			// Always pause first
			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "‚ñ∂ Play";
			}

			const finish = () => {
				skippingFrame = false;
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				timeDisplay.textContent = formatTime(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
			};

			// Time-based seek for deterministic 1-frame stepping
			const dt = 1 / frameRate;
			const target = Math.min(hiddenVideo.currentTime + dt, hiddenVideo.duration);

			let finished = false;
			const clean = () => {
				if (finished) return;
				finished = true;
				hiddenVideo.removeEventListener('seeked', onSeeked);
				clearTimeout(fallbackTimer);
				finish();
			};
			const onSeeked = () => clean();

			const fallbackTimer = setTimeout(clean, 500);
			hiddenVideo.addEventListener('seeked', onSeeked, { once: true });

			try {
				hiddenVideo.currentTime = target + 0.00001;
			} catch {
				clean();
			}
		}

		/* ===== Plotting ===== */
		const positionChartCanvas = document.getElementById('positionChart');

		function plotPosition() {
			currentPlotMode = 'pos';
			const xData = frameData.map(p => parseFloat(p.time.toFixed(3)));
			const yDataX = frameData.map(p => parseFloat(((p.x - (originSet ? originPoint.x : 0)) * scaleFactor).toFixed(3)));
			const yDataY = frameData.map(p => parseFloat(((p.y - (originSet ? originPoint.y : 0)) * scaleFactor).toFixed(3)));

			if (!positionChart) {
				positionChart = new Chart(positionChartCanvas.getContext("2d"), {
					type: "scatter",
					data: {
						datasets: [
							{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
							{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
						]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							x: {
								type: "linear",
								position: "bottom",
								title: { display: true, text: "Time (s)" },
								grid: { color: (c) => c.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)' }
							},
							y: {
								type: "linear",
								position: "left",
								beginAtZero: true,
								title: { display: true, text: `Position (${scaleUnit})` },
								grid: { color: (c) => c.tick.value === 0 ? 'rgba(0,0,0,1)' : 'rgba(200,200,200,0.7)' }
							}
						},
						plugins: { legend: { display: true, position: 'top' } }
					},
				});
			} else {
				positionChart.data.datasets = [
					{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
					{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
				];
				positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				positionChart.update();
			}
		}

		function plotVelocity(axis) {
			currentPlotMode = axis === 'x' ? 'vx' : 'vy';
			const windowSize = 3;
			if (frameData.length <= windowSize) {
				if (frameData.length > 1) {
					alert(`Insufficient data. At least ${windowSize + 1} points are needed for smoothed velocity.`);
				}
				return;
			}

			const velocityEstimates = [];
			const velocityTimes = [];
			for (let i = 1; i < frameData.length; i++) {
				const dt = frameData[i].time - frameData[i - 1].time;
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const d = axis === 'x' ? (p2.x - p1.x) : (p2.y - p1.y);
				const v = dt > 0 ? (d * scaleFactor) / dt : 0;
				if (dt > 0) {
					velocityEstimates.push(v);
					velocityTimes.push((frameData[i].time + frameData[i - 1].time) / 2);
				}
			}

			const smoothed = [];
			const times = [];
			for (let i = 2; i < velocityEstimates.length; i++) {
				const avg = (velocityEstimates[i - 2] + velocityEstimates[i - 1] + velocityEstimates[i]) / 3;
				smoothed.push(parseFloat(avg.toFixed(3)));
				const avgTime = (velocityTimes[i - 2] + velocityTimes[i]) / 2;
				times.push(parseFloat(avgTime.toFixed(3)));
			}

			if (!positionChart) return;
			positionChart.data.datasets = [{
				label: axis === "x" ? "x-velocity" : "y-velocity",
				data: times.map((t, i) => ({ x: t, y: smoothed[i] })),
				borderColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				backgroundColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				showLine: false,
				pointRadius: 4
			}];
			positionChart.options.scales.y.title.text = `Velocity (${scaleUnit}/s)`;
			positionChart.update();
		}

		plotVxButton.addEventListener("click", () => plotVelocity("x"));
		plotVyButton.addEventListener("click", () => plotVelocity("y"));
		backToPositionButton.addEventListener("click", plotPosition);

		/* Clear / Export */
		clearDataPointsButton.addEventListener("click", () => {
			frameData = [];
			if (positionChart) {
				positionChart.data.datasets.forEach(d => d.data = []);
				positionChart.update();
			}
			drawFrame();
			drawOverlay();
			document.getElementById('message').innerHTML = "<p>Data points cleared.</p>";
		});
		clearCalibrationButton.addEventListener("click", () => {
			scaleFactor = 1;
			scaleUnit = "pixels";
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			if (positionChart) {
				positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				plotPosition();
			}
			document.getElementById('message').innerHTML = "<p>Calibration cleared. Positions are now in pixel units.</p>";
		});
		clearOriginButton.addEventListener("click", () => {
			originSet = false;
			originPoint = { x: 0, y: 0 };
			drawOverlay();
			plotPosition();
			document.getElementById('message').innerHTML = "<p>Origin cleared. Default origin is used.</p>";
		});
		exportDataButton.addEventListener("click", () => {
			if (frameData.length === 0) { alert("No data to export."); return; }
			exportFilenameInput.value = "motion_tracker_data";
			exportPrompt.style.display = "block";
		});
		confirmExportButton.addEventListener("click", () => {
			const desired = exportFilenameInput.value.trim();
			if (!desired) { alert("Please enter a valid filename."); return; }
			const sanitized = desired.replace(/[^a-zA-Z0-9-_.]/g, "_");
			const finalName = sanitized.toLowerCase().endsWith(".csv") ? sanitized : sanitized + ".csv";
			exportCSV(finalName);
			exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = `<p>Data exported as ${finalName}.</p>`;
		});
		cancelExportButton.addEventListener("click", () => {
			exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = "<p>Export cancelled.</p>";
		});

		function exportCSV(filename) {
			const velocityData = [];
			for (let i = 1; i < frameData.length; i++) {
				const dt = frameData[i].time - frameData[i - 1].time;
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const dX = p2.x - p1.x,
					dY = p2.y - p1.y;
				const v_x = dt > 0 ? (dX * scaleFactor) / dt : 0;
				const v_y = dt > 0 ? (dY * scaleFactor) / dt : 0;
				velocityData.push({ v_x, v_y });
			}
			let csv = `Time (s),x (${scaleUnit}),y (${scaleUnit}),v_x (${scaleUnit}/s),v_y (${scaleUnit}/s)\n`;
			for (let i = 0; i < frameData.length; i++) {
				const xAdj = (frameData[i].x - (originSet ? originPoint.x : 0)) * scaleFactor;
				const yAdj = (frameData[i].y - (originSet ? originPoint.y : 0)) * scaleFactor;
				const time = frameData[i].time.toFixed(3);
				const x = xAdj.toFixed(3);
				const y = yAdj.toFixed(3);
				const v_x = i > 0 ? velocityData[i - 1].v_x.toFixed(3) : "";
				const v_y = i > 0 ? velocityData[i - 1].v_y.toFixed(3) : "";
				csv += `${time},${x},${y},${v_x},${v_y}\n`;
			}
			const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		/* Drawing */
		function resizeOverlay() {
			overlayCanvas.width = frameCanvas.width;
			overlayCanvas.height = frameCanvas.height;
		}

		function drawFrame() {
			ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
			ctx.drawImage(hiddenVideo, 0, 0, frameCanvas.width, frameCanvas.height);

			// Scale data points based on resolution
			const s = getVisualScale();
			frameData.forEach((p) => {
				const x = p.x,
					y = cartesianYToCanvasY(p.y);
				drawDataPoint(x, y, s);
			});
		}

		function drawDataPoint(x, y, s = 1) {
			const circleRadius = 5 * s;
			const crossSize = 10 * s;
			const lineWidth = Math.max(1, 2 * s);

			ctx.fillStyle = 'rgba(255,0,0,.3)';
			ctx.beginPath();
			ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
			ctx.fill();

			ctx.strokeStyle = 'red';
			ctx.lineWidth = lineWidth;
			ctx.beginPath();
			ctx.moveTo(x - crossSize, y);
			ctx.lineTo(x + crossSize, y);
			ctx.moveTo(x, y - crossSize);
			ctx.lineTo(x, y + crossSize);
			ctx.stroke();
		}

		function drawOverlay() {
			resizeOverlay();
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

			// Dynamic scaling factors
			const s = getVisualScale();
			const gridSize = 40 * s;
			const gridLineWidth = Math.max(0.5, 1 * s);
			const axisWidth = 2 * s;
			const originRadius = 6 * s;

			overlayCtx.save();
			overlayCtx.shadowColor = "black";
			overlayCtx.shadowBlur = 2;
			overlayCtx.strokeStyle = "white";
			overlayCtx.lineWidth = gridLineWidth;

			for (let x = 0; x <= overlayCanvas.width; x += gridSize) {
				overlayCtx.beginPath();
				overlayCtx.moveTo(x, 0);
				overlayCtx.lineTo(x, overlayCanvas.height);
				overlayCtx.stroke();
			}
			for (let y = 0; y <= overlayCanvas.height; y += gridSize) {
				overlayCtx.beginPath();
				overlayCtx.moveTo(0, y);
				overlayCtx.lineTo(overlayCanvas.width, y);
				overlayCtx.stroke();
			}
			overlayCtx.restore();

			const ox = originSet ? originPoint.x : 0;
			const oy = originSet ? originPoint.y : 0;
			const originCanvasX = ox;
			const originCanvasY = cartesianYToCanvasY(oy);

			overlayCtx.save();
			overlayCtx.lineWidth = axisWidth;
			overlayCtx.shadowColor = "black";
			overlayCtx.shadowBlur = 2;
			overlayCtx.strokeStyle = 'white';
			overlayCtx.beginPath();
			overlayCtx.moveTo(0, originCanvasY);
			overlayCtx.lineTo(overlayCanvas.width, originCanvasY);
			overlayCtx.stroke();
			overlayCtx.beginPath();
			overlayCtx.moveTo(originCanvasX, 0);
			overlayCtx.lineTo(originCanvasX, overlayCanvas.height);
			overlayCtx.stroke();
			overlayCtx.restore();

			overlayCtx.fillStyle = "cyan";
			overlayCtx.beginPath();
			overlayCtx.arc(originCanvasX, originCanvasY, originRadius, 0, 2 * Math.PI);
			overlayCtx.fill();

			if (calibrationStart && calibrationEnd) {
				overlayCtx.save();
				overlayCtx.lineWidth = 2 * s;
				overlayCtx.strokeStyle = "orange";
				overlayCtx.shadowColor = "black";
				overlayCtx.shadowBlur = 2;
				overlayCtx.setLineDash([5 * s, 5 * s]);
				overlayCtx.beginPath();
				overlayCtx.moveTo(calibrationStart.x, calibrationStart.y);
				overlayCtx.lineTo(calibrationEnd.x, calibrationEnd.y);
				overlayCtx.stroke();
				overlayCtx.setLineDash([]);
				overlayCtx.restore();
			}
		}
		window.addEventListener('resize', () => {
			drawOverlay();
			drawFrame();
		});

		/* Calibration */
		calibrateButton.addEventListener('click', () => {
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "auto";
			calibrationMode = true;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('message').innerHTML = "<p>Drag on the video to draw a line with a known length.</p>";
		});

		function startCalibrationDraw(x, y) {
			isDrawingCalibration = true;
			calibrationStart = { x, y };
			calibrationEnd = { x, y };
		}

		function updateCalibrationDraw(x, y) {
			if (isDrawingCalibration) {
				calibrationEnd = { x, y };
				drawOverlay();
			}
		}

		function endCalibrationDraw() {
			if (!isDrawingCalibration) return;
			isDrawingCalibration = false;
			calibrationMode = false;
			overlayCanvas.style.pointerEvents = "none";
			frameCanvas.style.cursor = "default";
			document.getElementById('message').innerHTML = "<p>Calibration line drawn. Enter actual length and unit.</p>";
			calibrationPrompt.style.display = "block";
		}
		overlayCanvas.addEventListener('mousedown', (e) => {
			if (!calibrationMode) return;
			const r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mousemove', (e) => {
			if (!calibrationMode || !isDrawingCalibration) return;
			const r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mouseup', () => { if (calibrationMode) endCalibrationDraw(); });
		overlayCanvas.addEventListener('touchstart', (e) => {
			if (!calibrationMode || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchmove', (e) => {
			if (!calibrationMode || !isDrawingCalibration || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchend', (e) => {
			if (calibrationMode) {
				e.preventDefault();
				endCalibrationDraw();
			}
		}, { passive: false });
		confirmCalibrationButton.addEventListener('click', () => {
			const actualLength = parseFloat(actualLengthInput.value);
			const actualUnit = actualUnitInput.value.trim();
			if (!Number.isFinite(actualLength) || actualLength <= 0 || !actualUnit) { alert("Enter a positive length and a unit."); return; }
			const dx = calibrationEnd.x - calibrationStart.x,
				dy = calibrationEnd.y - calibrationStart.y;
			const pxLen = Math.hypot(dx, dy);
			if (pxLen === 0) { alert("Calibration line length cannot be zero."); return; }
			scaleFactor = actualLength / pxLen;
			scaleUnit = actualUnit;
			calibrationPrompt.style.display = "none";
			drawOverlay();
			drawFrame();
			plotPosition();
			document.getElementById('message').innerHTML = `<p>Calibration successful: 1 pixel = ${scaleFactor.toFixed(4)} ${scaleUnit}</p>`;
		});
		cancelCalibrationButton.addEventListener('click', () => {
			calibrationPrompt.style.display = "none";
			calibrationMode = false;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			document.getElementById('message').innerHTML = "<p>Calibration cancelled.</p>";
		});

		/* Origin button */
		setOriginButton.addEventListener('click', () => {
			calibrationMode = false;
			isDrawingCalibration = false;
			originMode = true;
			overlayCanvas.style.pointerEvents = "auto";
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('crosshair').style.display = "block";
			document.getElementById('message').innerHTML = "<p>Click on the video to set the new origin.</p>";
		});

		/* Cleanup */
		window.addEventListener('beforeunload', () => { if (blobUrl) URL.revokeObjectURL(blobUrl); });
	</script>
</body>

</html>