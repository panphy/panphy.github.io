<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Motion Tracker</title>
	<link rel="icon" type="image/png" href="/favicon.png">
	<script>
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('/sw.js')
					.catch((err) => console.log('Service Worker registration failed', err));
			});
		}
	</script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Poppins:wght@600;700;800&display=swap');

		:root {
			--font-sans: 'Inter', sans-serif;
			--font-display: 'Poppins', 'Inter', sans-serif;
			--font-mono: 'JetBrains Mono', monospace;

			--bg-color: #f8f9fa;
			--bg-pattern: #e9ecef;
			--text-main: #2d3436;
			--text-muted: #636e72;

			--brand-primary: #6c5ce7;
			--brand-secondary: #a29bfe;
			--brand-accent: #00cec9;

			--surface: #ffffff;
			--surface-muted: #f4f6f8;
			--surface-strong: #1f2937;
			--border-color: rgba(45, 52, 54, 0.12);
			--shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
			--border-radius: 12px;

			--primary: #6c5ce7;
			--primary-hover: #5a4fd6;
			--danger: #ff7675;
			--warning: #fdcb6e;
			--success: #2ecc71;

			--nav-bg: rgba(255, 255, 255, 0.85);
			--nav-border: rgba(255, 255, 255, 0.5);

			--chart-grid: rgba(45, 52, 54, 0.18);
			--chart-axis: rgba(45, 52, 54, 0.9);
			--chart-text: rgba(45, 52, 54, 0.95);
			--overlay-axis: rgba(255, 255, 255, 0.9);
			--overlay-shadow: rgba(0, 0, 0, 0.35);
		}

		[data-theme="dark"] {
			--bg-color: #0f1014;
			--bg-pattern: #181a20;
			--text-main: #dfe6e9;
			--text-muted: #b2bec3;

			--brand-primary: #a29bfe;
			--brand-secondary: #6c5ce7;
			--brand-accent: #81ecec;

			--surface: #1e2129;
			--surface-muted: #171a21;
			--surface-strong: #111318;
			--border-color: rgba(255, 255, 255, 0.08);
			--shadow: 0 18px 40px rgba(0, 0, 0, 0.4);

			--primary: #6c5ce7;
			--primary-hover: #7f74f1;
			--danger: #ff6b6b;
			--warning: #f9ca24;
			--success: #55efc4;

			--nav-bg: rgba(22, 24, 29, 0.85);
			--nav-border: rgba(255, 255, 255, 0.08);

			--chart-grid: rgba(255, 255, 255, 0.16);
			--chart-axis: rgba(223, 230, 233, 0.92);
			--chart-text: rgba(223, 230, 233, 0.95);
			--overlay-axis: rgba(255, 255, 255, 0.75);
			--overlay-shadow: rgba(0, 0, 0, 0.7);
		}

		* {
			box-sizing: border-box;
			transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
		}

		body {
			font-family: var(--font-sans);
			margin: 0;
			background-color: var(--bg-color);
			background-image: radial-gradient(var(--bg-pattern) 1px, transparent 1px);
			background-size: 30px 30px;
			color: var(--text-main);
			line-height: 1.6;
		}

		/* --- Header --- */
		header.banner {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 16px;
			padding: 8px 20px;
			margin: 16px auto 0;
			width: min(1100px, calc(100% - 40px));
			background: var(--nav-bg);
			border: 1px solid var(--nav-border);
			border-radius: 20px;
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
		}

		a {
			color: var(--brand-primary);
			text-decoration: none;
		}

		a:hover {
			color: var(--brand-secondary);
			text-decoration: underline;
		}

		a:visited {
			color: var(--brand-primary);
		}

		.banner-logo {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.banner-logo img {
			height: 36px;
			width: auto;
			filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
		}

		.banner-title {
			font-family: var(--font-display);
			font-size: 1.6rem;
			font-weight: 800;
			text-align: center;
			flex: 1;
			letter-spacing: -0.5px;
			color: var(--brand-primary);
		}

		.banner-title.gradient-text {
			background: linear-gradient(135deg, var(--brand-primary), var(--brand-accent));
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
		}

		.banner-actions {
			display: flex;
			align-items: center;
			gap: 12px;
		}

		.theme-toggle button {
			background: transparent;
			border: none;
			cursor: pointer;
			font-size: 1.2rem;
			padding: 0.5rem;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			color: var(--text-main);
		}

		.theme-toggle button:hover {
			background-color: rgba(128, 128, 128, 0.2);
			transform: rotate(15deg);
		}

		.toolbar-divider {
			width: 1px;
			height: 30px;
			background: var(--border-color);
			margin: 0 8px;
		}

		.frame-rate-button {
			font-size: 0.8rem;
			padding: 4px 8px;
			background: var(--surface-muted);
			color: var(--text-main);
			border: 1px solid var(--border-color);
		}

		/* --- Main Toolbar (File & Data Ops) --- */
		.toolbar {
			display: flex;
			gap: 8px;
			padding: 16px;
			max-width: 1200px;
			margin: 0 auto;
			flex-wrap: wrap;
			justify-content: center;
			align-items: center;
			background: transparent;
			border-radius: var(--border-radius);
			box-shadow: none;
			border: 1px solid transparent;
			margin-top: 24px;
		}

		/* --- Buttons --- */
		button {
			padding: 8px 16px;
			border-radius: var(--border-radius);
			border: 1px solid transparent;
			font-weight: 600;
			cursor: pointer;
			font-size: 0.9rem;
			transition: all 0.2s;
			background: var(--surface);
			color: var(--text-main);
			border-color: var(--border-color);
			box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
		}

		button:hover:not(:disabled) {
			transform: translateY(-1px);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			filter: brightness(95%);
		}

		button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			background: var(--surface-muted);
			border-color: var(--border-color);
			color: var(--text-muted);
			box-shadow: none;
			transform: none;
		}

		/* Button Variants */
		.btn-primary {
			background: var(--primary);
			color: white;
			border: none;
		}

		.btn-primary:hover:not(:disabled) {
			background: var(--primary-hover);
		}

		.btn-danger {
			color: var(--danger);
			border-color: rgba(255, 107, 107, 0.3);
			background: rgba(255, 107, 107, 0.12);
		}

		.btn-danger:hover:not(:disabled) {
			background: rgba(255, 107, 107, 0.2);
		}

		.btn-tool {
			color: var(--brand-primary);
			border-color: rgba(108, 92, 231, 0.3);
			background: rgba(108, 92, 231, 0.12);
		}

		.btn-tool:hover:not(:disabled) {
			background: rgba(108, 92, 231, 0.2);
		}

		/* --- Plot Buttons (Colorful) --- */
		#backToPosition {
			background-color: var(--success);
			/* Green */
			color: white;
			border: none;
		}

		#backToPosition:hover:not(:disabled) {
			filter: brightness(0.95);
		}

		#plotVx {
			background-color: #2e9cff;
			/* Light blue to match v_x data points */
			color: white;
			border: none;
		}

		#plotVx:hover:not(:disabled) {
			filter: brightness(0.95);
		}

		#plotVy {
			background-color: #d946ef;
			/* Pink/Purple */
			color: white;
			border: none;
		}

		#plotVy:hover:not(:disabled) {
			filter: brightness(0.95);
		}

		/* Dark theme overrides for plot buttons - use darker colors for better contrast */
		[data-theme="dark"] #backToPosition {
			background-color: #00b894;
		}

		[data-theme="dark"] #plotVx {
			background-color: #2e9cff;
		}

		[data-theme="dark"] #plotVy {
			background-color: #be2edd;
		}

		/* Hide Crosses Toggle Button */
		.hide-crosses-toggle {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 4px;
			padding: 6px 10px;
			min-width: 72px;
			font-size: 0.85rem;
			background: var(--surface-muted);
			color: var(--text-muted);
			border: 1px solid var(--border-color);
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s;
			opacity: 0.8;
		}

		.hide-crosses-toggle:hover:not(:disabled) {
			opacity: 1;
			background: var(--surface);
			color: var(--text-main);
		}

		.hide-crosses-toggle.crosses-hidden {
			color: var(--warning);
			border-color: rgba(253, 203, 110, 0.4);
			background: rgba(253, 203, 110, 0.1);
		}

		.hide-crosses-toggle .toggle-text {
			font-size: 0.8rem;
		}

		.hide-crosses-toggle .toggle-cross {
			color: #ff4444;
			font-weight: 700;
			font-size: 1rem;
			line-height: 1;
		}

		/* --- Layout Grid --- */
		#analysisContainer {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			max-width: 1200px;
			margin: 0 auto;
			padding: 0 20px 40px 20px;
		}

		/* --- Cards (Video & Plot) --- */
		.card {
			background: var(--surface);
			border-radius: var(--border-radius);
			box-shadow: var(--shadow);
			padding: 15px;
			display: flex;
			flex-direction: column;
			align-items: center;
			border: 1px solid var(--border-color);
		}

		/* --- Video Section --- */
		#videoWrapper {
			position: relative;
			width: 100%;
			background: #000;
			border-radius: 4px;
			overflow: hidden;
			margin-bottom: 15px;
			/* Enforce aspect ratio or limits */
			max-height: 500px;
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 300px;
		}

		video,
		canvas {
			display: block;
			max-width: 100%;
			height: auto;
		}

		#hiddenVideo {
			display: none;
		}

		#frameCanvas {
			display: none;
		}

		#overlayCanvas {
			position: absolute;
			top: 0;
			left: 0;
			background: transparent;
			z-index: 2;
			pointer-events: auto;
			touch-action: none;
		}

		.crosshair {
			position: absolute;
			width: 20px;
			height: 20px;
			pointer-events: none;
			z-index: 3;
			display: none;
		}

		.crosshair::before,
		.crosshair::after {
			content: '';
			position: absolute;
			background: red;
		}

		.crosshair::before {
			top: 50%;
			left: 0;
			width: 100%;
			height: 1px;
			transform: translateY(-50%);
		}

		.crosshair::after {
			left: 50%;
			top: 0;
			width: 1px;
			height: 100%;
			transform: translateX(-50%);
		}


		/* Playback Controls (Under Video) */
		.playback-controls {
			display: flex;
			align-items: center;
			gap: 15px;
			width: 100%;
			background: transparent;
			padding: 10px;
			border-radius: var(--border-radius);
			border: 1px solid transparent;
			box-sizing: border-box;
		}

		#playPause {
			min-width: 96px;
			text-align: center;
		}

		#slider {
			flex-grow: 1;
			cursor: pointer;
			-webkit-appearance: none;
			appearance: none;
			background: transparent;
			height: 22px;
		}

		#slider::-webkit-slider-runnable-track {
			width: 100%;
			height: 6px;
			background: rgba(108, 92, 231, 0.3);
			border-radius: 3px;
			cursor: pointer;
		}

		#slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 22px;
			height: 22px;
			background: var(--brand-primary);
			border-radius: 50%;
			cursor: pointer;
			margin-top: -8px;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
		}

		#slider::-moz-range-track {
			width: 100%;
			height: 6px;
			background: rgba(108, 92, 231, 0.3);
			border-radius: 3px;
			cursor: pointer;
		}

		#slider::-moz-range-thumb {
			width: 22px;
			height: 22px;
			background: var(--brand-primary);
			border-radius: 50%;
			cursor: pointer;
			border: none;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
		}

		#timeDisplay {
			font-variant-numeric: tabular-nums;
			font-size: 0.9rem;
			color: var(--text-muted);
			width: 80px;
			text-align: right;
		}

		/* --- Chart Section --- */
		#chartCanvasContainer {
			width: 100%;
			height: 400px;
			position: relative;
			background: var(--surface);
			border-radius: var(--border-radius);
			border: 1px solid var(--border-color);
			padding: 10px;
		}

		.chart-controls {
			display: flex;
			gap: 10px;
			margin-top: 15px;
			width: 100%;
			justify-content: center;
		}

		.chart-controls button {
			min-height: 38px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
		}

		.btn-export {
			background: linear-gradient(135deg, var(--brand-accent), var(--brand-primary));
			color: #ffffff;
			border: none;
			box-shadow: 0 6px 14px rgba(0, 206, 201, 0.2);
		}

		.btn-export:hover:not(:disabled) {
			filter: brightness(0.95);
		}

		[data-theme="dark"] .btn-export {
			color: #000000;
			box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
		}

		/* --- Message Box --- */
		#message {
			background: rgba(0, 206, 201, 0.12);
			color: var(--text-main);
			padding: 10px 15px;
			border-radius: var(--border-radius);
			margin: 24px auto;
			max-width: 1160px;
			text-align: center;
			border: 1px solid rgba(0, 206, 201, 0.3);
		}

		/* --- Responsive --- */
		@media (max-width: 900px) {
			#analysisContainer {
				grid-template-columns: 1fr;
			}
		}

		/* --- Dialogs --- */
		#calibrationPrompt,
		#exportPrompt,
		#frameRatePrompt {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: min(92vw, 560px);
			max-width: 92vw;
			box-sizing: border-box;
			z-index: 9999;
			padding: 24px;
			border-radius: 10px;
			border: 1px solid var(--border-color);
			background: var(--surface);
			box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
			display: none;
		}

		#calibrationPrompt h2,
		#exportPrompt h2,
		#frameRatePrompt h2 {
			margin: 0 0 8px 0;
			font-size: 1.1rem;
			color: var(--text-main);
		}

		#calibrationPrompt p,
		#exportPrompt p,
		#frameRatePrompt p {
			margin: 0 0 15px 0;
			color: var(--text-muted);
		}

		#calibrationPrompt form,
		#exportPrompt form,
		#frameRatePrompt form {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.dialog-actions {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 10px;
		}

		.frame-rate-field {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}

		.frame-rate-field label {
			font-size: 0.9rem;
			font-weight: 600;
			color: var(--text-main);
		}

		.frame-rate-hint {
			font-size: 0.82rem;
			color: var(--text-muted);
			margin: 0;
		}

		#calibrationPrompt input[type="number"],
		#calibrationPrompt input[type="text"],
		#exportPrompt input[type="text"],
		#frameRatePrompt input[type="number"] {
			width: 100%;
			min-height: 38px;
			padding: 8px 10px;
			box-sizing: border-box;
			border: 1px solid var(--border-color);
			border-radius: 6px;
			font-size: 0.95rem;
			background: var(--surface-muted);
			color: var(--text-main);
		}

		footer {
			color: var(--text-muted);
			font-size: 0.85rem;
			margin-top: 40px;
			padding-bottom: 20px;
			text-align: center;
		}

		body.modal-open {
			overflow: hidden;
		}

		@media (pointer: coarse) {
			button,
			input,
			select,
			.control-button,
			.primary-button,
			.secondary-button {
				min-height: 44px;
				touch-action: manipulation;
			}

			#slider {
				height: 44px;
				touch-action: manipulation;
			}

			#slider::-webkit-slider-runnable-track {
				height: 6px;
			}

			#slider::-webkit-slider-thumb {
				width: 28px;
				height: 28px;
				margin-top: -11px;
			}

			#slider::-moz-range-track {
				height: 6px;
			}

			#slider::-moz-range-thumb {
				width: 28px;
				height: 28px;
			}
		}
	</style>
</head>

<body>
	<header class="banner">
		<div class="banner-logo">
			<a href="https://panphy.github.io/">
				<img src="/panphy.png" alt="PanPhy logo">
			</a>
		</div>
		<div class="banner-title">Motion Tracker</div>
		<div class="banner-actions">
			<div class="theme-toggle">
				<button id="theme-button" aria-label="Toggle Light/Dark Theme" title="Toggle between light and dark themes">‚òÄÔ∏è</button>
			</div>
		</div>
	</header>

	<div class="toolbar">
		<div style="display:flex; gap:10px;">
			<button id="openVideo" class="btn-primary">üìÇ Import Video</button>
		</div>

		<div class="toolbar-divider"></div>

		<div style="display:flex; gap:10px;">
			<button id="calibrate" class="btn-tool" disabled>üìè Calibrate</button>
			<button id="setOrigin" class="btn-tool" disabled>üéØ Set Origin</button>
		</div>

		<div class="toolbar-divider"></div>

		<div style="display:flex; gap:10px;">
			<button id="clearDataPoints" class="btn-danger" disabled>Clear Data</button>
			<button id="clearCalibration" class="btn-danger" disabled>Clear Calib</button>
			<button id="clearOrigin" class="btn-danger" disabled>Clear Origin</button>
		</div>

		<input type="file" id="videoUploadInput" accept="video/*" style="display:none">
	</div>

	<div id="message">
		<p>Import a video to start analysis.</p>
	</div>

	<div id="analysisContainer">

		<div class="card">
			<div
				style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
				<h3 style="margin:0; font-size:1.1rem;">Video Source</h3>
				<button id="frameRateButton" class="frame-rate-button" disabled>FPS: 30</button>
			</div>

			<div id="videoWrapper">
				<video id="hiddenVideo" playsinline webkit-playsinline muted preload="auto"
					crossorigin="anonymous"></video>
				<canvas id="frameCanvas" style="display:none"></canvas>
				<canvas id="overlayCanvas"></canvas>
				<div class="crosshair" id="crosshair"></div>
			</div>

			<div class="playback-controls">
				<button id="playPause" class="btn-primary" disabled>‚ñ∂ Play</button>
				<input type="range" id="slider" min="0" max="0" step="0.01" value="0" disabled>
				<span id="timeDisplay">0:00.000</span>
				<button id="hideCrossesToggle" class="hide-crosses-toggle" disabled title="Toggle crosses visibility (H)">
					<span class="toggle-text">Hide</span>
					<span class="toggle-cross">+</span>
				</button>
			</div>
		</div>

		<div class="card">
			<div
				style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
				<h3 style="margin:0; font-size:1.1rem;">Data Analysis</h3>
			</div>

			<div id="chartCanvasContainer">
				<canvas id="positionChart"></canvas>
			</div>

			<div class="chart-controls">
				<button id="backToPosition" disabled>Position (x,y)</button>
				<button id="plotVx" disabled>Velocity (v‚Çì)</button>
				<button id="plotVy" disabled>Velocity (v·µß)</button>
				<button id="exportData" class="btn-export" disabled>Export Data</button>
			</div>
		</div>
	</div>

	<div id="calibrationPrompt">
		<h2>Calibration</h2>
		<p>Enter the Length and its Unit:</p>
		<form autocomplete="off">
			<input type="number" id="actualLength" placeholder="Actual Length" min="0.0001" step="any"
				autocomplete="off">
			<input type="text" id="actualUnit" placeholder="Unit (e.g., meters, cm)" autocomplete="off">
			<div class="dialog-actions">
				<button type="button" id="confirmCalibration" class="btn-primary">Confirm</button>
				<button type="button" id="cancelCalibration">Cancel</button>
			</div>
		</form>
	</div>

	<div id="exportPrompt">
		<h2>Export Data</h2>
		<p>Enter the desired filename for the exported data:</p>
		<form autocomplete="off">
			<input type="text" id="exportFilename" placeholder="Filename" value="motion_tracker_data"
				autocomplete="off">
			<div class="dialog-actions">
				<button type="button" id="confirmExport" class="btn-primary">Export</button>
				<button type="button" id="cancelExport">Cancel</button>
			</div>
		</form>
	</div>

	<div id="frameRatePrompt">
		<h2>Frame Rate Settings</h2>
		<form autocomplete="off">
			<div class="frame-rate-field" id="detectedFpsSection">
				<label>Detected FPS</label>
				<div id="detectedFpsDisplay" style="padding: 8px 10px; background: var(--surface-muted); border-radius: 6px; font-weight: 600; color: var(--brand-primary);">
					Detecting...
				</div>
				<p class="frame-rate-hint">Auto-detected from video. Used for frame stepping and time calculation.</p>
			</div>
			<div class="frame-rate-field" style="margin-top: 16px;">
				<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
					<input type="checkbox" id="specialRecordingMode" style="width: 18px; height: 18px; cursor: pointer;" />
					<span>Special recording (slow-motion / time-lapse)</span>
				</label>
				<p class="frame-rate-hint">Enable if video was recorded at a different rate than playback (e.g., 240fps slow-mo played at 30fps).</p>
			</div>
			<div class="frame-rate-field" id="captureRateSection" style="display: none; margin-top: 12px;">
				<label for="userCaptureFrameRate">Original capture FPS</label>
				<input type="number" id="userCaptureFrameRate" value="240" min="1" step="any" autocomplete="off"
					placeholder="e.g. 240 for slow motion" />
				<p class="frame-rate-hint">The actual recording speed for accurate physics calculations.</p>
			</div>
			<div class="dialog-actions" style="margin-top: 16px;">
				<button type="button" id="confirmFrameRate" class="btn-primary">Confirm</button>
				<button type="button" id="cancelFrameRate">Cancel</button>
			</div>
		</form>
	</div>

	<footer>
		&copy; <a href="https://panphy.github.io/" target="_blank" rel="noopener noreferrer">PanPhy Labs</a> |
		<a href="https://buymeacoffee.com/panphy" target="_blank" rel="noopener noreferrer">Support My Projects</a>
	</footer>


	<script>
		/* ===== State ===== */
		let playbackFrameRate = 30;
		let captureFrameRate = 30;
		let detectedFps = null;  // Auto-detected FPS from video
		let isSpecialRecording = false;  // Whether user has slow-mo/time-lapse video
		let fpsDetectionPending = false;  // Whether FPS detection is in progress
		const dataPointColors = { x: '#ac57fb', y: '#ff7331', vx: '#2e9cff', vy: '#ff75f9' };
		let frameData = [];
		let isPlaying = false;
		let positionChart = null;
		let skippingFrame = false;
		let blobUrl = null;
		let currentPlotMode = 'pos'; // Tracks 'pos', 'vx', or 'vy'
		let crossesVisible = true; // Toggle for hiding crosses on video

		let calibrationMode = false;
		let calibrationStart = null;
		let calibrationEnd = null;
		let scaleFactor = 1;
		let scaleUnit = "pixels";
		let isDrawingCalibration = false;

		let originMode = false;
		let originSet = false;
		let originPoint = { x: 0, y: 0 };

		const baseResolutionWidth = 1280; // Reference width (720p)

		/* ===== Theme ===== */
		const themeButton = document.getElementById('theme-button');
		const DARK_THEME_KEY = "panphy-dark";
		const LIGHT_THEME_KEY = "panphy-light";

		const currentTheme = localStorage.getItem(DARK_THEME_KEY) ?
			"dark" :
			localStorage.getItem(LIGHT_THEME_KEY) ?
				"light" :
				"light";

		document.documentElement.setAttribute('data-theme', currentTheme);
		updateButtonEmoji(currentTheme);

		function updateButtonEmoji(theme) {
			if (!themeButton) return;
			themeButton.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
		}

		function getCssVar(name) {
			return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
		}

		function getChartTheme() {
			return {
				gridColor: getCssVar('--chart-grid'),
				axisColor: getCssVar('--chart-axis'),
				textColor: getCssVar('--chart-text')
			};
		}

		function applyThemeToChart() {
			if (!positionChart) return;
			const theme = getChartTheme();
			positionChart.options.scales.x.grid.color = (c) => c.tick.value === 0 ? theme.axisColor : theme.gridColor;
			positionChart.options.scales.y.grid.color = (c) => c.tick.value === 0 ? theme.axisColor : theme.gridColor;
			positionChart.options.scales.x.ticks.color = theme.textColor;
			positionChart.options.scales.y.ticks.color = theme.textColor;
			positionChart.options.scales.x.title.color = theme.textColor;
			positionChart.options.scales.y.title.color = theme.textColor;
			positionChart.options.plugins.legend.labels.color = theme.textColor;
			positionChart.update();
		}

		if (themeButton) {
			themeButton.addEventListener('click', function () {
				let theme = document.documentElement.getAttribute('data-theme');
				if (theme === 'light') {
					document.documentElement.setAttribute('data-theme', 'dark');
					localStorage.setItem(DARK_THEME_KEY, 'true');
					localStorage.removeItem(LIGHT_THEME_KEY);
					updateButtonEmoji('dark');
				} else {
					document.documentElement.setAttribute('data-theme', 'light');
					localStorage.setItem(LIGHT_THEME_KEY, 'true');
					localStorage.removeItem(DARK_THEME_KEY);
					updateButtonEmoji('light');
				}
				applyThemeToChart();
				drawOverlay();
			});
		}

		/* ===== DOM ===== */
		const hiddenVideo = document.getElementById('hiddenVideo');
		const openVideoButton = document.getElementById('openVideo');
		const videoUploadInput = document.getElementById('videoUploadInput');
		const playPauseButton = document.getElementById('playPause');
		const calibrateButton = document.getElementById('calibrate');
		const setOriginButton = document.getElementById('setOrigin');
		const exportDataButton = document.getElementById('exportData');
		const clearDataPointsButton = document.getElementById('clearDataPoints');
		const clearCalibrationButton = document.getElementById('clearCalibration');
		const clearOriginButton = document.getElementById('clearOrigin');
		const plotVxButton = document.getElementById('plotVx');
		const plotVyButton = document.getElementById('plotVy');
		const backToPositionButton = document.getElementById('backToPosition');
		const hideCrossesToggle = document.getElementById('hideCrossesToggle');

		const slider = document.getElementById('slider');
		const timeDisplay = document.getElementById('timeDisplay');
		const frameCanvas = document.getElementById('frameCanvas');
		const overlayCanvas = document.getElementById('overlayCanvas');
		const ctx = frameCanvas.getContext('2d');
		const overlayCtx = overlayCanvas.getContext('2d');

		const calibrationPrompt = document.getElementById('calibrationPrompt');
		const actualLengthInput = document.getElementById('actualLength');
		const actualUnitInput = document.getElementById('actualUnit');
		const confirmCalibrationButton = document.getElementById('confirmCalibration');
		const cancelCalibrationButton = document.getElementById('cancelCalibration');

		const exportPrompt = document.getElementById('exportPrompt');
		const exportFilenameInput = document.getElementById('exportFilename');
		const confirmExportButton = document.getElementById('confirmExport');
		const cancelExportButton = document.getElementById('cancelExport');

		const frameRatePrompt = document.getElementById('frameRatePrompt');
		const userCaptureFrameRateInput = document.getElementById('userCaptureFrameRate');
		const confirmFrameRateButton = document.getElementById('confirmFrameRate');
		const cancelFrameRateButton = document.getElementById('cancelFrameRate');
		const frameRateButton = document.getElementById('frameRateButton');
		const specialRecordingCheckbox = document.getElementById('specialRecordingMode');
		const captureRateSection = document.getElementById('captureRateSection');
		const detectedFpsDisplay = document.getElementById('detectedFpsDisplay');

		function canvasYToCartesianY(y) { return frameCanvas.height - y; }

		function cartesianYToCanvasY(y) { return frameCanvas.height - y; }

		function formatTime(t) {
			const m = Math.floor(t / 60),
				s = Math.floor(t % 60),
				ms = Math.floor((t - Math.floor(t)) * 1000);
			return `${m}:${s.toString().padStart(2, "0")}.${ms.toString().padStart(3, "0")}`;
		}

		function getAnalysisTime(playbackTime) {
			if (!Number.isFinite(playbackTime)) return 0;
			const frameIndex = Math.round(playbackTime * playbackFrameRate);
			return frameIndex / captureFrameRate;
		}

		function updateTimeDisplay(playbackTime) {
			timeDisplay.textContent = formatTime(getAnalysisTime(playbackTime));
		}

		// Scale helper
		function getVisualScale() {
			if (!frameCanvas.width) return 1;
			return Math.max(0.5, frameCanvas.width / baseResolutionWidth);
		}

		/* Seekable helpers */
		function getSeekableEnd() {
			const s = hiddenVideo.seekable;
			if (s && s.length > 0) return s.end(s.length - 1);
			const d = hiddenVideo.duration;
			if (Number.isFinite(d) && d > 0) return d;
			return 0;
		}

		/* ===== Auto FPS Detection ===== */
		function detectFrameRate() {
			if (typeof hiddenVideo.requestVideoFrameCallback !== 'function') {
				// Browser doesn't support requestVideoFrameCallback, use fallback
				console.log('requestVideoFrameCallback not supported, using fallback FPS');
				applyDetectedFps(30);
				return;
			}

			fpsDetectionPending = true;
			detectedFpsDisplay.textContent = 'Detecting...';
			frameRateButton.textContent = 'FPS: ...';

			const frameTimes = [];
			const maxSamples = 10;
			let lastMediaTime = null;
			let callbackId = null;
			let timeoutId = null;

			const cleanup = () => {
				fpsDetectionPending = false;
				if (callbackId !== null && typeof hiddenVideo.cancelVideoFrameCallback === 'function') {
					hiddenVideo.cancelVideoFrameCallback(callbackId);
				}
				if (timeoutId !== null) {
					clearTimeout(timeoutId);
				}
			};

			const calculateFps = () => {
				cleanup();

				if (frameTimes.length < 2) {
					// Not enough samples, use fallback
					console.log('Not enough frame samples, using fallback FPS');
					applyDetectedFps(30);
					return;
				}

				// Calculate average frame duration
				const durations = [];
				for (let i = 1; i < frameTimes.length; i++) {
					const dt = frameTimes[i] - frameTimes[i - 1];
					if (dt > 0 && dt < 1) {  // Filter out invalid durations
						durations.push(dt);
					}
				}

				if (durations.length === 0) {
					console.log('No valid frame durations, using fallback FPS');
					applyDetectedFps(30);
					return;
				}

				const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
				const fps = 1 / avgDuration;

				// Round to common frame rates for cleaner display
				const commonRates = [15, 24, 25, 29.97, 30, 48, 50, 59.94, 60, 120, 240];
				let roundedFps = fps;
				for (const rate of commonRates) {
					if (Math.abs(fps - rate) < 1) {
						roundedFps = rate;
						break;
					}
				}

				console.log(`Detected FPS: ${fps.toFixed(2)}, rounded to: ${roundedFps}`);
				applyDetectedFps(roundedFps);
			};

			const onFrame = (now, metadata) => {
				if (!fpsDetectionPending) return;

				const mediaTime = metadata.mediaTime;

				if (lastMediaTime !== null && mediaTime > lastMediaTime) {
					frameTimes.push(mediaTime);
				}
				lastMediaTime = mediaTime;

				if (frameTimes.length >= maxSamples) {
					calculateFps();
					return;
				}

				// Request next frame
				callbackId = hiddenVideo.requestVideoFrameCallback(onFrame);
			};

			// Start detection by playing briefly
			const wasPlaying = isPlaying;
			const startTime = hiddenVideo.currentTime;

			// Set timeout for detection (max 2 seconds)
			timeoutId = setTimeout(() => {
				hiddenVideo.pause();
				hiddenVideo.currentTime = startTime;
				calculateFps();
			}, 2000);

			// Start capturing frames
			callbackId = hiddenVideo.requestVideoFrameCallback(onFrame);

			// Play video to get frames
			hiddenVideo.play().then(() => {
				// Wait for enough samples, then stop
				setTimeout(() => {
					if (fpsDetectionPending && frameTimes.length >= 3) {
						hiddenVideo.pause();
						hiddenVideo.currentTime = startTime;
						calculateFps();
					}
				}, 500);
			}).catch(() => {
				// Autoplay blocked, use fallback
				cleanup();
				console.log('Autoplay blocked, using fallback FPS');
				applyDetectedFps(30);
			});
		}

		function applyDetectedFps(fps) {
			detectedFps = fps;
			playbackFrameRate = fps;

			// If not in special recording mode, capture rate = playback rate
			if (!isSpecialRecording) {
				captureFrameRate = fps;
			}

			// Update UI
			detectedFpsDisplay.textContent = `${fps} fps`;
			updateFpsButtonText();

			// Update slider step size
			slider.step = Math.max(1 / playbackFrameRate / 2, 0.001).toString();

			// Reset video to frame 0 and ensure it's paused for manual playback
			hiddenVideo.pause();
			isPlaying = false;
			playPauseButton.textContent = "‚ñ∂ Play";
			hiddenVideo.currentTime = 0;
			slider.value = "0";
			updateTimeDisplay(0);

			// Redraw frame after seeking completes
			const redrawOnSeek = () => {
				drawFrame();
				drawOverlay();
			};
			hiddenVideo.addEventListener('seeked', redrawOnSeek, { once: true });
		}

		function updateFpsButtonText() {
			if (isSpecialRecording) {
				frameRateButton.textContent = `FPS: ${playbackFrameRate}/${captureFrameRate}`;
			} else {
				frameRateButton.textContent = `FPS: ${playbackFrameRate}`;
			}
		}

		function updateSliderDomain() {
			const end = getSeekableEnd();
			if (end > 0) {
				const currentMax = parseFloat(slider.max) || 0;
				if (end > currentMax - 1e-3) {
					slider.max = end.toString();
					slider.disabled = false;
				}
			}
		}

		function disableControls(state) {
			playPauseButton.disabled = state;
			calibrateButton.disabled = state;
			setOriginButton.disabled = state;
			plotVxButton.disabled = state;
			plotVyButton.disabled = state;
			backToPositionButton.disabled = state;
			clearDataPointsButton.disabled = state;
			clearCalibrationButton.disabled = state;
			clearOriginButton.disabled = state;
			exportDataButton.disabled = state;
			frameRateButton.disabled = state;
			slider.disabled = state;
			hideCrossesToggle.disabled = state;
		}

		/* ===== RESET FUNCTION ===== */
		function resetApp() {
			// 1. Clear data
			frameData = [];
			calibrationMode = false;
			originMode = false;
			isDrawingCalibration = false;
			skippingFrame = false;
			isPlaying = false;
			crossesVisible = true;

			// 2. Reset FPS detection state
			detectedFps = null;
			isSpecialRecording = false;
			fpsDetectionPending = false;
			playbackFrameRate = 30;
			captureFrameRate = 30;

			// 3. Reset Calibration/Origin defaults
			scaleFactor = 1;
			scaleUnit = "pixels";
			calibrationStart = null;
			calibrationEnd = null;
			originSet = false;
			originPoint = { x: 0, y: 0 };

			// 4. Reset Chart
			if (positionChart) {
				positionChart.destroy();
				positionChart = null;
			}

			// 5. Clear Canvases
			ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

			// 6. Reset UI elements
			playPauseButton.textContent = "‚ñ∂ Play";
			frameCanvas.style.cursor = "default";
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "none";
			document.getElementById('message').innerHTML = "<p>Opening new video...</p>";
			hideCrossesToggle.classList.remove('crosses-hidden');
			hideCrossesToggle.querySelector('.toggle-text').textContent = 'Hide';
			specialRecordingCheckbox.checked = false;
			captureRateSection.style.display = 'none';
			detectedFpsDisplay.textContent = 'Detecting...';
			frameRateButton.textContent = 'FPS: 30';

			// 7. Hide any open prompts
			calibrationPrompt.style.display = 'none';
			exportPrompt.style.display = 'none';
			frameRatePrompt.style.display = 'none';

			// 8. Disable controls until loaded
			disableControls(true);
		}

		/* Init */
		document.addEventListener('DOMContentLoaded', () => {
			disableControls(true);
			updateFpsButtonText();
			document.getElementById('analysisContainer').style.display = "none"; // Hide grid until loaded
			frameCanvas.style.display = "none";

			// Toggle capture rate section visibility based on checkbox
			specialRecordingCheckbox.addEventListener('change', () => {
				captureRateSection.style.display = specialRecordingCheckbox.checked ? 'block' : 'none';
			});
		});

		/* Import video */
		openVideoButton.addEventListener('click', () => videoUploadInput.click());

		videoUploadInput.addEventListener('change', (e) => {
			const file = e.target.files?.[0];
			if (!file) return; // User cancelled

			// Perform full reset before loading new file
			if (blobUrl) URL.revokeObjectURL(blobUrl);
			resetApp();

			blobUrl = URL.createObjectURL(file);
			hiddenVideo.src = blobUrl;
			hiddenVideo.load();
			e.target.value = '';
		});

		/* Metadata */
		hiddenVideo.addEventListener('loadedmetadata', () => {
			slider.min = "0";
			slider.max = "0";
			slider.step = Math.max(1 / playbackFrameRate / 2, 0.001).toString();
			slider.value = "0";
			hiddenVideo.currentTime = 0;
			updateSliderDomain();
		});
		hiddenVideo.addEventListener('durationchange', updateSliderDomain);
		hiddenVideo.addEventListener('loadeddata', updateSliderDomain);
		hiddenVideo.addEventListener('canplay', updateSliderDomain);
		hiddenVideo.addEventListener('canplaythrough', updateSliderDomain);

		/* First frame ready */
		hiddenVideo.addEventListener('loadeddata', () => {
			frameCanvas.width = hiddenVideo.videoWidth || 1280;
			frameCanvas.height = hiddenVideo.videoHeight || 720;
			frameCanvas.style.display = "block";
			document.getElementById('analysisContainer').style.display = "grid"; // Show grid
			disableControls(false);
			drawFrame();
			resizeOverlay();
			drawOverlay();
			plotPosition();

			// Trigger automatic FPS detection
			detectFrameRate();

			if (frameData.length === 0) {
				document.getElementById('message').innerHTML =
					"<ul style='text-align:left;padding-left:20px; margin:0;'>" +
					"<li>Frame rate auto-detected. Click FPS button for special recordings (slow-mo/time-lapse).</li>" +
					"<li>Click the video to record a data point.</li>" +
					"</ul>";
			}
		});

		/* Playback sync */
		hiddenVideo.addEventListener('timeupdate', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				updateTimeDisplay(hiddenVideo.currentTime);
				drawFrame();
			}
		});
		hiddenVideo.addEventListener('seeked', () => {
			if (!skippingFrame) {
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				updateTimeDisplay(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
			}
		});
		// Reset play button if video ends naturally
		hiddenVideo.addEventListener('ended', () => {
			isPlaying = false;
			playPauseButton.textContent = "‚ñ∂ Play";
		});

		/* Scrubbing */
		function scrubToSlider() {
			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "‚ñ∂ Play";
			}
			const end = getSeekableEnd();
			let t = parseFloat(slider.value);
			if (!Number.isFinite(t)) return;
			if (end > 0) t = Math.min(t, end - 0.02);
			if (t < 0) t = 0;
			const EPS = Math.max(1e-3, (1 / playbackFrameRate) * 0.15);
			if (Math.abs(hiddenVideo.currentTime - t) < EPS) t += EPS;
			hiddenVideo.currentTime = t;
			updateTimeDisplay(t);
		}
		slider.addEventListener('input', scrubToSlider);
		slider.addEventListener('change', scrubToSlider);

		/* Play/Pause */
		playPauseButton.addEventListener('click', async () => {
			if (isPlaying) {
				hiddenVideo.pause();
				playPauseButton.textContent = "‚ñ∂ Play";
			} else {
				try {
					await hiddenVideo.play();
					isPlaying = true;
					playPauseButton.textContent = "‚è∏ Pause";
				} catch {
					isPlaying = false;
					playPauseButton.textContent = "‚ñ∂ Play";
				}
				return;
			}
			isPlaying = false;
		});

		/* Click to add point and step */
		frameCanvas.addEventListener('click', (event) => {
			if (!calibrationMode && !originMode && !skippingFrame) {
				const rect = frameCanvas.getBoundingClientRect();
				const scaleX = frameCanvas.width / rect.width;
				const scaleY = frameCanvas.height / rect.height;
				const canvasX = (event.clientX - rect.left) * scaleX;
				const canvasY = (event.clientY - rect.top) * scaleY;
				const cartesianY = canvasYToCartesianY(canvasY);

				// Store playbackTime so analysis time can be recalculated if FPS changes
				frameData.push({ x: canvasX, y: cartesianY, playbackTime: hiddenVideo.currentTime });

				// Update the specific plot user is viewing
				if (currentPlotMode === 'vx') {
					plotVelocity('x');
				} else if (currentPlotMode === 'vy') {
					plotVelocity('y');
				} else {
					plotPosition();
				}

				stepOneFrame();
			}
		});

		function finalizeOriginSelection(canvasX, canvasY) {
			const cartesianY = canvasYToCartesianY(canvasY);
			originPoint = { x: canvasX, y: cartesianY };
			originSet = true;
			originMode = false;
			frameCanvas.style.cursor = "default";
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "none";
			drawOverlay();
			plotPosition(); // Resets to position view on new origin
			document.getElementById('message').innerHTML = "<p>Origin set. Data will now be plotted relative to the chosen origin.</p>";
		}

		/* Origin selection on overlay */
		overlayCanvas.addEventListener('click', (event) => {
			if (originMode && !calibrationMode) {
				const rect = overlayCanvas.getBoundingClientRect();
				const scaleX = overlayCanvas.width / rect.width;
				const scaleY = overlayCanvas.height / rect.height;
				finalizeOriginSelection(
					(event.clientX - rect.left) * scaleX,
					(event.clientY - rect.top) * scaleY
				);
			}
		});
		overlayCanvas.addEventListener('touchstart', (event) => {
			if (!originMode || calibrationMode || event.touches.length !== 1) return;
			event.preventDefault();
			const touch = event.touches[0];
			const rect = overlayCanvas.getBoundingClientRect();
			const scaleX = overlayCanvas.width / rect.width;
			const scaleY = overlayCanvas.height / rect.height;
			finalizeOriginSelection(
				(touch.clientX - rect.left) * scaleX,
				(touch.clientY - rect.top) * scaleY
			);
		}, { passive: false });
		overlayCanvas.addEventListener('touchend', (event) => {
			if (originMode && !calibrationMode) {
				event.preventDefault();
			}
		}, { passive: false });

		/* Frame rate dialog */
		frameRateButton.addEventListener('click', () => {
			// Set up dialog state
			specialRecordingCheckbox.checked = isSpecialRecording;
			captureRateSection.style.display = isSpecialRecording ? 'block' : 'none';
			userCaptureFrameRateInput.value = isSpecialRecording ? captureFrameRate : 240;
			detectedFpsDisplay.textContent = detectedFps ? `${detectedFps} fps` : 'Not detected';
			frameRatePrompt.style.display = "block";
		});
		confirmFrameRateButton.addEventListener('click', () => {
			isSpecialRecording = specialRecordingCheckbox.checked;

			if (isSpecialRecording) {
				const captureValue = parseFloat(userCaptureFrameRateInput.value);
				if (Number.isFinite(captureValue) && captureValue > 0) {
					captureFrameRate = captureValue;
				}
			} else {
				// Normal mode: capture rate = playback rate
				captureFrameRate = playbackFrameRate;
			}

			frameRatePrompt.style.display = "none";
			updateFpsButtonText();
			slider.step = Math.max(1 / playbackFrameRate / 2, 0.001).toString();
			updateTimeDisplay(hiddenVideo.currentTime);

			// Re-plot if we have data (times are recalculated automatically from playbackTime)
			if (frameData.length > 0) {
				if (currentPlotMode === 'vx') {
					plotVelocity('x');
				} else if (currentPlotMode === 'vy') {
					plotVelocity('y');
				} else {
					plotPosition();
				}
			}

			document.getElementById('message').innerHTML = isSpecialRecording
				? `<p>Special recording mode enabled. Analysis time = frame √ó (1/${captureFrameRate}s)</p>`
				: `<p>Standard recording mode. Analysis time = frame √ó (1/${playbackFrameRate}s)</p>`;
		});
		cancelFrameRateButton.addEventListener('click', () => { frameRatePrompt.style.display = "none"; });

		/* ===== Robust frame stepping ===== */
		function stepOneFrame() {
			if (skippingFrame) return;
			skippingFrame = true;

			// Always pause first
			if (isPlaying) {
				hiddenVideo.pause();
				isPlaying = false;
				playPauseButton.textContent = "‚ñ∂ Play";
			}

			const finish = () => {
				skippingFrame = false;
				updateSliderDomain();
				slider.value = hiddenVideo.currentTime.toString();
				updateTimeDisplay(hiddenVideo.currentTime);
				drawFrame();
				drawOverlay();
			};

			let finished = false;
			let frameCallbackId = null;
			const clean = () => {
				if (finished) return;
				finished = true;
				hiddenVideo.removeEventListener('seeked', onSeeked);
				if (frameCallbackId !== null && typeof hiddenVideo.cancelVideoFrameCallback === "function") {
					hiddenVideo.cancelVideoFrameCallback(frameCallbackId);
				}
				clearTimeout(fallbackTimer);
				finish();
			};
			const onSeeked = () => clean();

			// Time-based seek for deterministic 1-frame stepping
			const dt = 1 / playbackFrameRate;
			const end = getSeekableEnd();
			const candidate = hiddenVideo.currentTime + dt;
			let target = candidate;
			if (end > 0) {
				target = Math.min(candidate, end);
			} else if (!Number.isFinite(candidate)) {
				clean();
				return;
			}

			const fallbackTimer = setTimeout(clean, 500);
			hiddenVideo.addEventListener('seeked', onSeeked, { once: true });
			if (typeof hiddenVideo.requestVideoFrameCallback === "function") {
				frameCallbackId = hiddenVideo.requestVideoFrameCallback(() => clean());
			}

			try {
				hiddenVideo.currentTime = target + 0.00001;
			} catch {
				clean();
			}
		}

		/* ===== Plotting ===== */
		const positionChartCanvas = document.getElementById('positionChart');

		function plotPosition() {
			currentPlotMode = 'pos';
			// Calculate analysis time on-the-fly from playbackTime
			const xData = frameData.map(p => parseFloat(getAnalysisTime(p.playbackTime).toFixed(3)));
			const yDataX = frameData.map(p => parseFloat(((p.x - (originSet ? originPoint.x : 0)) * scaleFactor).toFixed(3)));
			const yDataY = frameData.map(p => parseFloat(((p.y - (originSet ? originPoint.y : 0)) * scaleFactor).toFixed(3)));
			const theme = getChartTheme();

			if (!positionChart) {
				positionChart = new Chart(positionChartCanvas.getContext("2d"), {
					type: "scatter",
					data: {
						datasets: [
							{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
							{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
						]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							x: {
								type: "linear",
								position: "bottom",
								title: { display: true, text: "Time (s)", color: theme.textColor },
								grid: { color: (c) => c.tick.value === 0 ? theme.axisColor : theme.gridColor },
								ticks: { color: theme.textColor }
							},
							y: {
								type: "linear",
								position: "left",
								beginAtZero: true,
								title: { display: true, text: `Position (${scaleUnit})`, color: theme.textColor },
								grid: { color: (c) => c.tick.value === 0 ? theme.axisColor : theme.gridColor },
								ticks: { color: theme.textColor }
							}
						},
						plugins: { legend: { display: true, position: 'top', labels: { color: theme.textColor } } }
					},
				});
			} else {
				positionChart.data.datasets = [
					{ label: "x-position", data: xData.map((t, i) => ({ x: t, y: yDataX[i] })), borderColor: dataPointColors.x, backgroundColor: dataPointColors.x, showLine: false, pointRadius: 4 },
					{ label: "y-position", data: xData.map((t, i) => ({ x: t, y: yDataY[i] })), borderColor: dataPointColors.y, backgroundColor: dataPointColors.y, showLine: false, pointRadius: 4 }
				];
				positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				positionChart.update();
			}
			applyThemeToChart();
		}

		function plotVelocity(axis) {
			currentPlotMode = axis === 'x' ? 'vx' : 'vy';
			const velocityEstimates = [];
			const velocityTimes = [];
			for (let i = 1; i < frameData.length; i++) {
				// Calculate analysis times on-the-fly
				const t1 = getAnalysisTime(frameData[i - 1].playbackTime);
				const t2 = getAnalysisTime(frameData[i].playbackTime);
				const dt = t2 - t1;
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const d = axis === 'x' ? (p2.x - p1.x) : (p2.y - p1.y);
				const v = dt > 0 ? (d * scaleFactor) / dt : 0;
				if (dt > 0) {
					velocityEstimates.push(v);
					velocityTimes.push((t2 + t1) / 2);
				}
			}

			if (velocityEstimates.length < 3) {
				document.getElementById('message').innerHTML = "<p>Velocity smoothing requires multiple distinct timestamps. Add more points with different times to plot velocity.</p>";
				return;
			}

			const smoothed = [];
			const times = [];
			for (let i = 2; i < velocityEstimates.length; i++) {
				const avg = (velocityEstimates[i - 2] + velocityEstimates[i - 1] + velocityEstimates[i]) / 3;
				smoothed.push(parseFloat(avg.toFixed(3)));
				const avgTime = (velocityTimes[i - 2] + velocityTimes[i]) / 2;
				times.push(parseFloat(avgTime.toFixed(3)));
			}

			if (!positionChart) return;
			positionChart.data.datasets = [{
				label: axis === "x" ? "x-velocity" : "y-velocity",
				data: times.map((t, i) => ({ x: t, y: smoothed[i] })),
				borderColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				backgroundColor: axis === "x" ? dataPointColors.vx : dataPointColors.vy,
				showLine: false,
				pointRadius: 4
			}];
			positionChart.options.scales.y.title.text = `Velocity (${scaleUnit}/s)`;
			positionChart.update();
			applyThemeToChart();
		}

		plotVxButton.addEventListener("click", () => plotVelocity("x"));
		plotVyButton.addEventListener("click", () => plotVelocity("y"));
		backToPositionButton.addEventListener("click", plotPosition);

		/* Clear / Export */
		clearDataPointsButton.addEventListener("click", () => {
			frameData = [];
			if (positionChart) {
				positionChart.data.datasets.forEach(d => d.data = []);
				positionChart.update();
			}
			drawFrame();
			drawOverlay();
			document.getElementById('message').innerHTML = "<p>Data points cleared.</p>";
		});
		clearCalibrationButton.addEventListener("click", () => {
			scaleFactor = 1;
			scaleUnit = "pixels";
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			if (positionChart) {
				positionChart.options.scales.y.title.text = `Position (${scaleUnit})`;
				plotPosition();
			}
			document.getElementById('message').innerHTML = "<p>Calibration cleared. Positions are now in pixel units.</p>";
		});
		clearOriginButton.addEventListener("click", () => {
			originSet = false;
			originPoint = { x: 0, y: 0 };
			drawOverlay();
			plotPosition();
			document.getElementById('message').innerHTML = "<p>Origin cleared. Default origin is used.</p>";
		});
		exportDataButton.addEventListener("click", () => {
			if (frameData.length === 0) { alert("No data to export."); return; }
			exportFilenameInput.value = "motion_tracker_data";
			exportPrompt.style.display = "block";
		});
		confirmExportButton.addEventListener("click", () => {
			const desired = exportFilenameInput.value.trim();
			if (!desired) { alert("Please enter a valid filename."); return; }
			const sanitized = desired.replace(/[^a-zA-Z0-9-_.]/g, "_");
			const finalName = sanitized.toLowerCase().endsWith(".csv") ? sanitized : sanitized + ".csv";
			exportCSV(finalName);
			exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = `<p>Data exported as ${finalName}.</p>`;
		});
		cancelExportButton.addEventListener("click", () => {
			exportPrompt.style.display = "none";
			document.getElementById('message').innerHTML = "<p>Export cancelled.</p>";
		});

		function exportCSV(filename) {
			// Calculate analysis times for all points
			const analysisTimes = frameData.map(p => getAnalysisTime(p.playbackTime));

			const velocityData = [];
			for (let i = 1; i < frameData.length; i++) {
				const dt = analysisTimes[i] - analysisTimes[i - 1];
				const p1 = { x: frameData[i - 1].x - (originSet ? originPoint.x : 0), y: frameData[i - 1].y - (originSet ? originPoint.y : 0) };
				const p2 = { x: frameData[i].x - (originSet ? originPoint.x : 0), y: frameData[i].y - (originSet ? originPoint.y : 0) };
				const dX = p2.x - p1.x,
					dY = p2.y - p1.y;
				const v_x = dt > 0 ? (dX * scaleFactor) / dt : 0;
				const v_y = dt > 0 ? (dY * scaleFactor) / dt : 0;
				velocityData.push({ v_x, v_y });
			}
			let csv = `Time (s),x (${scaleUnit}),y (${scaleUnit}),v_x (${scaleUnit}/s),v_y (${scaleUnit}/s)\n`;
			for (let i = 0; i < frameData.length; i++) {
				const xAdj = (frameData[i].x - (originSet ? originPoint.x : 0)) * scaleFactor;
				const yAdj = (frameData[i].y - (originSet ? originPoint.y : 0)) * scaleFactor;
				const time = analysisTimes[i].toFixed(3);
				const x = xAdj.toFixed(3);
				const y = yAdj.toFixed(3);
				const v_x = i > 0 ? velocityData[i - 1].v_x.toFixed(3) : "";
				const v_y = i > 0 ? velocityData[i - 1].v_y.toFixed(3) : "";
				csv += `${time},${x},${y},${v_x},${v_y}\n`;
			}
			const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		/* Drawing */
		function resizeOverlay() {
			overlayCanvas.width = frameCanvas.width;
			overlayCanvas.height = frameCanvas.height;
		}

		function drawFrame() {
			ctx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
			ctx.drawImage(hiddenVideo, 0, 0, frameCanvas.width, frameCanvas.height);

			// Only draw data points if crosses are visible
			if (crossesVisible) {
				const s = getVisualScale();
				frameData.forEach((p) => {
					const x = p.x,
						y = cartesianYToCanvasY(p.y);
					drawDataPoint(x, y, s);
				});
			}
		}

		function drawDataPoint(x, y, s = 1) {
			const circleRadius = 5 * s;
			const crossSize = 10 * s;
			const lineWidth = Math.max(1, 2 * s);

			ctx.fillStyle = 'rgba(255,0,0,.3)';
			ctx.beginPath();
			ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
			ctx.fill();

			ctx.strokeStyle = 'red';
			ctx.lineWidth = lineWidth;
			ctx.beginPath();
			ctx.moveTo(x - crossSize, y);
			ctx.lineTo(x + crossSize, y);
			ctx.moveTo(x, y - crossSize);
			ctx.lineTo(x, y + crossSize);
			ctx.stroke();
		}

		function drawOverlay() {
			resizeOverlay();
			overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

			// Dynamic scaling factors
			const s = getVisualScale();
			const axisWidth = 2 * s;
			const originRadius = 6 * s;
			const axisColor = getCssVar('--overlay-axis') || 'white';
			const shadowColor = getCssVar('--overlay-shadow') || 'black';

			const ox = originSet ? originPoint.x : 0;
			const oy = originSet ? originPoint.y : 0;
			const originCanvasX = ox;
			const originCanvasY = cartesianYToCanvasY(oy);

			overlayCtx.save();
			overlayCtx.lineWidth = axisWidth;
			overlayCtx.shadowColor = shadowColor;
			overlayCtx.shadowBlur = 2;
			overlayCtx.strokeStyle = axisColor;
			overlayCtx.beginPath();
			overlayCtx.moveTo(0, originCanvasY);
			overlayCtx.lineTo(overlayCanvas.width, originCanvasY);
			overlayCtx.stroke();
			overlayCtx.beginPath();
			overlayCtx.moveTo(originCanvasX, 0);
			overlayCtx.lineTo(originCanvasX, overlayCanvas.height);
			overlayCtx.stroke();
			overlayCtx.restore();

			overlayCtx.fillStyle = "cyan";
			overlayCtx.beginPath();
			overlayCtx.arc(originCanvasX, originCanvasY, originRadius, 0, 2 * Math.PI);
			overlayCtx.fill();

			if (calibrationStart && calibrationEnd) {
				overlayCtx.save();
				overlayCtx.lineWidth = 2 * s;
				overlayCtx.strokeStyle = "orange";
				overlayCtx.shadowColor = "black";
				overlayCtx.shadowBlur = 2;
				overlayCtx.setLineDash([5 * s, 5 * s]);
				overlayCtx.beginPath();
				overlayCtx.moveTo(calibrationStart.x, calibrationStart.y);
				overlayCtx.lineTo(calibrationEnd.x, calibrationEnd.y);
				overlayCtx.stroke();
				overlayCtx.setLineDash([]);
				overlayCtx.restore();
			}
		}
		window.addEventListener('resize', () => {
			drawOverlay();
			drawFrame();
		});

		/* Calibration */
		calibrateButton.addEventListener('click', () => {
			document.getElementById('crosshair').style.display = "none";
			overlayCanvas.style.pointerEvents = "auto";
			calibrationMode = true;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('message').innerHTML = "<p>Drag on the video to draw a line with a known length.</p>";
		});

		function startCalibrationDraw(x, y) {
			isDrawingCalibration = true;
			calibrationStart = { x, y };
			calibrationEnd = { x, y };
		}

		function updateCalibrationDraw(x, y) {
			if (isDrawingCalibration) {
				calibrationEnd = { x, y };
				drawOverlay();
			}
		}

		function endCalibrationDraw() {
			if (!isDrawingCalibration) return;
			isDrawingCalibration = false;
			calibrationMode = false;
			overlayCanvas.style.pointerEvents = "none";
			frameCanvas.style.cursor = "default";
			document.getElementById('message').innerHTML = "<p>Calibration line drawn. Enter actual length and unit.</p>";
			calibrationPrompt.style.display = "block";
		}
		overlayCanvas.addEventListener('mousedown', (e) => {
			if (!calibrationMode) return;
			const r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mousemove', (e) => {
			if (!calibrationMode || !isDrawingCalibration) return;
			const r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((e.clientX - r.left) * (overlayCanvas.width / r.width), (e.clientY - r.top) * (overlayCanvas.height / r.height));
		});
		overlayCanvas.addEventListener('mouseup', () => { if (calibrationMode) endCalibrationDraw(); });
		overlayCanvas.addEventListener('touchstart', (e) => {
			if (!calibrationMode || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			startCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchmove', (e) => {
			if (!calibrationMode || !isDrawingCalibration || e.touches.length !== 1) return;
			e.preventDefault();
			const t = e.touches[0],
				r = overlayCanvas.getBoundingClientRect();
			updateCalibrationDraw((t.clientX - r.left) * (overlayCanvas.width / r.width), (t.clientY - r.top) * (overlayCanvas.height / r.height));
		}, { passive: false });
		overlayCanvas.addEventListener('touchend', (e) => {
			if (calibrationMode) {
				e.preventDefault();
				endCalibrationDraw();
			}
		}, { passive: false });
		confirmCalibrationButton.addEventListener('click', () => {
			const actualLength = parseFloat(actualLengthInput.value);
			const actualUnit = actualUnitInput.value.trim();
			if (!Number.isFinite(actualLength) || actualLength <= 0 || !actualUnit) { alert("Enter a positive length and a unit."); return; }
			const dx = calibrationEnd.x - calibrationStart.x,
				dy = calibrationEnd.y - calibrationStart.y;
			const pxLen = Math.hypot(dx, dy);
			if (pxLen === 0) { alert("Calibration line length cannot be zero."); return; }
			scaleFactor = actualLength / pxLen;
			scaleUnit = actualUnit;
			calibrationPrompt.style.display = "none";
			drawOverlay();
			drawFrame();
			plotPosition();
			document.getElementById('message').innerHTML = `<p>Calibration successful: 1 pixel = ${scaleFactor.toFixed(4)} ${scaleUnit}</p>`;
		});
		cancelCalibrationButton.addEventListener('click', () => {
			calibrationPrompt.style.display = "none";
			calibrationMode = false;
			isDrawingCalibration = false;
			calibrationStart = null;
			calibrationEnd = null;
			drawOverlay();
			drawFrame();
			document.getElementById('message').innerHTML = "<p>Calibration cancelled.</p>";
		});

		/* Origin button */
		setOriginButton.addEventListener('click', () => {
			calibrationMode = false;
			isDrawingCalibration = false;
			originMode = true;
			overlayCanvas.style.pointerEvents = "auto";
			frameCanvas.style.cursor = "crosshair";
			document.getElementById('crosshair').style.display = "block";
			document.getElementById('message').innerHTML = "<p>Click on the video to set the new origin.</p>";
		});

		/* Cleanup */
		window.addEventListener('beforeunload', () => { if (blobUrl) URL.revokeObjectURL(blobUrl); });

		/* ===== Hide Crosses Toggle ===== */
		function toggleCrossesVisibility() {
			crossesVisible = !crossesVisible;
			if (crossesVisible) {
				hideCrossesToggle.classList.remove('crosses-hidden');
				hideCrossesToggle.querySelector('.toggle-text').textContent = 'Hide';
			} else {
				hideCrossesToggle.classList.add('crosses-hidden');
				hideCrossesToggle.querySelector('.toggle-text').textContent = 'Show';
			}
			drawFrame();
		}

		hideCrossesToggle.addEventListener('click', toggleCrossesVisibility);

		/* Keyboard shortcut: H to toggle crosses */
		document.addEventListener('keydown', (e) => {
			// Ignore if typing in input fields or if video not loaded
			if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
			if (hideCrossesToggle.disabled) return;

			if (e.key === 'h' || e.key === 'H') {
				e.preventDefault();
				toggleCrossesVisibility();
			}
		});
	</script>
	<script>
		// Gradient text: skip on Brave iOS where background-clip:text is broken
		(function() {
			if (/iP(hone|ad|od)/.test(navigator.userAgent) && navigator.brave) return;
			document.querySelectorAll('.banner-title').forEach(function(el) { el.classList.add('gradient-text'); });
		})();
	</script>
</body>

</html>
